import { createClient } from "npm:@supabase/supabase-js@2";

const supabaseUrl = Deno.env.get("SUPABASE_URL") ?? "";
const serviceRoleKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "";

if (!supabaseUrl || !serviceRoleKey) {
  console.error("Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY");
}

const supabase = createClient(supabaseUrl, serviceRoleKey);

Deno.serve(async (req: Request): Promise<Response> => {
  if (req.method !== "POST") {
    return new Response("Method not allowed", { status: 405 });
  }

  const ipHeader = req.headers.get("x-forwarded-for") ?? "";
  const ip = ipHeader.split(",")[0].trim() || null;

  let body: any;
  try {
    body = await req.json();
  } catch {
    return new Response("Invalid JSON", { status: 400 });
  }

  const { fromPlayerId, toPlayerId } = body ?? {};

  if (
    typeof fromPlayerId !== "string" ||
    typeof toPlayerId !== "string" ||
    fromPlayerId.length < 3 ||
    toPlayerId.length < 3
  ) {
    return new Response("Invalid player ids", { status: 400 });
  }

  if (fromPlayerId === toPlayerId) {
    return new Response("Cannot friend yourself", { status: 400 });
  }

  // Rate limit sur l'IP + l'émetteur
  const { data: allowed, error: rateError } = await supabase.rpc(
    "check_rate_limit",
    {
      p_ip: ip,
      p_player_id: fromPlayerId,
    },
  );

  if (rateError) {
    console.error("rate limit error:", rateError);
    return new Response("Rate limiter error", { status: 500 });
  }

  if (allowed === false) {
    return new Response("Too many requests", { status: 429 });
  }

  // Normalisation du couple (ordre alphabétique)
  const [userOneId, userTwoId] =
    fromPlayerId < toPlayerId
      ? [fromPlayerId, toPlayerId]
      : [toPlayerId, fromPlayerId];

  // Vérifier que les deux players existent (par sécurité)
  const { data: players, error: playersError } = await supabase
    .from("players")
    .select("id")
    .in("id", [fromPlayerId, toPlayerId]);

  if (playersError) {
    console.error("players check error:", playersError);
    return new Response("DB error (players check)", { status: 500 });
  }

  if (!players || players.length < 2) {
    return new Response("One or both players not found", { status: 404 });
  }

  // Vérifier si une relation existe déjà
  const { data: existing, error: existingError } = await supabase
    .from("player_relationships")
    .select("status, requested_by")
    .eq("user_one_id", userOneId)
    .eq("user_two_id", userTwoId)
    .maybeSingle();

  if (existingError) {
    console.error("relationship check error:", existingError);
    return new Response("DB error (relationship check)", { status: 500 });
  }

  if (existing) {
    if (existing.status === "accepted") {
      return new Response("Already friends", { status: 409 });
    }
    if (existing.status === "pending") {
      return new Response("Friend request already pending", { status: 409 });
    }
    if (existing.status === "rejected") {
      // Tu peux décider d'autoriser de renvoyer une demande ou non.
      // Là on bloque pour éviter le spam.
      return new Response("Friend request previously rejected", {
        status: 409,
      });
    }
  }

  // Créer la demande
  const { error: insertError } = await supabase
    .from("player_relationships")
    .insert({
      user_one_id: userOneId,
      user_two_id: userTwoId,
      requested_by: fromPlayerId,
      status: "pending",
    });

  if (insertError) {
    console.error("friend-request insert error:", insertError);
    return new Response("DB error (create request)", { status: 500 });
  }

  return new Response(null, { status: 204 });
});
