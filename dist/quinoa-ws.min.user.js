// ==UserScript==
// @name         Arie's Mod
// @namespace    Quinoa
// @version      2.4.2
// @match        https://1227719606223765687.discordsays.com/*
// @match        https://magiccircle.gg/r/*
// @match        https://magicgarden.gg/r/*
// @match        https://starweaver.org/r/*
// @run-at       document-start
// @inject-into  page
// @grant        GM_xmlhttpRequest
// @grant        GM_info
// @grant        GM_openInTab 
// @grant        GM_registerMenuCommand
// @connect      raw.githubusercontent.com
// @connect      api.github.com
// @downloadURL  https://github.com/Ariedam64/MagicGarden-modMenu/raw/refs/heads/main/quinoa-ws.min.user.js
// @updateURL    https://github.com/Ariedam64/MagicGarden-modMenu/raw/refs/heads/main/quinoa-ws.min.user.js
// ==/UserScript==
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key2 of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key2) && key2 !== except)
          __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __publicField = (obj, key2, value) => __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);

  // node_modules/jszip/dist/jszip.min.js
  var require_jszip_min = __commonJS({
    "node_modules/jszip/dist/jszip.min.js"(exports, module) {
      !function(e) {
        if ("object" == typeof exports && "undefined" != typeof module) module.exports = e();
        else if ("function" == typeof define && define.amd) define([], e);
        else {
          ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).JSZip = e();
        }
      }(function() {
        return function s(a, o, h) {
          function u(r, e2) {
            if (!o[r]) {
              if (!a[r]) {
                var t = "function" == typeof __require && __require;
                if (!e2 && t) return t(r, true);
                if (l) return l(r, true);
                var n = new Error("Cannot find module '" + r + "'");
                throw n.code = "MODULE_NOT_FOUND", n;
              }
              var i = o[r] = { exports: {} };
              a[r][0].call(i.exports, function(e3) {
                var t2 = a[r][1][e3];
                return u(t2 || e3);
              }, i, i.exports, s, a, o, h);
            }
            return o[r].exports;
          }
          for (var l = "function" == typeof __require && __require, e = 0; e < h.length; e++) u(h[e]);
          return u;
        }({ 1: [function(e, t, r) {
          "use strict";
          var d = e("./utils"), c = e("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          r.encode = function(e2) {
            for (var t2, r2, n, i, s, a, o, h = [], u = 0, l = e2.length, f = l, c2 = "string" !== d.getTypeOf(e2); u < e2.length; ) f = l - u, n = c2 ? (t2 = e2[u++], r2 = u < l ? e2[u++] : 0, u < l ? e2[u++] : 0) : (t2 = e2.charCodeAt(u++), r2 = u < l ? e2.charCodeAt(u++) : 0, u < l ? e2.charCodeAt(u++) : 0), i = t2 >> 2, s = (3 & t2) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o));
            return h.join("");
          }, r.decode = function(e2) {
            var t2, r2, n, i, s, a, o = 0, h = 0, u = "data:";
            if (e2.substr(0, u.length) === u) throw new Error("Invalid base64 input, it looks like a data url.");
            var l, f = 3 * (e2 = e2.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
            if (e2.charAt(e2.length - 1) === p.charAt(64) && f--, e2.charAt(e2.length - 2) === p.charAt(64) && f--, f % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
            for (l = c.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e2.length; ) t2 = p.indexOf(e2.charAt(o++)) << 2 | (i = p.indexOf(e2.charAt(o++))) >> 4, r2 = (15 & i) << 4 | (s = p.indexOf(e2.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p.indexOf(e2.charAt(o++))), l[h++] = t2, 64 !== s && (l[h++] = r2), 64 !== a && (l[h++] = n);
            return l;
          };
        }, { "./support": 30, "./utils": 32 }], 2: [function(e, t, r) {
          "use strict";
          var n = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
          function o(e2, t2, r2, n2, i2) {
            this.compressedSize = e2, this.uncompressedSize = t2, this.crc32 = r2, this.compression = n2, this.compressedContent = i2;
          }
          o.prototype = { getContentWorker: function() {
            var e2 = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t2 = this;
            return e2.on("end", function() {
              if (this.streamInfo.data_length !== t2.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
            }), e2;
          }, getCompressedWorker: function() {
            return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
          } }, o.createWorkerFrom = function(e2, t2, r2) {
            return e2.pipe(new s()).pipe(new a("uncompressedSize")).pipe(t2.compressWorker(r2)).pipe(new a("compressedSize")).withStreamInfo("compression", t2);
          }, t.exports = o;
        }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, t, r) {
          "use strict";
          var n = e("./stream/GenericWorker");
          r.STORE = { magic: "\0\0", compressWorker: function() {
            return new n("STORE compression");
          }, uncompressWorker: function() {
            return new n("STORE decompression");
          } }, r.DEFLATE = e("./flate");
        }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, t, r) {
          "use strict";
          var n = e("./utils");
          var o = function() {
            for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
              e2 = r2;
              for (var n2 = 0; n2 < 8; n2++) e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
              t2[r2] = e2;
            }
            return t2;
          }();
          t.exports = function(e2, t2) {
            return void 0 !== e2 && e2.length ? "string" !== n.getTypeOf(e2) ? function(e3, t3, r2, n2) {
              var i = o, s = n2 + r2;
              e3 ^= -1;
              for (var a = n2; a < s; a++) e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3[a])];
              return -1 ^ e3;
            }(0 | t2, e2, e2.length, 0) : function(e3, t3, r2, n2) {
              var i = o, s = n2 + r2;
              e3 ^= -1;
              for (var a = n2; a < s; a++) e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3.charCodeAt(a))];
              return -1 ^ e3;
            }(0 | t2, e2, e2.length, 0) : 0;
          };
        }, { "./utils": 32 }], 5: [function(e, t, r) {
          "use strict";
          r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
        }, {}], 6: [function(e, t, r) {
          "use strict";
          var n = null;
          n = "undefined" != typeof Promise ? Promise : e("lie"), t.exports = { Promise: n };
        }, { lie: 37 }], 7: [function(e, t, r) {
          "use strict";
          var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n ? "uint8array" : "array";
          function h(e2, t2) {
            a.call(this, "FlateWorker/" + e2), this._pako = null, this._pakoAction = e2, this._pakoOptions = t2, this.meta = {};
          }
          r.magic = "\b\0", s.inherits(h, a), h.prototype.processChunk = function(e2) {
            this.meta = e2.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, e2.data), false);
          }, h.prototype.flush = function() {
            a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
          }, h.prototype.cleanUp = function() {
            a.prototype.cleanUp.call(this), this._pako = null;
          }, h.prototype._createPako = function() {
            this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
            var t2 = this;
            this._pako.onData = function(e2) {
              t2.push({ data: e2, meta: t2.meta });
            };
          }, r.compressWorker = function(e2) {
            return new h("Deflate", e2);
          }, r.uncompressWorker = function() {
            return new h("Inflate", {});
          };
        }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, t, r) {
          "use strict";
          function A(e2, t2) {
            var r2, n2 = "";
            for (r2 = 0; r2 < t2; r2++) n2 += String.fromCharCode(255 & e2), e2 >>>= 8;
            return n2;
          }
          function n(e2, t2, r2, n2, i2, s2) {
            var a, o, h = e2.file, u = e2.compression, l = s2 !== O.utf8encode, f = I.transformTo("string", s2(h.name)), c = I.transformTo("string", O.utf8encode(h.name)), d = h.comment, p = I.transformTo("string", s2(d)), m = I.transformTo("string", O.utf8encode(d)), _ = c.length !== h.name.length, g = m.length !== d.length, b = "", v = "", y = "", w = h.dir, k = h.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
            t2 && !r2 || (x.crc32 = e2.crc32, x.compressedSize = e2.compressedSize, x.uncompressedSize = e2.uncompressedSize);
            var S = 0;
            t2 && (S |= 8), l || !_ && !g || (S |= 2048);
            var z = 0, C = 0;
            w && (z |= 16), "UNIX" === i2 ? (C = 798, z |= function(e3, t3) {
              var r3 = e3;
              return e3 || (r3 = t3 ? 16893 : 33204), (65535 & r3) << 16;
            }(h.unixPermissions, w)) : (C = 20, z |= function(e3) {
              return 63 & (e3 || 0);
            }(h.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + c, b += "up" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p), 4) + m, b += "uc" + A(y.length, 2) + y);
            var E = "";
            return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f + b, dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + "\0\0\0\0" + A(z, 4) + A(n2, 4) + f + b + p };
          }
          var I = e("../utils"), i = e("../stream/GenericWorker"), O = e("../utf8"), B = e("../crc32"), R = e("../signature");
          function s(e2, t2, r2, n2) {
            i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t2, this.zipPlatform = r2, this.encodeFileName = n2, this.streamFiles = e2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
          }
          I.inherits(s, i), s.prototype.push = function(e2) {
            var t2 = e2.meta.percent || 0, r2 = this.entriesCount, n2 = this._sources.length;
            this.accumulate ? this.contentBuffer.push(e2) : (this.bytesWritten += e2.data.length, i.prototype.push.call(this, { data: e2.data, meta: { currentFile: this.currentFile, percent: r2 ? (t2 + 100 * (r2 - n2 - 1)) / r2 : 100 } }));
          }, s.prototype.openedSource = function(e2) {
            this.currentSourceOffset = this.bytesWritten, this.currentFile = e2.file.name;
            var t2 = this.streamFiles && !e2.file.dir;
            if (t2) {
              var r2 = n(e2, t2, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
              this.push({ data: r2.fileRecord, meta: { percent: 0 } });
            } else this.accumulate = true;
          }, s.prototype.closedSource = function(e2) {
            this.accumulate = false;
            var t2 = this.streamFiles && !e2.file.dir, r2 = n(e2, t2, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            if (this.dirRecords.push(r2.dirRecord), t2) this.push({ data: function(e3) {
              return R.DATA_DESCRIPTOR + A(e3.crc32, 4) + A(e3.compressedSize, 4) + A(e3.uncompressedSize, 4);
            }(e2), meta: { percent: 100 } });
            else for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
            this.currentFile = null;
          }, s.prototype.flush = function() {
            for (var e2 = this.bytesWritten, t2 = 0; t2 < this.dirRecords.length; t2++) this.push({ data: this.dirRecords[t2], meta: { percent: 100 } });
            var r2 = this.bytesWritten - e2, n2 = function(e3, t3, r3, n3, i2) {
              var s2 = I.transformTo("string", i2(n3));
              return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(e3, 2) + A(e3, 2) + A(t3, 4) + A(r3, 4) + A(s2.length, 2) + s2;
            }(this.dirRecords.length, r2, e2, this.zipComment, this.encodeFileName);
            this.push({ data: n2, meta: { percent: 100 } });
          }, s.prototype.prepareNextSource = function() {
            this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
          }, s.prototype.registerPrevious = function(e2) {
            this._sources.push(e2);
            var t2 = this;
            return e2.on("data", function(e3) {
              t2.processChunk(e3);
            }), e2.on("end", function() {
              t2.closedSource(t2.previous.streamInfo), t2._sources.length ? t2.prepareNextSource() : t2.end();
            }), e2.on("error", function(e3) {
              t2.error(e3);
            }), this;
          }, s.prototype.resume = function() {
            return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
          }, s.prototype.error = function(e2) {
            var t2 = this._sources;
            if (!i.prototype.error.call(this, e2)) return false;
            for (var r2 = 0; r2 < t2.length; r2++) try {
              t2[r2].error(e2);
            } catch (e3) {
            }
            return true;
          }, s.prototype.lock = function() {
            i.prototype.lock.call(this);
            for (var e2 = this._sources, t2 = 0; t2 < e2.length; t2++) e2[t2].lock();
          }, t.exports = s;
        }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, t, r) {
          "use strict";
          var u = e("../compressions"), n = e("./ZipFileWorker");
          r.generateWorker = function(e2, a, t2) {
            var o = new n(a.streamFiles, t2, a.platform, a.encodeFileName), h = 0;
            try {
              e2.forEach(function(e3, t3) {
                h++;
                var r2 = function(e4, t4) {
                  var r3 = e4 || t4, n3 = u[r3];
                  if (!n3) throw new Error(r3 + " is not a valid compression method !");
                  return n3;
                }(t3.options.compression, a.compression), n2 = t3.options.compressionOptions || a.compressionOptions || {}, i = t3.dir, s = t3.date;
                t3._compressWorker(r2, n2).withStreamInfo("file", { name: e3, dir: i, date: s, comment: t3.comment || "", unixPermissions: t3.unixPermissions, dosPermissions: t3.dosPermissions }).pipe(o);
              }), o.entriesCount = h;
            } catch (e3) {
              o.error(e3);
            }
            return o;
          };
        }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, t, r) {
          "use strict";
          function n() {
            if (!(this instanceof n)) return new n();
            if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
            this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
              var e2 = new n();
              for (var t2 in this) "function" != typeof this[t2] && (e2[t2] = this[t2]);
              return e2;
            };
          }
          (n.prototype = e("./object")).loadAsync = e("./load"), n.support = e("./support"), n.defaults = e("./defaults"), n.version = "3.10.1", n.loadAsync = function(e2, t2) {
            return new n().loadAsync(e2, t2);
          }, n.external = e("./external"), t.exports = n;
        }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, t, r) {
          "use strict";
          var u = e("./utils"), i = e("./external"), n = e("./utf8"), s = e("./zipEntries"), a = e("./stream/Crc32Probe"), l = e("./nodejsUtils");
          function f(n2) {
            return new i.Promise(function(e2, t2) {
              var r2 = n2.decompressed.getContentWorker().pipe(new a());
              r2.on("error", function(e3) {
                t2(e3);
              }).on("end", function() {
                r2.streamInfo.crc32 !== n2.decompressed.crc32 ? t2(new Error("Corrupted zip : CRC32 mismatch")) : e2();
              }).resume();
            });
          }
          t.exports = function(e2, o) {
            var h = this;
            return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n.utf8decode }), l.isNode && l.isStream(e2) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e2, true, o.optimizedBinaryString, o.base64).then(function(e3) {
              var t2 = new s(o);
              return t2.load(e3), t2;
            }).then(function(e3) {
              var t2 = [i.Promise.resolve(e3)], r2 = e3.files;
              if (o.checkCRC32) for (var n2 = 0; n2 < r2.length; n2++) t2.push(f(r2[n2]));
              return i.Promise.all(t2);
            }).then(function(e3) {
              for (var t2 = e3.shift(), r2 = t2.files, n2 = 0; n2 < r2.length; n2++) {
                var i2 = r2[n2], s2 = i2.fileNameStr, a2 = u.resolve(i2.fileNameStr);
                h.file(a2, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o.createFolders }), i2.dir || (h.file(a2).unsafeOriginalName = s2);
              }
              return t2.zipComment.length && (h.comment = t2.zipComment), h;
            });
          };
        }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, t, r) {
          "use strict";
          var n = e("../utils"), i = e("../stream/GenericWorker");
          function s(e2, t2) {
            i.call(this, "Nodejs stream input adapter for " + e2), this._upstreamEnded = false, this._bindStream(t2);
          }
          n.inherits(s, i), s.prototype._bindStream = function(e2) {
            var t2 = this;
            (this._stream = e2).pause(), e2.on("data", function(e3) {
              t2.push({ data: e3, meta: { percent: 0 } });
            }).on("error", function(e3) {
              t2.isPaused ? this.generatedError = e3 : t2.error(e3);
            }).on("end", function() {
              t2.isPaused ? t2._upstreamEnded = true : t2.end();
            });
          }, s.prototype.pause = function() {
            return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
          }, s.prototype.resume = function() {
            return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
          }, t.exports = s;
        }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, t, r) {
          "use strict";
          var i = e("readable-stream").Readable;
          function n(e2, t2, r2) {
            i.call(this, t2), this._helper = e2;
            var n2 = this;
            e2.on("data", function(e3, t3) {
              n2.push(e3) || n2._helper.pause(), r2 && r2(t3);
            }).on("error", function(e3) {
              n2.emit("error", e3);
            }).on("end", function() {
              n2.push(null);
            });
          }
          e("../utils").inherits(n, i), n.prototype._read = function() {
            this._helper.resume();
          }, t.exports = n;
        }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, t, r) {
          "use strict";
          t.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e2, t2) {
            if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(e2, t2);
            if ("number" == typeof e2) throw new Error('The "data" argument must not be a number');
            return new Buffer(e2, t2);
          }, allocBuffer: function(e2) {
            if (Buffer.alloc) return Buffer.alloc(e2);
            var t2 = new Buffer(e2);
            return t2.fill(0), t2;
          }, isBuffer: function(e2) {
            return Buffer.isBuffer(e2);
          }, isStream: function(e2) {
            return e2 && "function" == typeof e2.on && "function" == typeof e2.pause && "function" == typeof e2.resume;
          } };
        }, {}], 15: [function(e, t, r) {
          "use strict";
          function s(e2, t2, r2) {
            var n2, i2 = u.getTypeOf(t2), s2 = u.extend(r2 || {}, f);
            s2.date = s2.date || /* @__PURE__ */ new Date(), null !== s2.compression && (s2.compression = s2.compression.toUpperCase()), "string" == typeof s2.unixPermissions && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e2 = g(e2)), s2.createFolders && (n2 = _(e2)) && b.call(this, n2, true);
            var a2 = "string" === i2 && false === s2.binary && false === s2.base64;
            r2 && void 0 !== r2.binary || (s2.binary = !a2), (t2 instanceof c && 0 === t2.uncompressedSize || s2.dir || !t2 || 0 === t2.length) && (s2.base64 = false, s2.binary = true, t2 = "", s2.compression = "STORE", i2 = "string");
            var o2 = null;
            o2 = t2 instanceof c || t2 instanceof l ? t2 : p.isNode && p.isStream(t2) ? new m(e2, t2) : u.prepareContent(e2, t2, s2.binary, s2.optimizedBinaryString, s2.base64);
            var h2 = new d(e2, o2, s2);
            this.files[e2] = h2;
          }
          var i = e("./utf8"), u = e("./utils"), l = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), f = e("./defaults"), c = e("./compressedObject"), d = e("./zipObject"), o = e("./generate"), p = e("./nodejsUtils"), m = e("./nodejs/NodejsStreamInputAdapter"), _ = function(e2) {
            "/" === e2.slice(-1) && (e2 = e2.substring(0, e2.length - 1));
            var t2 = e2.lastIndexOf("/");
            return 0 < t2 ? e2.substring(0, t2) : "";
          }, g = function(e2) {
            return "/" !== e2.slice(-1) && (e2 += "/"), e2;
          }, b = function(e2, t2) {
            return t2 = void 0 !== t2 ? t2 : f.createFolders, e2 = g(e2), this.files[e2] || s.call(this, e2, null, { dir: true, createFolders: t2 }), this.files[e2];
          };
          function h(e2) {
            return "[object RegExp]" === Object.prototype.toString.call(e2);
          }
          var n = { load: function() {
            throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
          }, forEach: function(e2) {
            var t2, r2, n2;
            for (t2 in this.files) n2 = this.files[t2], (r2 = t2.slice(this.root.length, t2.length)) && t2.slice(0, this.root.length) === this.root && e2(r2, n2);
          }, filter: function(r2) {
            var n2 = [];
            return this.forEach(function(e2, t2) {
              r2(e2, t2) && n2.push(t2);
            }), n2;
          }, file: function(e2, t2, r2) {
            if (1 !== arguments.length) return e2 = this.root + e2, s.call(this, e2, t2, r2), this;
            if (h(e2)) {
              var n2 = e2;
              return this.filter(function(e3, t3) {
                return !t3.dir && n2.test(e3);
              });
            }
            var i2 = this.files[this.root + e2];
            return i2 && !i2.dir ? i2 : null;
          }, folder: function(r2) {
            if (!r2) return this;
            if (h(r2)) return this.filter(function(e3, t3) {
              return t3.dir && r2.test(e3);
            });
            var e2 = this.root + r2, t2 = b.call(this, e2), n2 = this.clone();
            return n2.root = t2.name, n2;
          }, remove: function(r2) {
            r2 = this.root + r2;
            var e2 = this.files[r2];
            if (e2 || ("/" !== r2.slice(-1) && (r2 += "/"), e2 = this.files[r2]), e2 && !e2.dir) delete this.files[r2];
            else for (var t2 = this.filter(function(e3, t3) {
              return t3.name.slice(0, r2.length) === r2;
            }), n2 = 0; n2 < t2.length; n2++) delete this.files[t2[n2].name];
            return this;
          }, generate: function() {
            throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
          }, generateInternalStream: function(e2) {
            var t2, r2 = {};
            try {
              if ((r2 = u.extend(e2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), "binarystring" === r2.type && (r2.type = "string"), !r2.type) throw new Error("No output type specified.");
              u.checkSupport(r2.type), "darwin" !== r2.platform && "freebsd" !== r2.platform && "linux" !== r2.platform && "sunos" !== r2.platform || (r2.platform = "UNIX"), "win32" === r2.platform && (r2.platform = "DOS");
              var n2 = r2.comment || this.comment || "";
              t2 = o.generateWorker(this, r2, n2);
            } catch (e3) {
              (t2 = new l("error")).error(e3);
            }
            return new a(t2, r2.type || "string", r2.mimeType);
          }, generateAsync: function(e2, t2) {
            return this.generateInternalStream(e2).accumulate(t2);
          }, generateNodeStream: function(e2, t2) {
            return (e2 = e2 || {}).type || (e2.type = "nodebuffer"), this.generateInternalStream(e2).toNodejsStream(t2);
          } };
          t.exports = n;
        }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, t, r) {
          "use strict";
          t.exports = e("stream");
        }, { stream: void 0 }], 17: [function(e, t, r) {
          "use strict";
          var n = e("./DataReader");
          function i(e2) {
            n.call(this, e2);
            for (var t2 = 0; t2 < this.data.length; t2++) e2[t2] = 255 & e2[t2];
          }
          e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
            return this.data[this.zero + e2];
          }, i.prototype.lastIndexOfSignature = function(e2) {
            for (var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.length - 4; 0 <= s; --s) if (this.data[s] === t2 && this.data[s + 1] === r2 && this.data[s + 2] === n2 && this.data[s + 3] === i2) return s - this.zero;
            return -1;
          }, i.prototype.readAndCheckSignature = function(e2) {
            var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.readData(4);
            return t2 === s[0] && r2 === s[1] && n2 === s[2] && i2 === s[3];
          }, i.prototype.readData = function(e2) {
            if (this.checkOffset(e2), 0 === e2) return [];
            var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
            return this.index += e2, t2;
          }, t.exports = i;
        }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, t, r) {
          "use strict";
          var n = e("../utils");
          function i(e2) {
            this.data = e2, this.length = e2.length, this.index = 0, this.zero = 0;
          }
          i.prototype = { checkOffset: function(e2) {
            this.checkIndex(this.index + e2);
          }, checkIndex: function(e2) {
            if (this.length < this.zero + e2 || e2 < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e2 + "). Corrupted zip ?");
          }, setIndex: function(e2) {
            this.checkIndex(e2), this.index = e2;
          }, skip: function(e2) {
            this.setIndex(this.index + e2);
          }, byteAt: function() {
          }, readInt: function(e2) {
            var t2, r2 = 0;
            for (this.checkOffset(e2), t2 = this.index + e2 - 1; t2 >= this.index; t2--) r2 = (r2 << 8) + this.byteAt(t2);
            return this.index += e2, r2;
          }, readString: function(e2) {
            return n.transformTo("string", this.readData(e2));
          }, readData: function() {
          }, lastIndexOfSignature: function() {
          }, readAndCheckSignature: function() {
          }, readDate: function() {
            var e2 = this.readInt(4);
            return new Date(Date.UTC(1980 + (e2 >> 25 & 127), (e2 >> 21 & 15) - 1, e2 >> 16 & 31, e2 >> 11 & 31, e2 >> 5 & 63, (31 & e2) << 1));
          } }, t.exports = i;
        }, { "../utils": 32 }], 19: [function(e, t, r) {
          "use strict";
          var n = e("./Uint8ArrayReader");
          function i(e2) {
            n.call(this, e2);
          }
          e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
            this.checkOffset(e2);
            var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
            return this.index += e2, t2;
          }, t.exports = i;
        }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, t, r) {
          "use strict";
          var n = e("./DataReader");
          function i(e2) {
            n.call(this, e2);
          }
          e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
            return this.data.charCodeAt(this.zero + e2);
          }, i.prototype.lastIndexOfSignature = function(e2) {
            return this.data.lastIndexOf(e2) - this.zero;
          }, i.prototype.readAndCheckSignature = function(e2) {
            return e2 === this.readData(4);
          }, i.prototype.readData = function(e2) {
            this.checkOffset(e2);
            var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
            return this.index += e2, t2;
          }, t.exports = i;
        }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, t, r) {
          "use strict";
          var n = e("./ArrayReader");
          function i(e2) {
            n.call(this, e2);
          }
          e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
            if (this.checkOffset(e2), 0 === e2) return new Uint8Array(0);
            var t2 = this.data.subarray(this.zero + this.index, this.zero + this.index + e2);
            return this.index += e2, t2;
          }, t.exports = i;
        }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, t, r) {
          "use strict";
          var n = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), h = e("./Uint8ArrayReader");
          t.exports = function(e2) {
            var t2 = n.getTypeOf(e2);
            return n.checkSupport(t2), "string" !== t2 || i.uint8array ? "nodebuffer" === t2 ? new o(e2) : i.uint8array ? new h(n.transformTo("uint8array", e2)) : new s(n.transformTo("array", e2)) : new a(e2);
          };
        }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, t, r) {
          "use strict";
          r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
        }, {}], 24: [function(e, t, r) {
          "use strict";
          var n = e("./GenericWorker"), i = e("../utils");
          function s(e2) {
            n.call(this, "ConvertWorker to " + e2), this.destType = e2;
          }
          i.inherits(s, n), s.prototype.processChunk = function(e2) {
            this.push({ data: i.transformTo(this.destType, e2.data), meta: e2.meta });
          }, t.exports = s;
        }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, t, r) {
          "use strict";
          var n = e("./GenericWorker"), i = e("../crc32");
          function s() {
            n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
          }
          e("../utils").inherits(s, n), s.prototype.processChunk = function(e2) {
            this.streamInfo.crc32 = i(e2.data, this.streamInfo.crc32 || 0), this.push(e2);
          }, t.exports = s;
        }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, t, r) {
          "use strict";
          var n = e("../utils"), i = e("./GenericWorker");
          function s(e2) {
            i.call(this, "DataLengthProbe for " + e2), this.propName = e2, this.withStreamInfo(e2, 0);
          }
          n.inherits(s, i), s.prototype.processChunk = function(e2) {
            if (e2) {
              var t2 = this.streamInfo[this.propName] || 0;
              this.streamInfo[this.propName] = t2 + e2.data.length;
            }
            i.prototype.processChunk.call(this, e2);
          }, t.exports = s;
        }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, t, r) {
          "use strict";
          var n = e("../utils"), i = e("./GenericWorker");
          function s(e2) {
            i.call(this, "DataWorker");
            var t2 = this;
            this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e2.then(function(e3) {
              t2.dataIsReady = true, t2.data = e3, t2.max = e3 && e3.length || 0, t2.type = n.getTypeOf(e3), t2.isPaused || t2._tickAndRepeat();
            }, function(e3) {
              t2.error(e3);
            });
          }
          n.inherits(s, i), s.prototype.cleanUp = function() {
            i.prototype.cleanUp.call(this), this.data = null;
          }, s.prototype.resume = function() {
            return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);
          }, s.prototype._tickAndRepeat = function() {
            this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
          }, s.prototype._tick = function() {
            if (this.isPaused || this.isFinished) return false;
            var e2 = null, t2 = Math.min(this.max, this.index + 16384);
            if (this.index >= this.max) return this.end();
            switch (this.type) {
              case "string":
                e2 = this.data.substring(this.index, t2);
                break;
              case "uint8array":
                e2 = this.data.subarray(this.index, t2);
                break;
              case "array":
              case "nodebuffer":
                e2 = this.data.slice(this.index, t2);
            }
            return this.index = t2, this.push({ data: e2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
          }, t.exports = s;
        }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, t, r) {
          "use strict";
          function n(e2) {
            this.name = e2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
          }
          n.prototype = { push: function(e2) {
            this.emit("data", e2);
          }, end: function() {
            if (this.isFinished) return false;
            this.flush();
            try {
              this.emit("end"), this.cleanUp(), this.isFinished = true;
            } catch (e2) {
              this.emit("error", e2);
            }
            return true;
          }, error: function(e2) {
            return !this.isFinished && (this.isPaused ? this.generatedError = e2 : (this.isFinished = true, this.emit("error", e2), this.previous && this.previous.error(e2), this.cleanUp()), true);
          }, on: function(e2, t2) {
            return this._listeners[e2].push(t2), this;
          }, cleanUp: function() {
            this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
          }, emit: function(e2, t2) {
            if (this._listeners[e2]) for (var r2 = 0; r2 < this._listeners[e2].length; r2++) this._listeners[e2][r2].call(this, t2);
          }, pipe: function(e2) {
            return e2.registerPrevious(this);
          }, registerPrevious: function(e2) {
            if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
            this.streamInfo = e2.streamInfo, this.mergeStreamInfo(), this.previous = e2;
            var t2 = this;
            return e2.on("data", function(e3) {
              t2.processChunk(e3);
            }), e2.on("end", function() {
              t2.end();
            }), e2.on("error", function(e3) {
              t2.error(e3);
            }), this;
          }, pause: function() {
            return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
          }, resume: function() {
            if (!this.isPaused || this.isFinished) return false;
            var e2 = this.isPaused = false;
            return this.generatedError && (this.error(this.generatedError), e2 = true), this.previous && this.previous.resume(), !e2;
          }, flush: function() {
          }, processChunk: function(e2) {
            this.push(e2);
          }, withStreamInfo: function(e2, t2) {
            return this.extraStreamInfo[e2] = t2, this.mergeStreamInfo(), this;
          }, mergeStreamInfo: function() {
            for (var e2 in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e2) && (this.streamInfo[e2] = this.extraStreamInfo[e2]);
          }, lock: function() {
            if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
            this.isLocked = true, this.previous && this.previous.lock();
          }, toString: function() {
            var e2 = "Worker " + this.name;
            return this.previous ? this.previous + " -> " + e2 : e2;
          } }, t.exports = n;
        }, {}], 29: [function(e, t, r) {
          "use strict";
          var h = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), u = e("../base64"), n = e("../support"), a = e("../external"), o = null;
          if (n.nodestream) try {
            o = e("../nodejs/NodejsStreamOutputAdapter");
          } catch (e2) {
          }
          function l(e2, o2) {
            return new a.Promise(function(t2, r2) {
              var n2 = [], i2 = e2._internalType, s2 = e2._outputType, a2 = e2._mimeType;
              e2.on("data", function(e3, t3) {
                n2.push(e3), o2 && o2(t3);
              }).on("error", function(e3) {
                n2 = [], r2(e3);
              }).on("end", function() {
                try {
                  var e3 = function(e4, t3, r3) {
                    switch (e4) {
                      case "blob":
                        return h.newBlob(h.transformTo("arraybuffer", t3), r3);
                      case "base64":
                        return u.encode(t3);
                      default:
                        return h.transformTo(e4, t3);
                    }
                  }(s2, function(e4, t3) {
                    var r3, n3 = 0, i3 = null, s3 = 0;
                    for (r3 = 0; r3 < t3.length; r3++) s3 += t3[r3].length;
                    switch (e4) {
                      case "string":
                        return t3.join("");
                      case "array":
                        return Array.prototype.concat.apply([], t3);
                      case "uint8array":
                        for (i3 = new Uint8Array(s3), r3 = 0; r3 < t3.length; r3++) i3.set(t3[r3], n3), n3 += t3[r3].length;
                        return i3;
                      case "nodebuffer":
                        return Buffer.concat(t3);
                      default:
                        throw new Error("concat : unsupported type '" + e4 + "'");
                    }
                  }(i2, n2), a2);
                  t2(e3);
                } catch (e4) {
                  r2(e4);
                }
                n2 = [];
              }).resume();
            });
          }
          function f(e2, t2, r2) {
            var n2 = t2;
            switch (t2) {
              case "blob":
              case "arraybuffer":
                n2 = "uint8array";
                break;
              case "base64":
                n2 = "string";
            }
            try {
              this._internalType = n2, this._outputType = t2, this._mimeType = r2, h.checkSupport(n2), this._worker = e2.pipe(new i(n2)), e2.lock();
            } catch (e3) {
              this._worker = new s("error"), this._worker.error(e3);
            }
          }
          f.prototype = { accumulate: function(e2) {
            return l(this, e2);
          }, on: function(e2, t2) {
            var r2 = this;
            return "data" === e2 ? this._worker.on(e2, function(e3) {
              t2.call(r2, e3.data, e3.meta);
            }) : this._worker.on(e2, function() {
              h.delay(t2, arguments, r2);
            }), this;
          }, resume: function() {
            return h.delay(this._worker.resume, [], this._worker), this;
          }, pause: function() {
            return this._worker.pause(), this;
          }, toNodejsStream: function(e2) {
            if (h.checkSupport("nodestream"), "nodebuffer" !== this._outputType) throw new Error(this._outputType + " is not supported by this method");
            return new o(this, { objectMode: "nodebuffer" !== this._outputType }, e2);
          } }, t.exports = f;
        }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, t, r) {
          "use strict";
          if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = "undefined" != typeof Buffer, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer) r.blob = false;
          else {
            var n = new ArrayBuffer(0);
            try {
              r.blob = 0 === new Blob([n], { type: "application/zip" }).size;
            } catch (e2) {
              try {
                var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                i.append(n), r.blob = 0 === i.getBlob("application/zip").size;
              } catch (e3) {
                r.blob = false;
              }
            }
          }
          try {
            r.nodestream = !!e("readable-stream").Readable;
          } catch (e2) {
            r.nodestream = false;
          }
        }, { "readable-stream": 16 }], 31: [function(e, t, s) {
          "use strict";
          for (var o = e("./utils"), h = e("./support"), r = e("./nodejsUtils"), n = e("./stream/GenericWorker"), u = new Array(256), i = 0; i < 256; i++) u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
          u[254] = u[254] = 1;
          function a() {
            n.call(this, "utf-8 decode"), this.leftOver = null;
          }
          function l() {
            n.call(this, "utf-8 encode");
          }
          s.utf8encode = function(e2) {
            return h.nodebuffer ? r.newBufferFrom(e2, "utf-8") : function(e3) {
              var t2, r2, n2, i2, s2, a2 = e3.length, o2 = 0;
              for (i2 = 0; i2 < a2; i2++) 55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
              for (t2 = h.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0; s2 < o2; i2++) 55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
              return t2;
            }(e2);
          }, s.utf8decode = function(e2) {
            return h.nodebuffer ? o.transformTo("nodebuffer", e2).toString("utf-8") : function(e3) {
              var t2, r2, n2, i2, s2 = e3.length, a2 = new Array(2 * s2);
              for (t2 = r2 = 0; t2 < s2; ) if ((n2 = e3[t2++]) < 128) a2[r2++] = n2;
              else if (4 < (i2 = u[n2])) a2[r2++] = 65533, t2 += i2 - 1;
              else {
                for (n2 &= 2 === i2 ? 31 : 3 === i2 ? 15 : 7; 1 < i2 && t2 < s2; ) n2 = n2 << 6 | 63 & e3[t2++], i2--;
                1 < i2 ? a2[r2++] = 65533 : n2 < 65536 ? a2[r2++] = n2 : (n2 -= 65536, a2[r2++] = 55296 | n2 >> 10 & 1023, a2[r2++] = 56320 | 1023 & n2);
              }
              return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
            }(e2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2));
          }, o.inherits(a, n), a.prototype.processChunk = function(e2) {
            var t2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2.data);
            if (this.leftOver && this.leftOver.length) {
              if (h.uint8array) {
                var r2 = t2;
                (t2 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), t2.set(r2, this.leftOver.length);
              } else t2 = this.leftOver.concat(t2);
              this.leftOver = null;
            }
            var n2 = function(e3, t3) {
              var r3;
              for ((t3 = t3 || e3.length) > e3.length && (t3 = e3.length), r3 = t3 - 1; 0 <= r3 && 128 == (192 & e3[r3]); ) r3--;
              return r3 < 0 ? t3 : 0 === r3 ? t3 : r3 + u[e3[r3]] > t3 ? r3 : t3;
            }(t2), i2 = t2;
            n2 !== t2.length && (h.uint8array ? (i2 = t2.subarray(0, n2), this.leftOver = t2.subarray(n2, t2.length)) : (i2 = t2.slice(0, n2), this.leftOver = t2.slice(n2, t2.length))), this.push({ data: s.utf8decode(i2), meta: e2.meta });
          }, a.prototype.flush = function() {
            this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
          }, s.Utf8DecodeWorker = a, o.inherits(l, n), l.prototype.processChunk = function(e2) {
            this.push({ data: s.utf8encode(e2.data), meta: e2.meta });
          }, s.Utf8EncodeWorker = l;
        }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, t, a) {
          "use strict";
          var o = e("./support"), h = e("./base64"), r = e("./nodejsUtils"), u = e("./external");
          function n(e2) {
            return e2;
          }
          function l(e2, t2) {
            for (var r2 = 0; r2 < e2.length; ++r2) t2[r2] = 255 & e2.charCodeAt(r2);
            return t2;
          }
          e("setimmediate"), a.newBlob = function(t2, r2) {
            a.checkSupport("blob");
            try {
              return new Blob([t2], { type: r2 });
            } catch (e2) {
              try {
                var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                return n2.append(t2), n2.getBlob(r2);
              } catch (e3) {
                throw new Error("Bug : can't construct the Blob.");
              }
            }
          };
          var i = { stringifyByChunk: function(e2, t2, r2) {
            var n2 = [], i2 = 0, s2 = e2.length;
            if (s2 <= r2) return String.fromCharCode.apply(null, e2);
            for (; i2 < s2; ) "array" === t2 || "nodebuffer" === t2 ? n2.push(String.fromCharCode.apply(null, e2.slice(i2, Math.min(i2 + r2, s2)))) : n2.push(String.fromCharCode.apply(null, e2.subarray(i2, Math.min(i2 + r2, s2)))), i2 += r2;
            return n2.join("");
          }, stringifyByChar: function(e2) {
            for (var t2 = "", r2 = 0; r2 < e2.length; r2++) t2 += String.fromCharCode(e2[r2]);
            return t2;
          }, applyCanBeUsed: { uint8array: function() {
            try {
              return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
            } catch (e2) {
              return false;
            }
          }(), nodebuffer: function() {
            try {
              return o.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length;
            } catch (e2) {
              return false;
            }
          }() } };
          function s(e2) {
            var t2 = 65536, r2 = a.getTypeOf(e2), n2 = true;
            if ("uint8array" === r2 ? n2 = i.applyCanBeUsed.uint8array : "nodebuffer" === r2 && (n2 = i.applyCanBeUsed.nodebuffer), n2) for (; 1 < t2; ) try {
              return i.stringifyByChunk(e2, r2, t2);
            } catch (e3) {
              t2 = Math.floor(t2 / 2);
            }
            return i.stringifyByChar(e2);
          }
          function f(e2, t2) {
            for (var r2 = 0; r2 < e2.length; r2++) t2[r2] = e2[r2];
            return t2;
          }
          a.applyFromCharCode = s;
          var c = {};
          c.string = { string: n, array: function(e2) {
            return l(e2, new Array(e2.length));
          }, arraybuffer: function(e2) {
            return c.string.uint8array(e2).buffer;
          }, uint8array: function(e2) {
            return l(e2, new Uint8Array(e2.length));
          }, nodebuffer: function(e2) {
            return l(e2, r.allocBuffer(e2.length));
          } }, c.array = { string: s, array: n, arraybuffer: function(e2) {
            return new Uint8Array(e2).buffer;
          }, uint8array: function(e2) {
            return new Uint8Array(e2);
          }, nodebuffer: function(e2) {
            return r.newBufferFrom(e2);
          } }, c.arraybuffer = { string: function(e2) {
            return s(new Uint8Array(e2));
          }, array: function(e2) {
            return f(new Uint8Array(e2), new Array(e2.byteLength));
          }, arraybuffer: n, uint8array: function(e2) {
            return new Uint8Array(e2);
          }, nodebuffer: function(e2) {
            return r.newBufferFrom(new Uint8Array(e2));
          } }, c.uint8array = { string: s, array: function(e2) {
            return f(e2, new Array(e2.length));
          }, arraybuffer: function(e2) {
            return e2.buffer;
          }, uint8array: n, nodebuffer: function(e2) {
            return r.newBufferFrom(e2);
          } }, c.nodebuffer = { string: s, array: function(e2) {
            return f(e2, new Array(e2.length));
          }, arraybuffer: function(e2) {
            return c.nodebuffer.uint8array(e2).buffer;
          }, uint8array: function(e2) {
            return f(e2, new Uint8Array(e2.length));
          }, nodebuffer: n }, a.transformTo = function(e2, t2) {
            if (t2 = t2 || "", !e2) return t2;
            a.checkSupport(e2);
            var r2 = a.getTypeOf(t2);
            return c[r2][e2](t2);
          }, a.resolve = function(e2) {
            for (var t2 = e2.split("/"), r2 = [], n2 = 0; n2 < t2.length; n2++) {
              var i2 = t2[n2];
              "." === i2 || "" === i2 && 0 !== n2 && n2 !== t2.length - 1 || (".." === i2 ? r2.pop() : r2.push(i2));
            }
            return r2.join("/");
          }, a.getTypeOf = function(e2) {
            return "string" == typeof e2 ? "string" : "[object Array]" === Object.prototype.toString.call(e2) ? "array" : o.nodebuffer && r.isBuffer(e2) ? "nodebuffer" : o.uint8array && e2 instanceof Uint8Array ? "uint8array" : o.arraybuffer && e2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
          }, a.checkSupport = function(e2) {
            if (!o[e2.toLowerCase()]) throw new Error(e2 + " is not supported by this platform");
          }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e2) {
            var t2, r2, n2 = "";
            for (r2 = 0; r2 < (e2 || "").length; r2++) n2 += "\\x" + ((t2 = e2.charCodeAt(r2)) < 16 ? "0" : "") + t2.toString(16).toUpperCase();
            return n2;
          }, a.delay = function(e2, t2, r2) {
            setImmediate(function() {
              e2.apply(r2 || null, t2 || []);
            });
          }, a.inherits = function(e2, t2) {
            function r2() {
            }
            r2.prototype = t2.prototype, e2.prototype = new r2();
          }, a.extend = function() {
            var e2, t2, r2 = {};
            for (e2 = 0; e2 < arguments.length; e2++) for (t2 in arguments[e2]) Object.prototype.hasOwnProperty.call(arguments[e2], t2) && void 0 === r2[t2] && (r2[t2] = arguments[e2][t2]);
            return r2;
          }, a.prepareContent = function(r2, e2, n2, i2, s2) {
            return u.Promise.resolve(e2).then(function(n3) {
              return o.blob && (n3 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n3))) && "undefined" != typeof FileReader ? new u.Promise(function(t2, r3) {
                var e3 = new FileReader();
                e3.onload = function(e4) {
                  t2(e4.target.result);
                }, e3.onerror = function(e4) {
                  r3(e4.target.error);
                }, e3.readAsArrayBuffer(n3);
              }) : n3;
            }).then(function(e3) {
              var t2 = a.getTypeOf(e3);
              return t2 ? ("arraybuffer" === t2 ? e3 = a.transformTo("uint8array", e3) : "string" === t2 && (s2 ? e3 = h.decode(e3) : n2 && true !== i2 && (e3 = function(e4) {
                return l(e4, o.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));
              }(e3))), e3) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
            });
          };
        }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, t, r) {
          "use strict";
          var n = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = e("./support");
          function h(e2) {
            this.files = [], this.loadOptions = e2;
          }
          h.prototype = { checkSignature: function(e2) {
            if (!this.reader.readAndCheckSignature(e2)) {
              this.reader.index -= 4;
              var t2 = this.reader.readString(4);
              throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t2) + ", expected " + i.pretty(e2) + ")");
            }
          }, isSignature: function(e2, t2) {
            var r2 = this.reader.index;
            this.reader.setIndex(e2);
            var n2 = this.reader.readString(4) === t2;
            return this.reader.setIndex(r2), n2;
          }, readBlockEndOfCentral: function() {
            this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
            var e2 = this.reader.readData(this.zipCommentLength), t2 = o.uint8array ? "uint8array" : "array", r2 = i.transformTo(t2, e2);
            this.zipComment = this.loadOptions.decodeFileName(r2);
          }, readBlockZip64EndOfCentral: function() {
            this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
            for (var e2, t2, r2, n2 = this.zip64EndOfCentralSize - 44; 0 < n2; ) e2 = this.reader.readInt(2), t2 = this.reader.readInt(4), r2 = this.reader.readData(t2), this.zip64ExtensibleData[e2] = { id: e2, length: t2, value: r2 };
          }, readBlockZip64EndOfCentralLocator: function() {
            if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
          }, readLocalFiles: function() {
            var e2, t2;
            for (e2 = 0; e2 < this.files.length; e2++) t2 = this.files[e2], this.reader.setIndex(t2.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t2.readLocalPart(this.reader), t2.handleUTF8(), t2.processAttributes();
          }, readCentralDir: function() {
            var e2;
            for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); ) (e2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e2);
            if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
          }, readEndOfCentral: function() {
            var e2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
            if (e2 < 0) throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
            this.reader.setIndex(e2);
            var t2 = e2;
            if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
              if (this.zip64 = true, (e2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
              if (this.reader.setIndex(e2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
              this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
            }
            var r2 = this.centralDirOffset + this.centralDirSize;
            this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
            var n2 = t2 - r2;
            if (0 < n2) this.isSignature(t2, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n2);
            else if (n2 < 0) throw new Error("Corrupted zip: missing " + Math.abs(n2) + " bytes.");
          }, prepareReader: function(e2) {
            this.reader = n(e2);
          }, load: function(e2) {
            this.prepareReader(e2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
          } }, t.exports = h;
        }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, t, r) {
          "use strict";
          var n = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), h = e("./compressions"), u = e("./support");
          function l(e2, t2) {
            this.options = e2, this.loadOptions = t2;
          }
          l.prototype = { isEncrypted: function() {
            return 1 == (1 & this.bitFlag);
          }, useUTF8: function() {
            return 2048 == (2048 & this.bitFlag);
          }, readLocalPart: function(e2) {
            var t2, r2;
            if (e2.skip(22), this.fileNameLength = e2.readInt(2), r2 = e2.readInt(2), this.fileName = e2.readData(this.fileNameLength), e2.skip(r2), -1 === this.compressedSize || -1 === this.uncompressedSize) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
            if (null === (t2 = function(e3) {
              for (var t3 in h) if (Object.prototype.hasOwnProperty.call(h, t3) && h[t3].magic === e3) return h[t3];
              return null;
            }(this.compressionMethod))) throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
            this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t2, e2.readData(this.compressedSize));
          }, readCentralPart: function(e2) {
            this.versionMadeBy = e2.readInt(2), e2.skip(2), this.bitFlag = e2.readInt(2), this.compressionMethod = e2.readString(2), this.date = e2.readDate(), this.crc32 = e2.readInt(4), this.compressedSize = e2.readInt(4), this.uncompressedSize = e2.readInt(4);
            var t2 = e2.readInt(2);
            if (this.extraFieldsLength = e2.readInt(2), this.fileCommentLength = e2.readInt(2), this.diskNumberStart = e2.readInt(2), this.internalFileAttributes = e2.readInt(2), this.externalFileAttributes = e2.readInt(4), this.localHeaderOffset = e2.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
            e2.skip(t2), this.readExtraFields(e2), this.parseZIP64ExtraField(e2), this.fileComment = e2.readData(this.fileCommentLength);
          }, processAttributes: function() {
            this.unixPermissions = null, this.dosPermissions = null;
            var e2 = this.versionMadeBy >> 8;
            this.dir = !!(16 & this.externalFileAttributes), 0 == e2 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e2 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
          }, parseZIP64ExtraField: function() {
            if (this.extraFields[1]) {
              var e2 = n(this.extraFields[1].value);
              this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
            }
          }, readExtraFields: function(e2) {
            var t2, r2, n2, i2 = e2.index + this.extraFieldsLength;
            for (this.extraFields || (this.extraFields = {}); e2.index + 4 < i2; ) t2 = e2.readInt(2), r2 = e2.readInt(2), n2 = e2.readData(r2), this.extraFields[t2] = { id: t2, length: r2, value: n2 };
            e2.setIndex(i2);
          }, handleUTF8: function() {
            var e2 = u.uint8array ? "uint8array" : "array";
            if (this.useUTF8()) this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
            else {
              var t2 = this.findExtraFieldUnicodePath();
              if (null !== t2) this.fileNameStr = t2;
              else {
                var r2 = s.transformTo(e2, this.fileName);
                this.fileNameStr = this.loadOptions.decodeFileName(r2);
              }
              var n2 = this.findExtraFieldUnicodeComment();
              if (null !== n2) this.fileCommentStr = n2;
              else {
                var i2 = s.transformTo(e2, this.fileComment);
                this.fileCommentStr = this.loadOptions.decodeFileName(i2);
              }
            }
          }, findExtraFieldUnicodePath: function() {
            var e2 = this.extraFields[28789];
            if (e2) {
              var t2 = n(e2.value);
              return 1 !== t2.readInt(1) ? null : a(this.fileName) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
            }
            return null;
          }, findExtraFieldUnicodeComment: function() {
            var e2 = this.extraFields[25461];
            if (e2) {
              var t2 = n(e2.value);
              return 1 !== t2.readInt(1) ? null : a(this.fileComment) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
            }
            return null;
          } }, t.exports = l;
        }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, t, r) {
          "use strict";
          function n(e2, t2, r2) {
            this.name = e2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = t2, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
          }
          var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), h = e("./stream/GenericWorker");
          n.prototype = { internalStream: function(e2) {
            var t2 = null, r2 = "string";
            try {
              if (!e2) throw new Error("No output type specified.");
              var n2 = "string" === (r2 = e2.toLowerCase()) || "text" === r2;
              "binarystring" !== r2 && "text" !== r2 || (r2 = "string"), t2 = this._decompressWorker();
              var i2 = !this._dataBinary;
              i2 && !n2 && (t2 = t2.pipe(new a.Utf8EncodeWorker())), !i2 && n2 && (t2 = t2.pipe(new a.Utf8DecodeWorker()));
            } catch (e3) {
              (t2 = new h("error")).error(e3);
            }
            return new s(t2, r2, "");
          }, async: function(e2, t2) {
            return this.internalStream(e2).accumulate(t2);
          }, nodeStream: function(e2, t2) {
            return this.internalStream(e2 || "nodebuffer").toNodejsStream(t2);
          }, _compressWorker: function(e2, t2) {
            if (this._data instanceof o && this._data.compression.magic === e2.magic) return this._data.getCompressedWorker();
            var r2 = this._decompressWorker();
            return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, e2, t2);
          }, _decompressWorker: function() {
            return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new i(this._data);
          } };
          for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function() {
            throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
          }, f = 0; f < u.length; f++) n.prototype[u[f]] = l;
          t.exports = n;
        }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, l, t) {
          (function(t2) {
            "use strict";
            var r, n, e2 = t2.MutationObserver || t2.WebKitMutationObserver;
            if (e2) {
              var i = 0, s = new e2(u), a = t2.document.createTextNode("");
              s.observe(a, { characterData: true }), r = function() {
                a.data = i = ++i % 2;
              };
            } else if (t2.setImmediate || void 0 === t2.MessageChannel) r = "document" in t2 && "onreadystatechange" in t2.document.createElement("script") ? function() {
              var e3 = t2.document.createElement("script");
              e3.onreadystatechange = function() {
                u(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;
              }, t2.document.documentElement.appendChild(e3);
            } : function() {
              setTimeout(u, 0);
            };
            else {
              var o = new t2.MessageChannel();
              o.port1.onmessage = u, r = function() {
                o.port2.postMessage(0);
              };
            }
            var h = [];
            function u() {
              var e3, t3;
              n = true;
              for (var r2 = h.length; r2; ) {
                for (t3 = h, h = [], e3 = -1; ++e3 < r2; ) t3[e3]();
                r2 = h.length;
              }
              n = false;
            }
            l.exports = function(e3) {
              1 !== h.push(e3) || n || r();
            };
          }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
        }, {}], 37: [function(e, t, r) {
          "use strict";
          var i = e("immediate");
          function u() {
          }
          var l = {}, s = ["REJECTED"], a = ["FULFILLED"], n = ["PENDING"];
          function o(e2) {
            if ("function" != typeof e2) throw new TypeError("resolver must be a function");
            this.state = n, this.queue = [], this.outcome = void 0, e2 !== u && d(this, e2);
          }
          function h(e2, t2, r2) {
            this.promise = e2, "function" == typeof t2 && (this.onFulfilled = t2, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r2 && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
          }
          function f(t2, r2, n2) {
            i(function() {
              var e2;
              try {
                e2 = r2(n2);
              } catch (e3) {
                return l.reject(t2, e3);
              }
              e2 === t2 ? l.reject(t2, new TypeError("Cannot resolve promise with itself")) : l.resolve(t2, e2);
            });
          }
          function c(e2) {
            var t2 = e2 && e2.then;
            if (e2 && ("object" == typeof e2 || "function" == typeof e2) && "function" == typeof t2) return function() {
              t2.apply(e2, arguments);
            };
          }
          function d(t2, e2) {
            var r2 = false;
            function n2(e3) {
              r2 || (r2 = true, l.reject(t2, e3));
            }
            function i2(e3) {
              r2 || (r2 = true, l.resolve(t2, e3));
            }
            var s2 = p(function() {
              e2(i2, n2);
            });
            "error" === s2.status && n2(s2.value);
          }
          function p(e2, t2) {
            var r2 = {};
            try {
              r2.value = e2(t2), r2.status = "success";
            } catch (e3) {
              r2.status = "error", r2.value = e3;
            }
            return r2;
          }
          (t.exports = o).prototype.finally = function(t2) {
            if ("function" != typeof t2) return this;
            var r2 = this.constructor;
            return this.then(function(e2) {
              return r2.resolve(t2()).then(function() {
                return e2;
              });
            }, function(e2) {
              return r2.resolve(t2()).then(function() {
                throw e2;
              });
            });
          }, o.prototype.catch = function(e2) {
            return this.then(null, e2);
          }, o.prototype.then = function(e2, t2) {
            if ("function" != typeof e2 && this.state === a || "function" != typeof t2 && this.state === s) return this;
            var r2 = new this.constructor(u);
            this.state !== n ? f(r2, this.state === a ? e2 : t2, this.outcome) : this.queue.push(new h(r2, e2, t2));
            return r2;
          }, h.prototype.callFulfilled = function(e2) {
            l.resolve(this.promise, e2);
          }, h.prototype.otherCallFulfilled = function(e2) {
            f(this.promise, this.onFulfilled, e2);
          }, h.prototype.callRejected = function(e2) {
            l.reject(this.promise, e2);
          }, h.prototype.otherCallRejected = function(e2) {
            f(this.promise, this.onRejected, e2);
          }, l.resolve = function(e2, t2) {
            var r2 = p(c, t2);
            if ("error" === r2.status) return l.reject(e2, r2.value);
            var n2 = r2.value;
            if (n2) d(e2, n2);
            else {
              e2.state = a, e2.outcome = t2;
              for (var i2 = -1, s2 = e2.queue.length; ++i2 < s2; ) e2.queue[i2].callFulfilled(t2);
            }
            return e2;
          }, l.reject = function(e2, t2) {
            e2.state = s, e2.outcome = t2;
            for (var r2 = -1, n2 = e2.queue.length; ++r2 < n2; ) e2.queue[r2].callRejected(t2);
            return e2;
          }, o.resolve = function(e2) {
            if (e2 instanceof this) return e2;
            return l.resolve(new this(u), e2);
          }, o.reject = function(e2) {
            var t2 = new this(u);
            return l.reject(t2, e2);
          }, o.all = function(e2) {
            var r2 = this;
            if ("[object Array]" !== Object.prototype.toString.call(e2)) return this.reject(new TypeError("must be an array"));
            var n2 = e2.length, i2 = false;
            if (!n2) return this.resolve([]);
            var s2 = new Array(n2), a2 = 0, t2 = -1, o2 = new this(u);
            for (; ++t2 < n2; ) h2(e2[t2], t2);
            return o2;
            function h2(e3, t3) {
              r2.resolve(e3).then(function(e4) {
                s2[t3] = e4, ++a2 !== n2 || i2 || (i2 = true, l.resolve(o2, s2));
              }, function(e4) {
                i2 || (i2 = true, l.reject(o2, e4));
              });
            }
          }, o.race = function(e2) {
            var t2 = this;
            if ("[object Array]" !== Object.prototype.toString.call(e2)) return this.reject(new TypeError("must be an array"));
            var r2 = e2.length, n2 = false;
            if (!r2) return this.resolve([]);
            var i2 = -1, s2 = new this(u);
            for (; ++i2 < r2; ) a2 = e2[i2], t2.resolve(a2).then(function(e3) {
              n2 || (n2 = true, l.resolve(s2, e3));
            }, function(e3) {
              n2 || (n2 = true, l.reject(s2, e3));
            });
            var a2;
            return s2;
          };
        }, { immediate: 36 }], 38: [function(e, t, r) {
          "use strict";
          var n = {};
          (0, e("./lib/utils/common").assign)(n, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t.exports = n;
        }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, t, r) {
          "use strict";
          var a = e("./zlib/deflate"), o = e("./utils/common"), h = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, c = 0, d = 8;
          function p(e2) {
            if (!(this instanceof p)) return new p(e2);
            this.options = o.assign({ level: f, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c, to: "" }, e2 || {});
            var t2 = this.options;
            t2.raw && 0 < t2.windowBits ? t2.windowBits = -t2.windowBits : t2.gzip && 0 < t2.windowBits && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
            var r2 = a.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
            if (r2 !== l) throw new Error(i[r2]);
            if (t2.header && a.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
              var n2;
              if (n2 = "string" == typeof t2.dictionary ? h.string2buf(t2.dictionary) : "[object ArrayBuffer]" === u.call(t2.dictionary) ? new Uint8Array(t2.dictionary) : t2.dictionary, (r2 = a.deflateSetDictionary(this.strm, n2)) !== l) throw new Error(i[r2]);
              this._dict_set = true;
            }
          }
          function n(e2, t2) {
            var r2 = new p(t2);
            if (r2.push(e2, true), r2.err) throw r2.msg || i[r2.err];
            return r2.result;
          }
          p.prototype.push = function(e2, t2) {
            var r2, n2, i2 = this.strm, s2 = this.options.chunkSize;
            if (this.ended) return false;
            n2 = t2 === ~~t2 ? t2 : true === t2 ? 4 : 0, "string" == typeof e2 ? i2.input = h.string2buf(e2) : "[object ArrayBuffer]" === u.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length;
            do {
              if (0 === i2.avail_out && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), 1 !== (r2 = a.deflate(i2, n2)) && r2 !== l) return this.onEnd(r2), !(this.ended = true);
              0 !== i2.avail_out && (0 !== i2.avail_in || 4 !== n2 && 2 !== n2) || ("string" === this.options.to ? this.onData(h.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));
            } while ((0 < i2.avail_in || 0 === i2.avail_out) && 1 !== r2);
            return 4 === n2 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : 2 !== n2 || (this.onEnd(l), !(i2.avail_out = 0));
          }, p.prototype.onData = function(e2) {
            this.chunks.push(e2);
          }, p.prototype.onEnd = function(e2) {
            e2 === l && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
          }, r.Deflate = p, r.deflate = n, r.deflateRaw = function(e2, t2) {
            return (t2 = t2 || {}).raw = true, n(e2, t2);
          }, r.gzip = function(e2, t2) {
            return (t2 = t2 || {}).gzip = true, n(e2, t2);
          };
        }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, t, r) {
          "use strict";
          var c = e("./zlib/inflate"), d = e("./utils/common"), p = e("./utils/strings"), m = e("./zlib/constants"), n = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _ = Object.prototype.toString;
          function a(e2) {
            if (!(this instanceof a)) return new a(e2);
            this.options = d.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e2 || {});
            var t2 = this.options;
            t2.raw && 0 <= t2.windowBits && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(0 <= t2.windowBits && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), 15 < t2.windowBits && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
            var r2 = c.inflateInit2(this.strm, t2.windowBits);
            if (r2 !== m.Z_OK) throw new Error(n[r2]);
            this.header = new s(), c.inflateGetHeader(this.strm, this.header);
          }
          function o(e2, t2) {
            var r2 = new a(t2);
            if (r2.push(e2, true), r2.err) throw r2.msg || n[r2.err];
            return r2.result;
          }
          a.prototype.push = function(e2, t2) {
            var r2, n2, i2, s2, a2, o2, h = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = false;
            if (this.ended) return false;
            n2 = t2 === ~~t2 ? t2 : true === t2 ? m.Z_FINISH : m.Z_NO_FLUSH, "string" == typeof e2 ? h.input = p.binstring2buf(e2) : "[object ArrayBuffer]" === _.call(e2) ? h.input = new Uint8Array(e2) : h.input = e2, h.next_in = 0, h.avail_in = h.input.length;
            do {
              if (0 === h.avail_out && (h.output = new d.Buf8(u), h.next_out = 0, h.avail_out = u), (r2 = c.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = "string" == typeof l ? p.string2buf(l) : "[object ArrayBuffer]" === _.call(l) ? new Uint8Array(l) : l, r2 = c.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && true === f && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK) return this.onEnd(r2), !(this.ended = true);
              h.next_out && (0 !== h.avail_out && r2 !== m.Z_STREAM_END && (0 !== h.avail_in || n2 !== m.Z_FINISH && n2 !== m.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i2 = p.utf8border(h.output, h.next_out), s2 = h.next_out - i2, a2 = p.buf2string(h.output, i2), h.next_out = s2, h.avail_out = u - s2, s2 && d.arraySet(h.output, h.output, i2, s2, 0), this.onData(a2)) : this.onData(d.shrinkBuf(h.output, h.next_out)))), 0 === h.avail_in && 0 === h.avail_out && (f = true);
            } while ((0 < h.avail_in || 0 === h.avail_out) && r2 !== m.Z_STREAM_END);
            return r2 === m.Z_STREAM_END && (n2 = m.Z_FINISH), n2 === m.Z_FINISH ? (r2 = c.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : n2 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h.avail_out = 0));
          }, a.prototype.onData = function(e2) {
            this.chunks.push(e2);
          }, a.prototype.onEnd = function(e2) {
            e2 === m.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
          }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(e2, t2) {
            return (t2 = t2 || {}).raw = true, o(e2, t2);
          }, r.ungzip = o;
        }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, t, r) {
          "use strict";
          var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
          r.assign = function(e2) {
            for (var t2 = Array.prototype.slice.call(arguments, 1); t2.length; ) {
              var r2 = t2.shift();
              if (r2) {
                if ("object" != typeof r2) throw new TypeError(r2 + "must be non-object");
                for (var n2 in r2) r2.hasOwnProperty(n2) && (e2[n2] = r2[n2]);
              }
            }
            return e2;
          }, r.shrinkBuf = function(e2, t2) {
            return e2.length === t2 ? e2 : e2.subarray ? e2.subarray(0, t2) : (e2.length = t2, e2);
          };
          var i = { arraySet: function(e2, t2, r2, n2, i2) {
            if (t2.subarray && e2.subarray) e2.set(t2.subarray(r2, r2 + n2), i2);
            else for (var s2 = 0; s2 < n2; s2++) e2[i2 + s2] = t2[r2 + s2];
          }, flattenChunks: function(e2) {
            var t2, r2, n2, i2, s2, a;
            for (t2 = n2 = 0, r2 = e2.length; t2 < r2; t2++) n2 += e2[t2].length;
            for (a = new Uint8Array(n2), t2 = i2 = 0, r2 = e2.length; t2 < r2; t2++) s2 = e2[t2], a.set(s2, i2), i2 += s2.length;
            return a;
          } }, s = { arraySet: function(e2, t2, r2, n2, i2) {
            for (var s2 = 0; s2 < n2; s2++) e2[i2 + s2] = t2[r2 + s2];
          }, flattenChunks: function(e2) {
            return [].concat.apply([], e2);
          } };
          r.setTyped = function(e2) {
            e2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
          }, r.setTyped(n);
        }, {}], 42: [function(e, t, r) {
          "use strict";
          var h = e("./common"), i = true, s = true;
          try {
            String.fromCharCode.apply(null, [0]);
          } catch (e2) {
            i = false;
          }
          try {
            String.fromCharCode.apply(null, new Uint8Array(1));
          } catch (e2) {
            s = false;
          }
          for (var u = new h.Buf8(256), n = 0; n < 256; n++) u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
          function l(e2, t2) {
            if (t2 < 65537 && (e2.subarray && s || !e2.subarray && i)) return String.fromCharCode.apply(null, h.shrinkBuf(e2, t2));
            for (var r2 = "", n2 = 0; n2 < t2; n2++) r2 += String.fromCharCode(e2[n2]);
            return r2;
          }
          u[254] = u[254] = 1, r.string2buf = function(e2) {
            var t2, r2, n2, i2, s2, a = e2.length, o = 0;
            for (i2 = 0; i2 < a; i2++) 55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
            for (t2 = new h.Buf8(o), i2 = s2 = 0; s2 < o; i2++) 55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
            return t2;
          }, r.buf2binstring = function(e2) {
            return l(e2, e2.length);
          }, r.binstring2buf = function(e2) {
            for (var t2 = new h.Buf8(e2.length), r2 = 0, n2 = t2.length; r2 < n2; r2++) t2[r2] = e2.charCodeAt(r2);
            return t2;
          }, r.buf2string = function(e2, t2) {
            var r2, n2, i2, s2, a = t2 || e2.length, o = new Array(2 * a);
            for (r2 = n2 = 0; r2 < a; ) if ((i2 = e2[r2++]) < 128) o[n2++] = i2;
            else if (4 < (s2 = u[i2])) o[n2++] = 65533, r2 += s2 - 1;
            else {
              for (i2 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; 1 < s2 && r2 < a; ) i2 = i2 << 6 | 63 & e2[r2++], s2--;
              1 < s2 ? o[n2++] = 65533 : i2 < 65536 ? o[n2++] = i2 : (i2 -= 65536, o[n2++] = 55296 | i2 >> 10 & 1023, o[n2++] = 56320 | 1023 & i2);
            }
            return l(o, n2);
          }, r.utf8border = function(e2, t2) {
            var r2;
            for ((t2 = t2 || e2.length) > e2.length && (t2 = e2.length), r2 = t2 - 1; 0 <= r2 && 128 == (192 & e2[r2]); ) r2--;
            return r2 < 0 ? t2 : 0 === r2 ? t2 : r2 + u[e2[r2]] > t2 ? r2 : t2;
          };
        }, { "./common": 41 }], 43: [function(e, t, r) {
          "use strict";
          t.exports = function(e2, t2, r2, n) {
            for (var i = 65535 & e2 | 0, s = e2 >>> 16 & 65535 | 0, a = 0; 0 !== r2; ) {
              for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (i = i + t2[n++] | 0) | 0, --a; ) ;
              i %= 65521, s %= 65521;
            }
            return i | s << 16 | 0;
          };
        }, {}], 44: [function(e, t, r) {
          "use strict";
          t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
        }, {}], 45: [function(e, t, r) {
          "use strict";
          var o = function() {
            for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
              e2 = r2;
              for (var n = 0; n < 8; n++) e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
              t2[r2] = e2;
            }
            return t2;
          }();
          t.exports = function(e2, t2, r2, n) {
            var i = o, s = n + r2;
            e2 ^= -1;
            for (var a = n; a < s; a++) e2 = e2 >>> 8 ^ i[255 & (e2 ^ t2[a])];
            return -1 ^ e2;
          };
        }, {}], 46: [function(e, t, r) {
          "use strict";
          var h, c = e("../utils/common"), u = e("./trees"), d = e("./adler32"), p = e("./crc32"), n = e("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, i = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
          function R(e2, t2) {
            return e2.msg = n[t2], t2;
          }
          function T(e2) {
            return (e2 << 1) - (4 < e2 ? 9 : 0);
          }
          function D(e2) {
            for (var t2 = e2.length; 0 <= --t2; ) e2[t2] = 0;
          }
          function F(e2) {
            var t2 = e2.state, r2 = t2.pending;
            r2 > e2.avail_out && (r2 = e2.avail_out), 0 !== r2 && (c.arraySet(e2.output, t2.pending_buf, t2.pending_out, r2, e2.next_out), e2.next_out += r2, t2.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t2.pending -= r2, 0 === t2.pending && (t2.pending_out = 0));
          }
          function N(e2, t2) {
            u._tr_flush_block(e2, 0 <= e2.block_start ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, F(e2.strm);
          }
          function U(e2, t2) {
            e2.pending_buf[e2.pending++] = t2;
          }
          function P(e2, t2) {
            e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
          }
          function L(e2, t2) {
            var r2, n2, i2 = e2.max_chain_length, s2 = e2.strstart, a2 = e2.prev_length, o2 = e2.nice_match, h2 = e2.strstart > e2.w_size - z ? e2.strstart - (e2.w_size - z) : 0, u2 = e2.window, l2 = e2.w_mask, f2 = e2.prev, c2 = e2.strstart + S, d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
            e2.prev_length >= e2.good_match && (i2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);
            do {
              if (u2[(r2 = t2) + a2] === p2 && u2[r2 + a2 - 1] === d2 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
                s2 += 2, r2++;
                do {
                } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < c2);
                if (n2 = S - (c2 - s2), s2 = c2 - S, a2 < n2) {
                  if (e2.match_start = t2, o2 <= (a2 = n2)) break;
                  d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
                }
              }
            } while ((t2 = f2[t2 & l2]) > h2 && 0 != --i2);
            return a2 <= e2.lookahead ? a2 : e2.lookahead;
          }
          function j(e2) {
            var t2, r2, n2, i2, s2, a2, o2, h2, u2, l2, f2 = e2.w_size;
            do {
              if (i2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= f2 + (f2 - z)) {
                for (c.arraySet(e2.window, e2.window, f2, f2, 0), e2.match_start -= f2, e2.strstart -= f2, e2.block_start -= f2, t2 = r2 = e2.hash_size; n2 = e2.head[--t2], e2.head[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; ) ;
                for (t2 = r2 = f2; n2 = e2.prev[--t2], e2.prev[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; ) ;
                i2 += f2;
              }
              if (0 === e2.strm.avail_in) break;
              if (a2 = e2.strm, o2 = e2.window, h2 = e2.strstart + e2.lookahead, u2 = i2, l2 = void 0, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r2 = 0 === l2 ? 0 : (a2.avail_in -= l2, c.arraySet(o2, a2.input, a2.next_in, l2, h2), 1 === a2.state.wrap ? a2.adler = d(a2.adler, o2, l2, h2) : 2 === a2.state.wrap && (a2.adler = p(a2.adler, o2, l2, h2)), a2.next_in += l2, a2.total_in += l2, l2), e2.lookahead += r2, e2.lookahead + e2.insert >= x) for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + x - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < x)); ) ;
            } while (e2.lookahead < z && 0 !== e2.strm.avail_in);
          }
          function Z(e2, t2) {
            for (var r2, n2; ; ) {
              if (e2.lookahead < z) {
                if (j(e2), e2.lookahead < z && t2 === l) return A;
                if (0 === e2.lookahead) break;
              }
              if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== r2 && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2)), e2.match_length >= x) if (n2 = u._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - x), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= x) {
                for (e2.match_length--; e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart, 0 != --e2.match_length; ) ;
                e2.strstart++;
              } else e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
              else n2 = u._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
              if (n2 && (N(e2, false), 0 === e2.strm.avail_out)) return A;
            }
            return e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
          }
          function W(e2, t2) {
            for (var r2, n2, i2; ; ) {
              if (e2.lookahead < z) {
                if (j(e2), e2.lookahead < z && t2 === l) return A;
                if (0 === e2.lookahead) break;
              }
              if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = x - 1, 0 !== r2 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2), e2.match_length <= 5 && (1 === e2.strategy || e2.match_length === x && 4096 < e2.strstart - e2.match_start) && (e2.match_length = x - 1)), e2.prev_length >= x && e2.match_length <= e2.prev_length) {
                for (i2 = e2.strstart + e2.lookahead - x, n2 = u._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - x), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2; ++e2.strstart <= i2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 != --e2.prev_length; ) ;
                if (e2.match_available = 0, e2.match_length = x - 1, e2.strstart++, n2 && (N(e2, false), 0 === e2.strm.avail_out)) return A;
              } else if (e2.match_available) {
                if ((n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && N(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out) return A;
              } else e2.match_available = 1, e2.strstart++, e2.lookahead--;
            }
            return e2.match_available && (n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
          }
          function M(e2, t2, r2, n2, i2) {
            this.good_length = e2, this.max_lazy = t2, this.nice_length = r2, this.max_chain = n2, this.func = i2;
          }
          function H() {
            this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(2 * w), this.dyn_dtree = new c.Buf16(2 * (2 * a + 1)), this.bl_tree = new c.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(k + 1), this.heap = new c.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
          }
          function G(e2) {
            var t2;
            return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = i, (t2 = e2.state).pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = t2.wrap ? C : E, e2.adler = 2 === t2.wrap ? 0 : 1, t2.last_flush = l, u._tr_init(t2), m) : R(e2, _);
          }
          function K(e2) {
            var t2 = G(e2);
            return t2 === m && function(e3) {
              e3.window_size = 2 * e3.w_size, D(e3.head), e3.max_lazy_match = h[e3.level].max_lazy, e3.good_match = h[e3.level].good_length, e3.nice_match = h[e3.level].nice_length, e3.max_chain_length = h[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = x - 1, e3.match_available = 0, e3.ins_h = 0;
            }(e2.state), t2;
          }
          function Y(e2, t2, r2, n2, i2, s2) {
            if (!e2) return _;
            var a2 = 1;
            if (t2 === g && (t2 = 6), n2 < 0 ? (a2 = 0, n2 = -n2) : 15 < n2 && (a2 = 2, n2 -= 16), i2 < 1 || y < i2 || r2 !== v || n2 < 8 || 15 < n2 || t2 < 0 || 9 < t2 || s2 < 0 || b < s2) return R(e2, _);
            8 === n2 && (n2 = 9);
            var o2 = new H();
            return (e2.state = o2).strm = e2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new c.Buf8(2 * o2.w_size), o2.head = new c.Buf16(o2.hash_size), o2.prev = new c.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t2, o2.strategy = s2, o2.method = r2, K(e2);
          }
          h = [new M(0, 0, 0, 0, function(e2, t2) {
            var r2 = 65535;
            for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {
              if (e2.lookahead <= 1) {
                if (j(e2), 0 === e2.lookahead && t2 === l) return A;
                if (0 === e2.lookahead) break;
              }
              e2.strstart += e2.lookahead, e2.lookahead = 0;
              var n2 = e2.block_start + r2;
              if ((0 === e2.strstart || e2.strstart >= n2) && (e2.lookahead = e2.strstart - n2, e2.strstart = n2, N(e2, false), 0 === e2.strm.avail_out)) return A;
              if (e2.strstart - e2.block_start >= e2.w_size - z && (N(e2, false), 0 === e2.strm.avail_out)) return A;
            }
            return e2.insert = 0, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : (e2.strstart > e2.block_start && (N(e2, false), e2.strm.avail_out), A);
          }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r.deflateInit = function(e2, t2) {
            return Y(e2, t2, v, 15, 8, 0);
          }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function(e2, t2) {
            return e2 && e2.state ? 2 !== e2.state.wrap ? _ : (e2.state.gzhead = t2, m) : _;
          }, r.deflate = function(e2, t2) {
            var r2, n2, i2, s2;
            if (!e2 || !e2.state || 5 < t2 || t2 < 0) return e2 ? R(e2, _) : _;
            if (n2 = e2.state, !e2.output || !e2.input && 0 !== e2.avail_in || 666 === n2.status && t2 !== f) return R(e2, 0 === e2.avail_out ? -5 : _);
            if (n2.strm = e2, r2 = n2.last_flush, n2.last_flush = t2, n2.status === C) if (2 === n2.wrap) e2.adler = 0, U(n2, 31), U(n2, 139), U(n2, 8), n2.gzhead ? (U(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), U(n2, 255 & n2.gzhead.time), U(n2, n2.gzhead.time >> 8 & 255), U(n2, n2.gzhead.time >> 16 & 255), U(n2, n2.gzhead.time >> 24 & 255), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (U(n2, 255 & n2.gzhead.extra.length), U(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 3), n2.status = E);
            else {
              var a2 = v + (n2.w_bits - 8 << 4) << 8;
              a2 |= (2 <= n2.strategy || n2.level < 2 ? 0 : n2.level < 6 ? 1 : 6 === n2.level ? 2 : 3) << 6, 0 !== n2.strstart && (a2 |= 32), a2 += 31 - a2 % 31, n2.status = E, P(n2, a2), 0 !== n2.strstart && (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), e2.adler = 1;
            }
            if (69 === n2.status) if (n2.gzhead.extra) {
              for (i2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending !== n2.pending_buf_size)); ) U(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);
            } else n2.status = 73;
            if (73 === n2.status) if (n2.gzhead.name) {
              i2 = n2.pending;
              do {
                if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                  s2 = 1;
                  break;
                }
                s2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
              } while (0 !== s2);
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.gzindex = 0, n2.status = 91);
            } else n2.status = 91;
            if (91 === n2.status) if (n2.gzhead.comment) {
              i2 = n2.pending;
              do {
                if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                  s2 = 1;
                  break;
                }
                s2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
              } while (0 !== s2);
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.status = 103);
            } else n2.status = 103;
            if (103 === n2.status && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && F(e2), n2.pending + 2 <= n2.pending_buf_size && (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), e2.adler = 0, n2.status = E)) : n2.status = E), 0 !== n2.pending) {
              if (F(e2), 0 === e2.avail_out) return n2.last_flush = -1, m;
            } else if (0 === e2.avail_in && T(t2) <= T(r2) && t2 !== f) return R(e2, -5);
            if (666 === n2.status && 0 !== e2.avail_in) return R(e2, -5);
            if (0 !== e2.avail_in || 0 !== n2.lookahead || t2 !== l && 666 !== n2.status) {
              var o2 = 2 === n2.strategy ? function(e3, t3) {
                for (var r3; ; ) {
                  if (0 === e3.lookahead && (j(e3), 0 === e3.lookahead)) {
                    if (t3 === l) return A;
                    break;
                  }
                  if (e3.match_length = 0, r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (N(e3, false), 0 === e3.strm.avail_out)) return A;
                }
                return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
              }(n2, t2) : 3 === n2.strategy ? function(e3, t3) {
                for (var r3, n3, i3, s3, a3 = e3.window; ; ) {
                  if (e3.lookahead <= S) {
                    if (j(e3), e3.lookahead <= S && t3 === l) return A;
                    if (0 === e3.lookahead) break;
                  }
                  if (e3.match_length = 0, e3.lookahead >= x && 0 < e3.strstart && (n3 = a3[i3 = e3.strstart - 1]) === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3]) {
                    s3 = e3.strstart + S;
                    do {
                    } while (n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && i3 < s3);
                    e3.match_length = S - (s3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
                  }
                  if (e3.match_length >= x ? (r3 = u._tr_tally(e3, 1, e3.match_length - x), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (N(e3, false), 0 === e3.strm.avail_out)) return A;
                }
                return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
              }(n2, t2) : h[n2.level].func(n2, t2);
              if (o2 !== O && o2 !== B || (n2.status = 666), o2 === A || o2 === O) return 0 === e2.avail_out && (n2.last_flush = -1), m;
              if (o2 === I && (1 === t2 ? u._tr_align(n2) : 5 !== t2 && (u._tr_stored_block(n2, 0, 0, false), 3 === t2 && (D(n2.head), 0 === n2.lookahead && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), F(e2), 0 === e2.avail_out)) return n2.last_flush = -1, m;
            }
            return t2 !== f ? m : n2.wrap <= 0 ? 1 : (2 === n2.wrap ? (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), U(n2, e2.adler >> 16 & 255), U(n2, e2.adler >> 24 & 255), U(n2, 255 & e2.total_in), U(n2, e2.total_in >> 8 & 255), U(n2, e2.total_in >> 16 & 255), U(n2, e2.total_in >> 24 & 255)) : (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), F(e2), 0 < n2.wrap && (n2.wrap = -n2.wrap), 0 !== n2.pending ? m : 1);
          }, r.deflateEnd = function(e2) {
            var t2;
            return e2 && e2.state ? (t2 = e2.state.status) !== C && 69 !== t2 && 73 !== t2 && 91 !== t2 && 103 !== t2 && t2 !== E && 666 !== t2 ? R(e2, _) : (e2.state = null, t2 === E ? R(e2, -3) : m) : _;
          }, r.deflateSetDictionary = function(e2, t2) {
            var r2, n2, i2, s2, a2, o2, h2, u2, l2 = t2.length;
            if (!e2 || !e2.state) return _;
            if (2 === (s2 = (r2 = e2.state).wrap) || 1 === s2 && r2.status !== C || r2.lookahead) return _;
            for (1 === s2 && (e2.adler = d(e2.adler, t2, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (0 === s2 && (D(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new c.Buf8(r2.w_size), c.arraySet(u2, t2, l2 - r2.w_size, r2.w_size, 0), t2 = u2, l2 = r2.w_size), a2 = e2.avail_in, o2 = e2.next_in, h2 = e2.input, e2.avail_in = l2, e2.next_in = 0, e2.input = t2, j(r2); r2.lookahead >= x; ) {
              for (n2 = r2.strstart, i2 = r2.lookahead - (x - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n2 + x - 1]) & r2.hash_mask, r2.prev[n2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n2, n2++, --i2; ) ;
              r2.strstart = n2, r2.lookahead = x - 1, j(r2);
            }
            return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, e2.next_in = o2, e2.input = h2, e2.avail_in = a2, r2.wrap = s2, m;
          }, r.deflateInfo = "pako deflate (from Nodeca project)";
        }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, t, r) {
          "use strict";
          t.exports = function() {
            this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
          };
        }, {}], 48: [function(e, t, r) {
          "use strict";
          t.exports = function(e2, t2) {
            var r2, n, i, s, a, o, h, u, l, f, c, d, p, m, _, g, b, v, y, w, k, x, S, z, C;
            r2 = e2.state, n = e2.next_in, z = e2.input, i = n + (e2.avail_in - 5), s = e2.next_out, C = e2.output, a = s - (t2 - e2.avail_out), o = s + (e2.avail_out - 257), h = r2.dmax, u = r2.wsize, l = r2.whave, f = r2.wnext, c = r2.window, d = r2.hold, p = r2.bits, m = r2.lencode, _ = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
            e: do {
              p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = m[d & g];
              t: for (; ; ) {
                if (d >>>= y = v >>> 24, p -= y, 0 === (y = v >>> 16 & 255)) C[s++] = 65535 & v;
                else {
                  if (!(16 & y)) {
                    if (0 == (64 & y)) {
                      v = m[(65535 & v) + (d & (1 << y) - 1)];
                      continue t;
                    }
                    if (32 & y) {
                      r2.mode = 12;
                      break e;
                    }
                    e2.msg = "invalid literal/length code", r2.mode = 30;
                    break e;
                  }
                  w = 65535 & v, (y &= 15) && (p < y && (d += z[n++] << p, p += 8), w += d & (1 << y) - 1, d >>>= y, p -= y), p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = _[d & b];
                  r: for (; ; ) {
                    if (d >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {
                      if (0 == (64 & y)) {
                        v = _[(65535 & v) + (d & (1 << y) - 1)];
                        continue r;
                      }
                      e2.msg = "invalid distance code", r2.mode = 30;
                      break e;
                    }
                    if (k = 65535 & v, p < (y &= 15) && (d += z[n++] << p, (p += 8) < y && (d += z[n++] << p, p += 8)), h < (k += d & (1 << y) - 1)) {
                      e2.msg = "invalid distance too far back", r2.mode = 30;
                      break e;
                    }
                    if (d >>>= y, p -= y, (y = s - a) < k) {
                      if (l < (y = k - y) && r2.sane) {
                        e2.msg = "invalid distance too far back", r2.mode = 30;
                        break e;
                      }
                      if (S = c, (x = 0) === f) {
                        if (x += u - y, y < w) {
                          for (w -= y; C[s++] = c[x++], --y; ) ;
                          x = s - k, S = C;
                        }
                      } else if (f < y) {
                        if (x += u + f - y, (y -= f) < w) {
                          for (w -= y; C[s++] = c[x++], --y; ) ;
                          if (x = 0, f < w) {
                            for (w -= y = f; C[s++] = c[x++], --y; ) ;
                            x = s - k, S = C;
                          }
                        }
                      } else if (x += f - y, y < w) {
                        for (w -= y; C[s++] = c[x++], --y; ) ;
                        x = s - k, S = C;
                      }
                      for (; 2 < w; ) C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;
                      w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));
                    } else {
                      for (x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3); ) ;
                      w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));
                    }
                    break;
                  }
                }
                break;
              }
            } while (n < i && s < o);
            n -= w = p >> 3, d &= (1 << (p -= w << 3)) - 1, e2.next_in = n, e2.next_out = s, e2.avail_in = n < i ? i - n + 5 : 5 - (n - i), e2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = d, r2.bits = p;
          };
        }, {}], 49: [function(e, t, r) {
          "use strict";
          var I = e("../utils/common"), O = e("./adler32"), B = e("./crc32"), R = e("./inffast"), T = e("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, n = 852, i = 592;
          function L(e2) {
            return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
          }
          function s() {
            this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
          }
          function a(e2) {
            var t2;
            return e2 && e2.state ? (t2 = e2.state, e2.total_in = e2.total_out = t2.total = 0, e2.msg = "", t2.wrap && (e2.adler = 1 & t2.wrap), t2.mode = P, t2.last = 0, t2.havedict = 0, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new I.Buf32(n), t2.distcode = t2.distdyn = new I.Buf32(i), t2.sane = 1, t2.back = -1, N) : U;
          }
          function o(e2) {
            var t2;
            return e2 && e2.state ? ((t2 = e2.state).wsize = 0, t2.whave = 0, t2.wnext = 0, a(e2)) : U;
          }
          function h(e2, t2) {
            var r2, n2;
            return e2 && e2.state ? (n2 = e2.state, t2 < 0 ? (r2 = 0, t2 = -t2) : (r2 = 1 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || 15 < t2) ? U : (null !== n2.window && n2.wbits !== t2 && (n2.window = null), n2.wrap = r2, n2.wbits = t2, o(e2))) : U;
          }
          function u(e2, t2) {
            var r2, n2;
            return e2 ? (n2 = new s(), (e2.state = n2).window = null, (r2 = h(e2, t2)) !== N && (e2.state = null), r2) : U;
          }
          var l, f, c = true;
          function j(e2) {
            if (c) {
              var t2;
              for (l = new I.Buf32(512), f = new I.Buf32(32), t2 = 0; t2 < 144; ) e2.lens[t2++] = 8;
              for (; t2 < 256; ) e2.lens[t2++] = 9;
              for (; t2 < 280; ) e2.lens[t2++] = 7;
              for (; t2 < 288; ) e2.lens[t2++] = 8;
              for (T(D, e2.lens, 0, 288, l, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; ) e2.lens[t2++] = 5;
              T(F, e2.lens, 0, 32, f, 0, e2.work, { bits: 5 }), c = false;
            }
            e2.lencode = l, e2.lenbits = 9, e2.distcode = f, e2.distbits = 5;
          }
          function Z(e2, t2, r2, n2) {
            var i2, s2 = e2.state;
            return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), n2 >= s2.wsize ? (I.arraySet(s2.window, t2, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n2 < (i2 = s2.wsize - s2.wnext) && (i2 = n2), I.arraySet(s2.window, t2, r2 - n2, i2, s2.wnext), (n2 -= i2) ? (I.arraySet(s2.window, t2, r2 - n2, n2, 0), s2.wnext = n2, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;
          }
          r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function(e2) {
            return u(e2, 15);
          }, r.inflateInit2 = u, r.inflate = function(e2, t2) {
            var r2, n2, i2, s2, a2, o2, h2, u2, l2, f2, c2, d, p, m, _, g, b, v, y, w, k, x, S, z, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
            if (!e2 || !e2.state || !e2.output || !e2.input && 0 !== e2.avail_in) return U;
            12 === (r2 = e2.state).mode && (r2.mode = 13), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, f2 = o2, c2 = h2, x = N;
            e: for (; ; ) switch (r2.mode) {
              case P:
                if (0 === r2.wrap) {
                  r2.mode = 13;
                  break;
                }
                for (; l2 < 16; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (2 & r2.wrap && 35615 === u2) {
                  E[r2.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0), l2 = u2 = 0, r2.mode = 2;
                  break;
                }
                if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                  e2.msg = "incorrect header check", r2.mode = 30;
                  break;
                }
                if (8 != (15 & u2)) {
                  e2.msg = "unknown compression method", r2.mode = 30;
                  break;
                }
                if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), 0 === r2.wbits) r2.wbits = k;
                else if (k > r2.wbits) {
                  e2.msg = "invalid window size", r2.mode = 30;
                  break;
                }
                r2.dmax = 1 << k, e2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;
                break;
              case 2:
                for (; l2 < 16; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (r2.flags = u2, 8 != (255 & r2.flags)) {
                  e2.msg = "unknown compression method", r2.mode = 30;
                  break;
                }
                if (57344 & r2.flags) {
                  e2.msg = "unknown header flags set", r2.mode = 30;
                  break;
                }
                r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 3;
              case 3:
                for (; l2 < 32; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                r2.head && (r2.head.time = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r2.check = B(r2.check, E, 4, 0)), l2 = u2 = 0, r2.mode = 4;
              case 4:
                for (; l2 < 16; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 5;
              case 5:
                if (1024 & r2.flags) {
                  for (; l2 < 16; ) {
                    if (0 === o2) break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0;
                } else r2.head && (r2.head.extra = null);
                r2.mode = 6;
              case 6:
                if (1024 & r2.flags && (o2 < (d = r2.length) && (d = o2), d && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, n2, s2, d, k)), 512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, r2.length -= d), r2.length)) break e;
                r2.length = 0, r2.mode = 7;
              case 7:
                if (2048 & r2.flags) {
                  if (0 === o2) break e;
                  for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && d < o2; ) ;
                  if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k) break e;
                } else r2.head && (r2.head.name = null);
                r2.length = 0, r2.mode = 8;
              case 8:
                if (4096 & r2.flags) {
                  if (0 === o2) break e;
                  for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && d < o2; ) ;
                  if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k) break e;
                } else r2.head && (r2.head.comment = null);
                r2.mode = 9;
              case 9:
                if (512 & r2.flags) {
                  for (; l2 < 16; ) {
                    if (0 === o2) break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (u2 !== (65535 & r2.check)) {
                    e2.msg = "header crc mismatch", r2.mode = 30;
                    break;
                  }
                  l2 = u2 = 0;
                }
                r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = 12;
                break;
              case 10:
                for (; l2 < 32; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                e2.adler = r2.check = L(u2), l2 = u2 = 0, r2.mode = 11;
              case 11:
                if (0 === r2.havedict) return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, 2;
                e2.adler = r2.check = 1, r2.mode = 12;
              case 12:
                if (5 === t2 || 6 === t2) break e;
              case 13:
                if (r2.last) {
                  u2 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;
                  break;
                }
                for (; l2 < 3; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                switch (r2.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {
                  case 0:
                    r2.mode = 14;
                    break;
                  case 1:
                    if (j(r2), r2.mode = 20, 6 !== t2) break;
                    u2 >>>= 2, l2 -= 2;
                    break e;
                  case 2:
                    r2.mode = 17;
                    break;
                  case 3:
                    e2.msg = "invalid block type", r2.mode = 30;
                }
                u2 >>>= 2, l2 -= 2;
                break;
              case 14:
                for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                  e2.msg = "invalid stored block lengths", r2.mode = 30;
                  break;
                }
                if (r2.length = 65535 & u2, l2 = u2 = 0, r2.mode = 15, 6 === t2) break e;
              case 15:
                r2.mode = 16;
              case 16:
                if (d = r2.length) {
                  if (o2 < d && (d = o2), h2 < d && (d = h2), 0 === d) break e;
                  I.arraySet(i2, n2, s2, d, a2), o2 -= d, s2 += d, h2 -= d, a2 += d, r2.length -= d;
                  break;
                }
                r2.mode = 12;
                break;
              case 17:
                for (; l2 < 14; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                  e2.msg = "too many length or distance symbols", r2.mode = 30;
                  break;
                }
                r2.have = 0, r2.mode = 18;
              case 18:
                for (; r2.have < r2.ncode; ) {
                  for (; l2 < 3; ) {
                    if (0 === o2) break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;
                }
                for (; r2.have < 19; ) r2.lens[A[r2.have++]] = 0;
                if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                  e2.msg = "invalid code lengths set", r2.mode = 30;
                  break;
                }
                r2.have = 0, r2.mode = 19;
              case 19:
                for (; r2.have < r2.nlen + r2.ndist; ) {
                  for (; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (0 === o2) break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (b < 16) u2 >>>= _, l2 -= _, r2.lens[r2.have++] = b;
                  else {
                    if (16 === b) {
                      for (z = _ + 2; l2 < z; ) {
                        if (0 === o2) break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      if (u2 >>>= _, l2 -= _, 0 === r2.have) {
                        e2.msg = "invalid bit length repeat", r2.mode = 30;
                        break;
                      }
                      k = r2.lens[r2.have - 1], d = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;
                    } else if (17 === b) {
                      for (z = _ + 3; l2 < z; ) {
                        if (0 === o2) break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      l2 -= _, k = 0, d = 3 + (7 & (u2 >>>= _)), u2 >>>= 3, l2 -= 3;
                    } else {
                      for (z = _ + 7; l2 < z; ) {
                        if (0 === o2) break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      l2 -= _, k = 0, d = 11 + (127 & (u2 >>>= _)), u2 >>>= 7, l2 -= 7;
                    }
                    if (r2.have + d > r2.nlen + r2.ndist) {
                      e2.msg = "invalid bit length repeat", r2.mode = 30;
                      break;
                    }
                    for (; d--; ) r2.lens[r2.have++] = k;
                  }
                }
                if (30 === r2.mode) break;
                if (0 === r2.lens[256]) {
                  e2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                  break;
                }
                if (r2.lenbits = 9, S = { bits: r2.lenbits }, x = T(D, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                  e2.msg = "invalid literal/lengths set", r2.mode = 30;
                  break;
                }
                if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x = T(F, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x) {
                  e2.msg = "invalid distances set", r2.mode = 30;
                  break;
                }
                if (r2.mode = 20, 6 === t2) break e;
              case 20:
                r2.mode = 21;
              case 21:
                if (6 <= o2 && 258 <= h2) {
                  e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, R(e2, c2), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, 12 === r2.mode && (r2.back = -1);
                  break;
                }
                for (r2.back = 0; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (g && 0 == (240 & g)) {
                  for (v = _, y = g, w = b; g = (C = r2.lencode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                    if (0 === o2) break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  u2 >>>= v, l2 -= v, r2.back += v;
                }
                if (u2 >>>= _, l2 -= _, r2.back += _, r2.length = b, 0 === g) {
                  r2.mode = 26;
                  break;
                }
                if (32 & g) {
                  r2.back = -1, r2.mode = 12;
                  break;
                }
                if (64 & g) {
                  e2.msg = "invalid literal/length code", r2.mode = 30;
                  break;
                }
                r2.extra = 15 & g, r2.mode = 22;
              case 22:
                if (r2.extra) {
                  for (z = r2.extra; l2 < z; ) {
                    if (0 === o2) break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                }
                r2.was = r2.length, r2.mode = 23;
              case 23:
                for (; g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (0 == (240 & g)) {
                  for (v = _, y = g, w = b; g = (C = r2.distcode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                    if (0 === o2) break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  u2 >>>= v, l2 -= v, r2.back += v;
                }
                if (u2 >>>= _, l2 -= _, r2.back += _, 64 & g) {
                  e2.msg = "invalid distance code", r2.mode = 30;
                  break;
                }
                r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
              case 24:
                if (r2.extra) {
                  for (z = r2.extra; l2 < z; ) {
                    if (0 === o2) break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                }
                if (r2.offset > r2.dmax) {
                  e2.msg = "invalid distance too far back", r2.mode = 30;
                  break;
                }
                r2.mode = 25;
              case 25:
                if (0 === h2) break e;
                if (d = c2 - h2, r2.offset > d) {
                  if ((d = r2.offset - d) > r2.whave && r2.sane) {
                    e2.msg = "invalid distance too far back", r2.mode = 30;
                    break;
                  }
                  p = d > r2.wnext ? (d -= r2.wnext, r2.wsize - d) : r2.wnext - d, d > r2.length && (d = r2.length), m = r2.window;
                } else m = i2, p = a2 - r2.offset, d = r2.length;
                for (h2 < d && (d = h2), h2 -= d, r2.length -= d; i2[a2++] = m[p++], --d; ) ;
                0 === r2.length && (r2.mode = 21);
                break;
              case 26:
                if (0 === h2) break e;
                i2[a2++] = r2.length, h2--, r2.mode = 21;
                break;
              case 27:
                if (r2.wrap) {
                  for (; l2 < 32; ) {
                    if (0 === o2) break e;
                    o2--, u2 |= n2[s2++] << l2, l2 += 8;
                  }
                  if (c2 -= h2, e2.total_out += c2, r2.total += c2, c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, a2 - c2) : O(r2.check, i2, c2, a2 - c2)), c2 = h2, (r2.flags ? u2 : L(u2)) !== r2.check) {
                    e2.msg = "incorrect data check", r2.mode = 30;
                    break;
                  }
                  l2 = u2 = 0;
                }
                r2.mode = 28;
              case 28:
                if (r2.wrap && r2.flags) {
                  for (; l2 < 32; ) {
                    if (0 === o2) break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (u2 !== (4294967295 & r2.total)) {
                    e2.msg = "incorrect length check", r2.mode = 30;
                    break;
                  }
                  l2 = u2 = 0;
                }
                r2.mode = 29;
              case 29:
                x = 1;
                break e;
              case 30:
                x = -3;
                break e;
              case 31:
                return -4;
              case 32:
              default:
                return U;
            }
            return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, (r2.wsize || c2 !== e2.avail_out && r2.mode < 30 && (r2.mode < 27 || 4 !== t2)) && Z(e2, e2.output, e2.next_out, c2 - e2.avail_out) ? (r2.mode = 31, -4) : (f2 -= e2.avail_in, c2 -= e2.avail_out, e2.total_in += f2, e2.total_out += c2, r2.total += c2, r2.wrap && c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, e2.next_out - c2) : O(r2.check, i2, c2, e2.next_out - c2)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (12 === r2.mode ? 128 : 0) + (20 === r2.mode || 15 === r2.mode ? 256 : 0), (0 == f2 && 0 === c2 || 4 === t2) && x === N && (x = -5), x);
          }, r.inflateEnd = function(e2) {
            if (!e2 || !e2.state) return U;
            var t2 = e2.state;
            return t2.window && (t2.window = null), e2.state = null, N;
          }, r.inflateGetHeader = function(e2, t2) {
            var r2;
            return e2 && e2.state ? 0 == (2 & (r2 = e2.state).wrap) ? U : ((r2.head = t2).done = false, N) : U;
          }, r.inflateSetDictionary = function(e2, t2) {
            var r2, n2 = t2.length;
            return e2 && e2.state ? 0 !== (r2 = e2.state).wrap && 11 !== r2.mode ? U : 11 === r2.mode && O(1, t2, n2, 0) !== r2.check ? -3 : Z(e2, t2, n2, n2) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;
          }, r.inflateInfo = "pako inflate (from Nodeca project)";
        }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, t, r) {
          "use strict";
          var D = e("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
          t.exports = function(e2, t2, r2, n, i, s, a, o) {
            var h, u, l, f, c, d, p, m, _, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S = 0, z = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R = null, T = 0;
            for (b = 0; b <= 15; b++) O[b] = 0;
            for (v = 0; v < n; v++) O[t2[r2 + v]]++;
            for (k = g, w = 15; 1 <= w && 0 === O[w]; w--) ;
            if (w < k && (k = w), 0 === w) return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
            for (y = 1; y < w && 0 === O[y]; y++) ;
            for (k < y && (k = y), b = z = 1; b <= 15; b++) if (z <<= 1, (z -= O[b]) < 0) return -1;
            if (0 < z && (0 === e2 || 1 !== w)) return -1;
            for (B[1] = 0, b = 1; b < 15; b++) B[b + 1] = B[b] + O[b];
            for (v = 0; v < n; v++) 0 !== t2[r2 + v] && (a[B[t2[r2 + v]]++] = v);
            if (d = 0 === e2 ? (A = R = a, 19) : 1 === e2 ? (A = F, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y, c = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, 1 === e2 && 852 < C || 2 === e2 && 592 < C) return 1;
            for (; ; ) {
              for (p = b - S, _ = a[v] < d ? (m = 0, a[v]) : a[v] > d ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h = 1 << b - S, y = u = 1 << x; i[c + (E >> S) + (u -= h)] = p << 24 | m << 16 | _ | 0, 0 !== u; ) ;
              for (h = 1 << b - 1; E & h; ) h >>= 1;
              if (0 !== h ? (E &= h - 1, E += h) : E = 0, v++, 0 == --O[b]) {
                if (b === w) break;
                b = t2[r2 + a[v]];
              }
              if (k < b && (E & f) !== l) {
                for (0 === S && (S = k), c += y, z = 1 << (x = b - S); x + S < w && !((z -= O[x + S]) <= 0); ) x++, z <<= 1;
                if (C += 1 << x, 1 === e2 && 852 < C || 2 === e2 && 592 < C) return 1;
                i[l = E & f] = k << 24 | x << 16 | c - s | 0;
              }
            }
            return 0 !== E && (i[c + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0;
          };
        }, { "../utils/common": 41 }], 51: [function(e, t, r) {
          "use strict";
          t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
        }, {}], 52: [function(e, t, r) {
          "use strict";
          var i = e("../utils/common"), o = 0, h = 1;
          function n(e2) {
            for (var t2 = e2.length; 0 <= --t2; ) e2[t2] = 0;
          }
          var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, c = 19, _ = 2 * l + 1, g = 15, d = 16, p = 7, m = 256, b = 16, v = 17, y = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = new Array(2 * (l + 2));
          n(z);
          var C = new Array(2 * f);
          n(C);
          var E = new Array(512);
          n(E);
          var A = new Array(256);
          n(A);
          var I = new Array(a);
          n(I);
          var O, B, R, T = new Array(f);
          function D(e2, t2, r2, n2, i2) {
            this.static_tree = e2, this.extra_bits = t2, this.extra_base = r2, this.elems = n2, this.max_length = i2, this.has_stree = e2 && e2.length;
          }
          function F(e2, t2) {
            this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
          }
          function N(e2) {
            return e2 < 256 ? E[e2] : E[256 + (e2 >>> 7)];
          }
          function U(e2, t2) {
            e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
          }
          function P(e2, t2, r2) {
            e2.bi_valid > d - r2 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, U(e2, e2.bi_buf), e2.bi_buf = t2 >> d - e2.bi_valid, e2.bi_valid += r2 - d) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += r2);
          }
          function L(e2, t2, r2) {
            P(e2, r2[2 * t2], r2[2 * t2 + 1]);
          }
          function j(e2, t2) {
            for (var r2 = 0; r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1, 0 < --t2; ) ;
            return r2 >>> 1;
          }
          function Z(e2, t2, r2) {
            var n2, i2, s2 = new Array(g + 1), a2 = 0;
            for (n2 = 1; n2 <= g; n2++) s2[n2] = a2 = a2 + r2[n2 - 1] << 1;
            for (i2 = 0; i2 <= t2; i2++) {
              var o2 = e2[2 * i2 + 1];
              0 !== o2 && (e2[2 * i2] = j(s2[o2]++, o2));
            }
          }
          function W(e2) {
            var t2;
            for (t2 = 0; t2 < l; t2++) e2.dyn_ltree[2 * t2] = 0;
            for (t2 = 0; t2 < f; t2++) e2.dyn_dtree[2 * t2] = 0;
            for (t2 = 0; t2 < c; t2++) e2.bl_tree[2 * t2] = 0;
            e2.dyn_ltree[2 * m] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
          }
          function M(e2) {
            8 < e2.bi_valid ? U(e2, e2.bi_buf) : 0 < e2.bi_valid && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
          }
          function H(e2, t2, r2, n2) {
            var i2 = 2 * t2, s2 = 2 * r2;
            return e2[i2] < e2[s2] || e2[i2] === e2[s2] && n2[t2] <= n2[r2];
          }
          function G(e2, t2, r2) {
            for (var n2 = e2.heap[r2], i2 = r2 << 1; i2 <= e2.heap_len && (i2 < e2.heap_len && H(t2, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++, !H(t2, n2, e2.heap[i2], e2.depth)); ) e2.heap[r2] = e2.heap[i2], r2 = i2, i2 <<= 1;
            e2.heap[r2] = n2;
          }
          function K(e2, t2, r2) {
            var n2, i2, s2, a2, o2 = 0;
            if (0 !== e2.last_lit) for (; n2 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], i2 = e2.pending_buf[e2.l_buf + o2], o2++, 0 === n2 ? L(e2, i2, t2) : (L(e2, (s2 = A[i2]) + u + 1, t2), 0 !== (a2 = w[s2]) && P(e2, i2 -= I[s2], a2), L(e2, s2 = N(--n2), r2), 0 !== (a2 = k[s2]) && P(e2, n2 -= T[s2], a2)), o2 < e2.last_lit; ) ;
            L(e2, m, t2);
          }
          function Y(e2, t2) {
            var r2, n2, i2, s2 = t2.dyn_tree, a2 = t2.stat_desc.static_tree, o2 = t2.stat_desc.has_stree, h2 = t2.stat_desc.elems, u2 = -1;
            for (e2.heap_len = 0, e2.heap_max = _, r2 = 0; r2 < h2; r2++) 0 !== s2[2 * r2] ? (e2.heap[++e2.heap_len] = u2 = r2, e2.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
            for (; e2.heap_len < 2; ) s2[2 * (i2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e2.depth[i2] = 0, e2.opt_len--, o2 && (e2.static_len -= a2[2 * i2 + 1]);
            for (t2.max_code = u2, r2 = e2.heap_len >> 1; 1 <= r2; r2--) G(e2, s2, r2);
            for (i2 = h2; r2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], G(e2, s2, 1), n2 = e2.heap[1], e2.heap[--e2.heap_max] = r2, e2.heap[--e2.heap_max] = n2, s2[2 * i2] = s2[2 * r2] + s2[2 * n2], e2.depth[i2] = (e2.depth[r2] >= e2.depth[n2] ? e2.depth[r2] : e2.depth[n2]) + 1, s2[2 * r2 + 1] = s2[2 * n2 + 1] = i2, e2.heap[1] = i2++, G(e2, s2, 1), 2 <= e2.heap_len; ) ;
            e2.heap[--e2.heap_max] = e2.heap[1], function(e3, t3) {
              var r3, n3, i3, s3, a3, o3, h3 = t3.dyn_tree, u3 = t3.max_code, l2 = t3.stat_desc.static_tree, f2 = t3.stat_desc.has_stree, c2 = t3.stat_desc.extra_bits, d2 = t3.stat_desc.extra_base, p2 = t3.stat_desc.max_length, m2 = 0;
              for (s3 = 0; s3 <= g; s3++) e3.bl_count[s3] = 0;
              for (h3[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < _; r3++) p2 < (s3 = h3[2 * h3[2 * (n3 = e3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m2++), h3[2 * n3 + 1] = s3, u3 < n3 || (e3.bl_count[s3]++, a3 = 0, d2 <= n3 && (a3 = c2[n3 - d2]), o3 = h3[2 * n3], e3.opt_len += o3 * (s3 + a3), f2 && (e3.static_len += o3 * (l2[2 * n3 + 1] + a3)));
              if (0 !== m2) {
                do {
                  for (s3 = p2 - 1; 0 === e3.bl_count[s3]; ) s3--;
                  e3.bl_count[s3]--, e3.bl_count[s3 + 1] += 2, e3.bl_count[p2]--, m2 -= 2;
                } while (0 < m2);
                for (s3 = p2; 0 !== s3; s3--) for (n3 = e3.bl_count[s3]; 0 !== n3; ) u3 < (i3 = e3.heap[--r3]) || (h3[2 * i3 + 1] !== s3 && (e3.opt_len += (s3 - h3[2 * i3 + 1]) * h3[2 * i3], h3[2 * i3 + 1] = s3), n3--);
              }
            }(e2, t2), Z(s2, u2, e2.bl_count);
          }
          function X(e2, t2, r2) {
            var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
            for (0 === a2 && (h2 = 138, u2 = 3), t2[2 * (r2 + 1) + 1] = 65535, n2 = 0; n2 <= r2; n2++) i2 = a2, a2 = t2[2 * (n2 + 1) + 1], ++o2 < h2 && i2 === a2 || (o2 < u2 ? e2.bl_tree[2 * i2] += o2 : 0 !== i2 ? (i2 !== s2 && e2.bl_tree[2 * i2]++, e2.bl_tree[2 * b]++) : o2 <= 10 ? e2.bl_tree[2 * v]++ : e2.bl_tree[2 * y]++, s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4));
          }
          function V(e2, t2, r2) {
            var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
            for (0 === a2 && (h2 = 138, u2 = 3), n2 = 0; n2 <= r2; n2++) if (i2 = a2, a2 = t2[2 * (n2 + 1) + 1], !(++o2 < h2 && i2 === a2)) {
              if (o2 < u2) for (; L(e2, i2, e2.bl_tree), 0 != --o2; ) ;
              else 0 !== i2 ? (i2 !== s2 && (L(e2, i2, e2.bl_tree), o2--), L(e2, b, e2.bl_tree), P(e2, o2 - 3, 2)) : o2 <= 10 ? (L(e2, v, e2.bl_tree), P(e2, o2 - 3, 3)) : (L(e2, y, e2.bl_tree), P(e2, o2 - 11, 7));
              s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4);
            }
          }
          n(T);
          var q = false;
          function J(e2, t2, r2, n2) {
            P(e2, (s << 1) + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
              M(e3), n3 && (U(e3, r3), U(e3, ~r3)), i.arraySet(e3.pending_buf, e3.window, t3, r3, e3.pending), e3.pending += r3;
            }(e2, t2, r2, true);
          }
          r._tr_init = function(e2) {
            q || (function() {
              var e3, t2, r2, n2, i2, s2 = new Array(g + 1);
              for (n2 = r2 = 0; n2 < a - 1; n2++) for (I[n2] = r2, e3 = 0; e3 < 1 << w[n2]; e3++) A[r2++] = n2;
              for (A[r2 - 1] = n2, n2 = i2 = 0; n2 < 16; n2++) for (T[n2] = i2, e3 = 0; e3 < 1 << k[n2]; e3++) E[i2++] = n2;
              for (i2 >>= 7; n2 < f; n2++) for (T[n2] = i2 << 7, e3 = 0; e3 < 1 << k[n2] - 7; e3++) E[256 + i2++] = n2;
              for (t2 = 0; t2 <= g; t2++) s2[t2] = 0;
              for (e3 = 0; e3 <= 143; ) z[2 * e3 + 1] = 8, e3++, s2[8]++;
              for (; e3 <= 255; ) z[2 * e3 + 1] = 9, e3++, s2[9]++;
              for (; e3 <= 279; ) z[2 * e3 + 1] = 7, e3++, s2[7]++;
              for (; e3 <= 287; ) z[2 * e3 + 1] = 8, e3++, s2[8]++;
              for (Z(z, l + 1, s2), e3 = 0; e3 < f; e3++) C[2 * e3 + 1] = 5, C[2 * e3] = j(e3, 5);
              O = new D(z, w, u + 1, l, g), B = new D(C, k, 0, f, g), R = new D(new Array(0), x, 0, c, p);
            }(), q = true), e2.l_desc = new F(e2.dyn_ltree, O), e2.d_desc = new F(e2.dyn_dtree, B), e2.bl_desc = new F(e2.bl_tree, R), e2.bi_buf = 0, e2.bi_valid = 0, W(e2);
          }, r._tr_stored_block = J, r._tr_flush_block = function(e2, t2, r2, n2) {
            var i2, s2, a2 = 0;
            0 < e2.level ? (2 === e2.strm.data_type && (e2.strm.data_type = function(e3) {
              var t3, r3 = 4093624447;
              for (t3 = 0; t3 <= 31; t3++, r3 >>>= 1) if (1 & r3 && 0 !== e3.dyn_ltree[2 * t3]) return o;
              if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26]) return h;
              for (t3 = 32; t3 < u; t3++) if (0 !== e3.dyn_ltree[2 * t3]) return h;
              return o;
            }(e2)), Y(e2, e2.l_desc), Y(e2, e2.d_desc), a2 = function(e3) {
              var t3;
              for (X(e3, e3.dyn_ltree, e3.l_desc.max_code), X(e3, e3.dyn_dtree, e3.d_desc.max_code), Y(e3, e3.bl_desc), t3 = c - 1; 3 <= t3 && 0 === e3.bl_tree[2 * S[t3] + 1]; t3--) ;
              return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
            }(e2), i2 = e2.opt_len + 3 + 7 >>> 3, (s2 = e2.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r2 + 5, r2 + 4 <= i2 && -1 !== t2 ? J(e2, t2, r2, n2) : 4 === e2.strategy || s2 === i2 ? (P(e2, 2 + (n2 ? 1 : 0), 3), K(e2, z, C)) : (P(e2, 4 + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
              var i3;
              for (P(e3, t3 - 257, 5), P(e3, r3 - 1, 5), P(e3, n3 - 4, 4), i3 = 0; i3 < n3; i3++) P(e3, e3.bl_tree[2 * S[i3] + 1], 3);
              V(e3, e3.dyn_ltree, t3 - 1), V(e3, e3.dyn_dtree, r3 - 1);
            }(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, a2 + 1), K(e2, e2.dyn_ltree, e2.dyn_dtree)), W(e2), n2 && M(e2);
          }, r._tr_tally = function(e2, t2, r2) {
            return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t2 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t2, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, 0 === t2 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (A[r2] + u + 1)]++, e2.dyn_dtree[2 * N(t2)]++), e2.last_lit === e2.lit_bufsize - 1;
          }, r._tr_align = function(e2) {
            P(e2, 2, 3), L(e2, m, z), function(e3) {
              16 === e3.bi_valid ? (U(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : 8 <= e3.bi_valid && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
            }(e2);
          };
        }, { "../utils/common": 41 }], 53: [function(e, t, r) {
          "use strict";
          t.exports = function() {
            this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
          };
        }, {}], 54: [function(e, t, r) {
          (function(e2) {
            !function(r2, n) {
              "use strict";
              if (!r2.setImmediate) {
                var i, s, t2, a, o = 1, h = {}, u = false, l = r2.document, e3 = Object.getPrototypeOf && Object.getPrototypeOf(r2);
                e3 = e3 && e3.setTimeout ? e3 : r2, i = "[object process]" === {}.toString.call(r2.process) ? function(e4) {
                  process.nextTick(function() {
                    c(e4);
                  });
                } : function() {
                  if (r2.postMessage && !r2.importScripts) {
                    var e4 = true, t3 = r2.onmessage;
                    return r2.onmessage = function() {
                      e4 = false;
                    }, r2.postMessage("", "*"), r2.onmessage = t3, e4;
                  }
                }() ? (a = "setImmediate$" + Math.random() + "$", r2.addEventListener ? r2.addEventListener("message", d, false) : r2.attachEvent("onmessage", d), function(e4) {
                  r2.postMessage(a + e4, "*");
                }) : r2.MessageChannel ? ((t2 = new MessageChannel()).port1.onmessage = function(e4) {
                  c(e4.data);
                }, function(e4) {
                  t2.port2.postMessage(e4);
                }) : l && "onreadystatechange" in l.createElement("script") ? (s = l.documentElement, function(e4) {
                  var t3 = l.createElement("script");
                  t3.onreadystatechange = function() {
                    c(e4), t3.onreadystatechange = null, s.removeChild(t3), t3 = null;
                  }, s.appendChild(t3);
                }) : function(e4) {
                  setTimeout(c, 0, e4);
                }, e3.setImmediate = function(e4) {
                  "function" != typeof e4 && (e4 = new Function("" + e4));
                  for (var t3 = new Array(arguments.length - 1), r3 = 0; r3 < t3.length; r3++) t3[r3] = arguments[r3 + 1];
                  var n2 = { callback: e4, args: t3 };
                  return h[o] = n2, i(o), o++;
                }, e3.clearImmediate = f;
              }
              function f(e4) {
                delete h[e4];
              }
              function c(e4) {
                if (u) setTimeout(c, 0, e4);
                else {
                  var t3 = h[e4];
                  if (t3) {
                    u = true;
                    try {
                      !function(e5) {
                        var t4 = e5.callback, r3 = e5.args;
                        switch (r3.length) {
                          case 0:
                            t4();
                            break;
                          case 1:
                            t4(r3[0]);
                            break;
                          case 2:
                            t4(r3[0], r3[1]);
                            break;
                          case 3:
                            t4(r3[0], r3[1], r3[2]);
                            break;
                          default:
                            t4.apply(n, r3);
                        }
                      }(t3);
                    } finally {
                      f(e4), u = false;
                    }
                  }
                }
              }
              function d(e4) {
                e4.source === r2 && "string" == typeof e4.data && 0 === e4.data.indexOf(a) && c(+e4.data.slice(a.length));
              }
            }("undefined" == typeof self ? void 0 === e2 ? this : e2 : self);
          }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
        }, {}] }, {}, [10])(10);
      });
    }
  });

  // src/utils/page-context.ts
  var sandboxWin = window;
  var pageWin = typeof unsafeWindow !== "undefined" && unsafeWindow ? unsafeWindow : sandboxWin;
  var pageWindow = pageWin;
  var isIsolatedContext = pageWin !== sandboxWin;
  function shareGlobal(name, value) {
    try {
      pageWin[name] = value;
    } catch {
    }
    if (isIsolatedContext) {
      try {
        sandboxWin[name] = value;
      } catch {
      }
    }
  }
  function readSharedGlobal(name) {
    if (isIsolatedContext) {
      const sandboxValue = sandboxWin[name];
      if (sandboxValue !== void 0) return sandboxValue;
    }
    return pageWin[name];
  }

  // src/core/state.ts
  var NativeWS = pageWindow.WebSocket;
  var NativeWorker = pageWindow.Worker;
  var sockets = [];
  var quinoaWS = null;
  function setQWS(ws, why) {
    if (!quinoaWS) {
      quinoaWS = ws;
      shareGlobal("quinoaWS", ws);
      try {
        console.log("[QuinoaWS] selected ->", why);
      } catch {
      }
    }
  }
  var workerFound = false;
  var Workers = typeof Set !== "undefined" ? /* @__PURE__ */ new Set() : {
    _a: [],
    add(w) {
      this._a.push(w);
    },
    delete(w) {
      const i = this._a.indexOf(w);
      if (i >= 0) this._a.splice(i, 1);
    },
    forEach(fn) {
      for (let i = 0; i < this._a.length; i++) fn(this._a[i]);
    }
  };
  function label(rs) {
    return ["CONNECTING", "OPEN", "CLOSING", "CLOSED"][rs ?? -1] || "none";
  }

  // src/core/parse.ts
  async function parseWSData(d) {
    try {
      if (typeof d === "string") return JSON.parse(d);
      if (d instanceof Blob) return JSON.parse(await d.text());
      if (d instanceof ArrayBuffer) return JSON.parse(new TextDecoder().decode(d));
    } catch {
    }
    return null;
  }

  // src/store/jotai.ts
  var _store = null;
  var _captureInProgress = false;
  var _captureError = null;
  var _lastCapturedVia = null;
  var getAtomCache = () => pageWindow.jotaiAtomCache?.cache;
  function findStoreViaFiber() {
    const hook = pageWindow.__REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!hook?.renderers?.size) return null;
    for (const [rid] of hook.renderers) {
      const roots = hook.getFiberRoots?.(rid);
      if (!roots) continue;
      for (const root of roots) {
        const seen = /* @__PURE__ */ new Set();
        const stack = [root.current];
        while (stack.length) {
          const f = stack.pop();
          if (!f || seen.has(f)) continue;
          seen.add(f);
          const v = f?.pendingProps?.value;
          if (v && typeof v.get === "function" && typeof v.set === "function" && typeof v.sub === "function") {
            _lastCapturedVia = "fiber";
            return v;
          }
          if (f.child) stack.push(f.child);
          if (f.sibling) stack.push(f.sibling);
          if (f.alternate) stack.push(f.alternate);
        }
      }
    }
    return null;
  }
  async function captureViaWriteOnce(timeoutMs = 5e3) {
    const cache2 = getAtomCache();
    if (!cache2) {
      console.warn("[jotai-bridge] jotaiAtomCache.cache introuvable");
      throw new Error("jotaiAtomCache.cache introuvable");
    }
    let capturedGet = null;
    let capturedSet = null;
    const patched = [];
    const restorePatched = () => {
      for (const a of patched) {
        try {
          if (a.__origWrite) {
            a.write = a.__origWrite;
            delete a.__origWrite;
          }
        } catch {
        }
      }
    };
    for (const atom of cache2.values()) {
      if (!atom || typeof atom.write !== "function" || atom.__origWrite) continue;
      const orig = atom.write;
      atom.__origWrite = orig;
      atom.write = function(get, set2, ...args) {
        if (!capturedSet) {
          capturedGet = get;
          capturedSet = set2;
          restorePatched();
        }
        return orig.call(this, get, set2, ...args);
      };
      patched.push(atom);
    }
    const wait = (ms) => new Promise((r) => setTimeout(r, ms));
    const t0 = Date.now();
    try {
      pageWindow.dispatchEvent?.(new pageWindow.Event("visibilitychange"));
    } catch {
    }
    while (!capturedSet && Date.now() - t0 < timeoutMs) {
      await wait(50);
    }
    if (!capturedSet) {
      restorePatched();
      _lastCapturedVia = "polyfill";
      console.warn("[jotai-bridge] write-once: timeout \u2192 polyfill");
      return {
        get: () => {
          throw new Error("Store non captur\xE9: get indisponible");
        },
        set: () => {
          throw new Error("Store non captur\xE9: set indisponible");
        },
        sub: () => () => {
        },
        __polyfill: true
      };
    }
    _lastCapturedVia = "write";
    return {
      get: (a) => capturedGet(a),
      set: (a, v) => capturedSet(a, v),
      sub: (a, cb) => {
        let last;
        try {
          last = capturedGet(a);
        } catch {
        }
        const id = setInterval(() => {
          let curr;
          try {
            curr = capturedGet(a);
          } catch {
            return;
          }
          if (curr !== last) {
            last = curr;
            try {
              cb();
            } catch {
            }
          }
        }, 100);
        return () => clearInterval(id);
      }
    };
  }
  async function ensureStore() {
    if (_store && !_store.__polyfill) return _store;
    if (_captureInProgress) {
      const t0 = Date.now();
      const maxWait = 5500;
      while (!_store && Date.now() - t0 < maxWait) {
        await new Promise((r) => setTimeout(r, 25));
      }
      if (_store && !_store.__polyfill) return _store;
    }
    _captureInProgress = true;
    try {
      const viaFiber = findStoreViaFiber();
      if (viaFiber) {
        _store = viaFiber;
        return _store;
      }
      const viaWrite = await captureViaWriteOnce();
      _store = viaWrite;
      return _store;
    } catch (e) {
      _captureError = e;
      throw e;
    } finally {
      _captureInProgress = false;
    }
  }
  function isStoreCaptured() {
    return !!_store && !_store.__polyfill;
  }
  function getCapturedInfo() {
    return { via: _lastCapturedVia, polyfill: !!_store?.__polyfill, error: _captureError };
  }
  async function jGet(atom) {
    const s = await ensureStore();
    return s.get(atom);
  }
  async function jSet(atom, value) {
    const s = await ensureStore();
    await s.set(atom, value);
  }
  async function jSub(atom, cb) {
    const s = await ensureStore();
    return s.sub(atom, cb);
  }
  function findAtomsByLabel(regex) {
    const cache2 = getAtomCache();
    if (!cache2) return [];
    const out = [];
    for (const a of cache2.values()) {
      const label2 = a?.debugLabel || a?.label || "";
      if (regex.test(String(label2))) out.push(a);
    }
    return out;
  }
  function getAtomByLabel(label2) {
    const escape = (s) => s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    return findAtomsByLabel(new RegExp("^" + escape(label2) + "$"))[0] || null;
  }

  // src/store/api.ts
  async function ensureStore2() {
    try {
      await ensureStore();
    } catch {
    }
  }
  async function select(label2, fallback) {
    await ensureStore2();
    const atom = getAtomByLabel(label2);
    if (!atom) return fallback;
    try {
      return await jGet(atom);
    } catch {
      return fallback;
    }
  }
  async function subscribe(label2, cb) {
    await ensureStore2();
    const atom = getAtomByLabel(label2);
    if (!atom) return () => {
    };
    const unsub = await jSub(atom, async () => {
      try {
        cb(await jGet(atom));
      } catch {
      }
    });
    return unsub;
  }
  async function subscribeImmediate(label2, cb) {
    const first = await select(label2);
    if (first !== void 0) cb(first);
    return subscribe(label2, cb);
  }
  async function set(label2, value) {
    await ensureStore2();
    const atom = getAtomByLabel(label2);
    if (!atom) return;
    await jSet(atom, value);
  }
  var Store = { ensure: ensureStore2, select, subscribe, subscribeImmediate, set };

  // src/store/hub.ts
  function toPathArray(path) {
    if (!path) return [];
    return Array.isArray(path) ? path.slice() : path.split(".").map((k) => k.match(/^\d+$/) ? Number(k) : k);
  }
  function getAtPath(root, path) {
    const segs = toPathArray(path);
    let cur = root;
    for (const s of segs) {
      if (cur == null) return void 0;
      cur = cur[s];
    }
    return cur;
  }
  function setAtPath(root, path, nextValue) {
    const segs = toPathArray(path);
    if (!segs.length) return nextValue;
    const clone = Array.isArray(root) ? root.slice() : { ...root ?? {} };
    let cur = clone;
    for (let i = 0; i < segs.length - 1; i++) {
      const key2 = segs[i];
      const src = cur[key2];
      const obj = typeof src === "object" && src !== null ? Array.isArray(src) ? src.slice() : { ...src } : {};
      cur[key2] = obj;
      cur = obj;
    }
    cur[segs[segs.length - 1]] = nextValue;
    return clone;
  }
  var eq = {
    shallow(a, b) {
      if (Object.is(a, b)) return true;
      if (!a || !b || typeof a !== "object" || typeof b !== "object") return false;
      const ka = Object.keys(a);
      const kb = Object.keys(b);
      if (ka.length !== kb.length) return false;
      for (const k of ka) if (!Object.is(a[k], b[k])) return false;
      return true;
    },
    idSet(a, b) {
      if (a === b) return true;
      if (!Array.isArray(a) || !Array.isArray(b) || a.length !== b.length) return false;
      const sa = new Set(a);
      for (const id of b) if (!sa.has(id)) return false;
      return true;
    }
  };
  function makeView(sourceLabel, opts = {}) {
    const { path, write = "replace" } = opts;
    async function get() {
      const src = await Store.select(sourceLabel);
      return path ? getAtPath(src, path) : src;
    }
    async function set2(next) {
      if (typeof write === "function") {
        const prev2 = await Store.select(sourceLabel);
        const raw2 = write(next, prev2);
        return Store.set(sourceLabel, raw2);
      }
      const prev = await Store.select(sourceLabel);
      const raw = path ? setAtPath(prev, path, next) : next;
      if (write === "merge-shallow" && !path && prev && typeof prev === "object" && typeof next === "object") {
        return Store.set(sourceLabel, { ...prev, ...next });
      }
      return Store.set(sourceLabel, raw);
    }
    async function update(fn) {
      const prev = await get();
      const next = fn(prev);
      await set2(next);
      return next;
    }
    async function onChange(cb, isEqual = Object.is) {
      let prev;
      return Store.subscribe(sourceLabel, (src) => {
        const v = path ? getAtPath(src, path) : src;
        if (typeof prev === "undefined" || !isEqual(prev, v)) {
          const p = prev;
          prev = v;
          cb(v, p);
        }
      });
    }
    async function onChangeNow(cb, isEqual = Object.is) {
      let prev;
      return Store.subscribeImmediate(sourceLabel, (src) => {
        const v = path ? getAtPath(src, path) : src;
        if (typeof prev === "undefined" || !isEqual(prev, v)) {
          const p = prev;
          prev = v;
          cb(v, p);
        }
      });
    }
    function asSignature(opts2) {
      return makeSignatureChannel(sourceLabel, path, opts2);
    }
    return { label: sourceLabel + (path ? ":" + toPathArray(path).join(".") : ""), get, set: set2, update, onChange, onChangeNow, asSignature };
  }
  function stablePick(obj, fields) {
    const out = {};
    for (const f of fields) {
      const v = getAtPath(obj, f.includes(".") ? f : [f]);
      out[f] = v;
    }
    try {
      return JSON.stringify(out);
    } catch {
      return String(out);
    }
  }
  function makeSignatureChannel(sourceLabel, path, opts) {
    const mode = opts.mode ?? "auto";
    function computeSig(whole) {
      const base = whole;
      const value = path ? getAtPath(base, path) : base;
      const sig = /* @__PURE__ */ new Map();
      if (value == null) return { sig, keys: [] };
      if ((mode === "array" || mode === "auto" && Array.isArray(value)) && Array.isArray(value)) {
        for (let i = 0; i < value.length; i++) {
          const item = value[i];
          const key2 = opts.key ? opts.key(item, i, whole) : i;
          const s = opts.sig ? opts.sig(item, i, whole) : opts.fields ? stablePick(item, opts.fields) : (() => {
            try {
              return JSON.stringify(item);
            } catch {
              return String(item);
            }
          })();
          sig.set(key2, s);
        }
      } else {
        for (const [k, item] of Object.entries(value)) {
          const key2 = opts.key ? opts.key(item, k, whole) : k;
          const s = opts.sig ? opts.sig(item, k, whole) : opts.fields ? stablePick(item, opts.fields) : (() => {
            try {
              return JSON.stringify(item);
            } catch {
              return String(item);
            }
          })();
          sig.set(key2, s);
        }
      }
      return { sig, keys: Array.from(sig.keys()) };
    }
    function mapEqual(a, b) {
      if (a === b) return true;
      if (!a || !b || a.size !== b.size) return false;
      for (const [k, v] of a) if (b.get(k) !== v) return false;
      return true;
    }
    async function sub(cb) {
      let prevSig = null;
      return Store.subscribeImmediate(sourceLabel, (src) => {
        const whole = path ? getAtPath(src, path) : src;
        const { sig } = computeSig(whole);
        if (!mapEqual(prevSig, sig)) {
          const allKeys = /* @__PURE__ */ new Set([
            ...prevSig ? Array.from(prevSig.keys()) : [],
            ...Array.from(sig.keys())
          ]);
          const changed = [];
          for (const k of allKeys) if ((prevSig?.get(k) ?? "__NONE__") !== (sig.get(k) ?? "__NONE__")) changed.push(k);
          prevSig = sig;
          cb({ value: whole, changedKeys: changed });
        }
      });
    }
    async function subKey(key2, cb) {
      let last = "__INIT__";
      return sub(({ value, changedKeys }) => {
        if (changedKeys.includes(key2)) cb({ value });
      });
    }
    async function subKeys(keys, cb) {
      const wanted = new Set(keys);
      return sub(({ value, changedKeys }) => {
        const hit = changedKeys.filter((k) => wanted.has(k));
        if (hit.length) cb({ value, changedKeys: hit });
      });
    }
    return { sub, subKey, subKeys };
  }
  var HubEq = eq;
  function makeAtom(label2) {
    return makeView(label2);
  }

  // src/store/atoms.ts
  var position = makeAtom("positionAtom");
  var state = makeAtom("stateAtom");
  var map = makeAtom("mapAtom");
  var player = makeAtom("playerAtom");
  var action = makeAtom("actionAtom");
  var myData = makeAtom("myDataAtom");
  var myInventory = makeAtom("myInventoryAtom");
  var myCropInventory = makeAtom("myCropInventoryAtom");
  var mySeedInventory = makeAtom("mySeedInventoryAtom");
  var myToolInventory = makeAtom("myToolInventoryAtom");
  var myEggInventory = makeAtom("myEggInventoryAtom");
  var myDecorInventory = makeAtom("myDecorInventoryAtom");
  var myPetInfos = makeAtom("myPetInfosAtom");
  var myPetSlotInfos = makeAtom("myPetSlotInfosAtom");
  var totalPetSellPrice = makeAtom("totalPetSellPriceAtom");
  var expandedPetSlotId = makeAtom("expandedPetSlotIdAtom");
  var myCropItemsToSell = makeAtom("myCropItemsToSellAtom");
  var shops = makeAtom("shopsAtom");
  var myShopPurchases = makeAtom("myShopPurchasesAtom");
  var numPlayers = makeAtom("numPlayersAtom");
  var totalCropSellPrice = makeAtom("totalCropSellPriceAtom");
  var myValidatedSelectedItemIndex = makeAtom("myValidatedSelectedItemIndexAtom");
  var setSelectedIndexToEnd = makeAtom("setSelectedIndexToEndAtom");
  var mySelectedItemName = makeAtom("mySelectedItemNameAtom");
  var myPossiblyNoLongerValidSelectedItemIndex = makeAtom("myPossiblyNoLongerValidSelectedItemIndexAtom");
  var myCurrentGardenObject = makeAtom("myCurrentGardenObjectAtom");
  var myCurrentSortedGrowSlotIndices = makeAtom("myCurrentSortedGrowSlotIndicesAtom");
  var myCurrentGrowSlotIndex = makeAtom("myCurrentGrowSlotIndexAtom");
  var myOwnCurrentGardenObject = makeAtom("myOwnCurrentGardenObjectAtom");
  var isCurrentGrowSlotMature = makeAtom("isCurrentGrowSlotMatureAtom");
  var myOwnCurrentDirtTileIndex = makeAtom("myOwnCurrentDirtTileIndexAtom");
  var weather = makeAtom("weatherAtom");
  var activeModal = makeAtom("activeModalAtom");
  var avatarTriggerAnimationAtom = makeAtom("avatarTriggerAnimationAtom");
  var garden = makeView("myDataAtom", { path: "garden" });
  var gardenTileObjects = makeView("myDataAtom", { path: "garden.tileObjects" });
  var favoriteIds = makeView("myInventoryAtom", { path: "favoritedItemIds" });
  var playerId = makeView("playerAtom", { path: "id" });
  var myOwnCurrentGardenObjectType = makeView("myOwnCurrentGardenObjectAtom", { path: "objectType" });
  var stateChild = makeView("stateAtom", { path: "child" });
  var stateChildData = makeView("stateAtom", { path: "child.data" });
  var stateShops = makeView("stateAtom", { path: "child.data.shops" });
  var stateUserSlots = makeView("stateAtom", { path: "child.data.userSlots" });
  var statePlayers = makeView("stateAtom", { path: "data.players" });
  var seedShop = makeView("shopsAtom", { path: "seed" });
  var toolShop = makeView("shopsAtom", { path: "tool" });
  var eggShop = makeView("shopsAtom", { path: "egg" });
  var decorShop = makeView("shopsAtom", { path: "decor" });
  function slotSig(o) {
    if (!o) return "\u2205";
    return [
      o.objectType ?? o.type ?? "",
      o.species ?? o.seedSpecies ?? o.plantSpecies ?? o.eggId ?? o.decorId ?? "",
      o.plantedAt ?? o.startTime ?? 0,
      o.maturedAt ?? o.endTime ?? 0
    ].join("|");
  }
  var GardenSlotsSig = gardenTileObjects.asSignature({
    mode: "record",
    key: (_item, key2) => Number(key2),
    sig: (item) => slotSig(item)
  });
  function activePetSig(p) {
    const s = p?.slot ?? {};
    const muts = Array.isArray(s.mutations) ? s.mutations.slice().sort().join(",") : "";
    const ab = Array.isArray(s.abilities) ? s.abilities.slice().sort().join(",") : "";
    const name = s.name ?? "";
    const species = s.petSpecies ?? "";
    const xp = Number.isFinite(s.xp) ? Math.round(s.xp) : 0;
    const hunger = Number.isFinite(s.hunger) ? Math.round(s.hunger * 1e3) : 0;
    const scale = Number.isFinite(s.targetScale) ? Math.round(s.targetScale * 1e3) : 0;
    const x = Number.isFinite(p?.position?.x) ? Math.round(p.position.x) : 0;
    const y = Number.isFinite(p?.position?.y) ? Math.round(p.position.y) : 0;
    return `${species}|${name}|xp:${xp}|hg:${hunger}|sc:${scale}|m:${muts}|a:${ab}|pos:${x},${y}`;
  }
  function activePetStableSig(p) {
    const s = p?.slot ?? {};
    const muts = Array.isArray(s.mutations) ? s.mutations.slice().sort().join(",") : "";
    const ab = Array.isArray(s.abilities) ? s.abilities.slice().sort().join(",") : "";
    const name = s.name ?? "";
    const species = s.petSpecies ?? "";
    const scale = Number.isFinite(s.targetScale) ? Math.round(s.targetScale * 1e3) : 0;
    return `${species}|${name}|sc:${scale}|m:${muts}|a:${ab}`;
  }
  var PetsByIdSig = myPetInfos.asSignature({
    mode: "array",
    key: (p) => String(p?.slot?.id ?? ""),
    sig: (p) => activePetSig(p)
  });
  var PetsByIdStableSig = myPetInfos.asSignature({
    mode: "array",
    key: (p) => String(p?.slot?.id ?? ""),
    sig: (p) => activePetStableSig(p)
  });
  var FavoriteIdsSig = favoriteIds.asSignature({
    mode: "array",
    key: (id) => String(id),
    sig: () => "1"
  });
  var Atoms = {
    ui: { activeModal },
    server: { numPlayers },
    player: {
      position,
      avatarTriggerAnimationAtom,
      player,
      action,
      playerId
    },
    garden: {
      myOwnCurrentGardenObject,
      isCurrentGrowSlotMature,
      myOwnCurrentGardenObjectType,
      myOwnCurrentDirtTileIndex,
      myCurrentGrowSlotIndex
    },
    root: { state, map },
    data: {
      myData,
      garden,
      gardenTileObjects,
      myCurrentGardenObject,
      myCurrentSortedGrowSlotIndices,
      myCurrentGrowSlotIndex,
      weather
    },
    inventory: {
      myInventory,
      myCropInventory,
      mySeedInventory,
      myToolInventory,
      myEggInventory,
      myDecorInventory,
      favoriteIds,
      mySelectedItemName,
      myPossiblyNoLongerValidSelectedItemIndex,
      myValidatedSelectedItemIndex,
      setSelectedIndexToEnd,
      myCropItemsToSell
    },
    pets: {
      myPetInfos,
      myPetSlotInfos,
      totalPetSellPrice,
      expandedPetSlotId
    },
    shop: {
      shops,
      myShopPurchases,
      totalCropSellPrice,
      seedShop,
      toolShop,
      eggShop,
      decorShop
    }
  };
  function onFavoriteIds(cb) {
    return favoriteIds.onChange((next) => cb(Array.isArray(next) ? next : []), HubEq.idSet);
  }
  async function onFavoriteIdsNow(cb) {
    cb(Array.isArray(await favoriteIds.get()) ? await favoriteIds.get() : []);
    return onFavoriteIds(cb);
  }
  function activePetsStructuralEq(a, b) {
    const snap = (st) => {
      const m = /* @__PURE__ */ new Map();
      const arr = Array.isArray(st) ? st : [];
      for (const it of arr) {
        const id = String(it?.slot?.id ?? "");
        if (id) m.set(id, activePetStableSig(it));
      }
      return m;
    };
    const A = snap(a);
    const B = snap(b);
    if (A.size !== B.size) return false;
    for (const [k, v] of A) if (B.get(k) !== v) return false;
    return true;
  }
  async function onActivePetsStructuralChangeNow(cb) {
    cb(await myPetInfos.get());
    return myPetInfos.onChange(cb, activePetsStructuralEq);
  }
  async function getFavoriteIdSet() {
    const arr = await favoriteIds.get();
    return new Set(Array.isArray(arr) ? arr : []);
  }

  // src/data/hardcoded-data.clean.js
  var endsWith1 = (guildId) => String(guildId).endsWith("1");
  var endsWith2 = (guildId) => String(guildId).endsWith("2");
  var isEvenGuild = (guildId) => {
    const d = parseInt(String(guildId).slice(-1), 10);
    return Number.isInteger(d) && d % 2 === 0;
  };
  var rarity = {
    Common: "Common",
    Uncommon: "Uncommon",
    Rare: "Rare",
    Legendary: "Legendary",
    Mythic: "Mythical",
    Divine: "Divine",
    Celestial: "Celestial"
  };
  var harvestType = {
    Single: "Single",
    Multiple: "Multiple"
  };
  var tileRefsMap = {
    Dirt1: 6,
    Dirt2: 7,
    Dirt3: 8,
    Sky0: 24,
    Sky1: 25,
    Sky2: 26,
    Sky3: 27,
    Bush1: 28,
    Sky4: 35,
    Sky5: 36,
    Sky6: 37,
    Bush2: 38,
    Sky7: 45,
    Sky8: 46,
    Sky9: 47,
    BushHomer: 48
  };
  var tileRefsPlants = {
    DirtPatch: 1,
    SproutFlower: 2,
    SproutVegetable: 3,
    SproutFruit: 4,
    SproutVine: 5,
    StemFlower: 6,
    Trellis: 7,
    Daffodil: 11,
    Tulip: 12,
    Sunflower: 13,
    Lily: 14,
    Starweaver: 15,
    AloePlant: 17,
    Aloe: 18,
    Blueberry: 21,
    Banana: 22,
    Strawberry: 23,
    Mango: 24,
    Grape: 25,
    Watermelon: 26,
    Lemon: 27,
    Apple: 28,
    Pear: 29,
    Pineapple: 30,
    Pepper: 31,
    Tomato: 32,
    BabyCarrot: 33,
    Carrot: 34,
    Pumpkin: 35,
    Corn: 36,
    Peach: 37,
    BroadBean: 38,
    PalmTreeTop: 39,
    BushyTree: 40,
    Coconut: 41,
    MushroomPlant: 42,
    PassionFruit: 43,
    DragonFruit: 44,
    Lychee: 45,
    Mushroom: 46,
    BurrosTail: 47,
    Cacao: 48,
    Echeveria: 49,
    Delphinium: 50,
    DawnCelestialCrop: 51,
    MoonCelestialCrop: 52,
    Squash: 60
  };
  var tileRefsTallPlants = {
    Bamboo: 1,
    PalmTree: 2,
    DawnCelestialPlatform: 3,
    DawnCelestialPlant: 4,
    DawnCelestialPlantActive: 5,
    DawnCelestialPlatformTopmostLayer: 6,
    Cactus: 7,
    Tree: 8,
    MoonCelestialPlatform: 9,
    MoonCelestialPlant: 10,
    MoonCelestialPlantActive: 11,
    StarweaverPlatform: 13,
    StarweaverPlant: 14
  };
  var tileRefsSeeds = {
    Daffodil: 1,
    Tulip: 2,
    Sunflower: 3,
    Starweaver: 6,
    DawnCelestial: 7,
    MoonCelestial: 8,
    Blueberry: 11,
    Banana: 12,
    Strawberry: 13,
    Mango: 14,
    Grape: 15,
    Watermelon: 16,
    Lemon: 17,
    Apple: 18,
    Pear: 19,
    Lily: 20,
    Pepper: 21,
    Tomato: 22,
    Carrot: 23,
    Pumpkin: 25,
    Corn: 26,
    Peach: 27,
    BroadBean: 28,
    Delphinium: 30,
    Coconut: 31,
    Mushroom: 32,
    PassionFruit: 33,
    DragonFruit: 34,
    Lychee: 35,
    BurrosTail: 37,
    Cacao: 38,
    Aloe: 39,
    Echeveria: 40,
    Bamboo: 41,
    Cactus: 42,
    Squash: 50
  };
  var tileRefsItems = {
    Coin: 1,
    Shovel: 2,
    Seeds: 3,
    PlanterPot: 5,
    InventoryBag: 6,
    RainbowPotion: 9,
    GoldPotion: 10,
    WateringCan: 14,
    Fertilizer: 15,
    WetPotion: 16,
    ChilledPotion: 17,
    FrozenPotion: 18,
    DawnlitPotion: 19,
    AmberlitPotion: 20,
    ArrowKeys: 41,
    Touchpad: 42
  };
  var tileRefsAnimations = {
    Rain: 10,
    Frost: 20,
    Sunny: 30,
    AmberMoon: 40,
    Dawn: 50,
    MoonCelestialActivationTile: 91,
    DawnCelestialActivationTile: 92
  };
  var tileRefsPets = {
    Bee: 1,
    Chicken: 2,
    Bunny: 3,
    Turtle: 4,
    Capybara: 5,
    Cow: 6,
    Pig: 7,
    Butterfly: 8,
    Snail: 9,
    Worm: 10,
    CommonEgg: 11,
    UncommonEgg: 12,
    RareEgg: 13,
    LegendaryEgg: 14,
    MythicalEgg: 15,
    DivineEgg: 16,
    CelestialEgg: 17,
    Squirrel: 18,
    Goat: 19,
    Dragonfly: 20,
    Peacock: 30
  };
  var tileRefsMutations = {
    Wet: 1,
    Chilled: 2,
    Frozen: 3,
    Puddle: 5,
    Dawnlit: 11,
    Ambershine: 12,
    Dawncharged: 13,
    Ambercharged: 14
  };
  var tileRefsMutationLabels = {
    Wet: "Wet",
    Chilled: "Chilled",
    Frozen: "Frozen",
    Puddle: "Puddle",
    Dawnlit: "Dawnlit",
    Ambershine: "Amberlit",
    Dawncharged: "Dawnbound",
    Ambercharged: "Amberbound"
  };
  var tileRefsDecor = {
    WoodPedestal: 4,
    StonePedestal: 6,
    MarblePedestal: 8,
    SmallRock: 11,
    WoodBench: 13,
    WoodBenchBackwards: 14,
    StoneBench: 15,
    StoneBucketPedestal: 16,
    MarbleBench: 17,
    MarbleBenchBackwards: 18,
    MediumRock: 21,
    WoodLampPost: 23,
    WoodBenchSideways: 24,
    StoneLampPost: 25,
    StoneBenchSideways: 26,
    StoneColumn: 26,
    MarbleLampPost: 27,
    MarbleBenchSideways: 28,
    HayBale: 29,
    LargeRock: 31,
    WoodArch: 33,
    WoodBucketPedestal: 34,
    WoodBridge: 34,
    StoneArch: 35,
    StoneBridge: 36,
    MarbleArch: 37,
    MarbleBridge: 38,
    HayBaleSideways: 39,
    MiniFairyForge: 40,
    WoodArchSide: 43,
    WoodBridgeSideways: 44,
    StoneArchSideways: 45,
    StoneBridgeSideways: 46,
    MarbleArchSideways: 47,
    MarbleBridgeSideways: 48,
    StrawScarecrow: 49,
    MiniFairyCottage: 50,
    WoodOwl: 53,
    Birdhouse: 54,
    StoneGnome: 55,
    StoneBirdBath: 56,
    MarbleBlobling: 57,
    MarbleBucketPedestal: 58,
    Cauldron: 59,
    MiniFairyKeep: 60,
    WoodStool: 63,
    StoneGardenBox: 66,
    MarbleColumn: 68,
    SmallGravestone: 69,
    SmallGravestoneSideways: 70,
    WoodenWindmill: 73,
    WoodGardenBox: 74,
    MarbleGardenBox: 78,
    MediumGravestone: 79,
    MediumGravestoneSideways: 80,
    LargeGravestone: 89,
    LargeGravestoneSideways: 90
  };
  var plantCatalog = {
    Carrot: {
      seed: { tileRef: tileRefsSeeds.Carrot, name: "Carrot Seed", coinPrice: 10, creditPrice: 7, rarity: rarity.Common },
      plant: { tileRef: tileRefsPlants.BabyCarrot, name: "Carrot Plant", harvestType: harvestType.Single, baseTileScale: 0.7 },
      crop: { tileRef: tileRefsPlants.Carrot, name: "Carrot", baseSellPrice: 20, baseWeight: 0.1, baseTileScale: 0.6, maxScale: 3 }
    },
    Strawberry: {
      seed: { tileRef: tileRefsSeeds.Strawberry, name: "Strawberry Seed", coinPrice: 50, creditPrice: 21, rarity: rarity.Common },
      plant: {
        tileRef: tileRefsPlants.SproutFruit,
        name: "Strawberry Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.2, y: -0.1, rotation: 0 },
          { x: 0.175, y: -0.2, rotation: 0 },
          { x: -0.18, y: 0.22, rotation: 0 },
          { x: 0.2, y: 0.2, rotation: 0 },
          { x: 0.01, y: 0.01, rotation: 0 }
        ],
        secondsToMature: 70,
        baseTileScale: 1,
        rotateSlotOffsetsRandomly: true
      },
      crop: { tileRef: tileRefsPlants.Strawberry, name: "Strawberry", baseSellPrice: 14, baseWeight: 0.05, baseTileScale: 0.25, maxScale: 2 }
    },
    Aloe: {
      seed: { tileRef: tileRefsSeeds.Aloe, name: "Aloe Seed", coinPrice: 135, creditPrice: 18, rarity: rarity.Common },
      plant: { tileRef: tileRefsPlants.AloePlant, name: "Aloe Plant", harvestType: harvestType.Single, baseTileScale: 0.9 },
      crop: { tileRef: tileRefsPlants.Aloe, name: "Aloe", baseSellPrice: 310, baseWeight: 1.5, baseTileScale: 0.7, maxScale: 2.5 }
    },
    Delphinium: {
      seed: { tileRef: tileRefsSeeds.Delphinium, name: "Delphinium Seed", coinPrice: 300, creditPrice: 12, rarity: rarity.Uncommon },
      plant: { tileRef: tileRefsPlants.Delphinium, name: "Delphinium Plant", harvestType: harvestType.Single, baseTileScale: 0.8, tileTransformOrigin: "bottom", nudgeY: -0.43, nudgeYMultiplier: 0.05 },
      crop: { tileRef: tileRefsPlants.Delphinium, name: "Delphinium", baseSellPrice: 530, baseWeight: 0.02, baseTileScale: 0.8, maxScale: 3 }
    },
    Blueberry: {
      seed: { tileRef: tileRefsSeeds.Blueberry, name: "Blueberry Seed", coinPrice: 400, creditPrice: 49, rarity: rarity.Uncommon },
      plant: {
        tileRef: tileRefsPlants.SproutFruit,
        name: "Blueberry Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.2, y: -0.1, rotation: 0 },
          { x: 0.175, y: -0.2, rotation: 0 },
          { x: -0.18, y: 0.22, rotation: 0 },
          { x: 0.2, y: 0.2, rotation: 0 },
          { x: 0.01, y: 0.01, rotation: 0 }
        ],
        secondsToMature: 105,
        baseTileScale: 1,
        rotateSlotOffsetsRandomly: true
      },
      crop: { tileRef: tileRefsPlants.Blueberry, name: "Blueberry", baseSellPrice: 23, baseWeight: 0.01, baseTileScale: 0.25, maxScale: 2 }
    },
    Apple: {
      seed: { tileRef: tileRefsSeeds.Apple, name: "Apple Seed", coinPrice: 500, creditPrice: 67, rarity: rarity.Uncommon, unavailableSurfaces: ["discord"] },
      plant: {
        tileRef: tileRefsTallPlants.Tree,
        name: "Apple Tree",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.35, y: -2.4, rotation: 0 },
          { x: -0.5, y: -2, rotation: 0 },
          { x: 0.1, y: -2.2, rotation: 0 },
          { x: -0.2, y: -1.65, rotation: 0 },
          { x: 0.55, y: -1.9, rotation: 0 },
          { x: 0.3, y: -1.7, rotation: 0 },
          { x: 0.4, y: 0.1, rotation: 0 }
        ],
        secondsToMature: 360 * 60,
        baseTileScale: 3,
        rotateSlotOffsetsRandomly: true,
        tileTransformOrigin: "bottom",
        nudgeY: -0.25
      },
      crop: { tileRef: tileRefsPlants.Apple, name: "Apple", baseSellPrice: 73, baseWeight: 0.18, baseTileScale: 0.5, maxScale: 2 }
    },
    OrangeTulip: {
      seed: { tileRef: tileRefsSeeds.Tulip, name: "Tulip Seed", coinPrice: 600, creditPrice: 14, rarity: rarity.Uncommon },
      plant: { tileRef: tileRefsPlants.Tulip, name: "Tulip Plant", harvestType: harvestType.Single, baseTileScale: 0.5 },
      crop: { tileRef: tileRefsPlants.Tulip, name: "Tulip", baseSellPrice: 767, baseWeight: 0.01, baseTileScale: 0.5, maxScale: 3 }
    },
    Tomato: {
      seed: { tileRef: tileRefsSeeds.Tomato, name: "Tomato Seed", coinPrice: 800, creditPrice: 79, rarity: rarity.Uncommon },
      plant: {
        tileRef: tileRefsPlants.SproutVine,
        name: "Tomato Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [{ x: -0.3, y: -0.3, rotation: 0 }, { x: 0.3, y: 0.3, rotation: 0 }],
        secondsToMature: 1100,
        baseTileScale: 1,
        rotateSlotOffsetsRandomly: false
      },
      crop: { tileRef: tileRefsPlants.Tomato, name: "Tomato", baseSellPrice: 27, baseWeight: 0.3, baseTileScale: 0.33, maxScale: 2 }
    },
    Daffodil: {
      seed: { tileRef: tileRefsSeeds.Daffodil, name: "Daffodil Seed", coinPrice: 1e3, creditPrice: 19, rarity: rarity.Rare },
      plant: { tileRef: tileRefsPlants.Daffodil, name: "Daffodil Plant", harvestType: harvestType.Single, baseTileScale: 0.5 },
      crop: { tileRef: tileRefsPlants.Daffodil, name: "Daffodil", baseSellPrice: 1090, baseWeight: 0.01, baseTileScale: 0.5, maxScale: 3 }
    },
    Corn: {
      seed: { tileRef: tileRefsSeeds.Corn, name: "Corn Kernel", coinPrice: 1300, creditPrice: 135, rarity: rarity.Rare },
      plant: {
        tileRef: tileRefsPlants.SproutVegetable,
        name: "Corn Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [{ x: 0, y: -0.1, rotation: 0 }],
        secondsToMature: 130,
        baseTileScale: 1,
        rotateSlotOffsetsRandomly: false
      },
      crop: { tileRef: tileRefsPlants.Corn, name: "Corn", baseSellPrice: 36, baseWeight: 1.2, baseTileScale: 0.7, maxScale: 2 }
    },
    Watermelon: {
      seed: { tileRef: tileRefsSeeds.Watermelon, name: "Watermelon Seed", coinPrice: 2500, creditPrice: 195, rarity: rarity.Rare },
      plant: { tileRef: tileRefsPlants.Watermelon, name: "Watermelon Plant", harvestType: harvestType.Single, baseTileScale: 0.8 },
      crop: { tileRef: tileRefsPlants.Watermelon, name: "Watermelon", baseSellPrice: 2708, baseWeight: 4.5, baseTileScale: 0.8, maxScale: 3 }
    },
    Pumpkin: {
      seed: { tileRef: tileRefsSeeds.Pumpkin, name: "Pumpkin Seed", coinPrice: 3e3, creditPrice: 210, rarity: rarity.Rare },
      plant: { tileRef: tileRefsPlants.Pumpkin, name: "Pumpkin Plant", harvestType: harvestType.Single, baseTileScale: 0.8 },
      crop: { tileRef: tileRefsPlants.Pumpkin, name: "Pumpkin", baseSellPrice: 3700, baseWeight: 6, baseTileScale: 0.8, maxScale: 3 }
    },
    Echeveria: {
      seed: { tileRef: tileRefsSeeds.Echeveria, name: "Echeveria Cutting", coinPrice: 4200, creditPrice: 113, rarity: rarity.Legendary },
      plant: { tileRef: tileRefsPlants.Echeveria, name: "Echeveria Plant", harvestType: harvestType.Single, baseTileScale: 0.8 },
      crop: { tileRef: tileRefsPlants.Echeveria, name: "Echeveria", baseSellPrice: 4600, baseWeight: 0.8, baseTileScale: 0.8, maxScale: 2.75 }
    },
    Coconut: {
      seed: { tileRef: tileRefsSeeds.Coconut, name: "Coconut Seed", coinPrice: 6e3, creditPrice: 235, rarity: rarity.Legendary },
      plant: {
        tileRef: tileRefsTallPlants.PalmTree,
        name: "Coconut Tree",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.2, y: -2.6, rotation: 0 },
          { x: -0.3, y: -2.4, rotation: 0 },
          { x: 0.2, y: -2.5, rotation: 0 },
          { x: -0.25, y: -2.1, rotation: 0 },
          { x: 0, y: -2.3, rotation: 0 },
          { x: 0.3, y: -2.2, rotation: 0 },
          { x: 0.05, y: -2, rotation: 0 }
        ],
        secondsToMature: 720 * 60,
        baseTileScale: 3,
        rotateSlotOffsetsRandomly: true,
        tileTransformOrigin: "bottom",
        nudgeY: -0.35
      },
      crop: { tileRef: tileRefsPlants.Coconut, name: "Coconut", baseSellPrice: 302, baseWeight: 5, baseTileScale: 0.25, maxScale: 3 }
    },
    Banana: {
      seed: {
        tileRef: tileRefsSeeds.Banana,
        name: "Banana Seed",
        coinPrice: 7500,
        creditPrice: 199,
        rarity: rarity.Legendary,
        getCanSpawnInGuild: (guildId) => isEvenGuild(guildId)
      },
      plant: {
        tileRef: tileRefsTallPlants.PalmTree,
        name: "Banana Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.3, y: -1.7, rotation: 10 },
          { x: -0.2, y: -1.7, rotation: -10 },
          { x: -0.1, y: -1.7, rotation: -30 },
          { x: 0, y: -1.7, rotation: -50 },
          { x: 0.1, y: -1.7, rotation: -70 }
        ],
        secondsToMature: 14400,
        baseTileScale: 2.5,
        rotateSlotOffsetsRandomly: false,
        tileTransformOrigin: "bottom",
        nudgeY: -0.4
      },
      crop: { tileRef: tileRefsPlants.Banana, name: "Banana", baseSellPrice: 1750, baseWeight: 0.12, baseTileScale: 0.5, maxScale: 1.7 }
    },
    Lily: {
      seed: { tileRef: tileRefsSeeds.Lily, name: "Lily Seed", coinPrice: 2e4, creditPrice: 34, rarity: rarity.Legendary },
      plant: { tileRef: tileRefsPlants.Lily, name: "Lily Plant", harvestType: harvestType.Single, baseTileScale: 0.75, nudgeY: -0.1 },
      crop: { tileRef: tileRefsPlants.Lily, name: "Lily", baseSellPrice: 20123, baseWeight: 0.02, baseTileScale: 0.5, maxScale: 2.75 }
    },
    Squash: {
      seed: { tileRef: tileRefsSeeds.Squash, name: "Squash Seed", coinPrice: 55e3, creditPrice: 199, rarity: rarity.Legendary },
      plant: {
        tileRef: tileRefsPlants.SproutFlower,
        name: "Squash Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.08, y: 0.2, rotation: 35 },
          { x: 0.2, y: 0, rotation: 35 },
          { x: -0.2, y: -0.1, rotation: 35 }
        ],
        secondsToMature: 1500,
        baseTileScale: 1.2,
        rotateSlotOffsetsRandomly: true
      },
      crop: { tileRef: tileRefsPlants.Squash, name: "Squash", baseSellPrice: 3500, baseWeight: 0.3, baseTileScale: 0.4, maxScale: 2.5 }
    },
    BurrosTail: {
      seed: { tileRef: tileRefsSeeds.BurrosTail, name: "Burro's Tail Cutting", coinPrice: 93e3, creditPrice: 338, rarity: rarity.Legendary },
      plant: {
        tileRef: tileRefsPlants.Trellis,
        name: "Burro's Tail Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [{ x: -0.13, y: -0.1, rotation: 0 }, { x: 0.17, y: 0.13, rotation: 0 }],
        secondsToMature: 1800,
        baseTileScale: 0.8,
        rotateSlotOffsetsRandomly: false
      },
      crop: { tileRef: tileRefsPlants.BurrosTail, name: "Burro's Tail", baseSellPrice: 6e3, baseWeight: 0.4, baseTileScale: 0.4, maxScale: 2.5 }
    },
    Mushroom: {
      seed: { tileRef: tileRefsSeeds.Mushroom, name: "Mushroom Spore", coinPrice: 15e4, creditPrice: 249, rarity: rarity.Mythic },
      plant: { tileRef: tileRefsPlants.MushroomPlant, name: "Mushroom Plant", harvestType: harvestType.Single, baseTileScale: 0.8 },
      crop: { tileRef: tileRefsPlants.Mushroom, name: "Mushroom", baseSellPrice: 16e4, baseWeight: 25, baseTileScale: 0.65, maxScale: 3.5 }
    },
    Cactus: {
      seed: { tileRef: tileRefsSeeds.Cactus, name: "Cactus Seed", coinPrice: 25e4, creditPrice: 250, rarity: rarity.Mythic },
      plant: { tileRef: tileRefsTallPlants.Cactus, name: "Cactus Plant", harvestType: harvestType.Single, baseTileScale: 2.5, tileTransformOrigin: "bottom", nudgeY: -0.4, nudgeYMultiplier: 0.3 },
      crop: { tileRef: tileRefsTallPlants.Cactus, name: "Cactus", baseSellPrice: 261e3, baseWeight: 1500, baseTileScale: 2.5, maxScale: 1.8 }
    },
    Bamboo: {
      seed: { tileRef: tileRefsSeeds.Bamboo, name: "Bamboo Seed", coinPrice: 4e5, creditPrice: 300, rarity: rarity.Mythic },
      plant: { tileRef: tileRefsTallPlants.Bamboo, name: "Bamboo Plant", harvestType: harvestType.Single, baseTileScale: 2.5, tileTransformOrigin: "bottom", nudgeY: -0.45, nudgeYMultiplier: 0.3 },
      crop: { tileRef: tileRefsTallPlants.Bamboo, name: "Bamboo Shoot", baseSellPrice: 5e5, baseWeight: 1, baseTileScale: 2.5, maxScale: 2 }
    },
    Grape: {
      seed: {
        tileRef: tileRefsSeeds.Grape,
        name: "Grape Seed",
        coinPrice: 85e4,
        creditPrice: 599,
        rarity: rarity.Mythic,
        getCanSpawnInGuild: (guildId) => endsWith1(guildId)
      },
      plant: {
        tileRef: tileRefsPlants.SproutVine,
        name: "Grape Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [{ x: 0, y: 0, rotation: 0 }],
        secondsToMature: 1440 * 60,
        baseTileScale: 1,
        rotateSlotOffsetsRandomly: true
      },
      crop: { tileRef: tileRefsPlants.Grape, name: "Grape", baseSellPrice: 7085, baseWeight: 3, baseTileScale: 0.5, maxScale: 2 }
    },
    Pepper: {
      seed: { tileRef: tileRefsSeeds.Pepper, name: "Pepper Seed", coinPrice: 1e6, creditPrice: 629, rarity: rarity.Divine },
      plant: {
        tileRef: tileRefsPlants.SproutVine,
        name: "Pepper Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.02, y: 0.219, rotation: 0 },
          { x: 0.172, y: 0.172, rotation: 0 },
          { x: -0.172, y: 0.137, rotation: 0 },
          { x: 0.168, y: -0.035, rotation: 0 },
          { x: -0.082, y: -0.047, rotation: 0 },
          { x: -0.207, y: -0.074, rotation: 0 },
          { x: 0.18, y: -0.176, rotation: 0 },
          { x: -0.273, y: -0.195, rotation: 0 },
          { x: -0.074, y: -0.25, rotation: 0 }
        ],
        secondsToMature: 560,
        baseTileScale: 1,
        rotateSlotOffsetsRandomly: true
      },
      crop: { tileRef: tileRefsPlants.Pepper, name: "Pepper", baseSellPrice: 7220, baseWeight: 0.5, baseTileScale: 0.3, maxScale: 2 }
    },
    Lemon: {
      seed: {
        tileRef: tileRefsSeeds.Lemon,
        name: "Lemon Seed",
        coinPrice: 2e6,
        creditPrice: 500,
        rarity: rarity.Divine,
        getCanSpawnInGuild: (guildId) => endsWith2(guildId)
      },
      plant: {
        tileRef: tileRefsTallPlants.Tree,
        name: "Lemon Tree",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.5, y: -1.5, rotation: 0 },
          { x: 0.4, y: -1.6, rotation: 0 },
          { x: -0.3, y: -1.18, rotation: 0 },
          { x: 0.2, y: -1.2, rotation: 0 },
          { x: 0.01, y: -1.5, rotation: 0 },
          { x: -0.05, y: -1.8, rotation: 0 }
        ],
        secondsToMature: 720 * 60,
        baseTileScale: 2.3,
        rotateSlotOffsetsRandomly: true,
        tileTransformOrigin: "bottom",
        nudgeY: -0.25
      },
      crop: { tileRef: tileRefsPlants.Lemon, name: "Lemon", baseSellPrice: 1e4, baseWeight: 0.5, baseTileScale: 0.25, maxScale: 3 }
    },
    PassionFruit: {
      seed: { tileRef: tileRefsSeeds.PassionFruit, name: "Passion Fruit Seed", coinPrice: 275e4, creditPrice: 679, rarity: rarity.Divine },
      plant: {
        tileRef: tileRefsPlants.SproutVine,
        name: "Passion Fruit Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [{ x: -0.3, y: -0.3, rotation: 0 }, { x: 0.3, y: 0.3, rotation: 0 }],
        secondsToMature: 1440 * 60,
        baseTileScale: 1.1,
        rotateSlotOffsetsRandomly: false
      },
      crop: { tileRef: tileRefsPlants.PassionFruit, name: "Passion Fruit", baseSellPrice: 24500, baseWeight: 9.5, baseTileScale: 0.35, maxScale: 2 }
    },
    DragonFruit: {
      seed: { tileRef: tileRefsSeeds.DragonFruit, name: "Dragon Fruit Seed", coinPrice: 5e6, creditPrice: 715, rarity: rarity.Divine },
      plant: {
        tileRef: tileRefsPlants.PalmTreeTop,
        name: "Dragon Fruit Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.3, y: -0.4, rotation: 0 },
          { x: -0.4, y: -0.05, rotation: 0 },
          { x: 0.36, y: -0.3, rotation: 0 },
          { x: -0.25, y: 0.3, rotation: 0 },
          { x: 0, y: -0.1, rotation: 0 },
          { x: 0.4, y: 0.1, rotation: 0 },
          { x: 0.1, y: 0.2, rotation: 0 }
        ],
        secondsToMature: 600,
        baseTileScale: 1.6,
        rotateSlotOffsetsRandomly: true
      },
      crop: { tileRef: tileRefsPlants.DragonFruit, name: "Dragon Fruit", baseSellPrice: 24500, baseWeight: 8.4, baseTileScale: 0.4, maxScale: 2 }
    },
    Lychee: {
      seed: {
        tileRef: tileRefsSeeds.Lychee,
        name: "Lychee Pit",
        coinPrice: 25e6,
        creditPrice: 819,
        rarity: rarity.Divine,
        getCanSpawnInGuild: (guildId) => endsWith2(guildId)
      },
      plant: {
        tileRef: tileRefsPlants.BushyTree,
        name: "Lychee Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.4, y: -0.1, rotation: 0 },
          { x: 0.3, y: -0.2, rotation: 0 },
          { x: -0.3, y: 0.22, rotation: 0 },
          { x: 0.2, y: 0.2, rotation: 0 },
          { x: 0.01, y: -0.1, rotation: 0 },
          { x: -0.2, y: -0.3, rotation: 0 }
        ],
        secondsToMature: 1440 * 60,
        baseTileScale: 1.2,
        rotateSlotOffsetsRandomly: true
      },
      crop: { tileRef: tileRefsPlants.Lychee, name: "Lychee Fruit", baseSellPrice: 5e4, baseWeight: 9, baseTileScale: 0.2, maxScale: 2 }
    },
    Sunflower: {
      seed: { tileRef: tileRefsSeeds.Sunflower, name: "Sunflower Seed", coinPrice: 1e8, creditPrice: 900, rarity: rarity.Divine },
      plant: {
        tileRef: tileRefsPlants.StemFlower,
        name: "Sunflower Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [{ x: 0.01, y: -0.6, rotation: 0 }],
        secondsToMature: 1440 * 60,
        rotateSlotOffsetsRandomly: false,
        tileTransformOrigin: "bottom",
        baseTileScale: 0.8,
        nudgeY: -0.35
      },
      crop: { tileRef: tileRefsPlants.Sunflower, name: "Sunflower", baseSellPrice: 75e4, baseWeight: 10, baseTileScale: 0.5, maxScale: 2.5 }
    },
    Starweaver: {
      seed: { tileRef: tileRefsSeeds.Starweaver, name: "Starweaver Pod", coinPrice: 1e9, creditPrice: 1e3, rarity: rarity.Celestial },
      plant: {
        tileRef: tileRefsTallPlants.StarweaverPlant,
        name: "Starweaver Plant",
        harvestType: harvestType.Multiple,
        immatureTileRef: tileRefsTallPlants.StarweaverPlatform,
        baseTileScale: 1.5,
        tileTransformOrigin: "bottom",
        nudgeY: -0.27,
        isFixedScale: true,
        rotateSlotOffsetsRandomly: false,
        secondsToMature: 1440 * 60,
        growingAnimationTiles: { frames: 10, row: 8, fps: 20, nudgeY: -0.2 },
        slotOffsets: [{ x: 0, y: -0.918, rotation: 0 }]
      },
      crop: { tileRef: tileRefsPlants.Starweaver, name: "Starweaver Fruit", baseSellPrice: 1e7, baseWeight: 10, baseTileScale: 0.6, maxScale: 2 }
    },
    DawnCelestial: {
      seed: { tileRef: tileRefsSeeds.DawnCelestial, name: "Dawnbinder Pod", coinPrice: 1e10, creditPrice: 1129, rarity: rarity.Celestial },
      plant: {
        tileRef: tileRefsTallPlants.DawnCelestialPlant,
        name: "Dawnbinder",
        harvestType: harvestType.Multiple,
        secondsToMature: 1440 * 60,
        slotOffsets: [{ x: -0.015, y: -0.95, rotation: 0 }],
        baseTileScale: 2.3,
        rotateSlotOffsetsRandomly: false,
        tileTransformOrigin: "bottom",
        nudgeY: -0.2,
        isFixedScale: true,
        abilities: ["DawnKisser"],
        activeState: {
          tileRef: tileRefsTallPlants.DawnCelestialPlantActive,
          requiredWeather: "Dawn",
          activeAnimationTiles: { frames: 10, row: 6, fps: 20, nudgeY: -0.1 }
        },
        topmostLayerTileRef: tileRefsTallPlants.DawnCelestialPlatformTopmostLayer,
        immatureTileRef: tileRefsTallPlants.DawnCelestialPlatform,
        growingAnimationTiles: { frames: 10, row: 8, fps: 20, nudgeY: -0.2 }
      },
      crop: { tileRef: tileRefsPlants.DawnCelestialCrop, name: "Dawnbinder Bulb", baseSellPrice: 11e6, baseWeight: 6, baseTileScale: 0.4, maxScale: 2.5, transformOrigin: "top" }
    },
    MoonCelestial: {
      seed: { tileRef: tileRefsSeeds.MoonCelestial, name: "Moonbinder Pod", coinPrice: 5e10, creditPrice: 1249, rarity: rarity.Celestial },
      plant: {
        tileRef: tileRefsTallPlants.MoonCelestialPlant,
        name: "Moonbinder",
        harvestType: harvestType.Multiple,
        secondsToMature: 1440 * 60,
        slotOffsets: [
          { x: 0.01, y: -1.81, rotation: 0 },
          { x: -0.26, y: -0.82, rotation: -20 },
          { x: 0.23, y: -1, rotation: 20 }
        ],
        baseTileScale: 2.5,
        rotateSlotOffsetsRandomly: false,
        tileTransformOrigin: "bottom",
        nudgeY: -0.2,
        isFixedScale: true,
        abilities: ["MoonKisser"],
        activeState: {
          tileRef: tileRefsTallPlants.MoonCelestialPlantActive,
          requiredWeather: "AmberMoon",
          activeAnimationTiles: { frames: 10, row: 6, fps: 20, nudgeY: -0.1 }
        },
        immatureTileRef: tileRefsTallPlants.MoonCelestialPlatform,
        growingAnimationTiles: { frames: 10, row: 8, fps: 20, nudgeY: -0.2 }
      },
      crop: { tileRef: tileRefsPlants.MoonCelestialCrop, name: "Moonbinder Bulb", baseSellPrice: 11e6, baseWeight: 2, baseTileScale: 0.4, maxScale: 2, transformOrigin: "bottom" }
    }
  };
  var mutationCatalog = {
    Gold: { name: "Gold", baseChance: 0.01, coinMultiplier: 25 },
    Rainbow: { name: "Rainbow", baseChance: 1e-3, coinMultiplier: 50 },
    Wet: { name: "Wet", baseChance: 0, coinMultiplier: 2, tileRef: tileRefsMutations.Wet },
    Chilled: { name: "Chilled", baseChance: 0, coinMultiplier: 2, tileRef: tileRefsMutations.Chilled },
    Frozen: { name: "Frozen", baseChance: 0, coinMultiplier: 10, tileRef: tileRefsMutations.Frozen },
    Dawnlit: { name: "Dawnlit", baseChance: 0, coinMultiplier: 2, tileRef: tileRefsMutations.Dawnlit },
    Ambershine: { name: "Amberlit", baseChance: 0, coinMultiplier: 5, tileRef: tileRefsMutations.Ambershine },
    Dawncharged: { name: "Dawnbound", baseChance: 0, coinMultiplier: 3, tileRef: tileRefsMutations.Dawncharged },
    Ambercharged: { name: "Amberbound", baseChance: 0, coinMultiplier: 6, tileRef: tileRefsMutations.Ambercharged }
  };
  var eggCatalog = {
    CommonEgg: { tileRef: tileRefsPets.CommonEgg, name: "Common Egg", coinPrice: 1e5, creditPrice: 19, rarity: rarity.Common, initialTileScale: 0.3, baseTileScale: 0.8, secondsToHatch: 600, faunaSpawnWeights: { Worm: 60, Snail: 35, Bee: 5 } },
    UncommonEgg: { tileRef: tileRefsPets.UncommonEgg, name: "Uncommon Egg", coinPrice: 1e6, creditPrice: 48, rarity: rarity.Uncommon, initialTileScale: 0.3, baseTileScale: 0.8, secondsToHatch: 3600, faunaSpawnWeights: { Chicken: 65, Bunny: 25, Dragonfly: 10 } },
    RareEgg: { tileRef: tileRefsPets.RareEgg, name: "Rare Egg", coinPrice: 1e7, creditPrice: 99, rarity: rarity.Rare, initialTileScale: 0.3, baseTileScale: 0.8, secondsToHatch: 21600, faunaSpawnWeights: { Pig: 90, Cow: 10 } },
    LegendaryEgg: { tileRef: tileRefsPets.LegendaryEgg, name: "Legendary Egg", coinPrice: 1e8, creditPrice: 249, rarity: rarity.Legendary, initialTileScale: 0.3, baseTileScale: 0.8, secondsToHatch: 43200, faunaSpawnWeights: { Squirrel: 60, Turtle: 30, Goat: 10 } },
    MythicalEgg: { tileRef: tileRefsPets.MythicalEgg, name: "Mythical Egg", coinPrice: 1e9, creditPrice: 599, rarity: rarity.Mythic, initialTileScale: 0.3, baseTileScale: 0.8, secondsToHatch: 86400, faunaSpawnWeights: { Butterfly: 75, Capybara: 5, Peacock: 20 } }
  };
  var petCatalog = {
    Worm: {
      tileRef: tileRefsPets.Worm,
      name: "Worm",
      description: "",
      coinsToFullyReplenishHunger: 500,
      innateAbilityWeights: { SeedFinderI: 50, ProduceEater: 50 },
      baseTileScale: 0.6,
      maxScale: 2,
      maturitySellPrice: 5e3,
      matureWeight: 0.1,
      moveProbability: 0.1,
      hoursToMature: 12,
      rarity: rarity.Common,
      tileTransformOrigin: "bottom",
      nudgeY: 0.25,
      diet: ["Carrot", "Strawberry", "Aloe", "Tomato", "Apple"]
    },
    Snail: {
      tileRef: tileRefsPets.Snail,
      name: "Snail",
      description: "",
      coinsToFullyReplenishHunger: 1e3,
      innateAbilityWeights: { CoinFinderI: 100 },
      baseTileScale: 0.6,
      maxScale: 2,
      maturitySellPrice: 5e3,
      matureWeight: 0.15,
      moveProbability: 0.01,
      hoursToMature: 12,
      rarity: rarity.Common,
      tileTransformOrigin: "bottom",
      nudgeY: -0.25,
      diet: ["Blueberry", "Tomato", "Corn", "Daffodil"]
    },
    Bee: {
      tileRef: tileRefsPets.Bee,
      name: "Bee",
      coinsToFullyReplenishHunger: 1500,
      innateAbilityWeights: { ProduceScaleBoost: 50, ProduceMutationBoost: 50 },
      baseTileScale: 0.6,
      maxScale: 2.5,
      maturitySellPrice: 3e4,
      matureWeight: 0.2,
      moveProbability: 0.5,
      hoursToMature: 12,
      rarity: rarity.Common,
      diet: ["Strawberry", "Blueberry", "OrangeTulip", "Daffodil", "Lily"]
    },
    Chicken: {
      tileRef: tileRefsPets.Chicken,
      name: "Chicken",
      coinsToFullyReplenishHunger: 3e3,
      innateAbilityWeights: { EggGrowthBoost: 80, PetRefund: 20 },
      baseTileScale: 0.8,
      maxScale: 2,
      maturitySellPrice: 5e4,
      matureWeight: 3,
      moveProbability: 0.2,
      hoursToMature: 24,
      rarity: rarity.Uncommon,
      tileTransformOrigin: "bottom",
      nudgeY: -0.2,
      diet: ["Aloe", "Corn", "Watermelon", "Pumpkin"]
    },
    Bunny: {
      tileRef: tileRefsPets.Bunny,
      name: "Bunny",
      coinsToFullyReplenishHunger: 750,
      innateAbilityWeights: { CoinFinderII: 60, SellBoostI: 40 },
      baseTileScale: 0.7,
      maxScale: 2,
      maturitySellPrice: 75e3,
      matureWeight: 2,
      moveProbability: 0.3,
      hoursToMature: 24,
      rarity: rarity.Uncommon,
      tileTransformOrigin: "bottom",
      nudgeY: -0.2,
      diet: ["Carrot", "Strawberry", "Blueberry", "Echeveria"]
    },
    Dragonfly: {
      tileRef: tileRefsPets.Dragonfly,
      name: "Dragonfly",
      coinsToFullyReplenishHunger: 250,
      innateAbilityWeights: { HungerRestore: 70, PetMutationBoost: 30 },
      baseTileScale: 0.6,
      maxScale: 2.5,
      maturitySellPrice: 15e4,
      matureWeight: 0.2,
      moveProbability: 0.7,
      hoursToMature: 24,
      rarity: rarity.Uncommon,
      tileTransformOrigin: "center",
      diet: ["Apple", "OrangeTulip", "Echeveria"]
    },
    Pig: {
      tileRef: tileRefsPets.Pig,
      name: "Pig",
      coinsToFullyReplenishHunger: 5e4,
      innateAbilityWeights: { SellBoostII: 30, PetAgeBoost: 30, PetHatchSizeBoost: 30 },
      baseTileScale: 1,
      maxScale: 2.5,
      maturitySellPrice: 5e5,
      matureWeight: 200,
      moveProbability: 0.2,
      hoursToMature: 72,
      rarity: rarity.Rare,
      tileTransformOrigin: "bottom",
      nudgeY: -0.15,
      diet: ["Watermelon", "Pumpkin", "Mushroom", "Bamboo"]
    },
    Cow: {
      tileRef: tileRefsPets.Cow,
      name: "Cow",
      coinsToFullyReplenishHunger: 25e3,
      innateAbilityWeights: { SeedFinderII: 30, HungerBoost: 30, PlantGrowthBoost: 30 },
      baseTileScale: 1.1,
      maxScale: 2.5,
      maturitySellPrice: 1e6,
      matureWeight: 600,
      moveProbability: 0.1,
      hoursToMature: 72,
      rarity: rarity.Rare,
      tileTransformOrigin: "bottom",
      nudgeY: -0.15,
      diet: ["Coconut", "Banana", "BurrosTail", "Mushroom"]
    },
    Squirrel: {
      tileRef: tileRefsPets.Squirrel,
      name: "Squirrel",
      coinsToFullyReplenishHunger: 15e3,
      innateAbilityWeights: { CoinFinderIII: 70, SellBoostIII: 20, PetMutationBoostII: 10 },
      baseTileScale: 0.6,
      maxScale: 2,
      maturitySellPrice: 5e6,
      matureWeight: 0.5,
      moveProbability: 0.4,
      hoursToMature: 100,
      rarity: rarity.Legendary,
      tileTransformOrigin: "bottom",
      nudgeY: -0.1,
      diet: ["Pumpkin", "Banana", "Grape"]
    },
    Turtle: {
      tileRef: tileRefsPets.Turtle,
      name: "Turtle",
      coinsToFullyReplenishHunger: 1e5,
      innateAbilityWeights: { HungerRestoreII: 25, HungerBoostII: 25, PlantGrowthBoostII: 25, EggGrowthBoostII: 25 },
      baseTileScale: 1,
      maxScale: 2.5,
      maturitySellPrice: 1e7,
      matureWeight: 150,
      moveProbability: 0.05,
      hoursToMature: 100,
      rarity: rarity.Legendary,
      tileTransformOrigin: "bottom",
      nudgeY: -0.15,
      diet: ["Watermelon", "BurrosTail", "Bamboo", "Pepper"]
    },
    Goat: {
      tileRef: tileRefsPets.Goat,
      name: "Goat",
      coinsToFullyReplenishHunger: 2e4,
      innateAbilityWeights: { PetHatchSizeBoostII: 10, PetAgeBoostII: 40, PetXpBoost: 40 },
      baseTileScale: 1,
      maxScale: 2,
      maturitySellPrice: 2e7,
      matureWeight: 100,
      moveProbability: 0.2,
      hoursToMature: 100,
      rarity: rarity.Legendary,
      tileTransformOrigin: "bottom",
      nudgeY: -0.1,
      diet: ["Pumpkin", "Coconut", "Cactus", "Pepper"]
    },
    Butterfly: {
      tileRef: tileRefsPets.Butterfly,
      name: "Butterfly",
      coinsToFullyReplenishHunger: 25e3,
      innateAbilityWeights: { ProduceScaleBoostII: 40, ProduceMutationBoostII: 40, SeedFinderIII: 20 },
      baseTileScale: 0.6,
      maxScale: 2.5,
      maturitySellPrice: 5e7,
      matureWeight: 0.2,
      moveProbability: 0.6,
      hoursToMature: 144,
      rarity: rarity.Mythic,
      tileTransformOrigin: "center",
      diet: ["Daffodil", "Lily", "Grape", "Lemon", "Sunflower"]
    },
    Capybara: {
      tileRef: tileRefsPets.Capybara,
      name: "Capybara",
      coinsToFullyReplenishHunger: 15e4,
      innateAbilityWeights: { DoubleHarvest: 50, ProduceRefund: 50 },
      baseTileScale: 1,
      maxScale: 2.5,
      maturitySellPrice: 2e8,
      matureWeight: 50,
      moveProbability: 0.2,
      hoursToMature: 144,
      rarity: rarity.Mythic,
      tileTransformOrigin: "bottom",
      nudgeY: -0.1,
      diet: ["Lemon", "PassionFruit", "DragonFruit", "Lychee"]
    },
    Peacock: {
      tileRef: tileRefsPets.Peacock,
      name: "Peacock",
      coinsToFullyReplenishHunger: 1e5,
      innateAbilityWeights: { SellBoostIV: 40, PetXpBoostII: 50, PetRefundII: 10 },
      baseTileScale: 1.2,
      maxScale: 2.5,
      maturitySellPrice: 1e8,
      matureWeight: 5,
      moveProbability: 0.2,
      hoursToMature: 144,
      rarity: rarity.Mythic,
      tileTransformOrigin: "bottom",
      nudgeY: -0.1,
      diet: ["Cactus", "Sunflower", "Lychee"]
    }
  };
  var petAbilities = {
    ProduceScaleBoost: {
      name: "Crop Size Boost I",
      description: "Increases the scale of garden crops",
      trigger: "continuous",
      baseProbability: 0.3,
      baseParameters: { cropScaleIncreasePercentage: 6 }
    },
    ProduceScaleBoostII: {
      name: "Crop Size Boost II",
      description: "Increases the scale of garden crops",
      trigger: "continuous",
      baseProbability: 0.4,
      baseParameters: { cropScaleIncreasePercentage: 10 }
    },
    DoubleHarvest: {
      name: "Double Harvest",
      description: "Chance to duplicate harvested crops",
      trigger: "harvest",
      baseProbability: 5,
      baseParameters: {}
    },
    ProduceEater: {
      name: "Crop Eater",
      description: "Harvests non-mutated crops and sells them",
      trigger: "continuous",
      baseProbability: 60,
      baseParameters: { cropSellPriceIncreasePercentage: 150 }
    },
    SellBoostI: {
      name: "Sell Boost I",
      description: "Receive bonus coins when selling crops",
      trigger: "sellAllCrops",
      baseProbability: 10,
      baseParameters: { cropSellPriceIncreasePercentage: 20 }
    },
    SellBoostII: {
      name: "Sell Boost II",
      description: "Receive bonus coins when selling crops",
      trigger: "sellAllCrops",
      baseProbability: 12,
      baseParameters: { cropSellPriceIncreasePercentage: 30 }
    },
    SellBoostIII: {
      name: "Sell Boost III",
      description: "Receive bonus coins when selling crops",
      trigger: "sellAllCrops",
      baseProbability: 14,
      baseParameters: { cropSellPriceIncreasePercentage: 40 }
    },
    SellBoostIV: {
      name: "Sell Boost IV",
      description: "Receive bonus coins when selling crops",
      trigger: "sellAllCrops",
      baseProbability: 16,
      baseParameters: { cropSellPriceIncreasePercentage: 50 }
    },
    ProduceRefund: {
      name: "Crop Refund",
      description: "Chance to get crops back when selling",
      trigger: "sellAllCrops",
      baseProbability: 20,
      baseParameters: {}
    },
    PlantGrowthBoost: {
      name: "Plant Growth Boost I",
      description: "Reduces the time for plants to grow",
      trigger: "continuous",
      baseProbability: 24,
      baseParameters: { plantGrowthReductionMinutes: 3 }
    },
    PlantGrowthBoostII: {
      name: "Plant Growth Boost II",
      description: "Reduces the time for plants to grow",
      trigger: "continuous",
      baseProbability: 27,
      baseParameters: { plantGrowthReductionMinutes: 5 }
    },
    ProduceMutationBoost: {
      name: "Crop Mutation Boost I",
      description: "Increases the chance of garden crops gaining mutations",
      trigger: "continuous",
      baseParameters: { mutationChanceIncreasePercentage: 10 }
    },
    ProduceMutationBoostII: {
      name: "Crop Mutation Boost II",
      description: "Increases the chance of garden crops gaining mutations",
      trigger: "continuous",
      baseParameters: { mutationChanceIncreasePercentage: 15 }
    },
    PetMutationBoost: {
      name: "Pet Mutation Boost I",
      description: "Increases the chance of hatched pets gaining mutations",
      trigger: "hatchEgg",
      baseParameters: { mutationChanceIncreasePercentage: 7 }
    },
    PetMutationBoostII: {
      name: "Pet Mutation Boost II",
      description: "Increases the chance of hatched pets gaining mutations",
      trigger: "hatchEgg",
      baseParameters: { mutationChanceIncreasePercentage: 10 }
    },
    GoldGranter: {
      name: "Gold Granter",
      description: "Grants the Gold mutation to a garden crop",
      trigger: "continuous",
      baseProbability: 0.72,
      baseParameters: { grantedMutations: ["Gold"] }
    },
    RainbowGranter: {
      name: "Rainbow Granter",
      description: "Grants the Rainbow mutation to a garden crop",
      trigger: "continuous",
      baseProbability: 0.72,
      baseParameters: { grantedMutations: ["Rainbow"] }
    },
    EggGrowthBoost: {
      name: "Egg Growth Boost I",
      description: "Reduces the time for eggs to hatch",
      trigger: "continuous",
      baseProbability: 21,
      baseParameters: { eggGrowthTimeReductionMinutes: 7 }
    },
    EggGrowthBoostII: {
      name: "Egg Growth Boost II",
      description: "Reduces the time for eggs to hatch",
      trigger: "continuous",
      baseProbability: 24,
      baseParameters: { eggGrowthTimeReductionMinutes: 10 }
    },
    EggGrowthBoostIII: {
      name: "Egg Growth Boost III",
      description: "Reduces the time for eggs to hatch",
      trigger: "continuous",
      baseProbability: 27,
      baseParameters: { eggGrowthTimeReductionMinutes: 13 }
    },
    PetAgeBoost: {
      name: "Hatch XP Boost I",
      description: "Hatched pets start with bonus XP",
      trigger: "hatchEgg",
      baseProbability: 50,
      baseParameters: { bonusXp: 8e3 }
    },
    PetAgeBoostII: {
      name: "Hatch XP Boost II",
      description: "Hatched pets start with bonus XP",
      trigger: "hatchEgg",
      baseProbability: 60,
      baseParameters: { bonusXp: 12e3 }
    },
    PetHatchSizeBoost: {
      name: "Max Strength Boost I",
      description: "Increases the maximum strength of hatched pets",
      trigger: "hatchEgg",
      baseProbability: 12,
      baseParameters: { maxStrengthIncreasePercentage: 2.4 }
    },
    PetHatchSizeBoostII: {
      name: "Max Strength Boost II",
      description: "Increases the maximum strength of hatched pets",
      trigger: "hatchEgg",
      baseProbability: 14,
      baseParameters: { maxStrengthIncreasePercentage: 3.5 }
    },
    PetXpBoost: {
      name: "XP Boost I",
      description: "Gives bonus XP to active pets",
      trigger: "continuous",
      baseProbability: 30,
      baseParameters: { bonusXp: 300 }
    },
    PetXpBoostII: {
      name: "XP Boost II",
      description: "Gives bonus XP to active pets",
      trigger: "continuous",
      baseProbability: 35,
      baseParameters: { bonusXp: 400 }
    },
    HungerRestore: {
      name: "Hunger Restore I",
      description: "Restores the hunger of a random active pet",
      trigger: "continuous",
      baseProbability: 12,
      baseParameters: { hungerRestorePercentage: 30 }
    },
    HungerRestoreII: {
      name: "Hunger Restore II",
      description: "Restores the hunger of a random active pet",
      trigger: "continuous",
      baseProbability: 14,
      baseParameters: { hungerRestorePercentage: 35 }
    },
    HungerBoost: {
      name: "Hunger Boost I",
      description: "Reduces the hunger depletion rate of active pets",
      trigger: "continuous",
      baseParameters: { hungerDepletionRateDecreasePercentage: 12 }
    },
    HungerBoostII: {
      name: "Hunger Boost II",
      description: "Reduces the hunger depletion rate of active pets",
      trigger: "continuous",
      baseParameters: { hungerDepletionRateDecreasePercentage: 16 }
    },
    PetRefund: {
      name: "Pet Refund I",
      description: "Chance to receive the pet back as an egg when sold",
      trigger: "sellPet",
      baseProbability: 5,
      baseParameters: {}
    },
    PetRefundII: {
      name: "Pet Refund II",
      description: "Chance to receive the pet back as an egg when sold",
      trigger: "sellPet",
      baseProbability: 7,
      baseParameters: {}
    },
    Copycat: {
      name: "Copycat",
      description: "Chance to copy the ability of another active pet",
      trigger: "continuous",
      baseProbability: 1,
      baseParameters: {}
    },
    CoinFinderI: {
      name: "Coin Finder I",
      description: "Finds coins in your garden",
      trigger: "continuous",
      baseProbability: 35,
      baseParameters: { baseMaxCoinsFindable: 12e4 }
    },
    CoinFinderII: {
      name: "Coin Finder II",
      description: "Finds coins in your garden",
      trigger: "continuous",
      baseProbability: 13,
      baseParameters: { baseMaxCoinsFindable: 12e5 }
    },
    CoinFinderIII: {
      name: "Coin Finder III",
      description: "Finds coins in your garden",
      trigger: "continuous",
      baseProbability: 6,
      baseParameters: { baseMaxCoinsFindable: 1e7 }
    },
    SeedFinderI: {
      name: "Seed Finder I",
      description: "Finds common and uncommon seeds in your garden",
      trigger: "continuous",
      baseProbability: 40,
      baseParameters: {}
    },
    SeedFinderII: {
      name: "Seed Finder II",
      description: "Finds rare and legendary seeds in your garden",
      trigger: "continuous",
      baseProbability: 16,
      baseParameters: {}
    },
    SeedFinderIII: {
      name: "Seed Finder III",
      description: "Finds mythical seeds in your garden",
      trigger: "continuous",
      baseProbability: 9,
      baseParameters: {}
    },
    SeedFinderIV: {
      name: "Seed Finder IV",
      description: "Finds divine and celestial seeds in your garden",
      trigger: "continuous",
      baseProbability: 0.01,
      baseParameters: {}
    }
  };
  var toolCatalog = {
    WateringCan: {
      tileRef: tileRefsItems.WateringCan,
      name: "Watering Can",
      coinPrice: 5e3,
      creditPrice: 2,
      rarity: rarity.Common,
      description: "Speeds up growth of plant by 5 minutes. SINGLE USE.",
      isOneTimePurchase: false,
      baseTileScale: 0.6,
      maxInventoryQuantity: 99
    },
    PlanterPot: {
      tileRef: tileRefsItems.PlanterPot,
      name: "Planter Pot",
      coinPrice: 25e3,
      creditPrice: 5,
      rarity: rarity.Common,
      description: "Extract a plant to your inventory (can be replanted). SINGLE USE.",
      isOneTimePurchase: false,
      baseTileScale: 0.8
    },
    Shovel: {
      tileRef: tileRefsItems.Shovel,
      name: "Garden Shovel",
      coinPrice: 1e6,
      creditPrice: 100,
      rarity: rarity.Uncommon,
      description: "Remove plants from your garden. UNLIMITED USES.",
      isOneTimePurchase: true,
      baseTileScale: 0.7
    },
    RainbowPotion: {
      tileRef: tileRefsItems.RainbowPotion,
      name: "Rainbow Potion",
      coinPrice: 1 / 0,
      creditPrice: 1 / 0,
      rarity: rarity.Celestial,
      description: "Adds the Rainbow mutation to a crop in your garden. SINGLE USE.",
      isOneTimePurchase: true,
      baseTileScale: 1
    }
  };
  var decorCatalog = {
    // Rochers
    SmallRock: {
      tileRef: tileRefsDecor.SmallRock,
      name: "Small Garden Rock",
      coinPrice: 1e3,
      creditPrice: 2,
      rarity: rarity.Common,
      baseTileScale: 1,
      isOneTimePurchase: false
    },
    MediumRock: {
      tileRef: tileRefsDecor.MediumRock,
      name: "Medium Garden Rock",
      coinPrice: 2500,
      creditPrice: 5,
      rarity: rarity.Common,
      baseTileScale: 1,
      isOneTimePurchase: false
    },
    LargeRock: {
      tileRef: tileRefsDecor.LargeRock,
      name: "Large Garden Rock",
      coinPrice: 5e3,
      creditPrice: 10,
      rarity: rarity.Common,
      baseTileScale: 1,
      isOneTimePurchase: false
    },
    // Bois
    WoodBench: {
      tileRef: tileRefsDecor.WoodBench,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.WoodBenchSideways, flipH: true, baseTileScale: 1.46, nudgeY: -0.3 },
        180: { tileRef: tileRefsDecor.WoodBenchBackwards },
        270: { tileRef: tileRefsDecor.WoodBenchSideways, baseTileScale: 1.46, nudgeY: -0.3 }
      },
      name: "Wood Bench",
      coinPrice: 1e4,
      creditPrice: 15,
      rarity: rarity.Common,
      baseTileScale: 1,
      isOneTimePurchase: false,
      nudgeY: -0.3,
      avatarNudgeY: -0.18
    },
    WoodArch: {
      tileRef: tileRefsDecor.WoodArch,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.WoodArchSide, flipH: true, baseTileScale: 2.1, nudgeY: -0.48 },
        180: { tileRef: tileRefsDecor.WoodArch, flipH: true },
        270: { tileRef: tileRefsDecor.WoodArchSide, baseTileScale: 2.1, nudgeY: -0.48 }
      },
      name: "Wood Arch",
      coinPrice: 2e4,
      creditPrice: 25,
      rarity: rarity.Common,
      baseTileScale: 1.53,
      isOneTimePurchase: false,
      nudgeY: -0.5
    },
    WoodBridge: {
      tileRef: tileRefsDecor.WoodBridge,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.WoodBridgeSideways, flipH: true, baseTileScale: 1.7, nudgeY: -0.28 },
        180: { tileRef: tileRefsDecor.WoodBridge, flipH: true },
        270: { tileRef: tileRefsDecor.WoodBridgeSideways, baseTileScale: 1.7, nudgeY: -0.28 }
      },
      name: "Wood Bridge",
      coinPrice: 4e4,
      creditPrice: 35,
      rarity: rarity.Common,
      baseTileScale: 1.22,
      isOneTimePurchase: false,
      nudgeY: -0.35,
      avatarNudgeY: -0.44
    },
    WoodLampPost: {
      tileRef: tileRefsDecor.WoodLampPost,
      name: "Wood Lamp Post",
      coinPrice: 8e4,
      creditPrice: 49,
      rarity: rarity.Common,
      baseTileScale: 1.5,
      isOneTimePurchase: false,
      nudgeY: -0.6
    },
    WoodOwl: {
      tileRef: tileRefsDecor.WoodOwl,
      name: "Wood Owl",
      coinPrice: 9e4,
      creditPrice: 59,
      rarity: rarity.Common,
      baseTileScale: 1.3,
      isOneTimePurchase: false,
      nudgeY: -0.4
    },
    WoodBirdhouse: {
      tileRef: tileRefsDecor.Birdhouse,
      name: "Wood Birdhouse",
      coinPrice: 1e5,
      creditPrice: 69,
      rarity: rarity.Common,
      baseTileScale: 1.5,
      isOneTimePurchase: false,
      nudgeY: -0.6
    },
    // Pierre
    StoneBench: {
      tileRef: tileRefsDecor.StoneBench,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.StoneBenchSideways, flipH: true, baseTileScale: 1.47, nudgeY: -0.3 },
        180: { tileRef: tileRefsDecor.StoneBench, flipH: true },
        270: { tileRef: tileRefsDecor.StoneBenchSideways, baseTileScale: 1.47, nudgeY: -0.3 }
      },
      name: "Stone Bench",
      coinPrice: 1e6,
      creditPrice: 75,
      rarity: rarity.Uncommon,
      baseTileScale: 1,
      isOneTimePurchase: false,
      nudgeY: -0.3,
      avatarNudgeY: -0.18
    },
    StoneArch: {
      tileRef: tileRefsDecor.StoneArch,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.StoneArchSideways, flipH: true, baseTileScale: 2.1, nudgeY: -0.44 },
        180: { tileRef: tileRefsDecor.StoneArch, flipH: true },
        270: { tileRef: tileRefsDecor.StoneArchSideways, baseTileScale: 2.1, nudgeY: -0.44 }
      },
      name: "Stone Arch",
      coinPrice: 4e6,
      creditPrice: 124,
      rarity: rarity.Uncommon,
      baseTileScale: 1.53,
      isOneTimePurchase: false,
      nudgeY: -0.5
    },
    StoneBridge: {
      tileRef: tileRefsDecor.StoneBridge,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.StoneBridgeSideways, flipH: true, baseTileScale: 1.7, nudgeY: -0.28 },
        180: { tileRef: tileRefsDecor.StoneBridge, flipH: true },
        270: { tileRef: tileRefsDecor.StoneBridgeSideways, baseTileScale: 1.7, nudgeY: -0.28 }
      },
      name: "Stone Bridge",
      coinPrice: 5e6,
      creditPrice: 179,
      rarity: rarity.Uncommon,
      baseTileScale: 1.22,
      isOneTimePurchase: false,
      nudgeY: -0.35,
      avatarNudgeY: -0.44
    },
    StoneLampPost: {
      tileRef: tileRefsDecor.StoneLampPost,
      name: "Stone Lamp Post",
      coinPrice: 8e6,
      creditPrice: 199,
      rarity: rarity.Uncommon,
      baseTileScale: 1.5,
      isOneTimePurchase: false,
      nudgeY: -0.6
    },
    StoneGnome: {
      tileRef: tileRefsDecor.StoneGnome,
      name: "Stone Gnome",
      coinPrice: 9e6,
      creditPrice: 219,
      rarity: rarity.Uncommon,
      baseTileScale: 1.3,
      isOneTimePurchase: false,
      nudgeY: -0.4
    },
    StoneBirdbath: {
      tileRef: tileRefsDecor.StoneBirdBath,
      name: "Stone Birdbath",
      coinPrice: 1e7,
      creditPrice: 249,
      rarity: rarity.Uncommon,
      baseTileScale: 1.2,
      isOneTimePurchase: false,
      nudgeY: -0.46
    },
    // Marbre
    MarbleBench: {
      tileRef: tileRefsDecor.MarbleBench,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.MarbleBenchSideways, flipH: true, baseTileScale: 1.55, nudgeY: -0.35 },
        180: { tileRef: tileRefsDecor.MarbleBenchBackwards },
        270: { tileRef: tileRefsDecor.MarbleBenchSideways, baseTileScale: 1.55, nudgeY: -0.35 }
      },
      name: "Marble Bench",
      coinPrice: 75e6,
      creditPrice: 349,
      rarity: rarity.Rare,
      baseTileScale: 1,
      isOneTimePurchase: false,
      nudgeY: -0.3,
      avatarNudgeY: -0.18
    },
    MarbleArch: {
      tileRef: tileRefsDecor.MarbleArch,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.MarbleArchSideways, flipH: true, baseTileScale: 2.38, nudgeY: -0.57 },
        180: { tileRef: tileRefsDecor.MarbleArch, flipH: true },
        270: { tileRef: tileRefsDecor.MarbleArchSideways, baseTileScale: 2.38, nudgeY: -0.57 }
      },
      name: "Marble Arch",
      coinPrice: 1e8,
      creditPrice: 399,
      rarity: rarity.Rare,
      baseTileScale: 1.53,
      isOneTimePurchase: false,
      nudgeY: -0.5
    },
    MarbleBridge: {
      tileRef: tileRefsDecor.MarbleBridge,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.MarbleBridgeSideways, flipH: true, baseTileScale: 1.7, nudgeY: -0.28 },
        180: { tileRef: tileRefsDecor.MarbleBridge, flipH: true },
        270: { tileRef: tileRefsDecor.MarbleBridgeSideways, baseTileScale: 1.7, nudgeY: -0.28 }
      },
      name: "Marble Bridge",
      coinPrice: 15e7,
      creditPrice: 429,
      rarity: rarity.Rare,
      baseTileScale: 1.22,
      isOneTimePurchase: false,
      nudgeY: -0.35,
      avatarNudgeY: -0.44
    },
    MarbleLampPost: {
      tileRef: tileRefsDecor.MarbleLampPost,
      name: "Marble Lamp Post",
      coinPrice: 2e8,
      creditPrice: 449,
      rarity: rarity.Rare,
      baseTileScale: 1.5,
      isOneTimePurchase: false,
      nudgeY: -0.6
    },
    MarbleBlobling: {
      tileRef: tileRefsDecor.MarbleBlobling,
      name: "Marble Blobling",
      coinPrice: 3e8,
      creditPrice: 499,
      rarity: rarity.Rare,
      baseTileScale: 1.5,
      isOneTimePurchase: false,
      nudgeY: -0.56
    },
    // Spéciaux
    MiniFairyCottage: {
      tileRef: tileRefsDecor.MiniFairyCottage,
      name: "Mini Fairy Cottage",
      coinPrice: 5e8,
      creditPrice: 549,
      rarity: rarity.Rare,
      baseTileScale: 1.1,
      isOneTimePurchase: false,
      nudgeY: -0.37
    },
    Cauldron: {
      tileRef: tileRefsDecor.Cauldron,
      name: "Cauldron",
      coinPrice: 666e6,
      creditPrice: 666,
      rarity: rarity.Legendary,
      baseTileScale: 1.5,
      isOneTimePurchase: false,
      nudgeY: -0.25,
      expiryDate: /* @__PURE__ */ new Date("2025-11-07T01:00:00.000Z")
    },
    StrawScarecrow: {
      tileRef: tileRefsDecor.StrawScarecrow,
      name: "Straw Scarecrow",
      coinPrice: 1e9,
      creditPrice: 599,
      rarity: rarity.Legendary,
      baseTileScale: 1.8,
      isOneTimePurchase: false,
      nudgeY: -0.65
    },
    MiniFairyForge: {
      tileRef: tileRefsDecor.MiniFairyForge,
      name: "Mini Fairy Forge",
      coinPrice: 5e9,
      creditPrice: 979,
      rarity: rarity.Legendary,
      baseTileScale: 1,
      isOneTimePurchase: false,
      nudgeY: -0.3
    },
    MiniFairyKeep: {
      tileRef: tileRefsDecor.MiniFairyKeep,
      name: "Mini Fairy Keep",
      coinPrice: 25e9,
      creditPrice: 1249,
      rarity: rarity.Mythic,
      baseTileScale: 1.05,
      isOneTimePurchase: false,
      nudgeY: -0.33
    },
    // Saisonniers (Halloween)
    HayBale: {
      tileRef: tileRefsDecor.HayBale,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.HayBaleSideways, flipH: true },
        180: { tileRef: tileRefsDecor.HayBale, flipH: true },
        270: { tileRef: tileRefsDecor.HayBaleSideways }
      },
      name: "Hay Bale",
      coinPrice: 7e3,
      creditPrice: 12,
      rarity: rarity.Common,
      baseTileScale: 1.8,
      isOneTimePurchase: false,
      nudgeY: -0.42,
      expiryDate: /* @__PURE__ */ new Date("2025-11-07T01:00:00.000Z")
    },
    SmallGravestone: {
      tileRef: tileRefsDecor.SmallGravestone,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.SmallGravestoneSideways, flipH: true, baseTileScale: 1.12, nudgeY: -0.32 },
        180: { tileRef: tileRefsDecor.SmallGravestone, flipH: true },
        270: { tileRef: tileRefsDecor.SmallGravestoneSideways, baseTileScale: 1.12, nudgeY: -0.32 }
      },
      name: "Small Gravestone",
      coinPrice: 8e3,
      creditPrice: 12,
      rarity: rarity.Common,
      baseTileScale: 1,
      isOneTimePurchase: false,
      nudgeY: -0.38,
      expiryDate: /* @__PURE__ */ new Date("2025-11-07T01:00:00.000Z")
    },
    MediumGravestone: {
      tileRef: tileRefsDecor.MediumGravestone,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.MediumGravestoneSideways, flipH: true, baseTileScale: 1.32, nudgeY: -0.33 },
        180: { tileRef: tileRefsDecor.MediumGravestone, flipH: true },
        270: { tileRef: tileRefsDecor.MediumGravestoneSideways, baseTileScale: 1.32, nudgeY: -0.33 }
      },
      name: "Medium Gravestone",
      coinPrice: 5e5,
      creditPrice: 72,
      rarity: rarity.Uncommon,
      baseTileScale: 1.2,
      isOneTimePurchase: false,
      nudgeY: -0.45,
      expiryDate: /* @__PURE__ */ new Date("2025-11-07T01:00:00.000Z")
    },
    LargeGravestone: {
      tileRef: tileRefsDecor.LargeGravestone,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.LargeGravestoneSideways, flipH: true, baseTileScale: 1.5, nudgeY: -0.39 },
        180: { tileRef: tileRefsDecor.LargeGravestone, flipH: true },
        270: { tileRef: tileRefsDecor.LargeGravestoneSideways, baseTileScale: 1.5, nudgeY: -0.39 }
      },
      name: "Large Gravestone",
      coinPrice: 5e7,
      creditPrice: 299,
      rarity: rarity.Rare,
      baseTileScale: 1.4,
      isOneTimePurchase: false,
      nudgeY: -0.51,
      expiryDate: /* @__PURE__ */ new Date("2025-11-07T01:00:00.000Z")
    }
  };
  var weatherCatalog = {
    Rain: {
      atomValue: "Rain",
      description: "Gives the Wet mutation to mature garden crops",
      type: "weather",
      cycle: { kind: "weather", startWindowMin: 20, startWindowMax: 35, durationMinutes: 5 },
      weightInCycle: 0.75,
      // 75% des events météo
      appliesRandomCropPercent: 30,
      // ~30% des cultures applicables
      conditions: { requiresMature: true, requiresNoExistingModifier: true },
      mutations: [
        { name: "Wet", multiplier: 2 },
        { name: "Frozen", multiplier: 10, conditional: "applies if crop already has Chilled" }
      ],
      stacking: {
        compatible: ["Golden", "Rainbow", "Giant"],
        incompatible: ["Wet", "Chilled", "Frozen"]
      },
      screenEffect: "Rain on screen",
      notes: ["Primary vs Snow (75%)", "Affecte une culture applicable au hasard"]
    },
    Frost: {
      atomValue: "Frost",
      description: "Gives the Frozen mutation to mature garden crops",
      type: "weather",
      displayName: "Snow",
      cycle: { kind: "weather", startWindowMin: 20, startWindowMax: 35, durationMinutes: 5 },
      weightInCycle: 0.25,
      // 25% des events météo
      appliesRandomCropPercent: 30,
      conditions: { requiresMature: true, requiresNoExistingModifier: true },
      mutations: [
        { name: "Chilled", multiplier: 2 },
        { name: "Frozen", multiplier: 10, conditional: "applies if crop already has Wet" }
      ],
      stacking: {
        compatible: ["Golden", "Rainbow", "Giant"],
        incompatible: ["Wet", "Chilled", "Frozen"]
      },
      screenEffect: "Snow on screen",
      notes: ["Secondary vs Rain (25%)", "Frozen recommand\xE9 pour champignon/cactus/bambou"]
    },
    Sunny: {
      atomValue: null,
      description: "No special effects",
      type: "base",
      cycle: { kind: "base" },
      appliesRandomCropPercent: 0,
      conditions: { requiresMature: false, requiresNoExistingModifier: false },
      mutations: [],
      stacking: {
        compatible: ["Golden", "Rainbow", "Giant"],
        incompatible: []
      },
      screenEffect: "Blue skies",
      notes: ["\xC9tat par d\xE9faut, aucun effet"]
    },
    AmberMoon: {
      atomValue: "Amber Moon",
      description: "Gives the Amberglow mutation to mature garden crops",
      type: "lunar",
      displayName: "Harvest Moon",
      cycle: { kind: "lunar", periodMinutes: 240, durationMinutes: 10 },
      weightInCycle: 0.33,
      // 33% des events lunaires
      appliesRandomCropPercent: 30,
      conditions: { requiresMature: true, requiresNoExistingModifier: true },
      mutations: [
        { name: "Amberglow", multiplier: 5 }
      ],
      stacking: { compatible: ["Gold", "Rainbow"], incompatible: ["Dawnlit", "Amberlit"] },
      screenEffect: "Nightfall glow (orange)",
      notes: ["1 fois / 4h", "Ne se cumule pas avec Dawnlit"]
    },
    Dawn: {
      atomValue: "Dawn",
      description: "Gives the Dawnlit mutation to mature garden crops",
      type: "lunar",
      cycle: { kind: "lunar", periodMinutes: 240, durationMinutes: 10 },
      weightInCycle: 0.67,
      // 67% des events lunaires
      appliesRandomCropPercent: 30,
      conditions: { requiresMature: true, requiresNoExistingModifier: true },
      mutations: [
        { name: "Dawnlit", multiplier: 2 }
      ],
      stacking: { compatible: ["Gold", "Rainbow"], incompatible: ["Amberlit", "Dawnlit"] },
      screenEffect: "Sunrise glow (purple)",
      notes: ["1 fois / 4h", "Ne se cumule pas avec Amberglow"]
    }
  };
  var coin = {
    img64: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAAIGNIUk0AAHomAACAhAAA+gAAAIDoAAB1MAAA6mAAADqYAAAXcJy6UTwAAAAGYktHRAD/AP8A/6C9p5MAAAAHdElNRQfpCR4CFRRuokQwAAAr0ElEQVR42u29eZRlV3Xm+dvn3HvfHENGRE5KSSkJISGExCAJlQFDmRmDmAzGVcY2dIMBYSiXMXZjTA1tL1tgMxZVBparbJahbKAAA2JqxCAJAZKQUGpINKZSyiEyY3zzu8M5u/8490WE2pRRpjIlcOdeK9bKjOHFu/s7Z4/f3gEn5ISckBNyQk7ICTkhJ+SEnJATckJOyAk5ISfkfyPySL+Bo5HXv/7l3H3Pfl78vF/iKRddyGPOOYeoWkF0hBePxFWWl7rccO2NfOfKa7jsvR/lwgvP47rrdj3Sb/1fhrz7fe/i37z6Em697Tsc3P9DDh28AdUFVJU/+N2/sCuHlpLhMK8Mu8uV/mChMvSDys037Y4BUXV0+zdy3/3f4sD+6/nIh/4cVeXfvuz5j/Rj/UT5mbwhl/3n13Ldrd/kta/8Pc7YeTZnnr0DqZ/Nj3ZdNd2q2s3VevWxszOt7Z3F+Vnj3emTE5NbTWwjKFTxaJRIVtDv9YZ76s3mvYV3C/Pzh3Y3qlv3/cE7Ll/85N9cXLTnlauvuoHDyx3mZqd40av+/SP92MDPGCDvf9/bSLOMFz3/+TzmjNP50Ef/Z/S8X/zFUydmaxfUpipPN9Y8oZrEp6DDmcgOK34wT9G+H1O0UT8E70BBo5hoZhYak6jEeK169a0VzarzWbf4UZFxlZfq96+9fvmO57+0Obxn1yG+9oUb2bJtkpf/n+96RHXwMwHI/J4r+dJXvs0zf+lCdp71PG784eUnnTQ79a/rVX1+HPELkc13SDWNJO7hWQaWMTrE9ZYZ3X831VEfozlePMYLXgxs24LZth0vCcZXgAgpHOnhDqQNNfHJi7nZdP3IVj5/eNF/7TGPn9q7fE+fd7/7f/Hc55/HL73k7f//A+SvP/zHDAYZL37xszj5zGdx561fOmtmeuIV1Ur1lRXJHyP5fOTSO8hGd2DrGZW5OdREiMlAPVLkjPbtx66uEnmHN4rxgBryiSbxztMgqiMIKinic4pDh9BDSwgViso0mpzi1W77cS5znx4Us5/YdtYP79xz41ZOe8Jv8/tvfC5/8Vdf/5cPyAff+05+49d/hR/ffhdPfurL+fFNXzx98+zMbzVr0atjWd3pR/dSdG7BD/ciro3RFK3WSE45HanVQTwqiqgnX1qiOLifiivwKKIgClkcE+84FTs1g2LxCCoe0+tQ3LuHOBuFz2FRU0OTk3DJ6Xeksum/zHebnzx7tr10xU1tpuo5Fzz7Tx423diHG4wD917D5OQUJ22Z4sDhzqa6WXrd3OzE+xrVwctltHsqX7wKXbkak95D5PtE3hGpQT1ovYJpVAGDigEMBoPvdLFFgaggIiCCqoCNMc0WWAE83gjGGHQwQEYjDB6MYrzD5Avg7p0R7T6nFfkL2/3o3nOf8Ud7i8PP4rK3v4Bd993H7bcv/csB5A2veglf++YnyLOCsx/3LA7cv/sZp5w898GJqrzR5rvn3NLX8MvXYNN9GBlg8RgsXhSkADyFjYiaE2AtECHE4WOYIsMMowZBEBWsGrwKMjkBcYSoARQjoN5R9HpY9SgSwBWDkGGLtomLxdMj235Be/5ZdIfbbnZuf/a63/tXPOMxp/G3n7nhuOopejjA+PZX/56nP/dXmd9zDYcWVlqV6vWv27q58fbYHdhSrNxI1rmBpDhE4hVUcAogoGAkKNMCvjfErw7wLibtZ2TdlLwzRJdXkE4XfAQWbOSpJAbT8Gi8THTSLFKJAo6imHqNPKnih4pRD7jy91lUADoY19vS0NGf2Vp27p5V3jHxw70HDjb+LfPX7mTrRe88bro67j5kee+P+NJnv8XLXv109ty5f+fO07b9SaXqX2VGt1m38E3M6G5QjxGPqBLMkQ+OgAhxFt/zpCuOfkfpDwyml5OPBqjLsfjyA0TAGUUFrAoeg6/XkU0TVE/aRP3UOarbGkRVT3HwXlhaxAYEEBQAL4ITwahDiCi0xSCf+kZ3OP22fHTnTTcvvYBTJ67iCS/9x58/QD76gXcyN7ONZ73gYlZWhhdNN2sfaMTDi133u7iVq4myZawWKBFeBDUFogWGBM2EUSejO58xmi+g5xHnkMgjFSWJPUlUYK1DbPAFiENFUQS8QdRQOHAF5EVEahvI9CYmzthMY7PFZ4tYV2A0uHfRAKYXg6hHsIiPQQ09P3XjwX719a24ff0737uL5zw54VV/tOfnB5D/+oF3ko4y/t3bL6M7f9MzkkT/W2wOnV0sXwGr1xG5UXkLXFAgwUmTWQYLjv59I7LFEUVeEBlLpeZI6gNsZYhGikGDU6ZUIoLo2CVqeeI9wXMoqAUXURQRI2fwSZXqzCSN7U2iGqg42HBLRT3eaHn3ALX0sqkf7Tucv2br1pkfzV38SX73khrv/+LomOrtuDj1A3u+x/z8Eq+79I/Ze8e3Xzg9HX8k0v2Pyhe+gmlfS+SDzXamCOErBusiskVlefeQ1Ts7+LYnMY7mxID6dJ+4NcRWMowpiNRhANSEkFYFRfDiAY8oqBicmHDaseH7bQFxRpx4Ii0ouj1Gq32MWOJaBWwAV8bgShFuLRaDI7J+a2Lt2bvu7HyndvDLq7/yrk+w7/KPceMBf8x0d8xvyPXfvZw779rHS178ZAbD/F83a/o3ke49JTv0DUznVmLN8RLjRRHJEI1gYGnvGdG+L0WHGdUoJ5nIsI2UyI4QcYhG5YfiUXIjuDhG4hiTRMRJeE0zHBF5JVeHcx4tPHiP8R7FYFTCrREfHHiWMDJKNNOkddIcWosQr1gffJngEQ05jOIppMFqr/qFu64r3nTqjsb+VsUy+fLP/WwC8s7f/23+5D0foXPoB3R6+UUz0/W/Tdh3dnb4cmz3NmJNUaAwQbHWK+mKsHR7m/SQwwhUmhmN1ggTD1FxiAogeAEwEFuo1zBb54i3b8U2W1CpYeIYshF67z7MaICaHHWgmafIMnyek2cO1+4RpTkGRU0wbR6L94JpNameshVTjzE+nHoVDe5JFRXFG493LZb3T3z2+u/Nv6Fel4VsVPC8y67/2QNkYf/3KFJlablz+s4dm/++Hh2+MFu8HOneRKIjVKs441BJsUXM4IBn8ccDXGdEtZJRn8qJajmIw/pwIr0RfGSQeo1kokncqEO1ip+ZId5xMhonIWJVj/EF+f37kaUljLj1qE0NWqki27aQ9YeM9u6H/Qcw/S6G0mdgQjLZqFM5dQumlgCKlxAvGAXw+NIMar/C/bv1b793XfutExNROy2EV37o2oesw2PmQ+687ZuoKsur3Ykzdm55Xy0aPDdf/jKmey2xL0AUZwTEY/OI3n0Zi7f1kL7SbGS0pofE1RQxOUiBE8VFlmiiSW3LHNW5TUStOiQxIlCoYJqTSJygCEYVNcGBF90u1juEEMYKinpFJyZJtm2nctJ24rkZClXy/gDjHK68MTbNcWlGXK8hsQ1HVkL8IYQqgMERxSMiy/lulEzffSC+sh677FfOn+MzN8w/8oD894+8myi2fPQfrjS//PTzfr9Vc5cW3W+La3+H2BUIcQDDZJg8on33iNUf94lSpTHVpTaVIUkWnCiKNwbfrFPdupna5hlso4pGBm8EUER8SB6TJJRSBChvgzEG3+tisxwRRUUQ8agUeCJsYyqUVFotku1bMa06WacHoxQjIXpzeU6e5yT1GiaKUNZwAZEQNJgC27Bih+6Jtp8Vb/jAwpUXn5PoS5+wjX+86dAjC8jnv/h5Tt1e48JzT3vOpsnoPWZ4a71Y+hqx64ZISELiZV1E996UlR/3iHKlMTWiMtlDI1eWMDwuNsSzc9S3bSFu1dHI4oXwGmUSNzYhDo+daCI2ZPOCRSxoPoJ+HxlHTIRipPOCaTaQShJKJWKJpieJWy3c8ipmGEJxb4Qiy/GFI6nVMNYEzAGV0qdh8FZoRCJ+OT//WedP3Pmyxzd3v++K+9m1v/fIAfK5v/8g9VrEcnu0dWaq9uHYHzgrP/xl4vQgkQ9mQI0n8obefsfS7h5RCo2pEfFUHyOCojhxSFKltnUb8dw0xDacxPL3hFB0rOCgIK8OaTaQSg0hBoLZEhTX7YIW4fu9IGJQr5DE2EYNlfDKaiJMPUbU4bp9XJZjFCIVijRDBZJGPZQBkJB4GkU0xqgSJRF+qNW0456w64C76sLTpuZ/82mn87ffve+o9GkeChivveQSilw45YyLadX0txIZPsWtXIukd5VZsysz4ITREiz9uI8ZQW2qQzLVxuAxqjg8vlmldso2kplJxIS3FW7W+CPU1UPCpzijiHNopwveoRpyEFSQSgtfbwQYNZhAEKwWuG4bzV3ISUUR7yGKMDObsNtPwsdNIm8xCtY7sqVlsnYv5DlGEUKwYDS8Lx/lTJyUMFlLz5ypuv+8p51NLrTb/PmLtz38gLzmLS/hqU87l3tv//r5rUb0RhneStG+Ees9qKWwBi8W34elH7fxvYxaY0R1wqFGcMaTWY9p1Zncvo2oVceVd8L8MwFgabmwHly/j+bBX1Bae4kibLNVluj/Pw+bpvjBsLx9Y5AtptkimqhTn5smJUI11F2Nc2QLi2iaw9rhCOV8RfHiiCci6pti6pF7wemT5v945e+9iAMrw4cfkHQofOYzt9iZyYk3VmT5FL/8PSK/gBEQDB4BZ+ncPSRbcNSSnMbEALEZiuDE45oVGtu3YOtV/PiJ1wzV/x4Mo2BQZJTh+wOUMtGTkC9EjSY+rqCUURYg3mALj+92QAu8hMwcjTC1BlKLSDY18M0JchehWIwq0huSL6+GW6XlURFAQulGIkdza42GyeyUHb3lE3/5+fOedu7JfPhXzz5inR61D/ncp97HBU98DGedNXfBVKvyp9q7ua6rP0DIoKwziViy+YLV3UMMSmvTAFsdhWhKFFOt0jhpG7bZWHPcyD+fHAWoQpgrKKrgjcFONEHKxxEQY/DDFB0Ny1xDygQvBAOm1YQ4KfGPQhPLjfDDAZGpMVjqYo1iRYm8J3OOqNnExBEipeEsTaggWBMxms+xuZvCRLz768tfO3nS+CeebLnmnsGD1utR3xBVZcvOZ0ijZv+N8UuzxcouREeEwoQNZYeB0L1riKQZtYkUU8vwodEKsaW6eTNRo4GqrgFh9J//veUlAMBLiHfoDWA0WgNSRcFaTGsCby1aNmtVyoQiG+L7fUKReFwlBmlO4pIq8USCaTXIUwPehpA9zShWe2uRXjB1Uv5fsQ3BbqoSqTBjePmlT51+4nnb65yzKTsivR4VIF/5woc57/zHs/uWb5xZrdZfooN7sOk9iOQYD6IelYTeoZzhUkZSLag2+kjZ5/DGEm2aI9rULE2QIB5M+bAq/5zRYu17XOlZbZbhugPwsgaKF4NtNKAaMm7YELGVHUPyEAR44xD1mKSBqTXQKKM+O0WRR6hacitYD361hy+Ktd8vKhi1wadEnsoMYBxNI5unav517/razXZ//8h6gEcFSJYOOOOsC5idajw3YnSq79wKdFEpCKVviw6F3n0DxCvRZIbEKUZ98CvNOpW5aZwtHeuawkqV6U+p6ZRXRMYtWzzSWYUiBxTjS7JDkmAarUALCj8RSiEo2u+jWYaKQTQQJjAGmZzEGaE6EeErVfI8RjREWEWW4gY9dPwWNOQlHvDiiSfBRmDEMB3nL3zzBdOPO2NCef2TjjMgp57+aHbd9INaox5dQnafMNobohyxZahqGS4OyZZHJBVPVM+D08WjcURtbhqJTSAlBD09AIEHV2CTtRuFKDIaoKMB40gLFVQE22rhbRzCYV37KjbPKXrdAL6atTdhG3Wo1DGxEE81GaWGyJeKV4fv9kB1w00MH6gS1yOohHyoGcVbJ1rTL3/VRWdwxxEk7kcHyPZtTNbix1mTPbEY3Ir6dnjYMnHQ3NM+mKLqqTZHRBQYFQojRFNNomYDLSk7x0rUeVynhyrB5pf2Xao1qNcDUOLXIiPrPb7XgaIogwkbfiaKsY0W3ljqrQTnLHiD8SGQyIcpOL92cjaeJWsN0oxQHLFJmEzcL/3fX71x+qUXNI8fILfv/hZTm1vUYvvMyHc2af9ORFJELRI622S9gmzJE8dCXBthNFB0fBKRTE+iNpxI8yDvwoMRQaHbhTwtS/Xl56ME25oszVboIq5FXMMBftgvs4r1H5LWBEUcETcsXiNcEZX1AfBpjktzynAC0fVAxFpBaqX5QpmI/fmzE5subFZrXPa8ieMDyC233sH7/+vllXqjcoGm85hsqTQdpnxzMcMlhwwLKjWPRHkoBhqwzTpRrbqWS+gxvCEAJh2i/QG2LJUjHjUm+JGkslYuGT+2KTJ8ZxW8Xw/fBKRWR+sVpCKYuEKRJes3wXk0zdGy/77RnyCKrQESqgL1KGlMxebi33jyyXQGDy7aOmJALrrgbH752Y/fHCV6vg7vx7q0pGo6hAJfCKNFR6wFca3ASXCkag3VyRZEprTbsgbMMRPNKLptTBHCXG9CNm0qNbTZwCMYNbDmMxR6XchKZZXhN0mEbdUhNpg4Jits2TEsfVMWIq01kzWORUSJY4Mpk9TEJrSs+YVL/+GOSiVOjj0gr/+tl5MN2uTDztn47hYd7QvRiQZAMOBGjqxThL51nEOoWCGVCrZew5WFh+PCrhDF9wf40WiNfSIKGIttTeCNKRUoZU4CZCP8oIdRR4jzgnZts4lUYiQCX1jK/iGioTxf/royQRz//mC2DMEwWmMx1p413ayePLLVYw/IFVdcxc6TT+HUHaeeEWu/6fPDZTIXTpzD4no5OsqRqsNIHpwnEbZehzjecCuUY+rVAS+WOM3QbjucXh+tJXK23kKrNVTLUkrp3I1XXKcLrgggqS1D5gbabGCsg6I8VOKC3r1DBKwPeXoIIsrSvFEUGwqQRokqsu2k6er2k2dqxx6QP3zHWzDN8+n1Bqdq0UHdiEDDCcwRVCkGOXhHlIRStYiCEaJaNfBuN2BwjF1IWQbxuF4XimKtMoyAxBGm0cCVlWQpzaYAbjDAp+kaWS4gGG6VSrQhSAihuqp/oAMc/1PDPfIlPVWAuvGRjvo7tlTyYw/Is575VL7x7S/F1Wr8WM2XEJeWX/GggdExGhSIeGxcJnuqEFlsrbJmqsbX/FibrbGCdTQKhGr8mJEKxmBbE7goKksu65Vbk+ehf+JLsyXhtEutiZrqGqueMhFV1fBcbHydMtJz4zqXRYAq3rYSzp31bR7XOsaAXHf9DyHvxbVatIliFaN5mYOVVDcPfgTGgJScK/BIbJEkClCMMzOOucVae22T5/hOF7xfP7yA1BtorR4I3GVREMA6j3a7ZaZfOm80MCqdZexutGxQiTGoeeBxEg3P5gtZP3QIiQj1xMw8bVsf544xIHv33s89d91dK9JBTYt+SVQuM1UUHGghWKOIKRgXQ0wcIdaslUQ2RInHXBSw6qHXQ4v1HgaA2ISo2QpRH77kPXqs+pCTjEalckMw4DJP0S8wAqbs1Kh6xIwR2vgAAmpwWRhvWAfWMizyCbmsEk3O/nR1HxEg1biGxdaLPK8bl2744TGzQ/BFuCEYt3Y6JbKoHZOaj5/o2m1VSFPcYFD6FV0bO4jqDSSO1g6FBiIJ4hxFr/uAQ1L0RvhBRmxC/Wucp9g4Ck8i8k/egMu05AU7VARnDKlS275FokrlpxcajwgQg8NoYdSn1vuipG7KevcNAqXfeDB5qX6DMVKSmMvXGd+UY47Ohg68K9DOKupcGe6WiqrV0PpkiITEhVoUBusd2uvgc8/Y6KSHh/i8T5RkBD6KosZAHGF0XPGl/Hc4kG5oylKMR9Tiy76NFGW7+FgCIlraJJysRTDA2MhK2W8YH5xAcjbh8z9JfccYkHGzKFB/FN/vo1n+AKw0irATE2FWUSnbBeGGSzrC9wYhWnIwPLAK6jBxgRLY9CKCSZK19y/jFxdwuScfFqiasp0A3uWIel+oPKio8ogAKYoC770TEbfOMA8fHsAIJtbStNp187SBFLBBN8fNh2j5Dy1yXL+LKUlzWlYNTL0OlQpSRoahfxPMFu1V8AVFN2ewb5XYCBIHb2y8xcYGkyTr/HrRMkgAN3S4tMBgELUYdXifYY0fHlqWInsQXv2IAHHqsXG1H0VxXzf86DiiUANSCc4yhIhlvOL9+gmVB9eAOloZeyoRxXqH67TX+iRrtf4khmYDH7ryqBmzKoFBG9Kc0b4ubqlLJfGIDaZNVJBaBYnHvkDXngc15N0CMi0rxyFfz3xBFEV9/cCwGOU//amPqJ310pddQqW1c1CpHeq51Wjtzq5FTgbimpArqLdlpCVo4cB5JDJstKKix9Zsbcxx8IoF3KCPH44wEwkgwUQZi5lo4VbaiMsCMaJ8EC1S3FKf3u2L2Dyj0spDkRLwxhM3GsGPEG69L8EQZ0lXCqQwa0A5lzMqHKm3q1++9p/GAD9JjuiGdLp9vvzV7xft7mBJbaW0qxsOH0qlHuPH6JRqKooiJFI/rRP4UEVDJLpW0/WKLQpcv7f2dVEJfN96Fa1VymDEY8ueh4iS7TnM8K5FksiTVDIoWZUkim02Az9r3GUMWScuh9FKgfUh3/KiFOpIHX44crvzeBM/3HeMAfnmN7/La1/764Xzsou4ihKVii+zcoGoGSOxRYsyGBbweYEWRbj2PjjSjVHXMcNjLQPXUomCRdFeF81TfHnSxQtEFUxrgnFvJESLMVLE9O5ZxHT7VGseseNxN2BqAuq1EEZL6eQBEU+26nG98ZwjiDhGRUHqoyKpTexdco0H9QxHBMjTnnIW3UNXkiTNu72tezW2VISusy/qFqlHuCJMIamA5A43TNeIAevMjWMLyJjCZspet5Y2QoZDfD/0/MNMSDlV1ZwIVKByIMcbKBYLhvtH2KSgUvc4E4Z2vI2JzjgDaTZDxZcQLoeBHs9wIUdTE0jdZaI8ylKyXNpLqV060H1wXvOIAPnIx6+lvTpg4fDqbjFTK74cL1g3WIpJoDpVJSsSVAN1X7yn6A3CzTBjJ3h8oqyfKN7huj2sC2ZmnDOZagXqzbKSWyCpo39XG4Ye01KiJMyqqBd0ZhPJKTswzUlQwYgrY2aPH0QMFoch9wBiB16F4agH4u7sDPO7O+32sQfkox/9KMY0qda37lXZtE/jMY1nvYKqpqA2VyMjQdWUIa/iBgNI8xAmmhCjPVyAGBTt9WCYhpqTKY2sFcxkC2cDS7F334jevMdWCmqNESojRB3exlROPw3bbCHNCTSulJVdxahhuOgoOg4kzE5aFfLcMchzUu+vf/dX7+rNNB4cJ/GIO4ZfuvxbnHzmqxc8je8Rby2nX9fLIiqOymSEbVTICln7FTpMwy0Zf69uSCyPswiKyTJ8r896kB6+IvU6WqmTHoblu4c4IqqTKUncw5siPN/sDNWTd4RoqlZBm40Q0AA+i+nuHyJZWPMxLt8M0wEDhxuZxnV//Wun8YdfWj0+gMSRRVc/QFpEV0q0o1BixrUsU0YcUnG0NlfJsjDqHJy5Uqx2oXDrFBqjDw8kJZNduz3Uu7KCUBY+K1XIWqze2qcY5FQn+lRrgQ7rEdJKleScMzHNBnjFx4q0JlCpIBgGy0q6mIetK86iCKl19IYdMrUH2pm5tptb3vLU49DCBXjt7/wRBw52yYrou0Qzd2vZmtRyFEDV4MXRmKtiajVyFyqeAhS9AXmnt8bSeCCf8AH6e+gIbPiQsuDoRgNcOlpvIosh7zqWb1oiW1Aa1ZzG5ApYB76CqqWyYzvRqdtD08mETqNpNiCp4TOhfX8fRqY0weGV+3lKLx3ivHzvQLd2b7fv+eDVx4nkAHDw0DLbznjmfXk08XVNNpfkABP6H1KOBNSVxo4muY+wPilbqp7R4iqaFuWsnoRcWcsMUc0aifmo7k5ZNhdVhALBbfiSoi7FdbuIEyDGrzqWvnEngzsXiZOCxnSKJiM8DtQTVRMqs5MYK6jxqAHjYiSqYJoNeocLigMZVmPA422BeBj2enRVXQf7pQu3L2Wbph9cyHvUgDzp6a9hOP9ZUlf7jEvOWIUKxpfUGh3nH0p9dgI70aRwimhYn+EHfdJDi5AHWqkXWa+OEjYpGH90EbGUHY7gNWI8wVkX4fxSyRU6bdSNyBaHHPrqbvq7DhBFXWpzbUwywvgEoxafWKpbZ4Of6A2w42fzgLWobdHd00MLyCOPl+Avh5rT7nfJNL695+0VC3249JMPfgXHUY0jbJ7qsXX2VFaGj5qfqnfOs9n+xxrfRoxsoMQIYgxJtcqw10OcxxgNu01GKRInmHp9fahGQjgajElolR4pKuvNL1u+bqDAhUFNU4bgSrqsHLrybordS9SMozE7JG50sN5jfQVnDfHWKezsVCBFRHEwU5hQr3OGxR8dIrt5OexTMR6rwV8uDZdZ6nfpFrW/vvRXVz//2as3cc2eBz9zeFQ35NLf/UtqNctpMzelGk99zFd3dJ2RtT7zuNzqxWGbMfWT5shig/FK7EG9o7ewQL64isnHIzWhLerL3snR1biCUrTcoSJSYCTHUIAB72MG9zgOf/le3J3LVGopjbkhcTXHeov1MU4Uu7lFZW4KZ8NWIHpdfJHiLCARg70dutfdhxTBMiQl0S4tMla6q6Rq9q3m0d99+B9meNb500f8BEcl286+hKVexL7+6VeOkpO+kEdb1zNjxq5EUXFUpxvUt81SWEuBDbcnzxkemKe3/xA6cBiXrG3e8XK00dfYWZeO3IPxMaaIKFYci7t6LN7Ug46n0chpznYx9Q4qjkITBlGEzE1Q3RLorlLygTUd4kdDjBrckmPhqjtIlnPCqJgQ+VA+Wumt0s0cQ2c//farq7tvOez4wBduO6IneEgLzGan6mT5zVkv3fLeSXvK07RYPkUlH3c6Sx15MEJtdhIjMJpfJM5zrHd4yXGLq6y2U6qzc9RmJjGJx0tGoJod2XnRtfTfB7Pnq+R96B7o0r9vSNER4jijOtel2shD9dWHpTVpxVDdeTLJRAN8XnYCAyDioGj3sdEsy9fcjr+7jcXgpcAJxF4YpgOW+ytkGt+7VLQ+9hdPd35/R/jKXUem04c0Fv3Lz7kALSbYefJlB7udX7CRdp4p2jchuolKYDYUHmtVTBKRDsL2BAsY8dhcyVaGjFZT1EfYqIbEZo3FvMZ01AdSbkJhj3JGJISxqEVyQ7astO8dsHRnl/7+ISbz1Bue5qY+SaMNpkA1CTeyElN97Jk0zjs3rAUcDh7QUMMYJBN6t7fpXXsQyS3eKpF6IKIg59DqIZazXAda+8s3vWjxs5/8TsL7v71yxDp9yOW9A7d8HNTRGTUmtkRX/4+a2/2ySLshBAUoN/mMaZpGIV1dZXhwAZMWhBzFYxQKJwyyGLUtqpNNqtMVkkYFm4AkYd79ARTRsbMpwOXg+hmjlYLBUkG2UqBpTiyepO5JGg5bzVA7BCkwPjDbi6kpGuc9muiMUyCqwEobv/duoiIHMcGnaET/fsfCLR3MwJStJ1nb2Xiw3+Pw8v2sUP3WPb3Wq+q2ONzpFvzJFasPPyAA2YEv0lu5hYXl/rlz9T3/s8nd50ZOy4qrR/yGqjBgvCfv9ukfWkT6KeujnMGxaiakI0tWGFxksNUKUk0wlQQTWYyWddZc8alSDB3ZMMcPQQuPkYIkcSS1nKRaYBKHmrBIU8XjBFRiktnNJE96AmbrJlQM1gvkI7K9d2P73RCd+YjsgGdxV5uiH4qplXJCNbeGbtph78ICvVyWFlP51WYkV1Bt8Ft/d3Q7T47Jao2TpjPe/bGYS5695/BAW3cmZM+saDZRTlCUlNINPRABW0lIGjXE5bgsB2cCR1hyiFJs1RNXIDIeshztpriVEflSn2ypR7rYJ1/p4zojSDNir8TVgkoroz45ojoxwNaGaJLibI6Kx5ZLlk2tRrJ1lsqpW7E7diAmLvdjaVgXmGWhy6iG9IBn8ZYu9Mp6g67PivRdxsHleYZ5rsuu8Z43ffa0v3nUXI8v37zAvUd+OY7dDQG455r/yFU/+jG/8caXsvfbl79ma3X5Q7FdbHgpG0Ciaw2ptWUuClJA0WmTLi4E+qcatBykHDeazIYmvPcG9UnZMi5NmPGI8RgZhTDAx6EXQyh2hvl3iyQxyWSLZNMk1COKyBLtOA0zOR3WQIkLowSdIe7efaT39Fi5rYP2xhNZBqsWZ5RMPfNLB1jut+mY5v+az+uvq+BXVlZG/IdvHCUaHMP1TB/462/zoudsRZcGRI3n3WL8gdRTPDWWNJaSwPRAHmxwy2oFU6uQNBtIpYL34J1HfKinSlk9deIDoNZjTIGJHGIcxriwmU5yDDbMnKuUiwQUrMHUayQzm6hunSHa1MRXbDBHTvGxRSabgC1buBbJY/q7Fli+aQE/NGWaWvJ6jcPhmV89zEK/S0+aN8yntTdtqkf7t05GvOFTR78JCI5Dz27fd9/BameZ79w2jJ5z1vzvb50a/XGtOgxcfB+H0Wjc2gkes+dVJICQe4r+CNftUQwGuKKAPDS5xlHVWo6ipty9WNJwjMEZQSJBKpaoXiepNzCNGpLEZW1rTPGMUDW4WoXotJ2YpA5E5L2C1avvZnTt/ZA5nA1jDbacgcmBpfYiS6sLrEpjz6Kf/PVWlF7zm3/3HF746E9w+Z0PTX/HhXPwg8+8gqw/4AffX4ie/fTWG0/dXryrWS1mA0U/DfE9Zi2RHFef1t+ShPJ44fBphg5T/ChHsxx1DjcerlFFxIRhS2vROMFWK9hqgqnESBQWkHlYW9VnSvC8hL2mhTHYHduJpjYzvG/A4lV3kN+1jHVhOYj1ptwi53F4FlfbHOos0CfZt5xW3nD29ujyz9+sbJuO+b8+f+Ah6+64kUC++VfPZHGhyyv/+Fpu+PCzX7Hz1OT9k7Pt7UYyFIu34aRaJ2sktkDVVBRX5hTjZlb5or4EQXXtVihgTGAUrk1FbXxADX7EGV8O49iSHFfuWxRDUd1EZzli9bp9xIeHiAncTOMjYh8c3cA4DrcP02mv0qG+72AxcelbXz77hde+dw+TCbz/6u4x0dtxZeW877dPww0ifu/jX+Wbf/bqF55xevTBLVvdaZVGQWEUVUusRWnz7QaytAs7rsotJWwk1+lP3hS0XrZfF0Noe4+NnDfjGdwQJUkhDBc8q/f2SA8pJq2EZJUwluCJcEZI3YjDq4dZHPQZkdy9nCdvftOv7/zqb//5HYg6PvL9o9v887ADAvCel+1kuZ3ytrdexPdvWHza9un8o6eexNmTm6tINUNNXo4kl6PSKv+0176RhirrDdh/+jBjc7RenJTyE1rW1QwGyWPSFUdnX598f4FLATVlxTZwqsJfWnB08h7zK0v0hhkdJq7tSvOt2xuD73/h5pSKZPy37/8cLFLeKP/P7lVe8OQpfrRrxKO2Ve47tL92fbrsz3Gd/skWJY4bWFMpVzqNz2/Yv+7NWt9qnYIqY4oPa9uD1rYIPaC0sgEQU3Yts4j0sKNzZ5/27X3cYYvNKoAJ61/Hq8qN4PAcHvQ5uHKYflr4Hq1Pz49al05VRrt+cKBCwxR88OqjX+X3iAECcMUtHX7nknP40g2bedrZvf33Ha59xWWulS5m52SLw9hlijWWyErYmVjybNcVrOv+Qca7ssZ1LF37QChBFIyEeUAKKNqO4f05q3cM6N6TUSwKprAgShY5BF8u5bd4I2RpysLqIZY6y/RcvLjqGn96KK+/a6YRHXzN3z2OXZ9f5j995eBx0dVxN1kb5T0v+Ve87XOP5x/ffCt3HDaVJ+zIXzFb6f5BNeLceqTUJoR4LiLeFBM3E2wMxhblVtH1ARkJzOdydpyydWtQ1fB3wVIl73qyZUe6kpN1cnToUR8R/u4IgAfjyr9bFdjqhfcs91dY7C7Tc84PqXy7l9k/e8Nn2t/40Cu2sXUq4ePf3MuX7jl+OnpYARnLR37tPGwc8eInncb39hx41GxifnfaDF+ZaDprxGMiIa4oUUOgFWPrCVHFYGNFIh8iMEz4sx+FwaeefOTJh0o+zCkGOZoqkgnGRWVCF3Yy6lqdIHT0DTDSnPZoldXeKqtpQarRXSMXfeS+YeV/nNFMl+5ZrTBTVd78uYXjrptHBBCAP3/BHFdeu8C/f83F/NW1K/YNF80+ecLkb2xI8fyG5jOiWs5eFIhYDLaMuXwZIpd/1ghKRXvwWs7M25BZi5azhCEkNj5EV4jiREldRn8wYKXfoZcNSVXuHzr7qWXf+tjFO/zt373XUU+ESz91/P/U0SMOCMB/+uVH8aiTJ2gPPOdsa3LF/VHy1M3pkxpV+c2mFM+tUeyMyIi8X1tOoJTb38o9vWFoxq8tzh+bL9ZIa2EYJySFDucKhvmI1XTA6mhENy+K3MW7cxd/uuMrn33rzRfd9qEnXqt33HWIR+9o8Tuf7zysOnlEAdkon7r0KfRSx5mbLE/77GPl68+75Ywojl5YldELWjZ7YhWdsSaYHkGx43E0wjrxMKdRJn2E8oyX8q8kFEqeZfSzNu1sQDfXfOTi/ZmPrumrubyb8a1Xbl06+NWlLewbVWjE8M7PHd3e3X8xgAC84wVn86eXvYgPvvcqzm0Jj56r8OkfHWpsaZpzJmv2KVX6T6nFeoZI5fSKoR6TxRaPiGHMh/SuwLmMzOcMc8/ISTHKtMjzYj4Xs7ejXDc01euGQ66/5R53/3Of4PNDqwVLgxabJzxv++z+R1QHP1OAbJRXzMGnvvjv+O8f/DpTNcMvnLWdX/svX49+8eyZqa3TU6dFpDMu7509UbOn1WJJvHeoqqiqepTM4zv9fB7i26i3Dh/sFweV+v4//dSe4Ydfs4VRKiwsjZieqvKH//jQFugfS/mZBWSjvOWiiMFIufDMKQ71LTMTLTbVPJvjLpP0iHxOPVEadc9qFw63oRDI4ohRNMPhPGFfJyXKCtRYXnPx6fyHy3fx8WuPXcnjWMnPBSA/Td4MfAvYAiTAWcAB4NOP9Bs7ISfkhJyQE3JCTsgJOSEn5ISckJ8D+X8B7L1HlK7Vi1oAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjUtMDktMzBUMDI6MjE6MDgrMDA6MDAu0X64AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDI1LTA5LTMwVDAyOjIxOjA4KzAwOjAwX4zGBAAAACh0RVh0ZGF0ZTp0aW1lc3RhbXAAMjAyNS0wOS0zMFQwMjoyMToyMCswMDowMHlTrsEAAAAASUVORK5CYII="
  };

  // src/services/locker.ts
  var VISUAL_MUTATIONS = /* @__PURE__ */ new Set(["Gold", "Rainbow"]);
  var LOCKER_NO_WEATHER_TAG = "NoWeatherEffect";
  var normalizeSpeciesKey = (value) => value.toLowerCase().replace(/['’`]/g, "").replace(/\s+/g, "").replace(/-/g, "").replace(/(seed|plant|baby|fruit|crop)$/i, "");
  var MAX_SCALE_BY_SPECIES = (() => {
    const map2 = /* @__PURE__ */ new Map();
    const register = (key2, value) => {
      if (typeof key2 !== "string") return;
      const normalized = normalizeSpeciesKey(key2.trim());
      if (!normalized || map2.has(normalized)) return;
      map2.set(normalized, value);
    };
    for (const [species, entry] of Object.entries(plantCatalog)) {
      const maxScale = Number(entry?.crop?.maxScale);
      if (!Number.isFinite(maxScale) || maxScale <= 0) continue;
      register(species, maxScale);
      register(entry?.seed?.name, maxScale);
      register(entry?.plant?.name, maxScale);
      register(entry?.crop?.name, maxScale);
    }
    return map2;
  })();
  var emptySlotInfo = () => ({
    isPlant: false,
    originalIndex: null,
    orderedIndex: null,
    totalSlots: 0,
    availableSlotCount: 0,
    slot: null,
    seedKey: null,
    sizePercent: null,
    mutations: []
  });
  var now = () => typeof performance !== "undefined" && typeof performance.now === "function" ? performance.now() : Date.now();
  var shallowEqualStrings = (a, b) => {
    if (a === b) return true;
    if (!a || !b) return (a?.length ?? 0) === (b?.length ?? 0);
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  };
  var slotInfosEqual = (a, b) => a.isPlant === b.isPlant && a.originalIndex === b.originalIndex && a.orderedIndex === b.orderedIndex && a.totalSlots === b.totalSlots && a.availableSlotCount === b.availableSlotCount && a.slot === b.slot && a.seedKey === b.seedKey && a.sizePercent === b.sizePercent && shallowEqualStrings(a.mutations, b.mutations);
  var isPlantObject = (o) => !!o && o.objectType === "plant";
  var slotSignature = (slot) => {
    if (!slot) return "\u2205";
    const species = slot.species ?? "";
    const start = Number.isFinite(slot.startTime) ? slot.startTime : 0;
    const end = Number.isFinite(slot.endTime) ? slot.endTime : 0;
    const target = Number.isFinite(slot.targetScale) ? slot.targetScale : 0;
    const muts = Array.isArray(slot.mutations) ? slot.mutations.join(",") : "";
    return `${species}|${start}|${end}|${target}|${muts}`;
  };
  var gardenObjectSignature = (obj) => {
    if (!obj) return "\u2205";
    if (!isPlantObject(obj)) {
      if (!obj || typeof obj !== "object") return String(obj);
      const entries = Object.keys(obj).sort().map((key2) => `${key2}:${JSON.stringify(obj[key2])}`);
      return `other|${entries.join(";")}`;
    }
    const base = `${obj.objectType}|${obj.species ?? ""}|${obj.plantedAt ?? 0}|${obj.maturedAt ?? 0}`;
    const slots = Array.isArray(obj.slots) ? obj.slots.map((slot) => slotSignature(slot)).join("||") : "";
    return `${base}|slots:${slots}`;
  };
  var arraySignature = (arr) => Array.isArray(arr) ? arr.join(",") : "\u2205";
  var defaultOrder = (n) => Array.from({ length: n }, (_, i) => i);
  var clamp = (n, min, max) => Math.max(min, Math.min(max, n));
  var extractSeedKey = (obj) => {
    if (!obj || typeof obj !== "object") return null;
    if (typeof obj.seedKey === "string") {
      return obj.seedKey;
    }
    if (typeof obj.species === "string" && obj.species) {
      return obj.species;
    }
    const asAny = obj;
    const fallbacks = ["seedSpecies", "plantSpecies", "cropSpecies", "speciesId"];
    for (const key2 of fallbacks) {
      const value = asAny[key2];
      if (typeof value === "string" && value) return value;
    }
    return null;
  };
  var clampPercent = (value, min, max) => Math.max(min, Math.min(max, value));
  var lookupMaxScale = (species) => {
    if (typeof species !== "string") return null;
    const normalized = normalizeSpeciesKey(species.trim());
    if (!normalized) return null;
    const found = MAX_SCALE_BY_SPECIES.get(normalized);
    if (typeof found === "number" && Number.isFinite(found) && found > 0) {
      return found;
    }
    return null;
  };
  var getMaxScaleForSlot = (slot) => {
    if (!slot || typeof slot !== "object") return null;
    const candidates = /* @__PURE__ */ new Set();
    const fromSeedKey = extractSeedKey(slot);
    if (fromSeedKey) candidates.add(fromSeedKey);
    const fields = [
      "species",
      "seedSpecies",
      "plantSpecies",
      "cropSpecies",
      "baseSpecies",
      "seedKey"
    ];
    for (const field of fields) {
      const value = slot[field];
      if (typeof value === "string" && value) {
        candidates.add(value);
      }
    }
    for (const cand of candidates) {
      const max = lookupMaxScale(cand);
      if (typeof max === "number" && Number.isFinite(max) && max > 0) {
        return max;
      }
    }
    return null;
  };
  var extractSizePercent = (slot) => {
    if (!slot || typeof slot !== "object") return 100;
    const direct = Number(slot.sizePercent ?? slot.sizePct ?? slot.size ?? slot.percent ?? slot.progressPercent);
    if (Number.isFinite(direct)) {
      return clampPercent(Math.round(direct), 0, 100);
    }
    const scale = Number(slot.targetScale ?? slot.scale);
    if (Number.isFinite(scale)) {
      const maxScale = getMaxScaleForSlot(slot);
      if (typeof maxScale === "number" && Number.isFinite(maxScale) && maxScale > 1) {
        const clamped = Math.max(1, Math.min(maxScale, scale));
        const pct2 = 50 + (clamped - 1) / (maxScale - 1) * 50;
        return clampPercent(Math.round(pct2), 50, 100);
      }
      if (scale > 1 && scale <= 2) {
        const pct2 = 50 + (scale - 1) / 1 * 50;
        return clampPercent(Math.round(pct2), 50, 100);
      }
      const pct = Math.round(scale * 100);
      return clampPercent(pct, 0, 100);
    }
    return 100;
  };
  function startLockerSlotWatcherViaGardenObject() {
    if (typeof window === "undefined") {
      return {
        get: () => emptySlotInfo(),
        onChange: () => () => {
        },
        stop() {
        },
        recompute() {
        }
      };
    }
    let cur = null;
    let sortedIdx = null;
    let sortedIdxSig = arraySignature(sortedIdx);
    let selectedIdx = null;
    let lastInfo = emptySlotInfo();
    let curSig = gardenObjectSignature(cur);
    const listeners4 = /* @__PURE__ */ new Set();
    const notify = () => {
      for (const fn of listeners4) {
        try {
          fn(lastInfo);
        } catch {
        }
      }
    };
    let scheduled = false;
    const scheduleRecomputeAndNotify = () => {
      recomputeAndNotify();
      if (scheduled) return;
      scheduled = true;
      const run = () => {
        scheduled = false;
        recomputeAndNotify();
      };
      if (typeof globalThis !== "undefined" && typeof globalThis.queueMicrotask === "function") {
        globalThis.queueMicrotask(run);
      } else if (typeof Promise !== "undefined") {
        Promise.resolve().then(run);
      } else if (typeof window !== "undefined" && typeof window.setTimeout === "function") {
        window.setTimeout(run, 0);
      } else {
        run();
      }
    };
    function getOrder(slotCount) {
      if (!slotCount) return [];
      if (Array.isArray(sortedIdx) && sortedIdx.length === slotCount) {
        return sortedIdx.slice();
      }
      return defaultOrder(slotCount);
    }
    function selectedOrderedPosition(order, slotCount) {
      if (!slotCount || !order.length) return 0;
      const raw = Number.isFinite(selectedIdx) ? selectedIdx : 0;
      const clampedRaw = clamp(raw, 0, slotCount - 1);
      const pos = order.indexOf(clampedRaw);
      return pos >= 0 ? pos : 0;
    }
    function sanitizeMutations2(raw) {
      if (!Array.isArray(raw)) return [];
      const out = [];
      for (let i = 0; i < raw.length; i++) {
        const value = raw[i];
        if (typeof value === "string") {
          if (value) out.push(value);
        } else if (value != null) {
          const str = String(value);
          if (str) out.push(str);
        }
      }
      return out;
    }
    function computeSlotInfo() {
      const seedKey = extractSeedKey(cur);
      if (!isPlantObject(cur)) {
        return {
          isPlant: false,
          originalIndex: null,
          orderedIndex: null,
          totalSlots: 0,
          availableSlotCount: 0,
          slot: null,
          seedKey,
          sizePercent: null,
          mutations: []
        };
      }
      const slots = Array.isArray(cur.slots) ? cur.slots : [];
      const slotCount = slots.length;
      if (!slotCount) {
        return {
          isPlant: true,
          originalIndex: null,
          orderedIndex: null,
          totalSlots: 0,
          availableSlotCount: 0,
          slot: null,
          seedKey,
          sizePercent: null,
          mutations: []
        };
      }
      const order = getOrder(slotCount);
      const availableIndices = [];
      for (const idx of order) {
        if (Number.isInteger(idx) && idx >= 0 && idx < slotCount) {
          if (slots[idx] != null) availableIndices.push(idx);
        }
      }
      const availableCount = availableIndices.length;
      if (!availableCount) {
        return {
          isPlant: true,
          originalIndex: null,
          orderedIndex: null,
          totalSlots: slotCount,
          availableSlotCount: 0,
          slot: null,
          seedKey,
          sizePercent: null,
          mutations: []
        };
      }
      const pos = selectedOrderedPosition(order, slotCount);
      const clampedPos = clamp(pos, 0, availableCount - 1);
      const originalIndex = availableIndices[clampedPos] ?? null;
      const slot = typeof originalIndex === "number" ? slots[originalIndex] ?? null : null;
      const sizePercent = slot ? extractSizePercent(slot) : null;
      const mutations = slot ? sanitizeMutations2(slot.mutations) : [];
      return {
        isPlant: true,
        originalIndex: typeof originalIndex === "number" ? originalIndex : null,
        orderedIndex: clampedPos,
        totalSlots: slotCount,
        availableSlotCount: availableCount,
        slot: slot ?? null,
        seedKey,
        sizePercent,
        mutations
      };
    }
    function mutationsEqual(a, b) {
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) return false;
      }
      return true;
    }
    function infosEqual(a, b) {
      return a.isPlant === b.isPlant && a.originalIndex === b.originalIndex && a.orderedIndex === b.orderedIndex && a.totalSlots === b.totalSlots && a.availableSlotCount === b.availableSlotCount && a.slot === b.slot && a.seedKey === b.seedKey && a.sizePercent === b.sizePercent && mutationsEqual(a.mutations, b.mutations);
    }
    function recomputeAndNotify() {
      const next = computeSlotInfo();
      if (!infosEqual(next, lastInfo)) {
        lastInfo = next;
        notify();
      }
    }
    (async () => {
      try {
        selectedIdx = await myCurrentGrowSlotIndex.get();
      } catch {
      }
      try {
        const v = await myCurrentSortedGrowSlotIndices.get();
        sortedIdx = Array.isArray(v) ? v.slice() : null;
        sortedIdxSig = arraySignature(sortedIdx);
      } catch {
      }
      try {
        cur = await myCurrentGardenObject.get();
        curSig = gardenObjectSignature(cur);
      } catch {
      }
      const refreshSorted = (v) => {
        const next = Array.isArray(v) ? v.slice() : null;
        const sig = arraySignature(next);
        if (sig === sortedIdxSig) return false;
        sortedIdx = next;
        sortedIdxSig = sig;
        return true;
      };
      const refreshGarden = (v) => {
        const sig = gardenObjectSignature(v ?? null);
        if (sig === curSig) return false;
        cur = v;
        curSig = sig;
        return true;
      };
      let awaitIndexBeforeRecompute = false;
      let awaitIndexTimer = null;
      const clearAwaitIndexTimer = () => {
        if (awaitIndexTimer == null) return;
        if (typeof globalThis !== "undefined") {
          const clearer = globalThis.clearTimeout;
          if (typeof clearer === "function") {
            clearer.call(globalThis, awaitIndexTimer);
          }
        }
        awaitIndexTimer = null;
      };
      const deferUntilIndexChanges = () => {
        awaitIndexBeforeRecompute = true;
        if (awaitIndexTimer != null) return;
        const run = () => {
          awaitIndexTimer = null;
          if (!awaitIndexBeforeRecompute) return;
          awaitIndexBeforeRecompute = false;
          scheduleRecomputeAndNotify();
        };
        if (typeof globalThis !== "undefined") {
          const setter = globalThis.setTimeout;
          if (typeof setter === "function") {
            awaitIndexTimer = setter.call(globalThis, run, 0);
            return;
          }
        }
        run();
      };
      myCurrentSortedGrowSlotIndices.onChange((v) => {
        const changed = refreshSorted(v);
        if (!changed) return;
        deferUntilIndexChanges();
      });
      myCurrentGardenObject.onChange((v) => {
        const changed = refreshGarden(v);
        if (!changed) return;
        deferUntilIndexChanges();
      });
      myCurrentGrowSlotIndex.onChange((idx) => {
        selectedIdx = Number.isFinite(idx) ? idx : 0;
        void (async () => {
          try {
            refreshSorted(await myCurrentSortedGrowSlotIndices.get());
          } catch {
          }
          try {
            refreshGarden(await myCurrentGardenObject.get());
          } catch {
          }
          if (awaitIndexBeforeRecompute) {
            awaitIndexBeforeRecompute = false;
            clearAwaitIndexTimer();
          }
          scheduleRecomputeAndNotify();
        })();
      });
      recomputeAndNotify();
    })();
    return {
      get() {
        return lastInfo;
      },
      onChange(cb) {
        listeners4.add(cb);
        return () => listeners4.delete(cb);
      },
      stop() {
        listeners4.clear();
      },
      recompute() {
        recomputeAndNotify();
      }
    };
  }
  function defaultSettings() {
    return {
      minScalePct: 50,
      maxScalePct: 100,
      scaleLockMode: "RANGE",
      minInventory: 91,
      avoidNormal: false,
      includeNormal: true,
      visualMutations: [],
      weatherMode: "ANY",
      weatherSelected: [],
      weatherRecipes: []
    };
  }
  function defaultState() {
    return {
      enabled: false,
      settings: defaultSettings(),
      overrides: {}
    };
  }
  var LS_KEY = "garden.locker.state.v2";
  var clampNumber = (value, min, max) => Math.max(min, Math.min(max, value));
  function sanitizeSettings(raw) {
    const base = defaultSettings();
    const scaleMode = raw?.scaleLockMode === "MINIMUM" ? "MINIMUM" : raw?.scaleLockMode === "NONE" ? "NONE" : "RANGE";
    base.scaleLockMode = scaleMode;
    const minClampHigh = scaleMode === "MINIMUM" ? 100 : 99;
    const minScaleRaw = Number(raw?.minScalePct);
    let minScale = Number.isFinite(minScaleRaw) ? clampNumber(Math.round(minScaleRaw), 50, minClampHigh) : 50;
    const maxScaleRaw = Number(raw?.maxScalePct);
    let maxScale = Number.isFinite(maxScaleRaw) ? clampNumber(Math.round(maxScaleRaw), 50, 100) : 100;
    if (scaleMode === "RANGE" || scaleMode === "NONE") {
      maxScale = clampNumber(maxScale, 51, 100);
      if (maxScale <= minScale) {
        if (minScale >= 99) {
          minScale = 99;
          maxScale = 100;
        } else {
          maxScale = clampNumber(minScale + 1, 51, 100);
        }
      }
    }
    base.minScalePct = minScale;
    base.maxScalePct = maxScale;
    const minInv = Number(raw?.minInventory);
    base.minInventory = Number.isFinite(minInv) ? clampNumber(Math.round(minInv), 0, 999) : 91;
    if (typeof raw?.avoidNormal === "boolean") {
      base.avoidNormal = raw.avoidNormal;
    } else {
      base.avoidNormal = raw?.includeNormal === false;
    }
    base.includeNormal = !base.avoidNormal;
    base.visualMutations = Array.isArray(raw?.visualMutations) ? Array.from(new Set(raw.visualMutations.filter((m) => VISUAL_MUTATIONS.has(m)))) : [];
    const mode = raw?.weatherMode;
    base.weatherMode = mode === "ALL" || mode === "RECIPES" ? mode : "ANY";
    base.weatherSelected = Array.isArray(raw?.weatherSelected) ? Array.from(new Set(raw.weatherSelected.map((m) => String(m || "")).filter(Boolean))) : [];
    base.weatherRecipes = Array.isArray(raw?.weatherRecipes) ? raw.weatherRecipes.map(
      (recipe) => Array.isArray(recipe) ? Array.from(new Set(recipe.map((m) => String(m || "")).filter(Boolean))) : []
    ).filter((arr) => arr.length > 0) : [];
    return base;
  }
  function sanitizeState(raw) {
    const state2 = defaultState();
    if (!raw || typeof raw !== "object") return state2;
    state2.enabled = raw.enabled === true;
    state2.settings = sanitizeSettings(raw.settings);
    state2.overrides = {};
    if (raw.overrides && typeof raw.overrides === "object") {
      for (const [key2, value] of Object.entries(raw.overrides)) {
        if (!key2) continue;
        state2.overrides[key2] = {
          enabled: value?.enabled === true,
          settings: sanitizeSettings(value?.settings)
        };
      }
    }
    return state2;
  }
  function cloneSettings(settings) {
    return {
      minScalePct: settings.minScalePct,
      maxScalePct: settings.maxScalePct,
      scaleLockMode: settings.scaleLockMode,
      minInventory: settings.minInventory,
      avoidNormal: settings.avoidNormal,
      includeNormal: settings.includeNormal,
      visualMutations: settings.visualMutations.slice(),
      weatherMode: settings.weatherMode,
      weatherSelected: settings.weatherSelected.slice(),
      weatherRecipes: settings.weatherRecipes.map((recipe) => recipe.slice())
    };
  }
  function cloneState(state2) {
    const overrides = {};
    for (const [key2, value] of Object.entries(state2.overrides)) {
      overrides[key2] = { enabled: value.enabled, settings: cloneSettings(value.settings) };
    }
    return {
      enabled: state2.enabled,
      settings: cloneSettings(state2.settings),
      overrides
    };
  }
  function cloneSlotInfo(info) {
    return {
      isPlant: info.isPlant,
      originalIndex: info.originalIndex,
      orderedIndex: info.orderedIndex,
      totalSlots: info.totalSlots,
      availableSlotCount: info.availableSlotCount,
      slot: info.slot,
      seedKey: info.seedKey,
      sizePercent: info.sizePercent,
      mutations: info.mutations.slice()
    };
  }
  function mutationsToArrays(raw) {
    let hasGold = false;
    let hasRainbow = false;
    const weather2 = [];
    if (!Array.isArray(raw)) {
      return { hasGold, hasRainbow, weather: weather2 };
    }
    for (let i = 0; i < raw.length; i++) {
      const tag = String(raw[i] || "");
      if (!tag) continue;
      if (tag === "Gold") {
        hasGold = true;
      } else if (tag === "Rainbow") {
        hasRainbow = true;
      } else {
        weather2.push(tag);
      }
    }
    return { hasGold, hasRainbow, weather: weather2 };
  }
  var LockerService = class {
    constructor() {
      __publicField(this, "state", defaultState());
      __publicField(this, "listeners", /* @__PURE__ */ new Set());
      __publicField(this, "slotInfoListeners", /* @__PURE__ */ new Set());
      __publicField(this, "slotWatcher", null);
      __publicField(this, "slotWatcherUnsub", null);
      __publicField(this, "currentSlotInfo", emptySlotInfo());
      __publicField(this, "currentSlotHarvestAllowed", null);
      __publicField(this, "lastSlotChangeDetectedAt", null);
      this.load();
      this.updateSlotWatcher();
    }
    load() {
      if (typeof window === "undefined" || typeof localStorage === "undefined") {
        this.state = defaultState();
        return;
      }
      try {
        const raw = localStorage.getItem(LS_KEY);
        if (!raw) {
          this.state = defaultState();
          return;
        }
        const parsed = JSON.parse(raw);
        this.state = sanitizeState(parsed);
      } catch {
        this.state = defaultState();
      }
    }
    save() {
      if (typeof window === "undefined" || typeof localStorage === "undefined") return;
      try {
        localStorage.setItem(LS_KEY, JSON.stringify(this.state));
      } catch {
      }
    }
    emit() {
      if (!this.listeners.size) return;
      const snapshot = this.getState();
      const event = { type: "locker-state-changed", state: snapshot };
      for (const listener of this.listeners) {
        try {
          listener(event);
        } catch {
        }
      }
    }
    setState(next) {
      this.state = next;
      this.updateSlotWatcher();
      this.save();
      this.emit();
      this.requestSlotWatcherRecompute();
      this.reapplyCurrentSlotInfo();
    }
    updateSlotWatcher() {
      const shouldWatch = this.state.enabled;
      if (shouldWatch) {
        if (!this.slotWatcher) {
          this.slotWatcher = startLockerSlotWatcherViaGardenObject();
        }
        if (this.slotWatcher && !this.slotWatcherUnsub) {
          try {
            this.slotWatcherUnsub = this.slotWatcher.onChange((info) => this.handleSlotInfo(info));
          } catch {
            this.slotWatcherUnsub = null;
          }
        }
        try {
          const info = this.slotWatcher ? this.slotWatcher.get() : emptySlotInfo();
          this.handleSlotInfo(info, { silent: true });
        } catch {
          this.handleSlotInfo(emptySlotInfo(), { silent: true });
        }
        return;
      }
      this.detachSlotWatcher();
    }
    getState() {
      return cloneState(this.state);
    }
    setGlobalState(next) {
      const current = this.state;
      const sanitized = sanitizeSettings(next.settings);
      const updated = {
        enabled: !!next.enabled,
        settings: sanitized,
        overrides: { ...current.overrides }
      };
      this.setState(updated);
    }
    setOverride(seedKey, override) {
      if (!seedKey) return;
      const sanitized = {
        enabled: !!override?.enabled,
        settings: sanitizeSettings(override?.settings)
      };
      const overrides = { ...this.state.overrides, [seedKey]: sanitized };
      this.setState({ ...this.state, overrides });
    }
    removeOverride(seedKey) {
      if (!seedKey) return;
      if (!(seedKey in this.state.overrides)) return;
      const overrides = { ...this.state.overrides };
      delete overrides[seedKey];
      this.setState({ ...this.state, overrides });
    }
    subscribe(listener) {
      this.listeners.add(listener);
      return () => this.listeners.delete(listener);
    }
    onSlotInfoChange(listener) {
      this.slotInfoListeners.add(listener);
      return () => this.slotInfoListeners.delete(listener);
    }
    getCurrentSlotSnapshot() {
      return {
        info: cloneSlotInfo(this.currentSlotInfo),
        harvestAllowed: this.currentSlotHarvestAllowed,
        detectedAt: this.lastSlotChangeDetectedAt
      };
    }
    requestSlotWatcherRecompute() {
      if (!this.slotWatcher) return;
      try {
        this.slotWatcher.recompute();
      } catch {
      }
    }
    detachSlotWatcher() {
      if (this.slotWatcherUnsub) {
        try {
          this.slotWatcherUnsub();
        } catch {
        }
        this.slotWatcherUnsub = null;
      }
      if (this.slotWatcher) {
        try {
          this.slotWatcher.stop();
        } catch {
        }
        this.slotWatcher = null;
      }
      this.handleSlotInfo(emptySlotInfo(), { silent: true });
    }
    handleSlotInfo(info, opts = {}) {
      const { silent = false } = opts;
      const prevInfo = this.currentSlotInfo;
      const prevHarvestAllowed = this.currentSlotHarvestAllowed;
      const normalizedMutations = Array.isArray(info.mutations) ? info.mutations.slice() : [];
      const nextInfo = { ...info, mutations: normalizedMutations };
      let computedSizePercent = null;
      let harvestAllowed = null;
      let displaySizePercent = null;
      if (nextInfo.isPlant && nextInfo.slot) {
        if (typeof nextInfo.sizePercent === "number" && Number.isFinite(nextInfo.sizePercent)) {
          computedSizePercent = nextInfo.sizePercent;
        } else {
          computedSizePercent = extractSizePercent(nextInfo.slot);
        }
        try {
          harvestAllowed = this.allowsHarvest({
            seedKey: nextInfo.seedKey ?? null,
            sizePercent: computedSizePercent ?? 0,
            mutations: normalizedMutations
          });
        } catch {
          harvestAllowed = null;
        }
      } else {
        computedSizePercent = typeof nextInfo.sizePercent === "number" && Number.isFinite(nextInfo.sizePercent) ? nextInfo.sizePercent : null;
        harvestAllowed = null;
      }
      if (typeof computedSizePercent === "number") {
        displaySizePercent = Math.max(50, Math.min(100, computedSizePercent));
      }
      this.currentSlotInfo = nextInfo;
      this.currentSlotHarvestAllowed = harvestAllowed;
      if (!silent) {
        if (nextInfo.isPlant) {
          if (nextInfo.slot) {
            console.log("[Locker] Slot selection", {
              seedKey: nextInfo.seedKey ?? null,
              slotIndex: nextInfo.originalIndex,
              orderedIndex: nextInfo.orderedIndex,
              sizePercent: computedSizePercent,
              displaySizePercent,
              harvestAllowed,
              mutations: normalizedMutations,
              slot: nextInfo.slot
            });
          } else {
            console.log("[Locker] Slot selection", {
              isPlant: true,
              slotIndex: nextInfo.originalIndex,
              orderedIndex: nextInfo.orderedIndex,
              totalSlots: nextInfo.totalSlots,
              availableSlotCount: nextInfo.availableSlotCount,
              seedKey: nextInfo.seedKey ?? null,
              displaySizePercent,
              slot: nextInfo.slot
            });
          }
        } else {
          console.log("[Locker] Slot selection", { isPlant: false, slot: nextInfo.slot });
        }
        const infoChanged = !slotInfosEqual(prevInfo, nextInfo) || (prevHarvestAllowed ?? null) !== (harvestAllowed ?? null);
        if (infoChanged) {
          this.lastSlotChangeDetectedAt = now();
        }
      }
      this.emitSlotInfoChange();
    }
    reapplyCurrentSlotInfo() {
      try {
        const info = this.slotWatcher ? this.slotWatcher.get() : emptySlotInfo();
        this.handleSlotInfo(info, { silent: true });
      } catch {
        this.handleSlotInfo(emptySlotInfo(), { silent: true });
      }
    }
    recomputeCurrentSlot() {
      this.requestSlotWatcherRecompute();
      this.reapplyCurrentSlotInfo();
    }
    effectiveSettings(seedKey) {
      if (!this.state.enabled) {
        return { enabled: false, settings: this.state.settings };
      }
      if (seedKey) {
        const override = this.state.overrides[seedKey];
        if (override?.enabled) {
          return { enabled: true, settings: override.settings };
        }
      }
      return { enabled: true, settings: this.state.settings };
    }
    slotShouldBeBlocked(settings, args) {
      const scaleMode = settings.scaleLockMode === "MINIMUM" ? "MINIMUM" : settings.scaleLockMode === "NONE" ? "NONE" : "RANGE";
      const minScaleClamp = scaleMode === "MINIMUM" ? 100 : 99;
      const minScale = clampNumber(Math.round(settings.minScalePct ?? 50), 50, minScaleClamp);
      const maxScaleBase = clampNumber(Math.round(settings.maxScalePct ?? 100), 50, 100);
      if (scaleMode === "MINIMUM") {
        if (args.sizePercent < minScale) return true;
      } else if (scaleMode === "RANGE") {
        const maxScaleRaw = clampNumber(maxScaleBase, 51, 100);
        const maxScale = maxScaleRaw <= minScale ? Math.min(100, Math.max(51, minScale + 1)) : maxScaleRaw;
        if (args.sizePercent >= minScale && args.sizePercent <= maxScale) return true;
      }
      const { hasGold, hasRainbow, weather: weather2 } = mutationsToArrays(args.mutations);
      const isNormal = !hasGold && !hasRainbow;
      if (isNormal) {
        if (settings.avoidNormal) return true;
      } else {
        const avoidGold = settings.visualMutations.includes("Gold");
        const avoidRainbow = settings.visualMutations.includes("Rainbow");
        if (avoidGold && hasGold || avoidRainbow && hasRainbow) return true;
      }
      const selected = settings.weatherSelected ?? [];
      const mode = settings.weatherMode ?? "ANY";
      if (mode === "RECIPES") {
        const recipes = settings.weatherRecipes ?? [];
        if (!recipes.length) return false;
        for (let i = 0; i < recipes.length; i++) {
          const recipe = recipes[i];
          if (!Array.isArray(recipe) || recipe.length === 0) continue;
          let matches = true;
          for (let j = 0; j < recipe.length; j++) {
            const required = recipe[j];
            if (required === LOCKER_NO_WEATHER_TAG) {
              if (weather2.length !== 0) {
                matches = false;
                break;
              }
              continue;
            }
            if (!weather2.includes(required)) {
              matches = false;
              break;
            }
          }
          if (matches) return true;
        }
        return false;
      }
      if (!selected.length) return false;
      if (mode === "ALL") {
        let hasRequirement = false;
        for (let i = 0; i < selected.length; i++) {
          const required = selected[i];
          if (required === LOCKER_NO_WEATHER_TAG) {
            hasRequirement = true;
            if (weather2.length !== 0) return false;
            continue;
          }
          hasRequirement = true;
          if (!weather2.includes(required)) return false;
        }
        return hasRequirement;
      }
      for (let i = 0; i < selected.length; i++) {
        const required = selected[i];
        if (required === LOCKER_NO_WEATHER_TAG) {
          if (weather2.length === 0) return true;
          continue;
        }
        if (weather2.includes(required)) return true;
      }
      return false;
    }
    emitSlotInfoChange() {
      if (!this.slotInfoListeners.size) {
        return;
      }
      const snapshot = {
        type: "locker-slot-info-changed",
        info: cloneSlotInfo(this.currentSlotInfo),
        harvestAllowed: this.currentSlotHarvestAllowed,
        detectedAt: this.lastSlotChangeDetectedAt
      };
      for (const listener of this.slotInfoListeners) {
        try {
          listener(snapshot);
        } catch {
        }
      }
    }
    allowsHarvest(args) {
      const effective = this.effectiveSettings(args.seedKey);
      if (!effective.enabled) {
        return true;
      }
      const blocked = this.slotShouldBeBlocked(effective.settings, args);
      return !blocked;
    }
  };
  var lockerService = new LockerService();

  // src/services/stats.ts
  var LS_STATS_KEY = "qws:stats:v1";
  var GARDEN_INT_KEYS = {
    totalPlanted: true,
    totalHarvested: true,
    totalDestroyed: true,
    watercanUsed: true,
    waterTimeSavedMs: true
  };
  var SHOP_INT_KEYS = {
    seedsBought: true,
    decorBought: true,
    eggsBought: true,
    toolsBought: true,
    cropsSoldCount: true,
    cropsSoldValue: false,
    petsSoldCount: true,
    petsSoldValue: false
  };
  var ABILITY_INT_KEYS = {
    triggers: true,
    totalValue: false
  };
  var WEATHER_INT_KEYS = {
    triggers: true
  };
  var memoryStore = null;
  var listeners = /* @__PURE__ */ new Set();
  var isRecord = (value) => typeof value === "object" && value !== null;
  var toNumber = (value, fallback = 0) => {
    const num = Number(value);
    if (!Number.isFinite(num)) return fallback;
    return num;
  };
  var toPositiveNumber = (value, fallback = 0) => {
    const num = toNumber(value, fallback);
    return Math.max(0, num);
  };
  var toPositiveInt = (value, fallback = 0) => {
    const num = toPositiveNumber(value, fallback);
    return Math.floor(num);
  };
  var toPositiveTimestamp = (value, fallback) => {
    const num = Number(value);
    if (!Number.isFinite(num) || num <= 0) return fallback;
    return Math.floor(num);
  };
  var cloneStats = (stats) => ({
    createdAt: stats.createdAt,
    garden: { ...stats.garden },
    shops: { ...stats.shops },
    pets: {
      hatchedByType: Object.fromEntries(
        Object.entries(stats.pets.hatchedByType).map(([key2, counts]) => [key2, { ...counts }])
      )
    },
    abilities: Object.fromEntries(
      Object.entries(stats.abilities).map(([key2, value]) => [key2, { ...value }])
    ),
    weather: Object.fromEntries(
      Object.entries(stats.weather).map(([key2, value]) => [key2, { ...value }])
    )
  });
  function getStorage() {
    if (typeof window === "undefined") return null;
    try {
      if (typeof window.localStorage === "undefined") return null;
      return window.localStorage;
    } catch {
      return null;
    }
  }
  function createDefaultStats(createdAt = Date.now()) {
    const hatchedByType = {};
    for (const species of Object.keys(petCatalog)) {
      hatchedByType[species.toLowerCase()] = { normal: 0, gold: 0, rainbow: 0 };
    }
    const abilities = {};
    for (const abilityId of Object.keys(petAbilities)) {
      abilities[abilityId] = { triggers: 0, totalValue: 0 };
    }
    const weather2 = {};
    for (const key2 of Object.keys(weatherCatalog)) {
      weather2[key2.toLowerCase()] = { triggers: 0 };
    }
    return {
      createdAt,
      garden: {
        totalPlanted: 0,
        totalHarvested: 0,
        totalDestroyed: 0,
        watercanUsed: 0,
        waterTimeSavedMs: 0
      },
      shops: {
        seedsBought: 0,
        decorBought: 0,
        eggsBought: 0,
        toolsBought: 0,
        cropsSoldCount: 0,
        cropsSoldValue: 0,
        petsSoldCount: 0,
        petsSoldValue: 0
      },
      pets: { hatchedByType },
      abilities,
      weather: weather2
    };
  }
  function normalizeHatchedCounts(value, fallback) {
    if (!isRecord(value)) return { ...fallback };
    return {
      normal: toPositiveInt(value.normal, fallback.normal),
      gold: toPositiveInt(value.gold, fallback.gold),
      rainbow: toPositiveInt(value.rainbow, fallback.rainbow)
    };
  }
  function normalizeStats(raw) {
    const fallbackCreatedAt = Date.now();
    const base = createDefaultStats(fallbackCreatedAt);
    if (!isRecord(raw)) return base;
    if (Object.prototype.hasOwnProperty.call(raw, "createdAt")) {
      base.createdAt = toPositiveTimestamp(raw.createdAt, fallbackCreatedAt);
    }
    if (isRecord(raw.garden)) {
      base.garden = {
        totalPlanted: toPositiveInt(raw.garden.totalPlanted, base.garden.totalPlanted),
        totalHarvested: toPositiveInt(raw.garden.totalHarvested, base.garden.totalHarvested),
        totalDestroyed: toPositiveInt(raw.garden.totalDestroyed, base.garden.totalDestroyed),
        watercanUsed: toPositiveInt(raw.garden.watercanUsed, base.garden.watercanUsed),
        waterTimeSavedMs: toPositiveInt(raw.garden.waterTimeSavedMs, base.garden.waterTimeSavedMs)
      };
    }
    if (isRecord(raw.shops)) {
      base.shops = {
        seedsBought: toPositiveInt(raw.shops.seedsBought, base.shops.seedsBought),
        decorBought: toPositiveInt(raw.shops.decorBought, base.shops.decorBought),
        eggsBought: toPositiveInt(raw.shops.eggsBought, base.shops.eggsBought),
        toolsBought: toPositiveInt(raw.shops.toolsBought, base.shops.toolsBought),
        cropsSoldCount: toPositiveInt(raw.shops.cropsSoldCount, base.shops.cropsSoldCount),
        cropsSoldValue: toPositiveNumber(raw.shops.cropsSoldValue, base.shops.cropsSoldValue),
        petsSoldCount: toPositiveInt(raw.shops.petsSoldCount, base.shops.petsSoldCount),
        petsSoldValue: toPositiveNumber(raw.shops.petsSoldValue, base.shops.petsSoldValue)
      };
    }
    if (isRecord(raw.pets) && isRecord(raw.pets.hatchedByType)) {
      for (const [key2, counts] of Object.entries(raw.pets.hatchedByType)) {
        if (typeof key2 !== "string") continue;
        const normalizedKey = key2.toLowerCase();
        const fallback = base.pets.hatchedByType[normalizedKey] ?? { normal: 0, gold: 0, rainbow: 0 };
        base.pets.hatchedByType[normalizedKey] = normalizeHatchedCounts(counts, fallback);
      }
    }
    if (isRecord(raw.abilities)) {
      for (const [key2, value] of Object.entries(raw.abilities)) {
        if (typeof key2 !== "string" || !isRecord(value)) continue;
        base.abilities[key2] = {
          triggers: toPositiveInt(value.triggers, base.abilities[key2]?.triggers ?? 0),
          totalValue: toPositiveNumber(value.totalValue, base.abilities[key2]?.totalValue ?? 0)
        };
      }
    }
    if (isRecord(raw.weather)) {
      for (const [key2, value] of Object.entries(raw.weather)) {
        if (typeof key2 !== "string" || !isRecord(value)) continue;
        const normalizedKey = key2.toLowerCase();
        const fallback = base.weather[normalizedKey] ?? { triggers: 0 };
        base.weather[normalizedKey] = {
          triggers: toPositiveInt(value.triggers, fallback.triggers)
        };
      }
    }
    return base;
  }
  function readFromStorage() {
    const storage = getStorage();
    if (!storage) {
      if (!memoryStore) memoryStore = createDefaultStats();
      return cloneStats(memoryStore);
    }
    try {
      const raw = storage.getItem(LS_STATS_KEY);
      if (!raw) {
        const fresh = createDefaultStats();
        memoryStore = cloneStats(fresh);
        return fresh;
      }
      const parsed = JSON.parse(raw);
      const normalized = normalizeStats(parsed);
      memoryStore = cloneStats(normalized);
      return normalized;
    } catch {
      const fresh = createDefaultStats();
      memoryStore = cloneStats(fresh);
      return fresh;
    }
  }
  function emitUpdate(stats) {
    const snapshot = cloneStats(stats);
    for (const listener of listeners) {
      try {
        listener(snapshot);
      } catch (error) {
        console.error("[StatsService] Listener error", error);
      }
    }
  }
  function writeToStorage(stats) {
    const snapshot = cloneStats(stats);
    const storage = getStorage();
    memoryStore = snapshot;
    if (storage) {
      try {
        storage.setItem(LS_STATS_KEY, JSON.stringify(snapshot));
      } catch {
      }
    }
    return snapshot;
  }
  function adjustValue(current, delta, integer) {
    const a = Number(current);
    const b = Number(delta);
    const sum = Number.isFinite(a) ? a : 0;
    const next = sum + (Number.isFinite(b) ? b : 0);
    const clamped = Math.max(0, next);
    return integer ? Math.floor(clamped) : clamped;
  }
  function updateStats(mutator) {
    const stats = readFromStorage();
    const draft = cloneStats(stats);
    mutator(draft);
    const stored = writeToStorage(draft);
    emitUpdate(stored);
    return stored;
  }
  function requireAbilityEntry(stats, abilityId) {
    if (!stats.abilities[abilityId]) {
      stats.abilities[abilityId] = { triggers: 0, totalValue: 0 };
    }
    return stats.abilities[abilityId];
  }
  function requireWeatherEntry(stats, weatherId) {
    const key2 = weatherId.toLowerCase();
    if (!stats.weather[key2]) {
      stats.weather[key2] = { triggers: 0 };
    }
    return stats.weather[key2];
  }
  function requirePetEntry(stats, species) {
    const key2 = species.toLowerCase();
    if (!stats.pets.hatchedByType[key2]) {
      stats.pets.hatchedByType[key2] = { normal: 0, gold: 0, rainbow: 0 };
    }
    return stats.pets.hatchedByType[key2];
  }
  var StatsService = {
    storageKey: LS_STATS_KEY,
    getSnapshot() {
      return readFromStorage();
    },
    setSnapshot(snapshot) {
      const normalized = normalizeStats(snapshot);
      const stored = writeToStorage(normalized);
      emitUpdate(stored);
      return stored;
    },
    reset() {
      const fresh = createDefaultStats();
      const stored = writeToStorage(fresh);
      emitUpdate(stored);
      return stored;
    },
    update(mutator) {
      return updateStats(mutator);
    },
    incrementGardenStat(key2, amount = 1) {
      return updateStats((draft) => {
        draft.garden[key2] = adjustValue(draft.garden[key2], amount, GARDEN_INT_KEYS[key2]);
      });
    },
    incrementShopStat(key2, amount = 1) {
      return updateStats((draft) => {
        draft.shops[key2] = adjustValue(draft.shops[key2], amount, SHOP_INT_KEYS[key2]);
      });
    },
    incrementPetHatched(species, rarityKey = "normal", amount = 1) {
      return updateStats((draft) => {
        const entry = requirePetEntry(draft, species);
        entry[rarityKey] = adjustValue(entry[rarityKey], amount, true);
      });
    },
    incrementAbilityStat(abilityId, key2, amount = 1) {
      return updateStats((draft) => {
        const entry = requireAbilityEntry(draft, abilityId);
        entry[key2] = adjustValue(entry[key2], amount, ABILITY_INT_KEYS[key2]);
      });
    },
    incrementWeatherStat(weatherId, key2 = "triggers", amount = 1) {
      return updateStats((draft) => {
        const entry = requireWeatherEntry(draft, weatherId);
        entry[key2] = adjustValue(entry[key2], amount, WEATHER_INT_KEYS[key2]);
      });
    },
    subscribe(listener) {
      listeners.add(listener);
      return () => {
        listeners.delete(listener);
      };
    }
  };
  var StatsDefaults = {
    rarityOrder: [
      rarity.Common,
      rarity.Uncommon,
      rarity.Rare,
      rarity.Legendary,
      rarity.Mythic,
      rarity.Divine,
      rarity.Celestial
    ],
    createEmpty() {
      return createDefaultStats();
    }
  };

  // src/hooks/ws-hook.ts
  function installPageWebSocketHook() {
    if (!pageWindow || !NativeWS) return;
    function WrappedWebSocket(url, protocols) {
      const ws = protocols !== void 0 ? new NativeWS(url, protocols) : new NativeWS(url);
      sockets.push(ws);
      ws.addEventListener("open", () => {
        setTimeout(() => {
          if (ws.readyState === NativeWS.OPEN) setQWS(ws, "open-fallback");
        }, 800);
      });
      ws.addEventListener("message", async (ev) => {
        const j = await parseWSData(ev.data);
        if (!j) return;
        if (!hasSharedQuinoaWS() && (j.type === "Welcome" || j.type === "Config" || j.fullState || j.config)) {
          setQWS(ws, "message:" + (j.type || "state"));
        }
      });
      return ws;
    }
    WrappedWebSocket.prototype = NativeWS.prototype;
    try {
      WrappedWebSocket.OPEN = NativeWS.OPEN;
    } catch {
    }
    try {
      WrappedWebSocket.CLOSED = NativeWS.CLOSED;
    } catch {
    }
    try {
      WrappedWebSocket.CLOSING = NativeWS.CLOSING;
    } catch {
    }
    try {
      WrappedWebSocket.CONNECTING = NativeWS.CONNECTING;
    } catch {
    }
    pageWindow.WebSocket = WrappedWebSocket;
    if (pageWindow !== window) {
      try {
        window.WebSocket = WrappedWebSocket;
      } catch {
      }
    }
    function hasSharedQuinoaWS() {
      const existing = readSharedGlobal("quinoaWS");
      return !!existing;
    }
    installHarvestCropInterceptor();
  }
  var interceptorsByType = /* @__PURE__ */ new Map();
  var interceptorStatus = readSharedGlobal(
    "__tmMessageHookInstalled"
  ) ? "installed" : "idle";
  var interceptorPoll = null;
  var interceptorTimeout = null;
  function registerMessageInterceptor(type, interceptor) {
    const list = interceptorsByType.get(type);
    if (list) {
      list.push(interceptor);
    } else {
      interceptorsByType.set(type, [interceptor]);
    }
    ensureMessageInterceptorInstalled();
    return () => {
      const current = interceptorsByType.get(type);
      if (!current) return;
      const index = current.indexOf(interceptor);
      if (index !== -1) current.splice(index, 1);
      if (current.length === 0) interceptorsByType.delete(type);
    };
  }
  function ensureMessageInterceptorInstalled() {
    if (interceptorStatus === "installed" || interceptorStatus === "installing") return;
    interceptorStatus = "installing";
    const tryInstall = () => {
      const Conn = pageWindow.MagicCircle_RoomConnection || readSharedGlobal("MagicCircle_RoomConnection");
      if (!Conn) return false;
      const original = resolveSendMessage(Conn);
      if (!original) return false;
      const wrap = function(message, ...rest) {
        let currentMessage = message;
        try {
          const type = currentMessage?.type;
          if (type && interceptorsByType.size > 0) {
            const context = { thisArg: this, args: rest };
            const result = applyInterceptors(type, currentMessage, context);
            if (result.drop) return;
            currentMessage = result.message;
          }
        } catch (error) {
          console.error("[MG-mod] Erreur dans le hook WS :", error);
        }
        return original.fn.call(this, currentMessage, ...rest);
      };
      if (original.kind === "static") {
        Conn.sendMessage = wrap;
      } else {
        Conn.prototype.sendMessage = wrap;
      }
      interceptorStatus = "installed";
      shareGlobal("__tmMessageHookInstalled", true);
      if (interceptorPoll !== null) {
        clearInterval(interceptorPoll);
        interceptorPoll = null;
      }
      if (interceptorTimeout !== null) {
        clearTimeout(interceptorTimeout);
        interceptorTimeout = null;
      }
      return true;
    };
    if (tryInstall()) return;
    interceptorPoll = window.setInterval(() => {
      if (tryInstall()) {
        if (interceptorPoll !== null) {
          clearInterval(interceptorPoll);
          interceptorPoll = null;
        }
      }
    }, 200);
    interceptorTimeout = window.setTimeout(() => {
      if (interceptorPoll !== null) {
        clearInterval(interceptorPoll);
        interceptorPoll = null;
      }
      if (interceptorStatus !== "installed") {
        interceptorStatus = "idle";
      }
      interceptorTimeout = null;
    }, 2e4);
  }
  function applyInterceptors(type, initialMessage, context) {
    const interceptors = interceptorsByType.get(type);
    if (!interceptors || interceptors.length === 0) {
      return { message: initialMessage, drop: false };
    }
    let currentMessage = initialMessage;
    for (const interceptor of [...interceptors]) {
      try {
        const result = interceptor(currentMessage, context);
        if (!result) continue;
        if (result.kind === "drop") {
          return { message: currentMessage, drop: true };
        }
        if (result.kind === "replace") {
          currentMessage = result.message;
        }
      } catch (error) {
      }
    }
    return { message: currentMessage, drop: false };
  }
  function installHarvestCropInterceptor() {
    if (readSharedGlobal("__tmHarvestHookInstalled")) return;
    let latestGardenState = null;
    void (async () => {
      try {
        latestGardenState = await Atoms.data.garden.get() ?? null;
      } catch {
      }
      try {
        await Atoms.data.garden.onChange((next) => {
          latestGardenState = next ?? null;
        });
      } catch {
      }
    })();
    registerMessageInterceptor("HarvestCrop", (message) => {
      const slot = message.slot;
      const slotsIndex = message.slotsIndex;
      if (!Number.isInteger(slot) || !Number.isInteger(slotsIndex)) {
        return;
      }
      const garden2 = latestGardenState;
      const tileObjects = garden2?.tileObjects;
      const tile = tileObjects ? tileObjects[String(slot)] : void 0;
      if (!tile || typeof tile !== "object" || tile.objectType !== "plant") {
        return;
      }
      const slots = Array.isArray(tile.slots) ? tile.slots : [];
      const cropSlot = slots[slotsIndex];
      if (!cropSlot || typeof cropSlot !== "object") {
        return;
      }
      const seedKey = extractSeedKey2(tile);
      const sizePercent = extractSizePercent2(cropSlot);
      const mutations = sanitizeMutations(cropSlot?.mutations);
      const lockerEnabled = (() => {
        try {
          return lockerService.getState().enabled;
        } catch {
          return false;
        }
      })();
      if (lockerEnabled) {
        let harvestAllowed = true;
        try {
          harvestAllowed = lockerService.allowsHarvest({
            seedKey,
            sizePercent,
            mutations
          });
        } catch {
          harvestAllowed = true;
        }
        if (!harvestAllowed) {
          console.log("[HarvestCrop] Blocked by locker", {
            slot,
            slotsIndex,
            seedKey,
            sizePercent,
            mutations
          });
          return { kind: "drop" };
        }
      }
      StatsService.incrementGardenStat("totalHarvested");
      void (async () => {
        try {
          const garden3 = await Atoms.data.garden.get();
          const tileObjects2 = garden3?.tileObjects ?? null;
          const tile2 = tileObjects2 ? tileObjects2[String(slot)] : void 0;
          const cropSlot2 = Array.isArray(tile2?.slots) ? tile2.slots?.[slotsIndex] : void 0;
          console.log("[HarvestCrop]", {
            slot,
            slotsIndex,
            cropSlot: cropSlot2
          });
        } catch (error) {
          console.error("[HarvestCrop] Unable to log crop slot", error);
        }
      })();
    });
    registerMessageInterceptor("RemoveGardenObject", (message) => {
      StatsService.incrementGardenStat("totalDestroyed");
    });
    registerMessageInterceptor("WaterPlant", (message) => {
      StatsService.incrementGardenStat("watercanUsed");
      StatsService.incrementGardenStat("waterTimeSavedMs", 5 * 60 * 1e3);
    });
    registerMessageInterceptor("PlantSeed", (message) => {
      StatsService.incrementGardenStat("totalPlanted");
    });
    registerMessageInterceptor("PurchaseDecor", (message) => {
      StatsService.incrementShopStat("decorBought");
    });
    registerMessageInterceptor("PurchaseSeed", (message) => {
      StatsService.incrementShopStat("seedsBought");
    });
    registerMessageInterceptor("PurchaseEgg", (message) => {
      StatsService.incrementShopStat("eggsBought");
    });
    registerMessageInterceptor("PurchaseTool", (message) => {
      StatsService.incrementShopStat("toolsBought");
    });
    registerMessageInterceptor("HatchEgg", () => {
      void (async () => {
        const previousPets = await readInventoryPetSnapshots();
        const previousMap = buildPetMap(previousPets);
        const nextPets = await waitForInventoryPetAddition(previousMap);
        if (!nextPets) return;
        const newPets = extractNewPets(nextPets, previousMap);
        if (!newPets.length) return;
        for (const pet of newPets) {
          const rarity2 = inferPetRarity(pet.mutations);
          if (pet.species) {
            StatsService.incrementPetHatched(pet.species, rarity2);
          }
        }
      })();
    });
    registerMessageInterceptor("SellAllCrops", (message) => {
      void (async () => {
        try {
          const items = await Atoms.inventory.myCropItemsToSell.get();
          const count = Array.isArray(items) ? items.length : 0;
          if (count > 0) {
            StatsService.incrementShopStat("cropsSoldCount", count);
          }
        } catch (error) {
          console.error("[SellAllCrops] Unable to read crop items", error);
        }
        try {
          const total = await Atoms.shop.totalCropSellPrice.get();
          const value = Number(total);
          if (Number.isFinite(value) && value > 0) {
            StatsService.incrementShopStat("cropsSoldValue", value);
          }
        } catch (error) {
          console.error("[SellAllCrops] Unable to read crop sell price", error);
        }
      })();
    });
    registerMessageInterceptor("SellPet", (message) => {
      StatsService.incrementShopStat("petsSoldCount");
      void (async () => {
        try {
          const total = await Atoms.pets.totalPetSellPrice.get();
          const value = Number(total);
          if (Number.isFinite(value) && value > 0) {
            StatsService.incrementShopStat("petsSoldValue", value);
          }
        } catch (error) {
          console.error("[SellPet] Unable to read pet sell price", error);
        }
      })();
    });
    shareGlobal("__tmHarvestHookInstalled", true);
  }
  function extractSeedKey2(tile) {
    if (!tile || typeof tile !== "object") return null;
    if (typeof tile.seedKey === "string" && tile.seedKey) return tile.seedKey;
    if (typeof tile.species === "string" && tile.species) return tile.species;
    const fallbacks = ["seedSpecies", "plantSpecies", "cropSpecies", "speciesId"];
    for (const key2 of fallbacks) {
      const value = tile[key2];
      if (typeof value === "string" && value) return value;
    }
    return null;
  }
  var normalizeSpeciesKey2 = (value) => value.toLowerCase().replace(/['’`]/g, "").replace(/\s+/g, "").replace(/-/g, "").replace(/(seed|plant|baby|fruit|crop)$/i, "");
  var MAX_SCALE_BY_SPECIES2 = (() => {
    const map2 = /* @__PURE__ */ new Map();
    const register = (key2, value) => {
      if (typeof key2 !== "string") return;
      const normalized = normalizeSpeciesKey2(key2.trim());
      if (!normalized || map2.has(normalized)) return;
      map2.set(normalized, value);
    };
    for (const [species, entry] of Object.entries(plantCatalog)) {
      const maxScale = Number(entry?.crop?.maxScale);
      if (!Number.isFinite(maxScale) || maxScale <= 0) continue;
      register(species, maxScale);
      register(entry?.seed?.name, maxScale);
      register(entry?.plant?.name, maxScale);
      register(entry?.crop?.name, maxScale);
    }
    return map2;
  })();
  function lookupMaxScale2(species) {
    if (typeof species !== "string") return null;
    const normalized = normalizeSpeciesKey2(species.trim());
    if (!normalized) return null;
    const found = MAX_SCALE_BY_SPECIES2.get(normalized);
    if (typeof found === "number" && Number.isFinite(found) && found > 0) {
      return found;
    }
    return null;
  }
  function getMaxScaleForSlot2(slot) {
    if (!slot || typeof slot !== "object") return null;
    const candidates = /* @__PURE__ */ new Set();
    const fromSeedKey = extractSeedKey2(slot);
    if (fromSeedKey) candidates.add(fromSeedKey);
    const fields = [
      "species",
      "seedSpecies",
      "plantSpecies",
      "cropSpecies",
      "baseSpecies",
      "seedKey"
    ];
    for (const field of fields) {
      const value = slot[field];
      if (typeof value === "string" && value) {
        candidates.add(value);
      }
    }
    for (const cand of candidates) {
      const max = lookupMaxScale2(cand);
      if (typeof max === "number" && Number.isFinite(max) && max > 0) {
        return max;
      }
    }
    return null;
  }
  function extractSizePercent2(slot) {
    if (!slot || typeof slot !== "object") return 100;
    const direct = Number(
      slot.sizePercent ?? slot.sizePct ?? slot.size ?? slot.percent ?? slot.progressPercent
    );
    if (Number.isFinite(direct)) {
      return clampPercent2(Math.round(direct), 0, 100);
    }
    const scale = Number(slot.targetScale ?? slot.scale);
    if (Number.isFinite(scale)) {
      const maxScale = getMaxScaleForSlot2(slot);
      if (typeof maxScale === "number" && Number.isFinite(maxScale) && maxScale > 1) {
        const clamped = Math.max(1, Math.min(maxScale, scale));
        const pct2 = 50 + (clamped - 1) / (maxScale - 1) * 50;
        return clampPercent2(Math.round(pct2), 50, 100);
      }
      if (scale > 1 && scale <= 2) {
        const pct2 = 50 + (scale - 1) / 1 * 50;
        return clampPercent2(Math.round(pct2), 50, 100);
      }
      const pct = Math.round(scale * 100);
      return clampPercent2(pct, 0, 100);
    }
    return 100;
  }
  function sanitizeMutations(raw) {
    if (!Array.isArray(raw)) return [];
    const out = [];
    for (let i = 0; i < raw.length; i++) {
      const value = raw[i];
      if (typeof value === "string") {
        if (value) out.push(value);
      } else if (value != null) {
        const str = String(value);
        if (str) out.push(str);
      }
    }
    return out;
  }
  function clampPercent2(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }
  var HATCH_EGG_TIMEOUT_MS = 5e3;
  async function readInventoryPetSnapshots() {
    try {
      const inventory = await Atoms.inventory.myInventory.get();
      return collectInventoryPets(inventory);
    } catch (error) {
      console.error("[HatchEgg] Unable to read inventory", error);
      return [];
    }
  }
  function collectInventoryPets(rawInventory) {
    const items = extractInventoryItems(rawInventory);
    const pets = [];
    for (const entry of items) {
      const pet = toInventoryPet(entry);
      if (pet) pets.push(pet);
    }
    return pets;
  }
  function extractInventoryItems(rawInventory) {
    if (!rawInventory) return [];
    if (Array.isArray(rawInventory)) return rawInventory;
    if (Array.isArray(rawInventory.items)) return rawInventory.items;
    if (Array.isArray(rawInventory.inventory)) return rawInventory.inventory;
    if (Array.isArray(rawInventory.inventory?.items)) return rawInventory.inventory.items;
    return [];
  }
  function toInventoryPet(entry) {
    if (!entry || typeof entry !== "object") return null;
    const source = entry.item && typeof entry.item === "object" ? entry.item : entry;
    if (!source || typeof source !== "object") return null;
    const type = source.itemType ?? source.data?.itemType ?? "";
    if (String(type).toLowerCase() !== "pet") return null;
    const id = source.id ?? source.data?.id;
    const species = source.petSpecies ?? source.data?.petSpecies;
    if (!id || !species) return null;
    const mutations = sanitizeMutations(source.mutations ?? source.data?.mutations);
    return {
      id: String(id),
      species: String(species),
      mutations
    };
  }
  function buildPetMap(pets) {
    const map2 = /* @__PURE__ */ new Map();
    for (const pet of pets) {
      map2.set(pet.id, pet);
    }
    return map2;
  }
  function extractNewPets(pets, previous) {
    return pets.filter((pet) => !previous.has(pet.id));
  }
  function inferPetRarity(mutations) {
    if (!Array.isArray(mutations) || mutations.length === 0) {
      return "normal";
    }
    const seen = new Set(mutations.map((m) => String(m).toLowerCase()));
    if (seen.has("rainbow")) return "rainbow";
    if (seen.has("gold") || seen.has("golden")) return "gold";
    return "normal";
  }
  async function waitForInventoryPetAddition(previous, timeoutMs = HATCH_EGG_TIMEOUT_MS) {
    await delay(0);
    const initial = await readInventoryPetSnapshots();
    if (hasNewInventoryPet(initial, previous)) {
      return initial;
    }
    return new Promise(async (resolve2) => {
      let settled = false;
      let unsub = null;
      let timer = null;
      const finalize = (value) => {
        if (settled) return;
        settled = true;
        if (timer !== null) {
          clearTimeout(timer);
        }
        if (unsub) {
          try {
            unsub();
          } catch {
          }
        }
        resolve2(value);
      };
      const evaluate = (source) => {
        const pets = collectInventoryPets(source);
        if (hasNewInventoryPet(pets, previous)) {
          finalize(pets);
        }
      };
      try {
        unsub = await Atoms.inventory.myInventory.onChange((next) => {
          evaluate(next);
        });
      } catch (error) {
        console.error("[HatchEgg] Unable to observe inventory", error);
        finalize(null);
        return;
      }
      timer = setTimeout(() => {
        void (async () => {
          const latest = await readInventoryPetSnapshots();
          if (hasNewInventoryPet(latest, previous)) {
            finalize(latest);
          } else {
            finalize(null);
          }
        })();
      }, timeoutMs);
    });
  }
  function hasNewInventoryPet(pets, previous) {
    return pets.some((pet) => !previous.has(pet.id));
  }
  function delay(ms) {
    return new Promise((resolve2) => setTimeout(resolve2, ms));
  }
  function resolveSendMessage(Conn) {
    const isFn = (value) => typeof value === "function";
    if (isFn(Conn.sendMessage)) {
      return { kind: "static", fn: Conn.sendMessage.bind(Conn) };
    }
    if (Conn.prototype && isFn(Conn.prototype.sendMessage)) {
      return { kind: "proto", fn: Conn.prototype.sendMessage };
    }
    return null;
  }

  // src/core/webSocketBridge.ts
  function postAllToWorkers(msg) {
    if (Workers.forEach) Workers.forEach((w) => {
      try {
        w.postMessage(msg);
      } catch {
      }
    });
    else for (const w of Workers._a) {
      try {
        w.postMessage(msg);
      } catch {
      }
    }
  }
  function getPageWS() {
    if (quinoaWS && quinoaWS.readyState === NativeWS.OPEN) return quinoaWS;
    let any = null;
    if (sockets.find) any = sockets.find((s) => s.readyState === NativeWS.OPEN) || null;
    if (!any) {
      for (let i = 0; i < sockets.length; i++) if (sockets[i].readyState === NativeWS.OPEN) {
        any = sockets[i];
        break;
      }
    }
    if (any) {
      setQWS(any, "getPageWS");
      return any;
    }
    throw new Error("No page WebSocket open");
  }
  function sendToGame(payloadObj) {
    const msg = { scopePath: ["Room", "Quinoa"], ...payloadObj };
    try {
      const ws = getPageWS();
      ws.send(JSON.stringify(msg));
      return true;
    } catch {
      postAllToWorkers({ __QWS_CMD: "send", payload: JSON.stringify(msg) });
      return true;
    }
  }

  // src/services/player.ts
  function slotSig2(o) {
    if (!o) return "\u2205";
    return [
      o.objectType ?? o.type ?? "",
      o.species ?? o.seedSpecies ?? o.plantSpecies ?? o.eggId ?? o.decorId ?? "",
      o.plantedAt ?? o.startTime ?? 0,
      o.maturedAt ?? o.endTime ?? 0
    ].join("|");
  }
  function diffGarden(prev, next) {
    const p = prev?.tileObjects ?? {};
    const n = next?.tileObjects ?? {};
    const added = [];
    const updated = [];
    const removed = [];
    const changes = [];
    const seen = /* @__PURE__ */ new Set();
    for (const k of Object.keys(n)) {
      seen.add(k);
      if (!(k in p)) {
        added.push(+k);
        changes.push({ kind: "added", slot: +k, next: n[k] });
      } else if (slotSig2(p[k]) !== slotSig2(n[k])) {
        updated.push(+k);
        changes.push({ kind: "updated", slot: +k, prev: p[k], next: n[k] });
      }
    }
    for (const k of Object.keys(p)) {
      if (!seen.has(k)) {
        removed.push(+k);
        changes.push({ kind: "removed", slot: +k, prev: p[k] });
      }
    }
    return { added, updated, removed, changes };
  }
  function petSig(p) {
    const s = p?.slot ?? {};
    const muts = Array.isArray(s.mutations) ? s.mutations.slice().sort().join(",") : "";
    const ab = Array.isArray(s.abilities) ? s.abilities.slice().sort().join(",") : "";
    const name = s.name ?? "";
    const species = s.petSpecies ?? "";
    const xp = Number.isFinite(s.xp) ? Math.round(s.xp) : 0;
    const hunger = Number.isFinite(s.hunger) ? Math.round(s.hunger * 1e3) : 0;
    const scale = Number.isFinite(s.targetScale) ? Math.round(s.targetScale * 1e3) : 0;
    const x = Number.isFinite(p?.position?.x) ? Math.round(p.position.x) : 0;
    const y = Number.isFinite(p?.position?.y) ? Math.round(p.position.y) : 0;
    return `${species}|${name}|xp:${xp}|hg:${hunger}|sc:${scale}|m:${muts}|a:${ab}|pos:${x},${y}`;
  }
  function snapshotPets(state2) {
    const snap = /* @__PURE__ */ new Map();
    const arr = Array.isArray(state2) ? state2 : [];
    for (const it of arr) {
      const id = String(it?.slot?.id ?? "");
      if (!id) continue;
      snap.set(id, petSig(it));
    }
    return snap;
  }
  function diffPetsSnapshot(prev, next) {
    const added = [];
    const updated = [];
    const removed = [];
    const changes = [];
    for (const [id, sig] of next) {
      if (!prev.has(id)) {
        added.push(id);
        changes.push({ kind: "added", id });
      } else if (prev.get(id) !== sig) {
        updated.push(id);
        changes.push({ kind: "updated", id });
      }
    }
    for (const id of prev.keys()) {
      if (!next.has(id)) {
        removed.push(id);
        changes.push({ kind: "removed", id });
      }
    }
    return { added, updated, removed, changes };
  }
  function cropSig(it) {
    const muts = Array.isArray(it.mutations) ? it.mutations.slice().sort().join(",") : "";
    const scale = Number.isFinite(it.scale) ? Math.round(it.scale * 1e3) : 0;
    return `${it.species ?? ""}|${it.itemType ?? ""}|${scale}|${muts}`;
  }
  function snapshotInventory(inv) {
    const snap = /* @__PURE__ */ new Map();
    const arr = Array.isArray(inv) ? inv : [];
    for (const it of arr) {
      const id = String(it?.id ?? "");
      if (!id) continue;
      snap.set(id, cropSig(it));
    }
    return snap;
  }
  function diffCropInventorySnapshot(prev, next) {
    const added = [];
    const updated = [];
    const removed = [];
    const changes = [];
    for (const [id, sig] of next) {
      if (!prev.has(id)) {
        added.push(id);
        changes.push({ kind: "added", key: id });
      } else if (prev.get(id) !== sig) {
        updated.push(id);
        changes.push({ kind: "updated", key: id });
      }
    }
    for (const id of prev.keys()) {
      if (!next.has(id)) {
        removed.push(id);
        changes.push({ kind: "removed", key: id });
      }
    }
    return { added, updated, removed, changes };
  }
  var PlayerService = {
    /* ------------------------- Position / Déplacement ------------------------- */
    getPosition() {
      return Atoms.player.position.get();
    },
    onPosition(cb) {
      return Atoms.player.position.onChange(cb);
    },
    onPositionNow(cb) {
      return Atoms.player.position.onChangeNow(cb);
    },
    async setPosition(x, y) {
      await Atoms.player.position.set({ x, y });
    },
    async teleport(x, y) {
      try {
        await this.setPosition(x, y);
      } catch (err) {
      }
      try {
        sendToGame({ type: "Teleport", position: { x, y } });
      } catch (err) {
      }
    },
    async move(x, y) {
      try {
        await this.setPosition(x, y);
      } catch (err) {
      }
      try {
        sendToGame({ type: "PlayerPosition", position: { x, y } });
      } catch (err) {
      }
    },
    /* ------------------------------ Actions jeu ------------------------------ */
    async plantSeed(slot, species) {
      try {
        sendToGame({ type: "PlantSeed", slot, species });
      } catch (err) {
      }
    },
    async sellAllCrops() {
      try {
        sendToGame({ type: "SellAllCrops" });
      } catch (err) {
      }
    },
    async sellPet(itemId) {
      try {
        sendToGame({ type: "SellPet", itemId });
      } catch (err) {
      }
    },
    async waterPlant(slot) {
      try {
        sendToGame({ type: "WaterPlant", slot });
      } catch (err) {
      }
    },
    async setSelectedItem(itemIndex) {
      try {
        sendToGame({ type: "SetSelectedItem", itemIndex });
      } catch (err) {
      }
    },
    async pickupObject() {
      try {
        sendToGame({ type: "PickupObject" });
      } catch (err) {
      }
    },
    async dropObject() {
      try {
        sendToGame({ type: "DropObject" });
      } catch (err) {
      }
    },
    async harvestCrop(slot, slotsIndex) {
      try {
        sendToGame({ type: "HarvestCrop", slot, slotsIndex });
      } catch (err) {
      }
    },
    async feedPet(petItemId, cropItemId) {
      try {
        sendToGame({ type: "FeedPet", petItemId, cropItemId });
      } catch (err) {
      }
    },
    async hatchEgg(slot) {
      try {
        sendToGame({ type: "HatchEgg", slot });
      } catch (err) {
      }
    },
    async placeDecor(tileType, localTileIndex, decorId) {
      try {
        sendToGame({ type: "PlaceDecor", tileType, localTileIndex, decorId });
      } catch (err) {
      }
    },
    async swapPet(petSlotId, petInventoryId) {
      try {
        sendToGame({ type: "SwapPet", petSlotId, petInventoryId });
      } catch (err) {
      }
    },
    async placePet(itemId, position2, tileType, localTileIndex) {
      try {
        sendToGame({ type: "PlacePet", itemId, position: position2, tileType, localTileIndex });
      } catch (err) {
      }
    },
    async petPositions(petPositions) {
      const entries = Object.entries(petPositions ?? {});
      if (!entries.length) {
        return;
      }
      const sanitized = {};
      for (const [id, pos] of entries) {
        const x = Number(pos?.x);
        const y = Number(pos?.y);
        if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
        sanitized[String(id)] = { x, y };
      }
      const validCount = Object.keys(sanitized).length;
      if (!validCount) {
        return;
      }
      try {
        sendToGame({ type: "PetPositions", petPositions: sanitized });
      } catch (err) {
      }
    },
    async storePet(itemId) {
      try {
        sendToGame({ type: "StorePet", itemId });
      } catch (err) {
      }
    },
    async wish(itemId) {
      try {
        sendToGame({ type: "Wish", itemId });
      } catch (err) {
      }
    },
    async purchaseSeed(species) {
      try {
        sendToGame({ type: "PurchaseSeed", species });
      } catch (err) {
      }
    },
    async purchaseDecor(decorId) {
      try {
        sendToGame({ type: "PurchaseDecor", decorId });
      } catch (err) {
      }
    },
    async purchaseEgg(eggId) {
      try {
        sendToGame({ type: "PurchaseEgg", eggId });
      } catch (err) {
      }
    },
    async purchaseTool(toolId) {
      try {
        sendToGame({ type: "PurchaseTool", toolId });
      } catch (err) {
      }
    },
    async triggerAnimation(playerId2, animation) {
      Atoms.player.avatarTriggerAnimationAtom.set({ playerId: playerId2, animation });
    },
    /* -------------------------------- Favorites ------------------------------ */
    async toggleFavoriteItem(itemId) {
      try {
        sendToGame({ type: "ToggleFavoriteItem", itemId });
      } catch (err) {
      }
    },
    async getFavoriteIds() {
      const ids = await Atoms.inventory.favoriteIds.get();
      return Array.isArray(ids) ? ids.slice() : [];
    },
    async getFavoriteIdSet() {
      return getFavoriteIdSet();
    },
    async isFavoriteItem(itemId) {
      const set2 = await getFavoriteIdSet();
      return set2.has(itemId);
    },
    async ensureFavoriteItem(itemId, shouldBeFavorite) {
      const cur = await this.isFavoriteItem(itemId);
      if (cur !== shouldBeFavorite) {
        await this.toggleFavoriteItem(itemId);
        return shouldBeFavorite;
      }
      return cur;
    },
    async ensureFavorites(items, shouldBeFavorite) {
      const set2 = await getFavoriteIdSet();
      for (const id of items) {
        const cur = set2.has(id);
        if (cur !== shouldBeFavorite) {
          try {
            await this.toggleFavoriteItem(id);
          } catch {
          }
        }
      }
    },
    onFavoriteIdsChange(cb) {
      return onFavoriteIds((ids) => cb(Array.isArray(ids) ? ids : []));
    },
    async onFavoriteIdsChangeNow(cb) {
      return onFavoriteIdsNow((ids) => cb(Array.isArray(ids) ? ids : []));
    },
    onFavoriteSetChange(cb) {
      return onFavoriteIds((ids) => cb(new Set(Array.isArray(ids) ? ids : [])));
    },
    async onFavoriteSetChangeNow(cb) {
      const cur = await getFavoriteIdSet();
      cb(cur);
      return onFavoriteIds((ids) => cb(new Set(Array.isArray(ids) ? ids : [])));
    },
    /* --------------------------------- Garden -------------------------------- */
    async getGardenState() {
      return await Atoms.data.garden.get() ?? null;
    },
    onGardenChange(cb) {
      return Atoms.data.garden.onChange(cb);
    },
    onGardenChangeNow(cb) {
      return Atoms.data.garden.onChangeNow(cb);
    },
    onGardenDiff(cb) {
      let prev = null;
      return Atoms.data.garden.onChange((g) => {
        const d = diffGarden(prev, g);
        if (d.added.length || d.updated.length || d.removed.length || g !== prev) {
          prev = g;
          cb(g, d);
        }
      });
    },
    async onGardenDiffNow(cb) {
      let prev = await Atoms.data.garden.get() ?? null;
      cb(prev, diffGarden(null, prev));
      return Atoms.data.garden.onChange((next) => {
        const d = diffGarden(prev, next);
        if (d.added.length || d.updated.length || d.removed.length) {
          prev = next;
          cb(next, d);
        }
      });
    },
    /* ------------------------------------ Pets ------------------------------------ */
    async getPets() {
      const arr = await Atoms.pets.myPetInfos.get();
      return Array.isArray(arr) ? arr : null;
    },
    onPetsChange(cb) {
      let prev = null;
      return Atoms.pets.myPetInfos.onChange((next) => {
        if (next !== prev) {
          prev = next;
          cb(prev);
        }
      });
    },
    async onPetsChangeNow(cb) {
      let prev = await this.getPets();
      cb(prev);
      return Atoms.pets.myPetInfos.onChange((next) => {
        if (next !== prev) {
          prev = next;
          cb(prev);
        }
      });
    },
    onPetsDiff(cb) {
      let prevSnap = snapshotPets(null);
      return Atoms.pets.myPetInfos.onChange((state2) => {
        const nextSnap = snapshotPets(state2);
        const d = diffPetsSnapshot(prevSnap, nextSnap);
        if (d.added.length || d.updated.length || d.removed.length) {
          cb(state2, d);
          prevSnap = nextSnap;
        }
      });
    },
    async onPetsDiffNow(cb) {
      let cur = await this.getPets();
      let prevSnap = snapshotPets(null);
      let nextSnap = snapshotPets(cur);
      const first = diffPetsSnapshot(prevSnap, nextSnap);
      cb(cur, first);
      prevSnap = nextSnap;
      return Atoms.pets.myPetInfos.onChange((state2) => {
        nextSnap = snapshotPets(state2);
        const d = diffPetsSnapshot(prevSnap, nextSnap);
        if (d.added.length || d.updated.length || d.removed.length) {
          cb(state2, d);
          prevSnap = nextSnap;
        }
      });
    },
    /* ------------------------- Crop Inventory (crops) ------------------------- */
    async getCropInventoryState() {
      return Atoms.inventory.myCropInventory.get();
    },
    onCropInventoryChange(cb) {
      let prev = null;
      return Atoms.inventory.myCropInventory.onChange((inv) => {
        if (inv !== prev) {
          prev = inv;
          cb(inv);
        }
      });
    },
    async onCropInventoryChangeNow(cb) {
      let prev = await Atoms.inventory.myCropInventory.get();
      cb(prev);
      return Atoms.inventory.myCropInventory.onChange((inv) => {
        if (inv !== prev) {
          prev = inv;
          cb(inv);
        }
      });
    },
    onCropInventoryDiff(cb) {
      let prevSnap = snapshotInventory(null);
      return Atoms.inventory.myCropInventory.onChange((inv) => {
        const nextSnap = snapshotInventory(inv);
        const d = diffCropInventorySnapshot(prevSnap, nextSnap);
        if (d.added.length || d.updated.length || d.removed.length) {
          cb(inv, d);
          prevSnap = nextSnap;
        }
      });
    },
    async onCropInventoryDiffNow(cb) {
      let cur = await Atoms.inventory.myCropInventory.get();
      let prevSnap = snapshotInventory(null);
      let nextSnap = snapshotInventory(cur);
      const firstDiff = diffCropInventorySnapshot(prevSnap, nextSnap);
      cb(cur, firstDiff);
      prevSnap = nextSnap;
      return Atoms.inventory.myCropInventory.onChange((inv) => {
        nextSnap = snapshotInventory(inv);
        const d = diffCropInventorySnapshot(prevSnap, nextSnap);
        if (d.added.length || d.updated.length || d.removed.length) {
          cb(inv, d);
          prevSnap = nextSnap;
        }
      });
    },
    /* --------------------------- Players in room --------------------------- */
    async getNumPlayers() {
      const n = await Atoms.server.numPlayers.get();
      return typeof n === "number" ? n : 0;
    },
    onNumPlayersChange(cb) {
      let prev = void 0;
      return Atoms.server.numPlayers.onChange((n) => {
        if (n !== prev) {
          prev = n;
          cb(n);
        }
      });
    },
    async onNumPlayersChangeNow(cb) {
      let prev = await this.getNumPlayers();
      cb(prev);
      return Atoms.server.numPlayers.onChange((n) => {
        if (n !== prev) {
          prev = n;
          cb(n);
        }
      });
    }
  };

  // src/services/fakeAtoms.ts
  var _fakeRegistry = /* @__PURE__ */ new Map();
  function _atomsByExactLabel(label2) {
    try {
      return findAtomsByLabel(new RegExp("^" + label2 + "$"));
    } catch {
      return [];
    }
  }
  function _findReadKey(atom) {
    if (atom && typeof atom.read === "function") return "read";
    for (const k of Object.keys(atom || {})) {
      const v = atom[k];
      if (typeof v === "function" && k !== "write" && k !== "onMount" && k !== "toString") {
        const ar = v.length;
        if (ar === 1 || ar === 2) return k;
      }
    }
    throw new Error("Impossible de localiser la fonction read() de l'atom");
  }
  function _getState(label2) {
    return _fakeRegistry.get(label2) || null;
  }
  async function _forceRepaintViaGate(gate) {
    if (!gate?.closeAction || !gate?.openAction) return;
    await gate.closeAction();
    await new Promise((r) => setTimeout(r, 0));
    await gate.openAction();
  }
  async function _ensureFakeInstalled(config) {
    const key2 = config.label;
    const existing = _fakeRegistry.get(key2);
    if (existing?.installed) return existing;
    const atoms = _atomsByExactLabel(config.label);
    if (!atoms.length) {
      throw new Error(`${config.label} introuvable`);
    }
    const state2 = existing ?? {
      config,
      enabled: false,
      payload: null,
      patched: /* @__PURE__ */ new Map(),
      installed: false
    };
    let gateAtom = null;
    if (config.gate?.label) gateAtom = getAtomByLabel(config.gate.label);
    for (const a of atoms) {
      const readKey = _findReadKey(a);
      const orig = a[readKey];
      a[readKey] = (get) => {
        try {
          if (gateAtom) get(gateAtom);
        } catch (err) {
        }
        for (const dep of config.extraDeps || []) {
          try {
            const d = getAtomByLabel(dep);
            d && get(d);
          } catch (err) {
          }
        }
        const real = orig(get);
        if (!state2.enabled || state2.payload == null) return real;
        return config.merge ? config.merge(real, state2.payload) : state2.payload;
      };
      state2.patched.set(a, { readKey, orig });
    }
    if (gateAtom && config.gate?.autoDisableOnClose) {
      state2.unsubGate = await jSub(gateAtom, async () => {
        let v;
        try {
          v = await jGet(gateAtom);
        } catch (err) {
          v = null;
        }
        const isOpen = config.gate?.isOpen ? config.gate.isOpen(v) : !!v;
        if (!isOpen && state2.enabled) state2.enabled = false;
      });
    }
    state2.installed = true;
    _fakeRegistry.set(key2, state2);
    return state2;
  }
  async function fakeShow(config, payload, options) {
    await ensureStore();
    const st = await _ensureFakeInstalled(config);
    st.payload = payload;
    st.enabled = true;
    if (options?.merge && !config.merge) {
      config.merge = (_real, fake) => fake;
    }
    if (options?.openGate && config.gate?.openAction) await config.gate.openAction();
    if (st.autoTimer) {
      clearTimeout(st.autoTimer);
      st.autoTimer = null;
    }
    if (options?.autoRestoreMs && options.autoRestoreMs > 0) {
      st.autoTimer = setTimeout(() => {
        void fakeHide(config.label);
      }, options.autoRestoreMs);
    }
  }
  async function fakeHide(label2) {
    const st = _getState(label2);
    if (!st) return;
    st.enabled = false;
    st.payload = null;
    if (st.autoTimer) {
      clearTimeout(st.autoTimer);
      st.autoTimer = null;
    }
    await _forceRepaintViaGate(st.config.gate);
  }

  // src/services/fakeModal.ts
  async function openModal(modalId) {
    try {
      await Atoms.ui.activeModal.set(modalId);
    } catch (err) {
    }
  }
  async function closeModal(_modalId) {
    try {
      await Atoms.ui.activeModal.set(null);
    } catch (err) {
    }
  }
  function isModalOpen(value, modalId) {
    return value === modalId;
  }
  async function isModalOpenAsync(modalId) {
    try {
      const v = await Atoms.ui.activeModal.get();
      return isModalOpen(v, modalId);
    } catch (err) {
      return false;
    }
  }
  async function waitModalClosed(modalId, timeoutMs = 12e4) {
    const t0 = performance.now();
    while (performance.now() - t0 < timeoutMs) {
      try {
        const v = await Atoms.ui.activeModal.get();
        if (!isModalOpen(v, modalId)) return true;
      } catch {
        return true;
      }
      await new Promise((r) => setTimeout(r, 80));
    }
    return false;
  }
  var SHARED_MYDATA_PATCH = {
    label: Atoms.data.myData.label,
    merge: (real, patch) => {
      const base = real && typeof real === "object" ? real : {};
      const add = patch && typeof patch === "object" ? patch : {};
      return { ...base, ...add };
    },
    gate: {
      label: Atoms.ui.activeModal.label,
      isOpen: (v) => v === "inventory" || v === "journal",
      autoDisableOnClose: true
    }
  };
  var INVENTORY_ATOM_PATCH = {
    label: Atoms.inventory.myInventory.label,
    merge: (_real, fake) => fake,
    gate: {
      label: Atoms.ui.activeModal.label,
      isOpen: (v) => v === "inventory",
      autoDisableOnClose: true
    }
  };
  var INVENTORY_MODAL_ID = "inventory";
  async function openInventoryPanel() {
    return openModal(INVENTORY_MODAL_ID);
  }
  async function closeInventoryPanel() {
    return closeModal(INVENTORY_MODAL_ID);
  }
  function isInventoryOpen(v) {
    return isModalOpen(v, INVENTORY_MODAL_ID);
  }
  async function isInventoryPanelOpen() {
    return isModalOpenAsync(INVENTORY_MODAL_ID);
  }
  async function waitInventoryPanelClosed(timeoutMs = 12e4) {
    return waitModalClosed(INVENTORY_MODAL_ID, timeoutMs);
  }
  async function fakeInventoryShow(payload, opts) {
    const shouldOpen = opts?.open !== false;
    await fakeShow(SHARED_MYDATA_PATCH, { inventory: payload }, {
      openGate: false,
      autoRestoreMs: opts?.autoRestoreMs
    });
    await fakeShow(INVENTORY_ATOM_PATCH, payload, {
      openGate: false,
      autoRestoreMs: opts?.autoRestoreMs
    });
    if (shouldOpen) await openInventoryPanel();
  }
  async function fakeInventoryHide() {
    await fakeHide(INVENTORY_ATOM_PATCH.label);
    await fakeHide(SHARED_MYDATA_PATCH.label);
    await closeInventoryPanel();
  }
  var JOURNAL_MODAL_ID = "journal";
  async function openJournalModal() {
    return openModal(JOURNAL_MODAL_ID);
  }
  async function isJournalModalOpen() {
    return isModalOpenAsync(JOURNAL_MODAL_ID);
  }
  async function waitJournalModalClosed(timeoutMs = 12e4) {
    return waitModalClosed(JOURNAL_MODAL_ID, timeoutMs);
  }
  async function fakeJournalShow(payload, opts) {
    const shouldOpen = opts?.open !== false;
    await fakeHide(INVENTORY_ATOM_PATCH.label);
    await fakeShow(SHARED_MYDATA_PATCH, { journal: payload ?? {} }, {
      openGate: false,
      autoRestoreMs: opts?.autoRestoreMs
    });
    if (shouldOpen) await openJournalModal();
  }

  // src/ui/menu.ts
  var Menu = class {
    constructor(opts = {}) {
      this.opts = opts;
      // NOTE: je rends root public pour pouvoir faire ui.root.appendChild(...) côté menus
      __publicField(this, "root");
      __publicField(this, "tabBar");
      __publicField(this, "views");
      __publicField(this, "tabs", /* @__PURE__ */ new Map());
      __publicField(this, "events", /* @__PURE__ */ new Map());
      __publicField(this, "currentId", null);
      __publicField(this, "lsKeyActive");
      __publicField(this, "_altDown", false);
      __publicField(this, "_insertDown", false);
      __publicField(this, "_hovering", false);
      __publicField(this, "_onKey", (e) => {
        if (e.code === "Insert" || e.key === "Insert") {
          this._insertDown = e.type === "keydown";
        }
        const alt = e.altKey || this._insertDown;
        if (alt !== this._altDown) {
          this._altDown = alt;
          this._updateAltCursor();
        }
      });
      __publicField(this, "_onBlur", () => {
        this._altDown = false;
        this._insertDown = false;
        this._updateAltCursor();
      });
      __publicField(this, "_onEnter", () => {
        this._hovering = true;
        this._updateAltCursor();
      });
      __publicField(this, "_onLeave", () => {
        this._hovering = false;
        this._updateAltCursor();
      });
      this.lsKeyActive = `menu:${opts.id || "default"}:activeTab`;
    }
    /** Monte le menu dans un conteneur */
    mount(container) {
      this.ensureStyles();
      container.innerHTML = "";
      this.root = el("div", `qmm ${this.opts.classes || ""} ${this.opts.compact ? "qmm-compact" : ""}`);
      if (this.opts.startHidden) this.root.style.display = "none";
      this.tabBar = el("div", "qmm-tabs");
      this.views = el("div", "qmm-views");
      this.root.appendChild(this.tabBar);
      this.root.appendChild(this.views);
      container.appendChild(this.root);
      if (this.tabs.size) {
        for (const [id, def] of this.tabs) this.createTabView(id, def);
        this.restoreActive();
      }
      this.updateTabsBarVisibility();
      this.root.addEventListener("pointerenter", this._onEnter);
      this.root.addEventListener("pointerleave", this._onLeave);
      window.addEventListener("keydown", this._onKey, true);
      window.addEventListener("keyup", this._onKey, true);
      window.addEventListener("blur", this._onBlur);
      document.addEventListener("visibilitychange", this._onBlur);
      if (this.opts.startWindowHidden) this.setWindowVisible(false);
      this.emit("mounted");
    }
    /** Démonte le menu (optionnel) */
    unmount() {
      this.root?.removeEventListener("pointerenter", this._onEnter);
      this.root?.removeEventListener("pointerleave", this._onLeave);
      window.removeEventListener("keydown", this._onKey, true);
      window.removeEventListener("keyup", this._onKey, true);
      window.removeEventListener("blur", this._onBlur);
      document.removeEventListener("visibilitychange", this._onBlur);
      if (this.root?.parentElement) this.root.parentElement.removeChild(this.root);
      this.emit("unmounted");
    }
    /** Retourne l'élément fenêtre englobant (barre – / ×) */
    getWindowEl() {
      if (!this.root) return null;
      const sel = this.opts.windowSelector || ".qws-win";
      return this.root.closest(sel);
    }
    /** Affiche/masque la FENÊTRE (barre incluse) */
    setWindowVisible(visible) {
      const win = this.getWindowEl();
      if (!win) return;
      win.classList.toggle("is-hidden", !visible);
      this.emit(visible ? "window:show" : "window:hide");
    }
    /** Bascule l’état de la fenêtre. Retourne true si maintenant visible. */
    toggleWindow() {
      const win = this.getWindowEl();
      if (!win) return false;
      const willShow = win.classList.contains("is-hidden");
      this.setWindowVisible(willShow);
      return willShow;
    }
    /** Donne l’état courant de la fenêtre (true = visible) */
    isWindowVisible() {
      const win = this.getWindowEl();
      if (!win) return true;
      return !win.classList.contains("is-hidden") && getComputedStyle(win).display !== "none";
    }
    /** Affiche/masque le root */
    setVisible(visible) {
      if (!this.root) return;
      this.root.style.display = visible ? "" : "none";
      this.emit(visible ? "show" : "hide");
    }
    toggle() {
      if (!this.root) return false;
      const v = this.root.style.display === "none";
      this.setVisible(v);
      return v;
    }
    /** Ajoute un onglet (peut être appelé avant ou après mount) */
    addTab(id, title, render) {
      this.tabs.set(id, { title, render, badge: null });
      if (this.root) {
        this.createTabView(id, this.tabs.get(id));
        this.updateTabsBarVisibility();
      }
      return this;
    }
    /** Ajoute plusieurs onglets en une fois */
    addTabs(defs) {
      defs.forEach((d) => this.addTab(d.id, d.title, d.render));
      return this;
    }
    /** Met à jour le titre de l’onglet (ex: compteur, libellé) */
    setTabTitle(id, title) {
      const def = this.tabs.get(id);
      if (!def) return;
      def.title = title;
      if (def.btn) {
        const label2 = def.btn.querySelector(".label");
        if (label2) label2.textContent = title;
      }
    }
    /** Ajoute/retire un badge à droite du titre (ex: “3”, “NEW”, “!”) */
    setTabBadge(id, text) {
      const def = this.tabs.get(id);
      if (!def || !def.btn) return;
      if (!def.badge) {
        def.badge = document.createElement("span");
        def.badge.className = "badge";
        def.btn.appendChild(def.badge);
      }
      if (text == null || text === "") {
        def.badge.style.display = "none";
      } else {
        def.badge.textContent = text;
        def.badge.style.display = "";
      }
    }
    /** Force le re-render d’un onglet (ré-exécute son render) */
    refreshTab(id) {
      const def = this.tabs.get(id);
      if (!def?.view) return;
      const scroller = this.findScrollableAncestor(def.view);
      const st = scroller ? scroller.scrollTop : null;
      const sl = scroller ? scroller.scrollLeft : null;
      const activeId = document.activeElement?.id || null;
      def.view.innerHTML = "";
      try {
        def.render(def.view, this);
      } catch (e) {
        def.view.textContent = String(e);
      }
      if (this.currentId === id) this.switchTo(id);
      this.emit("tab:render", id);
      if (scroller && st != null) {
        requestAnimationFrame(() => {
          try {
            scroller.scrollTop = st;
            scroller.scrollLeft = sl ?? 0;
          } catch {
          }
          if (activeId) {
            const n = document.getElementById(activeId);
            if (n && n.focus) try {
              n.focus();
            } catch {
            }
          }
        });
      }
    }
    findScrollableAncestor(start) {
      function isScrollable(el3) {
        const s = getComputedStyle(el3);
        const oy = s.overflowY || s.overflow;
        return /(auto|scroll)/.test(oy) && el3.scrollHeight > el3.clientHeight;
      }
      let el2 = start;
      while (el2) {
        if (isScrollable(el2)) return el2;
        el2 = el2.parentElement;
      }
      return document.querySelector(".qws-win");
    }
    firstTabId() {
      const it = this.tabs.keys().next();
      return it.done ? null : it.value ?? null;
    }
    _updateAltCursor() {
      if (!this.root) return;
      this.root.classList.toggle("qmm-alt-drag", this._altDown && this._hovering);
    }
    /** Récupère la vue DOM d’un onglet (pratique pour updates ciblées) */
    getTabView(id) {
      return this.tabs.get(id)?.view ?? null;
    }
    /** Retire un onglet */
    removeTab(id) {
      const def = this.tabs.get(id);
      if (!def) return;
      this.tabs.delete(id);
      const btn = this.tabBar?.querySelector(`button[data-id="${cssq(id)}"]`);
      if (btn && btn.parentElement) btn.parentElement.removeChild(btn);
      if (def.view && def.view.parentElement) def.view.parentElement.removeChild(def.view);
      if (this.currentId === id) {
        const first = this.tabs.keys().next().value || null;
        this.switchTo(first);
      }
      this.updateTabsBarVisibility();
    }
    /** Active un onglet (id=null => affiche toutes les vues) */
    switchTo(id) {
      this.currentId = id;
      [...this.tabBar.children].forEach((ch) => ch.classList.toggle("active", ch.dataset.id === id || id === null));
      [...this.views.children].forEach((ch) => ch.classList.toggle("active", ch.dataset.id === id || id === null));
      this.persistActive();
      this.emit("tab:change", id);
    }
    /** Événements */
    on(event, handler) {
      if (!this.events.has(event)) this.events.set(event, /* @__PURE__ */ new Set());
      this.events.get(event).add(handler);
      return () => this.off(event, handler);
    }
    off(event, handler) {
      this.events.get(event)?.delete(handler);
    }
    emit(event, ...args) {
      this.events.get(event)?.forEach((h) => {
        try {
          h(...args);
        } catch {
        }
      });
    }
    // ---------- Helpers UI publics (réutilisables dans tes tabs) ----------
    btn(label2, onClickOrOpts) {
      const opts = typeof onClickOrOpts === "function" ? { onClick: onClickOrOpts } : { ...onClickOrOpts || {} };
      const b = el("button", "qmm-btn");
      b.type = "button";
      let iconEl = null;
      if (opts.icon) {
        iconEl = typeof opts.icon === "string" ? document.createElement("span") : opts.icon;
        if (typeof opts.icon === "string" && iconEl) {
          iconEl.textContent = opts.icon;
        }
        if (iconEl) {
          iconEl.classList.add("qmm-btn__icon");
        }
      }
      const trimmedLabel = (label2 ?? "").trim();
      const shouldRenderLabel = !iconEl || trimmedLabel.length > 0;
      const labelSpan = shouldRenderLabel ? document.createElement("span") : null;
      if (labelSpan) {
        labelSpan.className = "label";
        labelSpan.textContent = label2;
      }
      if (iconEl) {
        if (trimmedLabel.length === 0) {
          b.classList.add("qmm-btn--icon");
        }
        if (opts.iconPosition === "right") {
          iconEl.classList.add("is-right");
          if (labelSpan) b.append(labelSpan);
          b.append(iconEl);
        } else {
          iconEl.classList.add("is-left");
          b.append(iconEl);
          if (labelSpan) b.append(labelSpan);
        }
      } else {
        if (labelSpan) b.append(labelSpan);
      }
      const variant = opts.variant && opts.variant !== "default" ? opts.variant : null;
      if (variant) b.classList.add(`qmm-btn--${variant}`);
      if (opts.fullWidth) b.classList.add("qmm-btn--full");
      if (opts.size === "sm") b.classList.add("qmm-btn--sm");
      if (opts.active) b.classList.add("active");
      if (opts.tooltip || opts.title) b.title = opts.tooltip || opts.title || "";
      if (opts.ariaLabel) b.setAttribute("aria-label", opts.ariaLabel);
      if (opts.onClick) b.addEventListener("click", opts.onClick);
      if (opts.disabled) this.setButtonEnabled(b, false);
      b.setEnabled = (enabled) => this.setButtonEnabled(b, enabled);
      b.setActive = (active) => b.classList.toggle("active", !!active);
      return b;
    }
    setButtonEnabled(button, enabled) {
      button.disabled = !enabled;
      button.classList.toggle("is-disabled", !enabled);
      button.setAttribute("aria-disabled", (!enabled).toString());
    }
    flexRow(opts = {}) {
      const row = document.createElement("div");
      row.className = ["qmm-flex", opts.className || ""].filter(Boolean).join(" ").trim();
      row.style.display = "flex";
      row.style.alignItems = this.mapAlign(opts.align ?? "center");
      row.style.justifyContent = this.mapJustify(opts.justify ?? "start");
      row.style.gap = `${opts.gap ?? 8}px`;
      row.style.flexWrap = opts.wrap === false ? "nowrap" : "wrap";
      if (opts.fullWidth) row.style.width = "100%";
      return row;
    }
    formGrid(opts = {}) {
      const grid = document.createElement("div");
      grid.className = "qmm-form-grid";
      grid.style.display = "grid";
      grid.style.gridTemplateColumns = opts.columns || "max-content 1fr";
      grid.style.columnGap = `${opts.columnGap ?? 8}px`;
      grid.style.rowGap = `${opts.rowGap ?? 8}px`;
      grid.style.alignItems = opts.align ? opts.align : "center";
      return grid;
    }
    formRow(labelText, control, opts = {}) {
      const wrap = document.createElement("div");
      wrap.className = "qmm-form-row";
      wrap.style.display = "grid";
      wrap.style.gridTemplateColumns = `${opts.labelWidth || "160px"} 1fr`;
      wrap.style.columnGap = `${opts.gap ?? 10}px`;
      wrap.style.alignItems = opts.alignTop ? "start" : "center";
      if (opts.wrap) wrap.classList.add("is-wrap");
      const lab = this.label(labelText);
      lab.classList.add("qmm-form-row__label");
      lab.style.margin = "0";
      lab.style.justifySelf = "start";
      if (opts.alignTop) lab.style.alignSelf = "start";
      wrap.append(lab, control);
      return { root: wrap, label: lab };
    }
    card(title, opts = {}) {
      const root = document.createElement("div");
      root.className = "qmm-card";
      root.dataset.tone = opts.tone || "default";
      if (opts.align === "center") root.classList.add("is-center");
      if (opts.align === "stretch") root.classList.add("is-stretch");
      if (opts.padding) root.style.padding = opts.padding;
      if (opts.gap != null) root.style.gap = `${opts.gap}px`;
      if (opts.maxWidth) {
        const max = typeof opts.maxWidth === "number" ? `${opts.maxWidth}px` : opts.maxWidth;
        root.style.width = `min(${max}, 100%)`;
      }
      const header = document.createElement("div");
      header.className = "qmm-card__header";
      if (opts.compactHeader) header.classList.add("is-compact");
      const titleWrap = document.createElement("div");
      titleWrap.className = "qmm-card__title";
      titleWrap.textContent = title;
      if (opts.icon) {
        const icon = typeof opts.icon === "string" ? document.createElement("span") : opts.icon;
        if (typeof opts.icon === "string" && icon) icon.textContent = opts.icon;
        if (icon) {
          icon.classList.add("qmm-card__icon");
          header.appendChild(icon);
        }
      }
      header.appendChild(titleWrap);
      if (opts.subtitle || opts.description) {
        const sub = document.createElement("div");
        sub.className = "qmm-card__subtitle";
        sub.textContent = opts.subtitle || opts.description || "";
        header.appendChild(sub);
      }
      if (opts.actions?.length) {
        const actions = document.createElement("div");
        actions.className = "qmm-card__actions";
        opts.actions.forEach((a) => actions.appendChild(a));
        header.appendChild(actions);
      }
      const body = document.createElement("div");
      body.className = "qmm-card__body";
      root.append(header, body);
      return {
        root,
        header,
        body,
        setTitle(next) {
          titleWrap.textContent = next;
        }
      };
    }
    toggleChip(labelText, opts = {}) {
      const wrap = document.createElement("label");
      wrap.className = "qmm-chip-toggle";
      if (opts.tooltip) wrap.title = opts.tooltip;
      const input = document.createElement("input");
      input.type = opts.type || "checkbox";
      if (opts.name) input.name = opts.name;
      if (opts.value) input.value = opts.value;
      input.checked = !!opts.checked;
      const face = document.createElement("div");
      face.className = "qmm-chip-toggle__face";
      if (opts.icon) {
        const icon = typeof opts.icon === "string" ? document.createElement("span") : opts.icon;
        if (typeof opts.icon === "string" && icon) icon.textContent = opts.icon;
        if (icon) {
          icon.classList.add("qmm-chip-toggle__icon");
          face.appendChild(icon);
        }
      }
      const labelEl = document.createElement("span");
      labelEl.className = "qmm-chip-toggle__label";
      labelEl.textContent = labelText;
      face.appendChild(labelEl);
      if (opts.description) {
        const desc = document.createElement("span");
        desc.className = "qmm-chip-toggle__desc";
        desc.textContent = opts.description;
        face.appendChild(desc);
      }
      if (opts.badge) {
        const badge = document.createElement("span");
        badge.className = "qmm-chip-toggle__badge";
        badge.textContent = opts.badge;
        face.appendChild(badge);
      }
      wrap.append(input, face);
      return { root: wrap, input, label: labelEl };
    }
    select(opts = {}) {
      const sel = document.createElement("select");
      sel.className = "qmm-input qmm-select";
      if (opts.id) sel.id = opts.id;
      if (opts.width) sel.style.minWidth = opts.width;
      if (opts.placeholder) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = opts.placeholder;
        opt.disabled = true;
        opt.selected = true;
        sel.appendChild(opt);
      }
      return sel;
    }
    errorBar() {
      const el2 = document.createElement("div");
      el2.className = "qmm-error";
      el2.style.display = "none";
      return {
        el: el2,
        show(message) {
          el2.textContent = message;
          el2.style.display = "block";
        },
        clear() {
          el2.textContent = "";
          el2.style.display = "none";
        }
      };
    }
    mapAlign(al) {
      if (al === "start") return "flex-start";
      if (al === "end") return "flex-end";
      if (al === "stretch") return "stretch";
      return "center";
    }
    mapJustify(j) {
      if (j === "center") return "center";
      if (j === "end") return "flex-end";
      if (j === "between") return "space-between";
      if (j === "around") return "space-around";
      return "flex-start";
    }
    label(text) {
      const l = el("label", "qmm-label");
      l.textContent = text;
      return l;
    }
    row(...children) {
      const r = el("div", "qmm-row");
      children.forEach((c) => r.appendChild(c));
      return r;
    }
    section(title) {
      const s = el("div", "qmm-section");
      s.appendChild(el("div", "qmm-section-title", escapeHtml(title)));
      return s;
    }
    inputNumber(min = 0, max = 9999, step = 1, value = 0) {
      const wrap = el("div", "qmm-input-number");
      const i = el("input", "qmm-input qmm-input-number-input");
      i.type = "number";
      i.min = String(min);
      i.max = String(max);
      i.step = String(step);
      i.value = String(value);
      i.inputMode = "numeric";
      const spin = el("div", "qmm-spin");
      const up = el("button", "qmm-step qmm-step--up", "\u25B2");
      const down = el("button", "qmm-step qmm-step--down", "\u25BC");
      up.type = down.type = "button";
      const clamp4 = () => {
        const n = Number(i.value);
        if (Number.isFinite(n)) {
          const lo = Number(i.min), hi = Number(i.max);
          const clamped = Math.max(lo, Math.min(hi, n));
          if (clamped !== n) i.value = String(clamped);
        }
      };
      const bump = (dir) => {
        if (dir < 0) i.stepDown();
        else i.stepUp();
        clamp4();
        i.dispatchEvent(new Event("input", { bubbles: true }));
        i.dispatchEvent(new Event("change", { bubbles: true }));
      };
      const addSpin = (btn, dir) => {
        let pressTimer = null;
        let repeatTimer = null;
        let suppressNextClick = false;
        const start = (ev) => {
          suppressNextClick = false;
          pressTimer = window.setTimeout(() => {
            suppressNextClick = true;
            bump(dir);
            repeatTimer = window.setInterval(() => bump(dir), 60);
          }, 300);
          btn.setPointerCapture?.(ev.pointerId);
        };
        const stop = () => {
          if (pressTimer != null) {
            clearTimeout(pressTimer);
            pressTimer = null;
          }
          if (repeatTimer != null) {
            clearInterval(repeatTimer);
            repeatTimer = null;
          }
        };
        btn.addEventListener("pointerdown", start);
        ["pointerup", "pointercancel", "pointerleave", "blur"].forEach(
          (ev) => btn.addEventListener(ev, stop)
        );
        btn.addEventListener("click", (e) => {
          if (suppressNextClick) {
            e.preventDefault();
            e.stopPropagation();
            suppressNextClick = false;
            return;
          }
          bump(dir);
        });
      };
      addSpin(up, 1);
      addSpin(down, -1);
      i.addEventListener("change", clamp4);
      spin.append(up, down);
      wrap.append(i, spin);
      i.wrap = wrap;
      return i;
    }
    inputText(placeholder = "", value = "") {
      const i = el("input", "qmm-input");
      i.type = "text";
      i.placeholder = placeholder;
      i.value = value;
      return i;
    }
    checkbox(checked = false) {
      const i = el("input", "qmm-check");
      i.type = "checkbox";
      i.checked = checked;
      return i;
    }
    radio(name, value, checked = false) {
      const i = el("input", "qmm-radio");
      i.type = "radio";
      i.name = name;
      i.value = value;
      i.checked = checked;
      return i;
    }
    slider(min = 0, max = 100, step = 1, value = 0) {
      const i = el("input", "qmm-range");
      i.type = "range";
      i.min = String(min);
      i.max = String(max);
      i.step = String(step);
      i.value = String(value);
      return i;
    }
    rangeDual(min = 0, max = 100, step = 1, valueMin = min, valueMax = max) {
      const wrap = el("div", "qmm-range-dual");
      const track = el("div", "qmm-range-dual-track");
      const fill = el("div", "qmm-range-dual-fill");
      track.appendChild(fill);
      wrap.appendChild(track);
      const createHandle = (value, extraClass) => {
        const input = this.slider(min, max, step, value);
        input.classList.add("qmm-range-dual-input", extraClass);
        wrap.appendChild(input);
        return input;
      };
      const minInput = createHandle(valueMin, "qmm-range-dual-input--min");
      const maxInput = createHandle(valueMax, "qmm-range-dual-input--max");
      const updateFill = () => {
        const minValue = Number(minInput.value);
        const maxValue = Number(maxInput.value);
        const total = max - min;
        if (!Number.isFinite(total) || total <= 0) {
          fill.style.left = "0%";
          fill.style.right = "100%";
          return;
        }
        const clampPercent3 = (value) => Math.max(0, Math.min(100, value));
        const start = (Math.min(minValue, maxValue) - min) / total * 100;
        const end = (Math.max(minValue, maxValue) - min) / total * 100;
        fill.style.left = `${clampPercent3(start)}%`;
        fill.style.right = `${clampPercent3(100 - end)}%`;
      };
      minInput.addEventListener("input", updateFill);
      maxInput.addEventListener("input", updateFill);
      const handle = {
        root: wrap,
        min: minInput,
        max: maxInput,
        setValues(minValue, maxValue) {
          minInput.value = String(minValue);
          maxInput.value = String(maxValue);
          updateFill();
        },
        refresh: updateFill
      };
      handle.refresh();
      return handle;
    }
    switch(checked = false) {
      const i = this.checkbox(checked);
      i.classList.add("qmm-switch");
      return i;
    }
    // Helpers “tableau simple” pour lister les items
    table(headers, opts) {
      const wrap = document.createElement("div");
      wrap.className = "qmm-table-wrap";
      if (opts?.minimal) wrap.classList.add("qmm-table-wrap--minimal");
      const scroller = document.createElement("div");
      scroller.className = "qmm-table-scroll";
      if (opts?.maxHeight) scroller.style.maxHeight = opts.maxHeight;
      wrap.appendChild(scroller);
      const t = document.createElement("table");
      t.className = "qmm-table";
      if (opts?.minimal) t.classList.add("qmm-table--minimal");
      if (opts?.compact) t.classList.add("qmm-table--compact");
      if (opts?.fixed) t.style.tableLayout = "fixed";
      const thead = document.createElement("thead");
      const trh = document.createElement("tr");
      headers.forEach((h) => {
        const th = document.createElement("th");
        if (typeof h === "string") {
          th.textContent = h;
        } else {
          th.textContent = h.label ?? "";
          if (h.align) th.classList.add(`is-${h.align}`);
          if (h.width) th.style.width = h.width;
        }
        trh.appendChild(th);
      });
      thead.appendChild(trh);
      const tbody = document.createElement("tbody");
      t.append(thead, tbody);
      scroller.appendChild(t);
      return { root: wrap, tbody };
    }
    segmented(items, selected, onChange, opts) {
      const root = document.createElement("div");
      root.className = "qmm-seg";
      if (opts?.fullWidth) root.classList.add("qmm-seg--full");
      if (opts?.id) root.id = opts.id;
      root.setAttribute("role", "radiogroup");
      if (opts?.ariaLabel) root.setAttribute("aria-label", opts.ariaLabel);
      const rail = document.createElement("div");
      rail.className = "qmm-seg__indicator";
      root.appendChild(rail);
      const reduceMotionQuery = typeof window !== "undefined" && "matchMedia" in window ? window.matchMedia("(prefers-reduced-motion: reduce)") : null;
      const canAnimateIndicator = typeof rail.animate === "function";
      if (canAnimateIndicator) {
        rail.style.transition = "none";
      }
      let indicatorMetrics = null;
      let indicatorAnimation = null;
      const applyIndicatorStyles = (left, width) => {
        rail.style.transform = `translate3d(${left}px,0,0)`;
        rail.style.width = `${width}px`;
      };
      const cancelIndicatorAnimation = () => {
        if (!indicatorAnimation) return;
        indicatorAnimation.cancel();
        indicatorAnimation = null;
      };
      let value = selected;
      const btns = [];
      const setSelected = (v, focus = false) => {
        if (v === value) {
          if (focus) {
            const alreadyActive = btns.find((b) => b.dataset.value === v);
            alreadyActive?.focus();
          }
          onChange?.(value);
          return;
        }
        value = v;
        for (const b of btns) {
          const active = b.dataset.value === v;
          b.setAttribute("aria-checked", active ? "true" : "false");
          b.tabIndex = active ? 0 : -1;
          b.classList.toggle("active", active);
          if (active && focus) b.focus();
        }
        moveIndicator(true);
        onChange?.(value);
      };
      const moveIndicator = (animate = false) => {
        const active = btns.find((b) => b.dataset.value === value);
        if (!active) return;
        const i = btns.indexOf(active);
        const n = btns.length;
        const cs = getComputedStyle(root);
        const gap = parseFloat(cs.gap || cs.columnGap || "0") || 0;
        const bL = parseFloat(cs.borderLeftWidth || "0") || 0;
        const bR = parseFloat(cs.borderRightWidth || "0") || 0;
        const rRoot = root.getBoundingClientRect();
        const rBtn = active.getBoundingClientRect();
        let left = rBtn.left - rRoot.left - bL;
        let width = rBtn.width;
        const padW = rRoot.width - bL - bR;
        if (n === 1) {
          left = 0;
          width = padW;
        } else if (i === 0) {
          const rightEdge = left + width + gap / 2;
          left = 0;
          width = rightEdge - left;
        } else if (i === n - 1) {
          left = left - gap / 2;
          width = padW - left;
        } else {
          left = left - gap / 2;
          width = width + gap;
        }
        const dpr = window.devicePixelRatio || 1;
        const snap = (x) => Math.round(x * dpr) / dpr;
        const targetLeft = snap(left);
        const targetWidth = snap(width);
        const previous = indicatorMetrics;
        indicatorMetrics = { left: targetLeft, width: targetWidth };
        const applyFinal = () => applyIndicatorStyles(targetLeft, targetWidth);
        const shouldAnimate = animate && canAnimateIndicator && !reduceMotionQuery?.matches && previous != null && previous.width > 0 && Number.isFinite(previous.width) && targetWidth > 0 && Number.isFinite(targetWidth);
        if (!shouldAnimate) {
          cancelIndicatorAnimation();
          applyFinal();
          return;
        }
        cancelIndicatorAnimation();
        applyIndicatorStyles(previous.left, previous.width);
        indicatorAnimation = rail.animate(
          [
            {
              transform: `translate3d(${previous.left}px,0,0)`,
              width: `${previous.width}px`,
              opacity: 0.92,
              offset: 0
            },
            {
              transform: `translate3d(${targetLeft}px,0,0)`,
              width: `${targetWidth}px`,
              opacity: 1,
              offset: 1
            }
          ],
          {
            duration: 260,
            easing: "cubic-bezier(.22,.7,.28,1)",
            fill: "forwards"
          }
        );
        const finalize = () => {
          applyFinal();
          indicatorAnimation = null;
        };
        indicatorAnimation.addEventListener("finish", finalize, { once: true });
        indicatorAnimation.addEventListener("cancel", finalize, { once: true });
      };
      items.forEach(({ value: v, label: label2, disabled }) => {
        const b = document.createElement("button");
        b.type = "button";
        b.className = "qmm-seg__btn";
        b.dataset.value = String(v);
        b.setAttribute("role", "radio");
        b.setAttribute("aria-checked", v === selected ? "true" : "false");
        b.tabIndex = v === selected ? 0 : -1;
        b.disabled = !!disabled;
        const labelSpan = document.createElement("span");
        labelSpan.className = "qmm-seg__btn-label";
        labelSpan.textContent = label2;
        b.appendChild(labelSpan);
        b.addEventListener("click", () => {
          if (!b.disabled) setSelected(v, false);
        });
        b.addEventListener("keydown", (e) => {
          if (!["ArrowRight", "ArrowLeft", "Home", "End"].includes(e.key)) return;
          e.preventDefault();
          const idx = items.findIndex((it) => it.value === value);
          if (e.key === "Home") {
            setSelected(items[0].value, true);
            return;
          }
          if (e.key === "End") {
            setSelected(items[items.length - 1].value, true);
            return;
          }
          const dir = e.key === "ArrowRight" ? 1 : -1;
          let j = idx;
          for (let k = 0; k < items.length; k++) {
            j = (j + dir + items.length) % items.length;
            if (!items[j].disabled) {
              setSelected(items[j].value, true);
              break;
            }
          }
        });
        btns.push(b);
        root.appendChild(b);
      });
      const ro = window.ResizeObserver ? new ResizeObserver(() => moveIndicator(false)) : null;
      if (ro) ro.observe(root);
      window.addEventListener("resize", () => moveIndicator(false));
      queueMicrotask(() => moveIndicator(false));
      root.get = () => value;
      root.set = (v) => setSelected(v, false);
      return root;
    }
    radioGroup(name, options, selected, onChange) {
      const wrap = el("div", "qmm-radio-group");
      for (const { value, label: label2 } of options) {
        const r = this.radio(name, value, selected === value);
        const lab = document.createElement("label");
        lab.className = "qmm-radio-label";
        lab.appendChild(r);
        lab.appendChild(document.createTextNode(label2));
        r.onchange = () => {
          if (r.checked) onChange(value);
        };
        wrap.appendChild(lab);
      }
      return wrap;
    }
    /** Bind LS: sauvegarde automatique via toStr/parse */
    bindLS(key2, read, write, parse, toStr) {
      try {
        const raw = localStorage.getItem(key2);
        if (raw != null) write(parse(raw));
      } catch {
      }
      return { save: () => {
        try {
          localStorage.setItem(key2, toStr(read()));
        } catch {
        }
      } };
    }
    /* -------------------------- split2 helper -------------------------- */
    /** Crée un layout 2 colonnes (gauche/droite) en CSS Grid.
     *  leftWidth: ex "200px" | "18rem" | "minmax(160px, 30%)" */
    split2(leftWidth = "260px") {
      const root = el("div", "qmm-split");
      root.style.gridTemplateColumns = "minmax(160px, max-content) 1fr";
      const left = el("div", "qmm-split-left");
      const right = el("div", "qmm-split-right");
      root.appendChild(left);
      root.appendChild(right);
      return { root, left, right };
    }
    /* -------------------------- VTabs factory -------------------------- */
    /** Crée des “tabs verticaux” génériques (liste sélectionnable + filtre). */
    vtabs(options = {}) {
      return new VTabs(this, options);
    }
    hotkeyButton(initial, onChange, opts) {
      const emptyLabel = opts?.emptyLabel ?? "None";
      const listeningLabel = opts?.listeningLabel ?? "Press a key\u2026";
      const clearable = opts?.clearable ?? true;
      let hk = initial ?? null;
      let recording = false;
      if (opts?.storageKey) {
        try {
          hk = stringToHotkey(localStorage.getItem(opts.storageKey) || "") ?? initial ?? null;
        } catch {
        }
      }
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "qmm-hotkey";
      btn.setAttribute("aria-live", "polite");
      const render = () => {
        btn.classList.toggle("is-recording", recording);
        btn.classList.toggle("is-empty", !hk);
        btn.classList.toggle("is-assigned", !recording && !!hk);
        if (recording) {
          btn.textContent = listeningLabel;
          btn.title = "Listening\u2026 press a key (Esc to cancel, Backspace to clear)";
        } else if (!hk) {
          btn.textContent = emptyLabel;
          btn.title = "No key assigned";
        } else {
          btn.textContent = hotkeyToPretty(hk);
          btn.title = "Click to rebind \u2022 Right-click to clear";
        }
      };
      const applyHotkey = (value, skipRender = false) => {
        hk = value ? { ...value } : null;
        if (!skipRender) render();
      };
      btn.refreshHotkey = (value) => {
        applyHotkey(value);
      };
      const stopRecording = (commit) => {
        recording = false;
        if (!commit) {
          render();
          return;
        }
        render();
      };
      const save = () => {
        if (opts?.storageKey) {
          const str = hotkeyToString(hk);
          try {
            if (str) localStorage.setItem(opts.storageKey, str);
            else localStorage.removeItem(opts.storageKey);
          } catch {
          }
        }
        onChange?.(hk, opts?.storageKey ? hotkeyToString(hk) : void 0);
      };
      const handleKeyDown = (e) => {
        if (!recording) return;
        e.preventDefault();
        e.stopPropagation();
        if (e.key === "Escape") {
          stopRecording(false);
          window.removeEventListener("keydown", handleKeyDown, true);
          return;
        }
        if ((e.key === "Backspace" || e.key === "Delete") && clearable) {
          applyHotkey(null, true);
          save();
          stopRecording(true);
          window.removeEventListener("keydown", handleKeyDown, true);
          return;
        }
        const next = eventToHotkey(e, opts?.allowModifierOnly ?? false);
        if (!next) {
          return;
        }
        applyHotkey(next, true);
        save();
        stopRecording(true);
        window.removeEventListener("keydown", handleKeyDown, true);
      };
      btn.addEventListener("click", (e) => {
        e.preventDefault();
        if (!recording) {
          recording = true;
          render();
          window.addEventListener("keydown", handleKeyDown, true);
          btn.focus();
        }
      });
      if (clearable) {
        btn.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          if (hk) {
            applyHotkey(null, true);
            save();
            render();
          }
        });
      }
      render();
      return btn;
    }
    // ---------- internes ----------
    createTabView(id, def) {
      const b = document.createElement("button");
      b.className = "qmm-tab";
      b.dataset.id = id;
      b.innerHTML = `<span class="label">${escapeHtml(def.title)}</span><span class="badge" style="display:none"></span>`;
      const badgeEl = b.querySelector(".badge");
      def.btn = b;
      def.badge = badgeEl;
      b.onclick = () => this.switchTo(id);
      this.tabBar.appendChild(b);
      const view = el("div", "qmm-view");
      view.dataset.id = id;
      def.view = view;
      this.views.appendChild(view);
      try {
        def.render(view, this);
      } catch (e) {
        view.textContent = String(e);
      }
      if (!this.currentId) this.switchTo(id);
    }
    persistActive() {
      if (!this.currentId) return;
      try {
        localStorage.setItem(this.lsKeyActive, this.currentId);
      } catch {
      }
    }
    restoreActive() {
      let id = null;
      try {
        id = localStorage.getItem(this.lsKeyActive);
      } catch {
      }
      if (id && this.tabs.has(id)) this.switchTo(id);
      else if (this.tabs.size) this.switchTo(this.firstTabId());
    }
    updateTabsBarVisibility() {
      if (!this.tabBar || !this.root) return;
      const hasTabs = this.tabs.size > 0;
      if (hasTabs) {
        if (!this.tabBar.parentElement) {
          this.root.insertBefore(this.tabBar, this.views);
        }
        this.tabBar.style.display = "flex";
        this.root.classList.remove("qmm-no-tabs");
      } else {
        if (this.tabBar.parentElement) {
          this.tabBar.parentElement.removeChild(this.tabBar);
        }
        this.root.classList.add("qmm-no-tabs");
      }
    }
    ensureStyles() {
      if (document.getElementById("__qmm_css__")) return;
      const css = `
    /* ================= Modern UI for qmm ================= */
.qmm{
  --qmm-bg:        #0f1318;
  --qmm-bg-soft:   #0b0f13;
  --qmm-panel:     #111823cc;
  --qmm-border:    #ffffff22;
  --qmm-border-2:  #ffffff14;
  --qmm-accent:    #7aa2ff;
  --qmm-accent-2:  #92b2ff;
  --qmm-text:      #e7eef7;
  --qmm-text-dim:  #b9c3cf;
  --qmm-shadow:    0 6px 20px rgba(0,0,0,.35);
  --qmm-blur:      8px;

  display:flex; flex-direction:column; gap:10px; color:var(--qmm-text);
}
.qmm-compact{ gap:6px }

/* ---------- Tabs (pill + underline) ---------- */
.qmm-tabs{
  display:flex; gap:6px; flex-wrap:wrap; align-items:flex-end;
  padding:0 6px 2px 6px; position:relative; isolation:isolate;
  border-bottom:1px solid var(--qmm-border);
  background:linear-gradient(180deg, rgba(255,255,255,.04), transparent);
  border-top-left-radius:10px; border-top-right-radius:10px;
}
.qmm-no-tabs .qmm-views{ margin-top:0 }

.qmm-tab{
  flex:1 1 0; min-width:0; cursor:pointer;
  display:inline-flex; justify-content:center; align-items:center; gap:8px;
  padding:8px 12px; color:var(--qmm-text);
  background:transparent; border:1px solid transparent; border-bottom:none;
  border-top-left-radius:10px; border-top-right-radius:10px;
  position:relative; margin:0; margin-bottom:-1px;
  transition:background .18s ease, color .18s ease, box-shadow .18s ease, transform .12s ease;
}
.qmm-compact .qmm-tab{ padding:6px 10px }
.qmm-tab:hover{ background:rgba(255,255,255,.06) }
.qmm-tab:active{ transform:translateY(1px) }
.qmm-tab:focus-visible{ outline:2px solid var(--qmm-accent); outline-offset:2px; border-radius:10px }

.qmm-tab .badge{
  font-size:11px; line-height:1; padding:2px 6px; border-radius:999px;
  background:#ffffff1a; border:1px solid #ffffff22;
}

.qmm-tab.active{
  background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
  color:#fff; box-shadow:inset 0 -1px 0 #0007;
}
.qmm-tab.active::after{
  content:""; position:absolute; left:10%; right:10%; bottom:-1px; height:2px;
  background:linear-gradient(90deg, transparent, var(--qmm-accent), transparent);
  border-radius:2px; box-shadow:0 0 12px var(--qmm-accent-2);
}

/* ---------- Views panel ---------- */
.qmm-views{
  border:1px solid var(--qmm-border); border-radius:12px; padding:12px;
  background:var(--qmm-panel); backdrop-filter:blur(var(--qmm-blur));
  display:flex; flex-direction:column;
  min-width:0; min-height:0; overflow:auto; box-shadow:var(--qmm-shadow);
}
.qmm-compact .qmm-views{ padding:8px }
.qmm-tabs + .qmm-views{ margin-top:-1px }

.qmm-view{ display:none; min-width:0; min-height:0; }
.qmm-view.active{ display:block; }

/* ---------- Basic controls ---------- */
.qmm-row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin:6px 0 }
.qmm-section{ margin-top:8px }
.qmm-section-title{ font-weight:650; margin:2px 0 8px 0; color:var(--qmm-text) }

.qmm-label{ opacity:.9 }
.qmm-val{ min-width:24px; text-align:center }

/* Buttons */
.qmm-btn{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:8px;
  padding:8px 14px;
  border-radius:10px;
  border:1px solid var(--qmm-border);
  background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.02));
  color:var(--qmm-text);
  font-weight:600;
  font-size:13px;
  line-height:1.2;
  cursor:pointer;
  user-select:none;
  transition:background .18s ease, border-color .18s ease, transform .1s ease, box-shadow .18s ease, color .18s ease;
}
.qmm-compact .qmm-btn{ padding:6px 10px }
.qmm-btn:hover{ background:linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.04)); border-color:#ffffff3d }
.qmm-btn:active{ transform:translateY(1px) }
.qmm-btn:focus-visible{ outline:2px solid var(--qmm-accent); outline-offset:2px; }
.qmm-btn:disabled,
.qmm-btn.is-disabled{
  opacity:.55;
  cursor:not-allowed;
  filter:saturate(.6);
  box-shadow:none;
}
.qmm-btn--full{ width:100%; justify-content:center; }
.qmm-btn--sm{ padding:6px 10px; font-size:12px; border-radius:8px; }
.qmm-btn--icon{ padding:6px; width:34px; height:34px; border-radius:50%; gap:0; }
.qmm-btn__icon{ display:inline-flex; align-items:center; justify-content:center; font-size:1.1em; }
.qmm-btn__icon.is-right{ order:2; }
.qmm-btn__icon.is-left{ order:0; }

/* Button variants */
.qmm-btn--primary,
.qmm-btn.qmm-primary{
  background:linear-gradient(180deg, rgba(122,162,255,.38), rgba(122,162,255,.16));
  border-color:#9db7ff55;
  box-shadow:0 4px 14px rgba(122,162,255,.26);
}
.qmm-btn--primary:hover,
.qmm-btn.qmm-primary:hover{ border-color:#afc5ff77; }
.qmm-btn--secondary{
  background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.01));
}
.qmm-btn--danger,
.qmm-btn.qmm-danger{
  background:linear-gradient(180deg, rgba(255,86,86,.32), rgba(255,86,86,.14));
  border-color:#ff6a6a55;
  box-shadow:0 4px 14px rgba(255,86,86,.25);
}
.qmm-btn--ghost{ background:transparent; border-color:transparent; }
.qmm-btn--ghost:hover{ background:rgba(255,255,255,.06); border-color:#ffffff2a; }
.qmm-btn.active{
  background:#79a6ff22;
  border-color:#79a6ff66;
  box-shadow: inset 0 0 0 1px #79a6ff33;
}

.qmm-flex{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; }

.qmm-form-grid{ width:100%; }

.qmm-form-row{ width:100%; }
.qmm-form-row.is-wrap{ grid-template-columns:1fr; }
.qmm-form-row__label{ font-weight:600; opacity:.9; }

.qmm-card{
  display:grid;
  gap:12px;
  border:1px solid var(--qmm-border);
  border-radius:12px;
  padding:14px;
  background:var(--qmm-panel);
  backdrop-filter:blur(var(--qmm-blur));
  box-shadow:var(--qmm-shadow);
  width:100%;
}
.qmm-card.is-center{ text-align:center; align-items:center; }
.qmm-card.is-stretch{ align-items:stretch; }
.qmm-card__header{
  display:flex;
  align-items:center;
  gap:10px;
  flex-wrap:wrap;
  justify-content:space-between;
}
.qmm-card__header.is-compact{ gap:6px; }
.qmm-card__icon{ font-size:18px; }
.qmm-card__title{ font-weight:700; font-size:14px; letter-spacing:.01em; }
.qmm-card__subtitle{ font-size:12px; opacity:.75; flex-basis:100%; }
.qmm-card__actions{ display:flex; gap:6px; margin-left:auto; }
.qmm-card__body{ display:grid; gap:10px; }
.qmm-card[data-tone="muted"]{
  background:rgba(15,17,22,.88);
  border-color:#ffffff1a;
  box-shadow:none;
}
.qmm-card[data-tone="accent"]{
  border-color:#7aa2ff99;
  box-shadow:0 10px 26px rgba(122,162,255,.25);
}

.qmm .stats-collapse-toggle{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:8px;
  padding:6px 12px;
  min-height:32px;
  border-radius:999px;
  border:1px solid rgba(122,162,255,.45);
  background:linear-gradient(135deg, rgba(122,162,255,.18), rgba(33,59,121,.18));
  color:rgba(220,230,255,.92);
  font-size:12px;
  font-weight:600;
  letter-spacing:.01em;
  text-transform:uppercase;
  box-shadow:inset 0 1px 0 rgba(255,255,255,.12), 0 10px 24px rgba(9,13,27,.28);
  transition:background .26s ease, border-color .26s ease, box-shadow .26s ease, color .26s ease, transform .16s ease;
}
.qmm .stats-collapse-toggle:hover{
  background:linear-gradient(135deg, rgba(122,162,255,.28), rgba(53,94,182,.24));
  border-color:rgba(122,162,255,.62);
  color:#fff;
  box-shadow:0 14px 30px rgba(66,106,201,.32), inset 0 1px 0 rgba(255,255,255,.18);
}
.qmm .stats-collapse-toggle:active{
  transform:translateY(1px) scale(.99);
}
.qmm-card--collapsible[data-collapsed="true"] .stats-collapse-toggle{
  background:linear-gradient(135deg, rgba(122,162,255,.12), rgba(23,36,78,.12));
  border-color:rgba(122,162,255,.32);
  color:rgba(208,219,255,.82);
  box-shadow:inset 0 1px 0 rgba(255,255,255,.1), 0 6px 18px rgba(9,13,27,.22);
}
.qmm-card--collapsible[data-collapsed="false"] .stats-collapse-toggle{
  background:linear-gradient(135deg, rgba(122,162,255,.36), rgba(83,124,255,.28));
  border-color:rgba(122,162,255,.78);
  color:#fff;
  box-shadow:0 16px 32px rgba(72,112,214,.35), inset 0 1px 0 rgba(255,255,255,.22);
}
.qmm .stats-collapse-toggle__icon{
  width:16px;
  height:16px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  position:relative;
  color:inherit;
  transition:transform .24s ease;
}
.qmm .stats-collapse-toggle__icon::before{
  content:"";
  position:absolute;
  width:8px;
  height:8px;
  border-right:2px solid currentColor;
  border-bottom:2px solid currentColor;
  transform:rotate(45deg);
  transition:transform .24s ease;
}
.qmm .stats-collapse-toggle__label{
  color:inherit;
  font-size:11px;
  letter-spacing:.08em;
  font-weight:700;
}
.qmm-card--collapsible[data-collapsed="false"] .stats-collapse-toggle__icon::before{
  transform:rotate(-135deg);
}
.qmm-card--collapsible[data-collapsed="true"] .stats-collapse-toggle__icon::before{
  transform:rotate(45deg);
}

.qmm-chip-toggle{
  display:inline-flex;
  align-items:stretch;
  border-radius:999px;
  border:1px solid #ffffff1f;
  background:rgba(255,255,255,.05);
  cursor:pointer;
  transition:border-color .18s ease, background .18s ease, box-shadow .18s ease, transform .1s ease;
}
.qmm-chip-toggle input{ display:none; }
.qmm-chip-toggle__face{
  display:flex;
  align-items:center;
  gap:8px;
  padding:6px 12px;
  border-radius:999px;
}
.qmm-chip-toggle__icon{ font-size:14px; }
.qmm-chip-toggle__label{ font-weight:600; }
.qmm-chip-toggle__desc{ font-size:12px; opacity:.75; }
.qmm-chip-toggle__badge{ font-size:11px; padding:2px 6px; border-radius:999px; background:#ffffff1a; border:1px solid #ffffff22; }
.qmm-chip-toggle:hover{ border-color:#7aa2ff55; background:rgba(122,162,255,.12); }
.qmm-chip-toggle input:checked + .qmm-chip-toggle__face{
  background:linear-gradient(180deg, rgba(122,162,255,.25), rgba(122,162,255,.10));
  box-shadow:0 0 0 1px #7aa2ff55 inset, 0 6px 18px rgba(122,162,255,.22);
}

.qmm .stats-metric-grid{
  display:grid;
  gap:10px;
  grid-template-columns:repeat(auto-fit, minmax(160px, 1fr));
}
.qmm .stats-metric{
  border-radius:12px;
  padding:12px 14px;
  background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
  border:1px solid rgba(255,255,255,.08);
  box-shadow:inset 0 1px 0 rgba(255,255,255,.08);
  display:flex;
  flex-direction:column;
  gap:6px;
  transition:border-color .18s ease, background .18s ease, transform .14s ease;
}
.qmm .stats-metric:hover{
  border-color:#7aa2ff55;
  background:linear-gradient(180deg, rgba(122,162,255,.22), rgba(122,162,255,.10));
  transform:translateY(-1px);
}
.qmm .stats-metric__label{
  font-size:12px;
  letter-spacing:.02em;
  text-transform:uppercase;
  color:var(--qmm-text-dim);
}
.qmm .stats-metric__value{
  font-size:20px;
  font-weight:700;
  color:#fff;
}

.qmm .stats-list{
  display:flex;
  flex-direction:column;
  gap:6px;
}
.qmm .stats-list__row{
  display:grid;
  align-items:center;
  gap:10px;
  padding:10px 12px;
  border-radius:10px;
  background:rgba(255,255,255,.035);
  border:1px solid rgba(255,255,255,.08);
  transition:border-color .18s ease, background .18s ease;
}
.qmm .stats-list__row:not(.stats-list__row--header):hover{
  background:rgba(122,162,255,.12);
  border-color:#7aa2ff55;
}
.qmm .stats-list__row--header{
  background:transparent;
  border:none;
  padding:0 6px 2px 6px;
  font-size:11px;
  letter-spacing:.05em;
  text-transform:uppercase;
  color:var(--qmm-text-dim);
}
.qmm .stats-list__row--header .stats-list__cell{
  font-weight:600;
}
.qmm .stats-list__header-label--gold,
.qmm .stats-list__header-label--rainbow{
  display:inline-block;
}
.qmm .stats-list__header-label--gold{
  color:#f7d774;
  background:linear-gradient(135deg,#fff5c0 0%,#f3c76a 55%,#f5b84f 100%);
  background-clip:text;
  -webkit-background-clip:text;
  -webkit-text-fill-color:transparent;
  text-shadow:0 1px 4px rgba(0,0,0,.35);
}
.qmm .stats-list__header-label--rainbow{
  color:#ffd6ff;
  background:linear-gradient(90deg,#ff6b6b 0%,#ffd86f 25%,#6bff8f 50%,#6bc7ff 75%,#b86bff 100%);
  background-clip:text;
  -webkit-background-clip:text;
  -webkit-text-fill-color:transparent;
  text-shadow:0 1px 4px rgba(0,0,0,.35);
}
.qmm .stats-list__cell{
  min-width:0;
  font-size:13px;
}
.qmm .stats-pet__species{
  display:inline-flex;
  align-items:center;
  gap:8px;
  min-width:0;
}
.qmm .stats-pet__label{
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}
.qmm .stats-pet__total-value{
  font-weight:700;
}
.qmm .stats-pet__sprite-icon{
  --stats-pet-sprite-size:28px;
  width:var(--stats-pet-sprite-size);
  height:var(--stats-pet-sprite-size);
  display:inline-flex;
  align-items:center;
  justify-content:center;
  border-radius:6px;
  background:rgba(255,255,255,.08);
  padding:2px;
  flex-shrink:0;
}
.qmm .stats-pet__sprite-icon img{
  width:100%;
  height:100%;
  object-fit:contain;
  image-rendering:pixelated;
}
.qmm .stats-weather__name{
  display:inline-flex;
  align-items:center;
  gap:8px;
  min-width:0;
}
.qmm .stats-weather__icon{
  width:32px;
  height:32px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  border-radius:6px;
  background:rgba(255,255,255,.08);
  overflow:hidden;
  flex-shrink:0;
}
.qmm .stats-weather__icon img{
  width:100%;
  height:100%;
  object-fit:contain;
  image-rendering:pixelated;
}
.qmm .stats-weather__label{
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}
.qmm .stats-list__cell--align-right{ text-align:right; }
.qmm .stats-list__cell--align-center{ text-align:center; }

.qmm .stats-pet-group{
  border:1px solid var(--stats-pet-group-border-color, rgba(255,255,255,.09));
  border-radius:12px;
  padding:10px 12px;
  background:rgba(255,255,255,.05);
  transition:border-color .18s ease, background .18s ease;
  display:flex;
  flex-direction:column;
  align-items:stretch;
  width:100%;
}
.qmm .stats-pet-group + .stats-pet-group{
  margin-top:8px;
}
.qmm .stats-pet-group__summary{
  display:flex;
  align-items:center;
  gap:6px;
  font-weight:650;
  font-size:13px;
  color:var(--qmm-text);
  margin:0;
  user-select:none;
  justify-content:center;
  text-align:center;
}
.qmm .stats-pet-group__content{
  margin-top:8px;
  display:flex;
  flex-direction:column;
  align-items:stretch;
  gap:8px;
}

.qmm-error{
  border:1px solid #ff6a6a55;
  background:rgba(120,20,20,.35);
  border-radius:10px;
  color:#ffdada;
  padding:10px;
  font-size:13px;
  line-height:1.4;
}

.qmm-select{
  background-image:linear-gradient(45deg, transparent 50%, #ffffff80 50%), linear-gradient(135deg, #ffffff80 50%, transparent 50%), linear-gradient(90deg, transparent 50%, rgba(255,255,255,.1) 50%);
  background-position:calc(100% - 18px) 50%, calc(100% - 13px) 50%, 100% 0;
  background-size:5px 5px, 5px 5px, 2.5rem 2.5rem;
  background-repeat:no-repeat;
  padding-right:34px;
}

.qmm-vlist-wrap{ display:flex; flex-direction:column; width:100%; }

/* Inputs */
.qmm-input{
  min-width:90px; background:rgba(0,0,0,.42); color:#fff;
  border:1px solid var(--qmm-border); border-radius:10px;
  padding:8px 10px; box-shadow:inset 0 1px 0 rgba(255,255,255,.06);
  transition:border-color .18s ease, background .18s ease, box-shadow .18s ease;
}
.qmm-input::placeholder{ color:#cbd6e780 }
.qmm-input:focus{ outline:none; border-color:var(--qmm-accent); background:#0f1521; box-shadow:0 0 0 2px #7aa2ff33 }

/* Number input + spinner (unchanged API) */
.qmm-input-number{ display:inline-flex; align-items:center; gap:6px }
.qmm-input-number-input{ width:70px; text-align:center; padding-right:8px }
.qmm-spin{ display:inline-flex; flex-direction:column; gap:2px }
.qmm-step{
  width:22px; height:16px; font-size:11px; line-height:1;
  display:inline-flex; align-items:center; justify-content:center;
  border-radius:6px; border:1px solid var(--qmm-border);
  background:rgba(255,255,255,.08); color:#fff; cursor:pointer; user-select:none;
  transition:background .18s ease, border-color .18s ease, transform .08s ease;
}
.qmm-step:hover{ background:#ffffff18; border-color:#ffffff40 }
.qmm-step:active{ transform:translateY(1px) }

/* Switch (checkbox) */
.qmm-switch{
  appearance:none; width:42px; height:24px; background:#6c7488aa; border-radius:999px;
  position:relative; outline:none; cursor:pointer; transition:background .18s ease, box-shadow .18s ease;
  box-shadow:inset 0 1px 0 rgba(255,255,255,.12);
}
.qmm-switch::before{
  content:""; position:absolute; top:2px; left:2px; width:20px; height:20px;
  background:#fff; border-radius:50%; transition:transform .2s ease;
  box-shadow:0 2px 8px rgba(0,0,0,.35);
}
.qmm-switch:checked{ background:linear-gradient(180deg, rgba(122,162,255,.9), rgba(122,162,255,.6)) }
.qmm-switch:checked::before{ transform:translateX(18px) }
.qmm-switch:focus-visible{ outline:2px solid var(--qmm-accent); outline-offset:2px }

/* Checkbox & radio (native inputs skinned lightly) */
.qmm-check, .qmm-radio{ transform:scale(1.1); accent-color: var(--qmm-accent) }

/* Slider */
.qmm-range{
  width:180px; appearance:none; background:transparent; height:22px;
}
.qmm-range:focus{ outline:none }
.qmm-range::-webkit-slider-runnable-track{
  height:6px; background:linear-gradient(90deg, var(--qmm-accent), #7aa2ff44);
  border-radius:999px; box-shadow:inset 0 1px 0 rgba(255,255,255,.14);
}
.qmm-range::-moz-range-track{
  height:6px; background:linear-gradient(90deg, var(--qmm-accent), #7aa2ff44);
  border-radius:999px; box-shadow:inset 0 1px 0 rgba(255,255,255,.14);
}
.qmm-range::-webkit-slider-thumb{
  appearance:none; width:16px; height:16px; border-radius:50%; margin-top:-5px;
  background:#fff; box-shadow:0 2px 10px rgba(0,0,0,.35), 0 0 0 2px #ffffff66 inset;
  transition:transform .1s ease;
}
.qmm-range:active::-webkit-slider-thumb{ transform:scale(1.04) }
.qmm-range::-moz-range-thumb{
  width:16px; height:16px; border-radius:50%; background:#fff; border:none;
  box-shadow:0 2px 10px rgba(0,0,0,.35), 0 0 0 2px #ffffff66 inset;
}

.qmm-range-dual{
  position:relative;
  width:100%;
  padding:18px 0 10px;
}
.qmm-range-dual-track{
  position:absolute;
  left:0;
  right:0;
  top:50%;
  transform:translateY(-50%);
  height:8px;
  border-radius:999px;
  background:linear-gradient(90deg, rgba(8,19,33,.8), rgba(27,43,68,.9));
  box-shadow:inset 0 1px 0 rgba(255,255,255,.08), inset 0 0 0 1px rgba(118,156,255,.08);
}
.qmm-range-dual-fill{
  position:absolute;
  top:50%;
  transform:translateY(-50%);
  height:8px;
  border-radius:999px;
  background:linear-gradient(90deg, var(--qmm-accent), #7aa2ff99);
  box-shadow:0 4px 14px rgba(37,92,255,.3);
  transition:left .12s ease, right .12s ease;
}
.qmm-range-dual-input{
  position:absolute;
  left:0;
  right:0;
  top:50%;
  transform:translateY(-50%);
  width:100%;
  height:28px;
  margin:0;
  background:transparent;
  pointer-events:none;
}
.qmm-range-dual-input::-webkit-slider-runnable-track{ background:none; }
.qmm-range-dual-input::-moz-range-track{ background:none; }
.qmm-range-dual-input::-webkit-slider-thumb{
  pointer-events:auto;
  width:18px;
  height:18px;
  border-radius:50%;
  background:linear-gradient(145deg, #fff, #dce6ff);
  border:2px solid rgba(122,162,255,.8);
  box-shadow:0 4px 12px rgba(0,0,0,.35);
  transition:transform .12s ease, box-shadow .12s ease;
}
.qmm-range-dual-input:active::-webkit-slider-thumb,
.qmm-range-dual-input:focus-visible::-webkit-slider-thumb{
  transform:scale(1.05);
  box-shadow:0 6px 16px rgba(0,0,0,.4);
}
.qmm-range-dual-input::-moz-range-thumb{
  pointer-events:auto;
  width:18px;
  height:18px;
  border-radius:50%;
  background:linear-gradient(145deg, #fff, #dce6ff);
  border:2px solid rgba(122,162,255,.8);
  box-shadow:0 4px 12px rgba(0,0,0,.35);
  transition:transform .12s ease, box-shadow .12s ease;
}
.qmm-range-dual-input:active::-moz-range-thumb,
.qmm-range-dual-input:focus-visible::-moz-range-thumb{
  transform:scale(1.05);
  box-shadow:0 6px 16px rgba(0,0,0,.4);
}
.qmm-range-dual-input--min{ z-index:2; }
.qmm-range-dual-input--max{ z-index:3; }
.qmm-range-dual-bubble{
  position:absolute;
  top:14px;
  transform:translate(-50%, -100%);
  padding:4px 8px;
  border-radius:6px;
  font-size:11px;
  line-height:1;
  font-weight:600;
  color:#dbe6ff;
  background:rgba(17,28,46,.9);
  box-shadow:0 4px 14px rgba(0,0,0,.35);
  pointer-events:none;
  transition:opacity .12s ease, transform .12s ease;
  opacity:.85;
}
.qmm-range-dual-bubble::after{
  content:"";
  position:absolute;
  left:50%;
  bottom:-4px;
  width:8px;
  height:8px;
  background:inherit;
  transform:translateX(-50%) rotate(45deg);
  border-radius:2px;
  box-shadow:0 4px 14px rgba(0,0,0,.35);
}
.qmm-range-dual-input--min:focus-visible + .qmm-range-dual-bubble--min,
.qmm-range-dual-input--max:focus-visible + .qmm-range-dual-bubble--max,
.qmm-range-dual-input--min:active + .qmm-range-dual-bubble--min,
.qmm-range-dual-input--max:active + .qmm-range-dual-bubble--max{
  opacity:1;
  transform:translate(-50%, -110%) scale(1.02);
}

/* ---------- Minimal table ---------- */
/* container */
.qmm-table-wrap--minimal{
  border:1px solid #263040; border-radius:8px; background:#0b0f14; box-shadow:none;
}
/* scroller (height cap) */
.qmm-table-scroll{
  overflow:auto; max-height:44vh; /* override via opts.maxHeight */
}

/* base */
.qmm-table--minimal{
  width:100%;
  border-collapse:collapse;
  background:transparent;
  font-size:13px; line-height:1.35; color:var(--qmm-text, #cdd6e3);
}

/* header */
.qmm-table--minimal thead th{
  position:sticky; top:0; z-index:1;
  text-align:left; font-weight:600;
  padding:8px 10px;
  color:#cbd5e1; background:#0f1318;
  border-bottom:1px solid #263040;
  text-transform:none; letter-spacing:0;
}
.qmm-table--minimal thead th.is-center { text-align: center; }
.qmm-table--minimal thead th.is-left   { text-align: left; }   /* d\xE9j\xE0 pr\xE9sent, ok */
.qmm-table--minimal thead th.is-right  { text-align: right; }
.qmm-table--minimal thead th,
.qmm-table--minimal td { vertical-align: middle; }

/* cells */
.qmm-table--minimal td{
  padding:8px 10px; border-bottom:1px solid #1f2937; vertical-align:middle;
}
.qmm-table--minimal tbody tr:hover{ background:#0f1824; }

/* compact variant */
.qmm-table--compact thead th,
.qmm-table--compact td{ padding:6px 8px; font-size:12px }

/* utils */
.qmm-table--minimal td.is-num{ text-align:right; font-variant-numeric:tabular-nums }
.qmm-table--minimal td.is-center{ text-align:center }
.qmm-ellipsis{ overflow:hidden; text-overflow:ellipsis; white-space:nowrap }
.qmm-prewrap{ white-space:pre-wrap; word-break:break-word }


/* ---------- Split panels ---------- */
.qmm-split{
  display:grid; gap:12px;
  grid-template-columns:minmax(180px,260px) minmax(0,1fr);
  align-items:start;
}
.qmm-split-left{ display:flex; flex-direction:column; gap:10px }
.qmm-split-right{
  border:1px solid var(--qmm-border); border-radius:12px; padding:12px;
  display:flex; flex-direction:column; gap:12px;
  background:var(--qmm-panel); backdrop-filter:blur(var(--qmm-blur));
  box-shadow:var(--qmm-shadow);
}

/* ---------- VTabs (vertical list + filter) ---------- */
.qmm-vtabs{ display:flex; flex-direction:column; gap:8px; min-width:0 }
.qmm-vtabs .filter{ display:block }
.qmm-vtabs .filter input{ width:100% }

.qmm-vlist{
  flex:0 0 auto; overflow:visible;
  border:1px solid var(--qmm-border); border-radius:12px; padding:6px;
  background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
  box-shadow:inset 0 1px 0 rgba(255,255,255,.04);
}

.qmm-vtab{
  width:100%; text-align:left; cursor:pointer;
  display:grid; grid-template-columns:28px 1fr auto; align-items:center; gap:10px;
  padding:8px 10px; border-radius:10px; border:1px solid #ffffff18;
  background:rgba(255,255,255,.03); color:inherit;
  transition:background .18s ease, border-color .18s ease, transform .08s ease;
}
.qmm-vtab:hover{ background:rgba(255,255,255,.07); border-color:#ffffff34 }
.qmm-vtab:active{ transform:translateY(1px) }
.qmm-vtab.active{
  background:linear-gradient(180deg, rgba(122,162,255,.18), rgba(122,162,255,.08));
  border-color:#9db7ff55;
  box-shadow:0 1px 14px rgba(122,162,255,.18) inset;
}

.qmm-dot{ width:10px; height:10px; border-radius:50%; justify-self:center; box-shadow:0 0 0 1px #0006 inset }
.qmm-chip{ display:flex; align-items:center; gap:8px; min-width:0 }
.qmm-chip img{
  width:20px; height:20px; border-radius:50%; object-fit:cover; border:1px solid #4446;
  box-shadow:0 1px 0 rgba(255,255,255,.08) inset;
}
.qmm-chip .t{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis }
.qmm-tag{
  font-size:11px; line-height:1; padding:3px 7px; border-radius:999px;
  background:#ffffff14; border:1px solid #ffffff26;
}

/* ---------- Small helpers (optional) ---------- */
.qmm .qmm-card{
  border:1px solid var(--qmm-border); border-radius:12px; padding:12px;
  background:var(--qmm-panel); backdrop-filter:blur(var(--qmm-blur)); box-shadow:var(--qmm-shadow);
}
  .qmm .qmm-help{ font-size:12px; color:var(--qmm-text-dim) }
  .qmm .qmm-sep{ height:1px; background:var(--qmm-border); width:100%; opacity:.6; }

/* ta poign\xE9e, inchang\xE9 */
.qmm-grab { margin-left:auto; opacity:.8; cursor:grab; user-select:none; }
.qmm-grab:active { cursor:grabbing; }
.qmm-dragging { opacity:.6; }

/* items animables */
.qmm-team-item {
  will-change: transform;
  transition: transform 160ms ease;
}
.qmm-team-item.drag-ghost {
  opacity: .4;
}

.qmm.qmm-alt-drag { cursor: grab; }
.qmm.qmm-alt-drag:active { cursor: grabbing; }

.qws-win.is-hidden { display: none !important; }

.qmm-hotkey{
  cursor:pointer; user-select:none;
  border:1px solid var(--qmm-border); border-radius:10px;
  padding:8px 12px;
  background:linear-gradient(180deg, #ffffff10, #ffffff06);
  color:var(--qmm-text);
  box-shadow:0 1px 0 #000 inset, 0 1px 16px rgba(0,0,0,.18);
  transition:
    background .18s ease,
    border-color .18s ease,
    box-shadow .18s ease,
    transform .08s ease,
    color .18s ease;
}
.qmm-hotkey{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  white-space:nowrap;
  width: var(--qmm-hotkey-w, 180px); 
}
.qmm-hotkey:hover{ background:linear-gradient(180deg, #ffffff16, #ffffff08); border-color:#ffffff40 }
.qmm-hotkey:active{ transform:translateY(1px) }

.qmm-hotkey:focus-visible{ outline:none }

.qmm-hotkey.is-empty{
  color:var(--qmm-text-dim);
  font-style:italic;
}

.qmm-hotkey.is-assigned{
  border-color: rgba(122,162,255,.45);
  box-shadow:0 1px 0 #000 inset, 0 1px 16px rgba(0,0,0,.18), 0 0 0 2px rgba(122,162,255,.24);
}

.qmm-hotkey.is-recording{
  outline:2px solid var(--qmm-accent);
  outline-offset:2px;
  border-color: var(--qmm-accent);
  background:linear-gradient(180deg, rgba(122,162,255,.25), rgba(122,162,255,.10));
  animation: qmm-hotkey-breathe 1.2s ease-in-out infinite;
}
  
@keyframes qmm-hotkey-breathe{
  0%   { box-shadow: 0 0 0 0 rgba(122,162,255,.55), 0 1px 16px rgba(0,0,0,.25); }
  60%  { box-shadow: 0 0 0 12px rgba(122,162,255,0), 0 1px 16px rgba(0,0,0,.25); }
  100% { box-shadow: 0 0 0 0 rgba(122,162,255,0),  0 1px 16px rgba(0,0,0,.25); }
}

/* ---------- Segmented (minimal, modern) ---------- */
.qmm-seg{
  --seg-pad: 8px;
  --seg-radius: 999px;
  --seg-stroke: 1.2px;      /* \xE9paisseur du trait */
  --seg-nudge-x: 0px;       /* micro-ajustements optionnels */
  --seg-nudge-w: 0px;
  --seg-fill: rgba(122,162,255,.05);           
  --seg-stroke-color: rgba(122,162,255,.60);

  position: relative;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: var(--seg-pad);
  border-radius: var(--seg-radius);
  background: var(--qmm-bg-soft);
  border: 1px solid var(--qmm-border-2);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
  overflow: hidden;
  background-clip: padding-box; /* important pour que le fond ne passe pas sous la bordure */
}

.qmm-seg--full{ display:flex; width:100% }

.qmm-seg__btn{
  position: relative;
  z-index: 1;
  appearance: none; background: transparent; border: 0; cursor: pointer;
  padding: 8px 14px;
  border-radius: 999px;
  color: var(--qmm-text-dim);
  font: inherit; line-height: 1; white-space: nowrap;
  transition: color .15s ease, transform .06s ease;
}
.qmm-seg__btn-label{
  display: inline-flex;
  align-items: center;
  justify-content: center;
  white-space: inherit;
}
.qmm-compact .qmm-seg__btn{ padding: 6px 10px }
.qmm-seg__btn:hover{ color: var(--qmm-text); }
.qmm-seg__btn.active{ color:#fff; font-weight:600; }
.qmm-seg__btn:active{ transform: translateY(1px); }
.qmm-seg__btn[disabled]{ opacity:.5; cursor:not-allowed; }

.qmm-seg__indicator{
  position: absolute;
  top: 0; left: 0;
  height: 100%;
  width: 40px;                      /* maj en JS */
  border-radius: inherit;
  background: var(--seg-fill);              /* \u2B05\uFE0F applique la couleur */
  outline: var(--seg-stroke,1.2px) solid var(--seg-stroke-color);
  outline-offset: calc(-1 * var(--seg-stroke));

  box-shadow: 0 1px 4px rgba(122,162,255,.10);
  transform-origin: left center;
  will-change: transform, width, opacity;
  transition: transform .18s cubic-bezier(.2,.8,.2,1),
              width .18s cubic-bezier(.2,.8,.2,1),
              opacity .18s ease-out;
  pointer-events: none;
}

/* Accessibilit\xE9 */
@media (prefers-reduced-motion: reduce){
  .qmm-seg__indicator, .qmm-seg__btn { transition: none; }
}  /* \u2190 manquait cette accolade */

    `;
      const st = document.createElement("style");
      st.id = "__qmm_css__";
      st.textContent = css;
      (document.documentElement || document.body).appendChild(st);
    }
  };
  var VTabs = class {
    constructor(api, opts = {}) {
      this.api = api;
      this.opts = opts;
      __publicField(this, "root");
      __publicField(this, "filterWrap", null);
      __publicField(this, "filterInput", null);
      __publicField(this, "list");
      __publicField(this, "listWrap", null);
      __publicField(this, "items", []);
      __publicField(this, "selectedId", null);
      __publicField(this, "onSelectCb");
      __publicField(this, "renderItemCustom");
      __publicField(this, "emptyText");
      this.root = el("div", "qmm-vtabs");
      this.root.style.minWidth = "0";
      this.emptyText = opts.emptyText || "Aucun \xE9l\xE9ment.";
      this.renderItemCustom = opts.renderItem;
      if (opts.filterPlaceholder) {
        this.filterWrap = el("div", "filter");
        this.filterInput = document.createElement("input");
        this.filterInput.type = "search";
        this.filterInput.placeholder = opts.filterPlaceholder;
        this.filterInput.className = "qmm-input";
        this.filterInput.oninput = () => this.renderList();
        this.filterWrap.appendChild(this.filterInput);
        this.root.appendChild(this.filterWrap);
      }
      this.list = el("div", "qmm-vlist");
      this.list.style.minWidth = "0";
      if (opts.maxHeightPx) {
        this.list.style.maxHeight = `${opts.maxHeightPx}px`;
        this.list.style.overflow = "auto";
        this.list.style.flex = "1 1 auto";
      }
      if (opts.fillAvailableHeight) {
        this.listWrap = document.createElement("div");
        this.listWrap.className = "qmm-vlist-wrap";
        Object.assign(this.listWrap.style, {
          flex: "1 1 auto",
          minHeight: "0",
          display: "flex",
          flexDirection: "column"
        });
        this.list.style.flex = "1 1 auto";
        if (!opts.maxHeightPx) this.list.style.overflow = "auto";
        this.listWrap.appendChild(this.list);
        this.root.appendChild(this.listWrap);
      } else {
        this.root.appendChild(this.list);
      }
      this.selectedId = opts.initialId ?? null;
      this.onSelectCb = opts.onSelect;
    }
    setItems(items) {
      this.items = Array.isArray(items) ? items.slice() : [];
      if (this.selectedId && !this.items.some((i) => i.id === this.selectedId)) {
        this.selectedId = this.items[0]?.id ?? null;
      }
      this.renderList();
    }
    getSelected() {
      return this.items.find((i) => i.id === this.selectedId) ?? null;
    }
    select(id) {
      this.selectedId = id;
      this.renderList();
      this.onSelectCb?.(this.selectedId, this.getSelected());
    }
    onSelect(cb) {
      this.onSelectCb = cb;
    }
    setBadge(id, text) {
      const btn = this.list.querySelector(`button[data-id="${cssq(id)}"]`);
      if (!btn) return;
      let tag = btn.querySelector(".qmm-tag");
      if (!tag && text != null) {
        tag = el("span", "qmm-tag");
        btn.appendChild(tag);
      }
      if (!tag) return;
      if (text == null || text === "") tag.style.display = "none";
      else {
        tag.textContent = text;
        tag.style.display = "";
      }
    }
    getFilter() {
      return (this.filterInput?.value || "").trim().toLowerCase();
    }
    renderList() {
      const keepScroll = this.list.scrollTop;
      this.list.innerHTML = "";
      const q = this.getFilter();
      const filtered = q ? this.items.filter((it) => (it.title || "").toLowerCase().includes(q) || (it.subtitle || "").toLowerCase().includes(q)) : this.items;
      if (!filtered.length) {
        const empty = document.createElement("div");
        empty.style.opacity = "0.75";
        empty.textContent = this.emptyText;
        this.list.appendChild(empty);
        return;
      }
      const ul = document.createElement("ul");
      ul.style.listStyle = "none";
      ul.style.margin = "0";
      ul.style.padding = "0";
      ul.style.display = "flex";
      ul.style.flexDirection = "column";
      ul.style.gap = "4px";
      for (const it of filtered) {
        const li = document.createElement("li");
        const btn = document.createElement("button");
        btn.className = "qmm-vtab";
        btn.dataset.id = it.id;
        btn.disabled = !!it.disabled;
        if (this.renderItemCustom) {
          this.renderItemCustom(it, btn);
        } else {
          const dot = el("div", "qmm-dot");
          dot.style.background = it.statusColor || "#999a";
          const chip = el("div", "qmm-chip");
          const img = document.createElement("img");
          img.src = it.avatarUrl || "";
          img.alt = it.title;
          const wrap = document.createElement("div");
          wrap.style.display = "flex";
          wrap.style.flexDirection = "column";
          wrap.style.gap = "2px";
          const t = el("div", "t");
          t.textContent = it.title;
          const sub = document.createElement("div");
          sub.textContent = it.subtitle || "";
          sub.style.opacity = "0.7";
          sub.style.fontSize = "12px";
          if (!it.subtitle) sub.style.display = "none";
          wrap.appendChild(t);
          wrap.appendChild(sub);
          chip.appendChild(img);
          chip.appendChild(wrap);
          btn.appendChild(dot);
          btn.appendChild(chip);
          if (it.badge != null) {
            const tag = el("span", "qmm-tag", escapeHtml(String(it.badge)));
            btn.appendChild(tag);
          } else {
            const spacer = document.createElement("div");
            spacer.style.width = "0";
            btn.appendChild(spacer);
          }
        }
        btn.classList.toggle("active", it.id === this.selectedId);
        btn.onclick = () => this.select(it.id);
        li.appendChild(btn);
        ul.appendChild(li);
      }
      this.list.appendChild(ul);
      this.list.scrollTop = keepScroll;
    }
  };
  function el(tag, cls, html) {
    const e = document.createElement(tag);
    if (cls) e.className = cls;
    if (html != null) e.innerHTML = html;
    return e;
  }
  function cssq(s) {
    return s.replace(/"/g, '\\"');
  }
  function escapeHtml(s) {
    return s.replace(/[&<>"']/g, (m) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" })[m]);
  }
  var _MOD_CODES = /* @__PURE__ */ new Set([
    "ShiftLeft",
    "ShiftRight",
    "ControlLeft",
    "ControlRight",
    "AltLeft",
    "AltRight",
    "MetaLeft",
    "MetaRight"
  ]);
  function codesMatch(expected, actual) {
    if (expected === actual) return true;
    const altCodes = expected === "AltLeft" || expected === "AltRight";
    const ctrlCodes = expected === "ControlLeft" || expected === "ControlRight";
    const shiftCodes = expected === "ShiftLeft" || expected === "ShiftRight";
    const metaCodes = expected === "MetaLeft" || expected === "MetaRight";
    if (altCodes && (actual === "AltLeft" || actual === "AltRight")) return true;
    if (ctrlCodes && (actual === "ControlLeft" || actual === "ControlRight")) return true;
    if (shiftCodes && (actual === "ShiftLeft" || actual === "ShiftRight")) return true;
    if (metaCodes && (actual === "MetaLeft" || actual === "MetaRight")) return true;
    return false;
  }
  function isMac() {
    return navigator.platform?.toLowerCase().includes("mac") || /mac|iphone|ipad|ipod/i.test(navigator.userAgent);
  }
  function eventToHotkey(e, allowModifierOnly = false) {
    const isModifier = _MOD_CODES.has(e.code) || e.key === "Shift" || e.key === "Control" || e.key === "Alt" || e.key === "Meta";
    if (isModifier && !allowModifierOnly) {
      return null;
    }
    return {
      code: e.code,
      ctrl: e.ctrlKey,
      alt: e.altKey,
      shift: e.shiftKey,
      meta: e.metaKey
    };
  }
  function matchHotkey(e, h) {
    if (!h) return false;
    if (!!h.ctrl !== e.ctrlKey) return false;
    if (!!h.shift !== e.shiftKey) return false;
    if (!!h.alt !== e.altKey) return false;
    if (!!h.meta !== e.metaKey) return false;
    return codesMatch(h.code, e.code);
  }
  function hotkeyToString(hk) {
    if (!hk) return "";
    const parts = [];
    if (hk.ctrl) parts.push("Ctrl");
    if (hk.shift) parts.push("Shift");
    if (hk.alt) parts.push("Alt");
    if (hk.meta) parts.push("Meta");
    if (hk.code) parts.push(hk.code);
    return parts.join("+");
  }
  function stringToHotkey(s) {
    if (!s) return null;
    const parts = s.split("+").map((p) => p.trim()).filter(Boolean);
    if (!parts.length) return null;
    const code = canonicalizeCode(parts.pop() || "");
    const hk = { code };
    for (const p of parts) {
      const P = p.toLowerCase();
      if (P === "ctrl" || P === "control") hk.ctrl = true;
      else if (P === "shift") hk.shift = true;
      else if (P === "alt") hk.alt = true;
      else if (P === "meta" || P === "cmd" || P === "command") hk.meta = true;
    }
    return hk.code ? hk : null;
  }
  var CANONICAL_CODES = {
    space: "Space",
    enter: "Enter",
    escape: "Escape",
    tab: "Tab",
    backspace: "Backspace",
    delete: "Delete",
    insert: "Insert",
    home: "Home",
    end: "End",
    pageup: "PageUp",
    pagedown: "PageDown",
    arrowup: "ArrowUp",
    arrowdown: "ArrowDown",
    arrowleft: "ArrowLeft",
    arrowright: "ArrowRight",
    bracketleft: "BracketLeft",
    bracketright: "BracketRight",
    backslash: "Backslash",
    slash: "Slash",
    minus: "Minus",
    equal: "Equal",
    semicolon: "Semicolon",
    quote: "Quote",
    backquote: "Backquote",
    comma: "Comma",
    period: "Period",
    dot: "Period",
    capslock: "CapsLock",
    numlock: "NumLock",
    scrolllock: "ScrollLock",
    pause: "Pause",
    contextmenu: "ContextMenu",
    printscreen: "PrintScreen",
    metaleft: "MetaLeft",
    metaright: "MetaRight",
    altleft: "AltLeft",
    altright: "AltRight",
    controlleft: "ControlLeft",
    controlright: "ControlRight",
    shiftleft: "ShiftLeft",
    shiftright: "ShiftRight"
  };
  function canonicalizeCode(rawCode) {
    const trimmed = rawCode.trim();
    if (!trimmed) return "";
    const lower = trimmed.toLowerCase();
    const keyMatch = lower.match(/^key([a-z])$/);
    if (keyMatch) return `Key${keyMatch[1].toUpperCase()}`;
    const digitMatch = lower.match(/^digit([0-9])$/);
    if (digitMatch) return `Digit${digitMatch[1]}`;
    const numpadDigitMatch = lower.match(/^numpad([0-9])$/);
    if (numpadDigitMatch) return `Numpad${numpadDigitMatch[1]}`;
    if (lower.startsWith("numpad")) {
      const suffix = lower.slice(6);
      if (!suffix) return "Numpad";
      const mappedSuffix = CANONICAL_CODES[suffix] ?? capitalizeWord(suffix);
      return `Numpad${mappedSuffix}`;
    }
    const fMatch = lower.match(/^f([0-9]{1,2})$/);
    if (fMatch) return `F${fMatch[1]}`;
    const arrowMatch = lower.match(/^arrow([a-z]+)$/);
    if (arrowMatch) {
      const suffix = arrowMatch[1];
      const mappedSuffix = CANONICAL_CODES[suffix] ?? capitalizeWord(suffix);
      return `Arrow${mappedSuffix}`;
    }
    if (CANONICAL_CODES[lower]) {
      return CANONICAL_CODES[lower];
    }
    return trimmed[0].toUpperCase() + trimmed.slice(1);
  }
  function capitalizeWord(word) {
    if (!word) return "";
    return word[0].toUpperCase() + word.slice(1);
  }
  function prettyCode(code) {
    if (code === "AltLeft" || code === "AltRight") return "Alt";
    if (code === "ControlLeft" || code === "ControlRight") return "Ctrl";
    if (code === "ShiftLeft" || code === "ShiftRight") return "Shift";
    if (code === "MetaLeft" || code === "MetaRight") return isMac() ? "\u2318" : "Meta";
    if (code.startsWith("Key")) return code.slice(3);
    if (code.startsWith("Digit")) return code.slice(5);
    if (code.startsWith("Numpad")) return "Numpad " + code.slice(6);
    const arrows = { ArrowUp: "\u2191", ArrowDown: "\u2193", ArrowLeft: "\u2190", ArrowRight: "\u2192" };
    if (arrows[code]) return arrows[code];
    return code;
  }
  function hotkeyToPretty(h) {
    if (!h) return "\u2014";
    const mac = isMac();
    const mods = [];
    if (mac) {
      if (h.ctrl) mods.push("\u2303");
      if (h.alt) mods.push("\u2325");
      if (h.shift) mods.push("\u21E7");
      if (h.meta) mods.push("\u2318");
    } else {
      if (h.ctrl) mods.push("Ctrl");
      if (h.alt) mods.push("Alt");
      if (h.shift) mods.push("Shift");
      if (h.meta) mods.push("Meta");
    }
    const modifierCode = h.alt && (h.code === "AltLeft" || h.code === "AltRight") || h.ctrl && (h.code === "ControlLeft" || h.code === "ControlRight") || h.shift && (h.code === "ShiftLeft" || h.code === "ShiftRight") || h.meta && (h.code === "MetaLeft" || h.code === "MetaRight");
    const parts = mods.slice();
    const codePretty = prettyCode(h.code);
    if (!modifierCode || parts.length === 0) {
      parts.push(codePretty);
    }
    if (!parts.length) return codePretty;
    return parts.join(mac ? "" : " + ");
  }

  // src/core/ingameHotkeys.ts
  var resolveContext = (context) => {
    if (context) return context;
    const win = pageWindow ?? window;
    const doc = win.document ?? document;
    return { window: win, document: doc };
  };
  var KEYCODE_TABLE = {
    KeyA: 65,
    KeyB: 66,
    KeyC: 67,
    KeyD: 68,
    KeyE: 69,
    KeyF: 70,
    KeyG: 71,
    KeyH: 72,
    KeyI: 73,
    KeyJ: 74,
    KeyK: 75,
    KeyL: 76,
    KeyM: 77,
    KeyN: 78,
    KeyO: 79,
    KeyP: 80,
    KeyQ: 81,
    KeyR: 82,
    KeyS: 83,
    KeyT: 84,
    KeyU: 85,
    KeyV: 86,
    KeyW: 87,
    KeyX: 88,
    KeyY: 89,
    KeyZ: 90,
    Digit0: 48,
    Digit1: 49,
    Digit2: 50,
    Digit3: 51,
    Digit4: 52,
    Digit5: 53,
    Digit6: 54,
    Digit7: 55,
    Digit8: 56,
    Digit9: 57,
    Space: 32,
    Enter: 13,
    Escape: 27,
    Tab: 9,
    Backspace: 8,
    Delete: 46,
    Insert: 45,
    ArrowLeft: 37,
    ArrowUp: 38,
    ArrowRight: 39,
    ArrowDown: 40
  };
  var codeToKey = (code, shift = false) => {
    if (!code) return "";
    if (/^Key[A-Z]$/.test(code)) return shift ? code.slice(3).toUpperCase() : code.slice(3).toLowerCase();
    if (/^Digit[0-9]$/.test(code)) return code.slice(5);
    if (code === "Space") return " ";
    return code;
  };
  var isEditableTarget = (t) => {
    const el2 = t;
    if (!el2 || !el2.tagName) return false;
    const tag = el2.tagName.toLowerCase();
    if (tag === "input" || tag === "textarea") return true;
    const ce = el2.getAttribute && el2.getAttribute("contenteditable");
    return !!(ce && ce !== "false");
  };
  var normalizeCombo = (c) => {
    const parts = String(c).split("+").map((s) => s.trim()).filter(Boolean);
    const mods = [];
    let code = "";
    for (const p of parts) {
      const P = p.toLowerCase();
      if (P === "ctrl" || P === "control") mods.push("ctrl");
      else if (P === "shift") mods.push("shift");
      else if (P === "alt") mods.push("alt");
      else if (P === "meta" || P === "cmd" || P === "command" || P === "win") mods.push("meta");
      else code = p;
    }
    mods.sort((a, b) => ["ctrl", "shift", "alt", "meta"].indexOf(a) - ["ctrl", "shift", "alt", "meta"].indexOf(b));
    return (mods.length ? mods.join("+") + "+" : "") + code;
  };
  var parseCombo = (c) => {
    const parts = String(c).split("+").map((s) => s.trim()).filter(Boolean);
    const spec = {};
    for (const p of parts) {
      const P = p.toLowerCase();
      if (P === "ctrl" || P === "control") spec.ctrl = true;
      else if (P === "shift") spec.shift = true;
      else if (P === "alt") spec.alt = true;
      else if (P === "meta" || P === "cmd" || P === "command" || P === "win") spec.meta = true;
      else spec.code = p;
    }
    if (spec.code && spec.key === void 0) spec.key = codeToKey(spec.code, !!spec.shift);
    return spec;
  };
  var evToCombo = (e) => {
    const mods = [];
    if (e.ctrlKey) mods.push("ctrl");
    if (e.shiftKey) mods.push("shift");
    if (e.altKey) mods.push("alt");
    if (e.metaKey) mods.push("meta");
    mods.sort((a, b) => ["ctrl", "shift", "alt", "meta"].indexOf(a) - ["ctrl", "shift", "alt", "meta"].indexOf(b));
    return (mods.length ? mods.join("+") + "+" : "") + (e.code || "");
  };
  var REMAP_FLAG = "__inGameHotkeysRemapped__";
  var RAPID_SYN_FLAG = "__inGameHotkeysRapidSynthetic__";
  var InGameHotkeys = class {
    constructor(autoAttach = true, context) {
      __publicField(this, "win");
      __publicField(this, "doc");
      // remapper
      __publicField(this, "enabled", true);
      __publicField(this, "map", /* @__PURE__ */ new Map());
      // combo normalisé -> spec destination
      __publicField(this, "blockedSet", /* @__PURE__ */ new Set());
      // combos bloqués
      __publicField(this, "eventBlockers", /* @__PURE__ */ new Set());
      __publicField(this, "attachedDocs", /* @__PURE__ */ new WeakSet());
      // docs déjà hookés
      __publicField(this, "observers", []);
      __publicField(this, "handlers", /* @__PURE__ */ new Map());
      __publicField(this, "passthrough", /* @__PURE__ */ new Set(["F5", "F12"]));
      // rapid-fire manager
      __publicField(this, "sessions", /* @__PURE__ */ new Map());
      const ctx = resolveContext(context);
      this.win = ctx.window;
      this.doc = ctx.document;
      if (autoAttach) {
        this.attachDoc(this.doc);
        this.attachAllFrames();
        if (this.win.MutationObserver) {
          const mo = new this.win.MutationObserver(() => this.attachAllFrames());
          mo.observe(this.doc.documentElement || this.doc, { childList: true, subtree: true });
          this.observers.push(mo);
        }
      }
    }
    /* --------- on/off remapper --------- */
    enable(flag = true) {
      this.enabled = !!flag;
    }
    disable() {
      this.enabled = false;
    }
    isEnabled() {
      return this.enabled;
    }
    /* --------- remaps --------- */
    setMap(m) {
      this.map.clear();
      for (const [from, to] of Object.entries(m || {})) this.map.set(normalizeCombo(from), parseCombo(to));
    }
    add(from, to) {
      this.map.set(normalizeCombo(from), parseCombo(to));
    }
    remove(from) {
      this.map.delete(normalizeCombo(from));
    }
    clear() {
      this.map.clear();
    }
    current() {
      const out = {};
      for (const [k, v] of this.map.entries()) {
        const mods = [];
        if (v.ctrl) mods.push("Ctrl");
        if (v.shift) mods.push("Shift");
        if (v.alt) mods.push("Alt");
        if (v.meta) mods.push("Meta");
        out[k] = (mods.length ? mods.join("+") + "+" : "") + (v.code || "");
      }
      return out;
    }
    /* --------- blocages --------- */
    block(combo) {
      this.blockedSet.add(normalizeCombo(combo));
    }
    unblock(combo) {
      this.blockedSet.delete(normalizeCombo(combo));
    }
    blocked() {
      return Array.from(this.blockedSet);
    }
    addEventBlocker(blocker) {
      if (typeof blocker !== "function") {
        return () => {
        };
      }
      this.eventBlockers.add(blocker);
      return () => {
        this.eventBlockers.delete(blocker);
      };
    }
    /* --------- helpers de binding --------- */
    /** Déplace l’action bindée sur oldBase vers newPhysical et désactive oldBase. */
    replace(oldBase, newPhysical) {
      const oldN = normalizeCombo(oldBase);
      const newN = normalizeCombo(newPhysical);
      this.blockedSet.add(oldN);
      this.map.set(newN, parseCombo(oldN));
    }
    /** Échange réciproquement deux touches (ne bloque pas). */
    swap(a, b) {
      const an = normalizeCombo(a), bn = normalizeCombo(b);
      this.map.set(an, parseCombo(bn));
      this.map.set(bn, parseCombo(an));
    }
    /* --------- frames & cleanup --------- */
    attachAllFrames() {
      this.doc.querySelectorAll("iframe").forEach((f) => {
        try {
          const d = f.contentDocument;
          const origin = d?.location?.origin;
          if (d && origin && origin === this.win.location.origin) this.attachDoc(d);
        } catch {
        }
      });
    }
    destroy() {
      for (const [doc, handler] of this.handlers.entries()) {
        try {
          const win = doc.defaultView || this.win;
          win.removeEventListener("keydown", handler, true);
          win.removeEventListener("keypress", handler, true);
          win.removeEventListener("keyup", handler, true);
        } catch {
        }
      }
      this.handlers.clear();
      this.attachedDocs = /* @__PURE__ */ new WeakSet();
      for (const mo of this.observers) mo.disconnect();
      this.observers = [];
      this.stopAllRapidFires();
      this.eventBlockers.clear();
    }
    /* --------- rapid-fire (API) --------- */
    startRapidFire(opts) {
      const trigger = normalizeCombo(opts.trigger);
      const emit = normalizeCombo(opts.emit ?? opts.trigger);
      const rateMs = 1e3 / Math.max(1, opts.rateHz ?? 12);
      const mode = opts.mode ?? "tap";
      const keyupDelayMs = opts.keyupDelayMs ?? 20;
      this.sessions.set(trigger, {
        trigger: parseRapid(trigger),
        emit: parseRapid(emit),
        rateMs,
        mode,
        keyupDelayMs,
        pressed: false,
        lastTarget: null,
        tickTimer: null,
        upTimer: null
      });
    }
    stopRapidFire(trigger) {
      if (!trigger) {
        this.stopAllRapidFires();
        return;
      }
      const key2 = normalizeCombo(trigger);
      const s = this.sessions.get(key2);
      if (!s) return;
      this.endSession(s);
      this.sessions.delete(key2);
    }
    stopAllRapidFires() {
      for (const s of this.sessions.values()) this.endSession(s);
      this.sessions.clear();
    }
    isRapidFireActive(trigger) {
      const s = this.sessions.get(normalizeCombo(trigger));
      return !!(s && s.pressed);
    }
    setRapidFireRate(trigger, hz) {
      const s = this.sessions.get(normalizeCombo(trigger));
      if (!s) return;
      s.rateMs = 1e3 / Math.max(1, hz);
      if (s.pressed) this.restartLoop(s);
    }
    setRapidFireMode(trigger, mode) {
      const s = this.sessions.get(normalizeCombo(trigger));
      if (!s) return;
      s.mode = mode;
    }
    listRapidFires() {
      const out = [];
      for (const [key2, s] of this.sessions.entries()) {
        out.push({
          trigger: key2,
          emit: joinRapid(s.emit),
          rateHz: Math.round(1e3 / s.rateMs),
          mode: s.mode
        });
      }
      return out;
    }
    /* ================= internes ================= */
    attachDoc(doc) {
      if (!doc || this.attachedDocs.has(doc)) return;
      const handler = this.makeHandler(doc);
      const win = doc.defaultView || this.win;
      win.addEventListener("keydown", handler, true);
      win.addEventListener("keypress", handler, true);
      win.addEventListener("keyup", handler, true);
      this.handlers.set(doc, handler);
      this.attachedDocs.add(doc);
    }
    makeHandler(doc) {
      return (evt) => {
        const e = evt;
        if (e[REMAP_FLAG]) return;
        const isRapidSynthetic = !!e[RAPID_SYN_FLAG];
        if (!isRapidSynthetic) this.handleRapidFireInput(doc, e);
        if (!isRapidSynthetic && this.eventBlockers.size) {
          for (const blocker of Array.from(this.eventBlockers)) {
            let shouldBlock = false;
            try {
              shouldBlock = blocker(e);
            } catch {
              shouldBlock = false;
            }
            if (shouldBlock) {
              e.stopImmediatePropagation();
              e.preventDefault();
              return;
            }
          }
        }
        if (!this.enabled) return;
        if (isEditableTarget(e.target)) return;
        if (this.passthrough.has(e.code)) return;
        const combo = evToCombo(e);
        if (this.blockedSet.has(combo)) {
          e.stopImmediatePropagation();
          e.preventDefault();
          return;
        }
        const spec = this.map.get(combo);
        if (!spec) return;
        e.stopImmediatePropagation();
        e.preventDefault();
        const code = spec.code || "";
        const key2 = spec.key !== void 0 ? spec.key : codeToKey(code, e.shiftKey);
        const ctrl = spec.ctrl ?? e.ctrlKey;
        const shift = spec.shift ?? e.shiftKey;
        const alt = spec.alt ?? e.altKey;
        const meta = spec.meta ?? e.metaKey;
        const kc = KEYCODE_TABLE[code] ?? (key2 && key2.length === 1 ? key2.toUpperCase().charCodeAt(0) : 0);
        const eventWindow = doc.defaultView || this.win;
        const ne = new eventWindow.KeyboardEvent(e.type, {
          bubbles: true,
          cancelable: true,
          composed: true,
          key: key2,
          code,
          ctrlKey: ctrl,
          shiftKey: shift,
          altKey: alt,
          metaKey: meta,
          repeat: e.repeat,
          location: e.location
        });
        Object.defineProperties(ne, {
          keyCode: { get: () => kc },
          which: { get: () => kc },
          charCode: { get: () => kc },
          [REMAP_FLAG]: { value: true }
        });
        const target = e.target || doc;
        target.dispatchEvent(ne);
      };
    }
    /* ---------- Rapid-fire internes ---------- */
    handleRapidFireInput(doc, e) {
      if (isEditableTarget(e.target)) return;
      if (e.type === "keydown" && !e.repeat) {
        for (const s of this.sessions.values()) {
          if (this.matches(e, s.trigger)) {
            s.pressed = true;
            s.lastTarget = e.target || doc;
            this.startLoop(doc, s);
          }
        }
      } else if (e.type === "keyup") {
        for (const s of this.sessions.values()) {
          if (this.matches(e, s.trigger)) {
            s.pressed = false;
            this.stopLoop(doc, s);
          }
        }
      }
    }
    matches(e, c) {
      return e.code === c.code && !!e.ctrlKey === !!c.ctrl && !!e.shiftKey === !!c.shift && !!e.altKey === !!c.alt && !!e.metaKey === !!c.meta;
    }
    startLoop(doc, s) {
      this.stopLoop(doc, s);
      const tick = () => {
        if (!s.pressed) return;
        this.dispatchKey(doc, s.lastTarget || doc, "keydown", s.emit, true);
        if (s.mode === "tap") {
          if (s.upTimer) this.win.clearTimeout(s.upTimer);
          s.upTimer = this.win.setTimeout(() => {
            this.dispatchKey(doc, s.lastTarget || doc, "keyup", s.emit, false);
          }, s.keyupDelayMs);
        }
      };
      tick();
      s.tickTimer = this.win.setInterval(tick, s.rateMs);
    }
    stopLoop(doc, s) {
      if (s.tickTimer) {
        this.win.clearInterval(s.tickTimer);
        s.tickTimer = null;
      }
      if (s.upTimer) {
        this.win.clearTimeout(s.upTimer);
        s.upTimer = null;
      }
      if (s.mode === "hold" && s.lastTarget) {
        this.dispatchKey(doc, s.lastTarget, "keyup", s.emit, false);
      }
    }
    restartLoop(s) {
      if (!s.pressed) return;
      const anyDoc = this.doc;
      this.startLoop(anyDoc, s);
    }
    endSession(s) {
      this.stopLoop(this.doc, s);
      s.pressed = false;
      s.lastTarget = null;
    }
    dispatchKey(doc, target, type, c, repeat) {
      const code = c.code;
      const key2 = codeToKey(code, c.shift);
      const kc = KEYCODE_TABLE[code] ?? (key2 && key2.length === 1 ? key2.toUpperCase().charCodeAt(0) : 0);
      const eventWindow = doc.defaultView || this.win;
      const ev = new eventWindow.KeyboardEvent(type, {
        bubbles: true,
        cancelable: true,
        composed: true,
        key: key2,
        code,
        ctrlKey: c.ctrl,
        shiftKey: c.shift,
        altKey: c.alt,
        metaKey: c.meta,
        repeat
      });
      Object.defineProperties(ev, {
        keyCode: { get: () => kc },
        which: { get: () => kc },
        charCode: { get: () => kc },
        [RAPID_SYN_FLAG]: { value: true }
      });
      try {
        target.dispatchEvent(ev);
      } catch {
        doc.dispatchEvent(ev);
      }
    }
  };
  function parseRapid(c) {
    const parts = String(c).split("+").map((s) => s.trim()).filter(Boolean);
    let code = "";
    let ctrl = false, shift = false, alt = false, meta = false;
    for (const p of parts) {
      const P = p.toLowerCase();
      if (P === "ctrl" || P === "control") ctrl = true;
      else if (P === "shift") shift = true;
      else if (P === "alt") alt = true;
      else if (P === "meta" || P === "cmd" || P === "command" || P === "win") meta = true;
      else code = p;
    }
    return { code, ctrl, shift, alt, meta };
  }
  function joinRapid(c) {
    const mods = [];
    if (c.ctrl) mods.push("Ctrl");
    if (c.shift) mods.push("Shift");
    if (c.alt) mods.push("Alt");
    if (c.meta) mods.push("Meta");
    mods.push(c.code);
    return mods.join("+");
  }
  var defaultContext = resolveContext();
  var inGameHotkeys = new InGameHotkeys(true, defaultContext);
  shareGlobal("inGameHotkeys", inGameHotkeys);
  try {
    window.inGameHotkeys = inGameHotkeys;
  } catch {
  }

  // src/services/keybinds.ts
  var SECTION_CONFIG = [
    {
      id: "gui",
      title: "GUI",
      icon: "\u{1F5A5}\uFE0F",
      description: "Choose how you open and move the overlay.",
      actions: [
        {
          id: "gui.toggle",
          label: "\u{1F441}\uFE0F Toggle menu visibility",
          hint: "Opens or closes the Arie's Mod overlay.",
          defaultHotkey: { alt: true, code: "KeyX" }
        },
        {
          id: "gui.drag",
          label: "\u270B Drag HUD",
          hint: "Hold to drag menus interfaces around the screen.",
          defaultHotkey: { alt: true, code: "AltLeft" },
          allowModifierOnly: true
        }
      ]
    },
    {
      id: "shops",
      title: "Shops",
      icon: "\u{1F6D2}",
      description: "Quick shortcuts to every shop tab.",
      actions: [
        {
          id: "shops.seeds",
          label: "\u{1F330} Seeds shop",
          defaultHotkey: { alt: true, code: "KeyS" }
        },
        {
          id: "shops.eggs",
          label: "\u{1F95A} Eggs shop",
          defaultHotkey: { alt: true, code: "KeyE" }
        },
        {
          id: "shops.decors",
          label: "\u{1FA91} Decors shop",
          defaultHotkey: { alt: true, code: "KeyD" }
        },
        {
          id: "shops.tools",
          label: "\u{1F9FA} Tools shop",
          defaultHotkey: { alt: true, code: "KeyT" }
        }
      ]
    },
    {
      id: "game",
      title: "Game",
      icon: "\u{1F3AE}",
      description: "Remap the in-game actions",
      actions: [
        {
          id: "game.action",
          label: "\u26A1 Action",
          defaultHotkey: { code: "Space" },
          holdDetection: {
            label: "Hold to repeat",
            defaultEnabled: false
          }
        },
        {
          id: "game.inventory",
          label: "\u{1F392} Inventory",
          defaultHotkey: { code: "KeyE" }
        },
        {
          id: "game.move-up",
          label: "\u2B06 Move up",
          defaultHotkey: { code: "KeyW" }
        },
        {
          id: "game.move-down",
          label: "\u2B07 Move down",
          defaultHotkey: { code: "KeyS" }
        },
        {
          id: "game.move-left",
          label: "\u2B05 Move left",
          defaultHotkey: { code: "KeyA" }
        },
        {
          id: "game.move-right",
          label: "\u27A1 Move right",
          defaultHotkey: { code: "KeyD" }
        }
      ]
    },
    {
      id: "sell",
      title: "Sell",
      icon: "\u{1F4B0}",
      description: "Streamline selling actions.",
      actions: [
        {
          id: "sell.sell-all",
          label: "\u{1F33E} All crops",
          hint: "Trigger the sell-all flow for harvested crops.",
          defaultHotkey: null
        },
        {
          id: "sell.sell-all-pets",
          label: "\u{1F43E} All pets",
          hint: "Sell every non-favorited pet in your inventory.",
          defaultHotkey: null
        }
      ]
    }
  ];
  var STORAGE_PREFIX = "qws:keybind:";
  var HOLD_STORAGE_PREFIX = "qws:keybind-hold:";
  var STORED_NONE = "__none__";
  var actionMap = /* @__PURE__ */ new Map();
  var defaultMap = /* @__PURE__ */ new Map();
  var cache = /* @__PURE__ */ new Map();
  var listeners2 = /* @__PURE__ */ new Map();
  var holdDefaultMap = /* @__PURE__ */ new Map();
  var holdCache = /* @__PURE__ */ new Map();
  var holdListeners = /* @__PURE__ */ new Map();
  var keybindSections = SECTION_CONFIG.map((section) => {
    const actions = section.actions.map((action2) => {
      const normalized = {
        id: action2.id,
        sectionId: section.id,
        label: action2.label,
        hint: action2.hint,
        allowModifierOnly: action2.allowModifierOnly,
        defaultHotkey: cloneHotkey(action2.defaultHotkey),
        holdDetection: action2.holdDetection ? {
          label: action2.holdDetection.label,
          description: action2.holdDetection.description,
          defaultEnabled: action2.holdDetection.defaultEnabled
        } : void 0
      };
      actionMap.set(normalized.id, normalized);
      defaultMap.set(normalized.id, cloneHotkey(action2.defaultHotkey));
      if (action2.holdDetection) {
        holdDefaultMap.set(normalized.id, !!action2.holdDetection.defaultEnabled);
      }
      return normalized;
    });
    return {
      id: section.id,
      title: section.title,
      description: section.description,
      icon: section.icon,
      actions
    };
  });
  var PET_SECTION_ID = "pets";
  var PET_TEAM_ACTION_PREFIX = "pets.team.";
  var PET_TEAM_NEXT_ID = "pets.team.next";
  var PET_TEAM_PREV_ID = "pets.team.prev";
  var petSection = {
    id: PET_SECTION_ID,
    title: "Pets",
    icon: "\u{1F437}",
    description: "Assign shortcuts to your pet teams and cycle through them instantly.",
    actions: []
  };
  keybindSections.push(petSection);
  var petActionIds = /* @__PURE__ */ new Set();
  function getPetTeamActionId(teamId) {
    return `${PET_TEAM_ACTION_PREFIX}${teamId}`;
  }
  function disposePetAction(id) {
    actionMap.delete(id);
    defaultMap.delete(id);
    cache.delete(id);
    listeners2.delete(id);
    holdDefaultMap.delete(id);
    holdCache.delete(id);
    holdListeners.delete(id);
  }
  function registerPetAction(action2, defaultHotkey) {
    const normalized = {
      id: action2.id,
      sectionId: PET_SECTION_ID,
      label: action2.label,
      hint: action2.hint,
      allowModifierOnly: action2.allowModifierOnly,
      defaultHotkey: cloneHotkey(defaultHotkey),
      holdDetection: action2.holdDetection ? {
        label: action2.holdDetection.label,
        description: action2.holdDetection.description,
        defaultEnabled: action2.holdDetection.defaultEnabled
      } : void 0
    };
    actionMap.set(normalized.id, normalized);
    defaultMap.set(normalized.id, cloneHotkey(defaultHotkey));
    petActionIds.add(normalized.id);
    petSection.actions.push(normalized);
  }
  function updatePetKeybinds(teams) {
    for (const id of petActionIds) {
      disposePetAction(id);
    }
    petActionIds.clear();
    petSection.actions = [];
    registerPetAction(
      {
        id: PET_TEAM_PREV_ID,
        sectionId: PET_SECTION_ID,
        label: "\u25C0\uFE0F Previous team",
        defaultHotkey: null
      },
      null
    );
    registerPetAction(
      {
        id: PET_TEAM_NEXT_ID,
        sectionId: PET_SECTION_ID,
        label: "\u25B6\uFE0F Next team",
        defaultHotkey: null
      },
      null
    );
    teams.forEach((team, index) => {
      const name = String(team?.name || "").trim();
      const labelName = name.length ? name : `Team ${index + 1}`;
      registerPetAction(
        {
          id: getPetTeamActionId(team.id),
          sectionId: PET_SECTION_ID,
          label: `Use team \u2014 ${labelName}`,
          defaultHotkey: null
        },
        null
      );
    });
  }
  updatePetKeybinds([]);
  var GAME_KEYBIND_TARGETS = {
    "game.action": "Space",
    "game.inventory": "KeyE",
    "game.move-up": "KeyW",
    // Z (AZERTY) == KeyW
    "game.move-down": "KeyS",
    // S
    "game.move-left": "KeyA",
    // Q (AZERTY) == KeyA
    "game.move-right": "KeyD"
    // D
  };
  var GAME_KEYBIND_IDS = [
    "game.action",
    "game.inventory",
    "game.move-up",
    "game.move-down",
    "game.move-left",
    "game.move-right"
  ];
  var gameActiveStates = /* @__PURE__ */ new Map();
  var gameKeybindsInstalled = false;
  var GAME_ACTION_ID = "game.action";
  var gameActionBlockers = /* @__PURE__ */ new Set();
  var gameActionBlockedCombos = /* @__PURE__ */ new Set();
  function getCombosForGameAction() {
    const state2 = gameActiveStates.get(GAME_ACTION_ID);
    if (!state2) return [];
    const combo = state2.combo;
    return typeof combo === "string" && combo.length ? [combo] : [];
  }
  function applyGameActionBlockers() {
    const shouldBlock = gameActionBlockers.size > 0;
    const desired = /* @__PURE__ */ new Set();
    if (shouldBlock) {
      for (const combo of getCombosForGameAction()) {
        if (combo) desired.add(combo);
      }
    }
    for (const combo of gameActionBlockedCombos) {
      if (!desired.has(combo)) {
        try {
          inGameHotkeys.unblock(combo);
        } catch {
        }
      }
    }
    if (shouldBlock) {
      for (const combo of desired) {
        if (!gameActionBlockedCombos.has(combo)) {
          try {
            inGameHotkeys.block(combo);
          } catch {
          }
        }
      }
    }
    gameActionBlockedCombos.clear();
    if (shouldBlock) {
      for (const combo of desired) gameActionBlockedCombos.add(combo);
    }
  }
  function hotkeyToCombo(hk) {
    if (!hk) return null;
    const combo = hotkeyToString(hk);
    return combo.length ? combo : null;
  }
  function purgeTargetBindings(emitCombo) {
    try {
      inGameHotkeys.unblock(emitCombo);
    } catch {
    }
    try {
      const curr = inGameHotkeys.current();
      for (const [from, to] of Object.entries(curr)) {
        const toCode = String(to).split("+").pop();
        if (toCode === emitCombo) {
          try {
            inGameHotkeys.remove(from);
          } catch {
          }
        }
      }
    } catch {
    }
  }
  function isMac2() {
    return typeof navigator !== "undefined" && /Mac|iPhone|iPad|iPod/.test(navigator.platform || "");
  }
  function codeToDisplay(code) {
    if (!code) return "";
    const mKey = code.match(/^Key([A-Z])$/);
    if (mKey) return mKey[1];
    const mDigit = code.match(/^Digit([0-9])$/);
    if (mDigit) return mDigit[1];
    if (code === "ControlLeft" || code === "ControlRight") return "Ctrl";
    if (code === "AltLeft" || code === "AltRight") return "Alt";
    if (code === "ShiftLeft" || code === "ShiftRight") return "Shift";
    if (code === "MetaLeft" || code === "MetaRight") return isMac2() ? "\u2318" : "Win";
    if (code === "Space") return "Space";
    if (code === "Enter") return "Enter";
    if (code === "Escape") return "Esc";
    if (code === "Tab") return "Tab";
    if (code === "Backspace") return "Backspace";
    if (code === "Delete") return "Del";
    if (code === "Insert") return "Ins";
    if (code === "ArrowUp") return "\u2191";
    if (code === "ArrowDown") return "\u2193";
    if (code === "ArrowLeft") return "\u2190";
    if (code === "ArrowRight") return "\u2192";
    return code;
  }
  function prettyHotkey(hk) {
    if (!hk) return "\u2014";
    const mods = [];
    if (hk.ctrl) mods.push("Ctrl");
    if (hk.shift) mods.push("Shift");
    if (hk.alt) mods.push("Alt");
    if (hk.meta) mods.push(isMac2() ? "\u2318" : "Win");
    let base = "";
    const k = hk.key;
    if (typeof k === "string" && k.length === 1) {
      base = k.toUpperCase();
    } else {
      base = codeToDisplay(hk.code);
    }
    const baseIsModifier = base && ["Ctrl", "Shift", "Alt", "\u2318", "Win"].includes(base);
    const parts = baseIsModifier ? mods : mods.concat(base ? [base] : []);
    return parts.join(" + ");
  }
  function syncGameKeybind(id) {
    if (typeof window === "undefined") return;
    const emitCombo = GAME_KEYBIND_TARGETS[id];
    purgeTargetBindings(emitCombo);
    const prev = gameActiveStates.get(id);
    if (prev) {
      if (prev.rapidFire) {
        try {
          inGameHotkeys.stopRapidFire(prev.combo);
        } catch {
        }
      }
      gameActiveStates.delete(id);
    }
    const combo = hotkeyToCombo(getKeybind(id));
    if (!combo) {
      if (id === GAME_ACTION_ID) {
        applyGameActionBlockers();
      }
      return;
    }
    const holdEnabled = getKeybindHoldDetection(id);
    let replaced = false;
    if (combo !== emitCombo) {
      try {
        inGameHotkeys.replace(emitCombo, combo);
        replaced = true;
      } catch {
      }
    }
    let rapidFire = false;
    if (holdEnabled) {
      try {
        inGameHotkeys.startRapidFire({
          trigger: combo,
          // on tient la touche choisie
          emit: combo,
          // remapper convertira en emitCombo si replace() actif
          mode: "tap",
          rateHz: 10
        });
        rapidFire = true;
      } catch {
      }
    }
    gameActiveStates.set(id, { combo, replaced, rapidFire });
    if (id === GAME_ACTION_ID) {
      applyGameActionBlockers();
    }
  }
  function cloneHotkey(hk) {
    return hk ? { ...hk } : null;
  }
  function hotkeysEqual(a, b) {
    if (!a && !b) return true;
    if (!a || !b) return false;
    return hotkeyToString(a) === hotkeyToString(b);
  }
  function storageKey(id) {
    return `${STORAGE_PREFIX}${id}`;
  }
  function holdStorageKey(id) {
    return `${HOLD_STORAGE_PREFIX}${id}`;
  }
  function readStored(id) {
    if (typeof window === "undefined") return void 0;
    let raw = null;
    try {
      raw = window.localStorage.getItem(storageKey(id));
    } catch {
      return void 0;
    }
    if (raw == null) return void 0;
    if (raw === STORED_NONE) return null;
    const parsed = stringToHotkey(raw);
    return parsed ?? null;
  }
  function writeStored(id, hk) {
    if (typeof window === "undefined") return;
    try {
      if (hk) {
        window.localStorage.setItem(storageKey(id), hotkeyToString(hk));
      } else {
        window.localStorage.setItem(storageKey(id), STORED_NONE);
      }
    } catch {
    }
  }
  function removeStored(id) {
    if (typeof window === "undefined") return;
    try {
      window.localStorage.removeItem(storageKey(id));
    } catch {
    }
  }
  function readHoldStored(id) {
    if (typeof window === "undefined") return void 0;
    let raw = null;
    try {
      raw = window.localStorage.getItem(holdStorageKey(id));
    } catch {
      return void 0;
    }
    if (raw == null) return void 0;
    return raw === "1";
  }
  function writeHoldStored(id, enabled) {
    if (typeof window === "undefined") return;
    try {
      window.localStorage.setItem(holdStorageKey(id), enabled ? "1" : "0");
    } catch {
    }
  }
  function emitHoldChange(id) {
    const set2 = holdListeners.get(id);
    if (!set2 || set2.size === 0) return;
    const current = getKeybindHoldDetection(id);
    for (const cb of set2) cb(current);
  }
  function emitChange(id) {
    const set2 = listeners2.get(id);
    if (!set2 || set2.size === 0) return;
    const current = cloneHotkey(getKeybind(id));
    for (const cb of set2) cb(current);
  }
  function ensureCache(id) {
    if (cache.has(id)) {
      return cloneHotkey(cache.get(id) ?? null);
    }
    const stored = readStored(id);
    const resolved = stored === void 0 ? cloneHotkey(defaultMap.get(id) ?? null) : cloneHotkey(stored);
    cache.set(id, resolved);
    return cloneHotkey(resolved);
  }
  function ensureHoldCache(id) {
    if (!holdDefaultMap.has(id)) return false;
    if (holdCache.has(id)) {
      return holdCache.get(id) ?? false;
    }
    const stored = readHoldStored(id);
    const resolved = stored === void 0 ? !!holdDefaultMap.get(id) : stored;
    holdCache.set(id, resolved);
    return resolved;
  }
  function getKeybind(id) {
    return ensureCache(id);
  }
  function getDefaultKeybind(id) {
    return cloneHotkey(defaultMap.get(id) ?? null);
  }
  function setKeybind(id, hk) {
    const current = getKeybind(id);
    if (hotkeysEqual(current, hk)) return;
    const next = cloneHotkey(hk);
    if (next) {
      const asString = hotkeyToString(next);
      for (const otherId of actionMap.keys()) {
        if (otherId === id) continue;
        const other = getKeybind(otherId);
        if (!other) continue;
        if (hotkeyToString(other) !== asString) continue;
        cache.set(otherId, null);
        writeStored(otherId, null);
        emitChange(otherId);
      }
    }
    cache.set(id, next);
    writeStored(id, next);
    emitChange(id);
  }
  function resetKeybind(id) {
    cache.delete(id);
    removeStored(id);
    emitChange(id);
  }
  function getKeybindHoldDetection(id) {
    return ensureHoldCache(id);
  }
  function setKeybindHoldDetection(id, enabled) {
    if (!holdDefaultMap.has(id)) return;
    const current = ensureHoldCache(id);
    if (current === enabled) return;
    holdCache.set(id, enabled);
    writeHoldStored(id, enabled);
    emitHoldChange(id);
  }
  function onKeybindHoldDetectionChange(id, cb) {
    if (!holdDefaultMap.has(id)) {
      return () => {
      };
    }
    const set2 = holdListeners.get(id) ?? /* @__PURE__ */ new Set();
    if (!holdListeners.has(id)) holdListeners.set(id, set2);
    set2.add(cb);
    return () => {
      set2.delete(cb);
      if (set2.size === 0) holdListeners.delete(id);
    };
  }
  function onKeybindChange(id, cb) {
    const set2 = listeners2.get(id) ?? /* @__PURE__ */ new Set();
    if (!listeners2.has(id)) listeners2.set(id, set2);
    set2.add(cb);
    return () => {
      set2.delete(cb);
      if (set2.size === 0) listeners2.delete(id);
    };
  }
  function eventMatchesKeybind(id, e) {
    return matchHotkey(e, getKeybind(id));
  }
  function installGameKeybindsOnce() {
    if (gameKeybindsInstalled || typeof window === "undefined") return;
    gameKeybindsInstalled = true;
    for (const id of GAME_KEYBIND_IDS) {
      syncGameKeybind(id);
      onKeybindChange(id, () => syncGameKeybind(id));
      onKeybindHoldDetectionChange(id, () => syncGameKeybind(id));
    }
  }
  function getKeybindLabel(id) {
    return prettyHotkey(getKeybind(id));
  }
  function getKeybindSections() {
    return keybindSections.map((section) => ({
      ...section,
      actions: section.actions.map((action2) => ({
        ...action2,
        defaultHotkey: cloneHotkey(action2.defaultHotkey),
        holdDetection: action2.holdDetection ? {
          label: action2.holdDetection.label,
          description: action2.holdDetection.description,
          defaultEnabled: action2.holdDetection.defaultEnabled
        } : void 0
      }))
    }));
  }
  if (typeof window !== "undefined") {
    window.addEventListener("storage", (event) => {
      if (!event.key || !event.key.startsWith(STORAGE_PREFIX)) return;
      const id = event.key.slice(STORAGE_PREFIX.length);
      if (!actionMap.has(id)) return;
      cache.delete(id);
      emitChange(id);
    });
    window.addEventListener("storage", (event) => {
      if (!event.key || !event.key.startsWith(HOLD_STORAGE_PREFIX)) return;
      const id = event.key.slice(HOLD_STORAGE_PREFIX.length);
      if (!holdDefaultMap.has(id)) return;
      holdCache.delete(id);
      emitHoldChange(id);
    });
  }

  // src/utils/keyboard.ts
  function shouldIgnoreKeydown(e) {
    const el2 = e.target;
    if (!el2) return false;
    return el2.isContentEditable || el2.tagName === "INPUT" || el2.tagName === "TEXTAREA" || el2.tagName === "SELECT";
  }

  // src/services/pets.ts
  var LS_OVERRIDES_KEY = "qws:pets:overrides:v1";
  var LS_UI_KEY = "qws:pets:ui:v1";
  var LS_TEAMS_KEY = "qws:pets:teams:v1";
  var LS_TEAM_SEARCH_KEY = "qws:pets:teamSearch:v1";
  var LS_TEAM_HK_PREFIX = "qws:hk:petteam:use:";
  var TEAM_HK_MAP = /* @__PURE__ */ new Map();
  var TEAM_HK_UNSUBS = /* @__PURE__ */ new Map();
  var hkNextTeam = null;
  var hkPrevTeam = null;
  var unsubNextHotkey = null;
  var unsubPrevHotkey = null;
  var orderedTeamIds = [];
  var lastUsedTeamId = null;
  var legacyKeyForTeam = (id) => `${LS_TEAM_HK_PREFIX}${id}`;
  function syncTeamHotkey(teamId) {
    const hk = getKeybind(getPetTeamActionId(teamId));
    if (hk) TEAM_HK_MAP.set(teamId, hk);
    else TEAM_HK_MAP.delete(teamId);
  }
  function syncNextTeamHotkey() {
    hkNextTeam = getKeybind(PET_TEAM_NEXT_ID);
  }
  function syncPrevTeamHotkey() {
    hkPrevTeam = getKeybind(PET_TEAM_PREV_ID);
  }
  function ensureLegacyTeamHotkeyMigration(teamId) {
    if (typeof window === "undefined") return;
    try {
      const legacy = localStorage.getItem(legacyKeyForTeam(teamId));
      if (!legacy) return;
      const actionId = getPetTeamActionId(teamId);
      const existing = getKeybind(actionId);
      if (!existing) {
        const hk = stringToHotkey(legacy);
        if (hk) {
          setKeybind(actionId, hk);
        }
      }
      localStorage.removeItem(legacyKeyForTeam(teamId));
    } catch {
    }
  }
  function normalizeTeamList(teams) {
    if (!Array.isArray(teams)) return [];
    return teams.map((t) => ({ id: String(t?.id ?? ""), name: t?.name ?? null })).filter((t) => t.id.length > 0);
  }
  function ensureLastUsedTeamIsValid() {
    if (!orderedTeamIds.length) {
      lastUsedTeamId = null;
      return;
    }
    if (!lastUsedTeamId || !orderedTeamIds.includes(lastUsedTeamId)) {
      lastUsedTeamId = orderedTeamIds[0] ?? null;
    }
  }
  function adjacentTeam(direction) {
    if (!orderedTeamIds.length) return null;
    if (!lastUsedTeamId || !orderedTeamIds.includes(lastUsedTeamId)) {
      return direction === 1 ? orderedTeamIds[0] ?? null : orderedTeamIds[orderedTeamIds.length - 1] ?? null;
    }
    if (orderedTeamIds.length === 1) return orderedTeamIds[0] ?? null;
    const currentIndex2 = orderedTeamIds.indexOf(lastUsedTeamId);
    let nextIndex = currentIndex2 + direction;
    if (nextIndex < 0) nextIndex = orderedTeamIds.length - 1;
    if (nextIndex >= orderedTeamIds.length) nextIndex = 0;
    return orderedTeamIds[nextIndex] ?? null;
  }
  function markTeamAsUsed(teamId) {
    lastUsedTeamId = teamId ? String(teamId) : null;
  }
  function setTeamsForHotkeys(rawTeams) {
    for (const unsub of TEAM_HK_UNSUBS.values()) {
      try {
        unsub();
      } catch {
      }
    }
    TEAM_HK_UNSUBS.clear();
    if (unsubNextHotkey) {
      try {
        unsubNextHotkey();
      } catch {
      }
      unsubNextHotkey = null;
    }
    if (unsubPrevHotkey) {
      try {
        unsubPrevHotkey();
      } catch {
      }
      unsubPrevHotkey = null;
    }
    const teams = normalizeTeamList(rawTeams);
    updatePetKeybinds(teams);
    orderedTeamIds = teams.map((t) => t.id);
    ensureLastUsedTeamIsValid();
    const keep = new Set(orderedTeamIds);
    for (const teamId of Array.from(TEAM_HK_MAP.keys())) {
      if (!keep.has(teamId)) TEAM_HK_MAP.delete(teamId);
    }
    teams.forEach((team) => {
      ensureLegacyTeamHotkeyMigration(team.id);
      syncTeamHotkey(team.id);
      const unsub = onKeybindChange(getPetTeamActionId(team.id), () => syncTeamHotkey(team.id));
      TEAM_HK_UNSUBS.set(team.id, unsub);
    });
    syncNextTeamHotkey();
    syncPrevTeamHotkey();
    unsubNextHotkey = onKeybindChange(PET_TEAM_NEXT_ID, () => syncNextTeamHotkey());
    unsubPrevHotkey = onKeybindChange(PET_TEAM_PREV_ID, () => syncPrevTeamHotkey());
  }
  function installPetTeamHotkeysOnce(onUseTeam) {
    const FLAG = "__qws_pet_team_hk_installed";
    if (window[FLAG]) return;
    window.addEventListener(
      "keydown",
      (e) => {
        if (shouldIgnoreKeydown(e)) return;
        const useTeam = (teamId) => {
          if (!teamId) return;
          markTeamAsUsed(teamId);
          onUseTeam(teamId);
        };
        if (hkPrevTeam && matchHotkey(e, hkPrevTeam)) {
          const target = adjacentTeam(-1);
          if (target) {
            e.preventDefault();
            e.stopPropagation();
            useTeam(target);
            return;
          }
        }
        if (hkNextTeam && matchHotkey(e, hkNextTeam)) {
          const target = adjacentTeam(1);
          if (target) {
            e.preventDefault();
            e.stopPropagation();
            useTeam(target);
            return;
          }
        }
        for (const [teamId, hk] of TEAM_HK_MAP) {
          if (matchHotkey(e, hk)) {
            e.preventDefault();
            e.stopPropagation();
            useTeam(teamId);
            break;
          }
        }
      },
      true
    );
    window[FLAG] = true;
  }
  var _AB = petAbilities ?? {};
  function _abilityName(id) {
    const key2 = String(id ?? "");
    const raw = typeof _AB?.[key2]?.name === "string" && _AB[key2].name.trim() ? _AB[key2].name : key2;
    return String(raw);
  }
  function _abilityNameWithoutLevel(id) {
    const key2 = String(id ?? "");
    const raw = typeof _AB?.[key2]?.name === "string" && _AB[key2].name.trim() ? _AB[key2].name : key2;
    return String(raw).replace(/(?:\s+|-)?(?:I|II|III|IV|V|VI|VII|VIII|IX|X)\s*$/, "").trim();
  }
  function _parseTeamSearch(raw) {
    const s = String(raw || "").trim();
    const m = s.match(/^(ab|sp):\s*(.*)$/i);
    if (!m) return { mode: "text", value: s };
    return { mode: m[1].toLowerCase() === "ab" ? "ability" : "species", value: (m[2] || "").trim() };
  }
  async function _abilityNameToPresentIds(name) {
    await _ensureInventoryWatchersStarted();
    const target = String(name || "").toLowerCase().trim().replace(/(?:\s+|-)?(?:i|ii|iii|iv|v|vi|vii|viii|ix|x)\s*$/i, "");
    const ids = /* @__PURE__ */ new Set();
    if (!target) return ids;
    for (const p of _invPetsCache) {
      const abs = Array.isArray(p.abilities) ? p.abilities : [];
      for (const id of abs) {
        if (_abilityNameWithoutLevel(id).toLowerCase() === target) ids.add(id);
      }
    }
    return ids;
  }
  var _s = (v) => (v ?? "").toLowerCase();
  var _sOpt = (v) => typeof v === "string" ? v : null;
  var _n = (v) => Number.isFinite(v) ? v : 0;
  var _sArr = (v) => Array.isArray(v) ? v.filter((x) => typeof x === "string") : [];
  function _canonicalSpecies(s) {
    if (!s) return s;
    if (petCatalog[s]) return s;
    const t = s.charAt(0).toUpperCase() + s.slice(1).toLowerCase();
    return petCatalog[t] ? t : s;
  }
  function _invPetToRawItem(p) {
    return {
      id: p.id,
      itemType: "Pet",
      petSpecies: _canonicalSpecies(p.petSpecies),
      name: p.name ?? null,
      xp: p.xp,
      hunger: p.hunger,
      mutations: Array.isArray(p.mutations) ? p.mutations.slice() : [],
      targetScale: p.targetScale,
      abilities: Array.isArray(p.abilities) ? p.abilities.slice() : []
    };
  }
  function loadTeams() {
    try {
      const raw = localStorage.getItem(LS_TEAMS_KEY);
      if (!raw) return [];
      const arr = JSON.parse(raw);
      if (!Array.isArray(arr)) return [];
      return arr.map((t) => ({
        id: String(t?.id || ""),
        name: String(t?.name || "Team"),
        slots: Array.isArray(t?.slots) ? t.slots.slice(0, 3).map((x) => x ? String(x) : null) : [null, null, null]
      })).filter((t) => t.id);
    } catch {
      return [];
    }
  }
  function saveTeams(arr) {
    try {
      localStorage.setItem(LS_TEAMS_KEY, JSON.stringify(arr));
    } catch {
    }
  }
  function _uid() {
    try {
      return crypto.randomUUID();
    } catch {
      return `t_${Date.now().toString(36)}_${Math.random().toString(16).slice(2)}`;
    }
  }
  function _loadTeamSearchMap() {
    try {
      const raw = localStorage.getItem(LS_TEAM_SEARCH_KEY);
      const obj = raw ? JSON.parse(raw) : {};
      return obj && typeof obj === "object" ? obj : {};
    } catch {
      return {};
    }
  }
  function _saveTeamSearchMap(map2) {
    try {
      localStorage.setItem(LS_TEAM_SEARCH_KEY, JSON.stringify(map2));
    } catch {
    }
  }
  var _teams = loadTeams();
  var _teamSearch = _loadTeamSearchMap();
  var _invRaw = null;
  var _activeRaw = [];
  var _invPetsCache = [];
  var _invUnsub = null;
  var _activeUnsub = null;
  var _invSig = null;
  var _activeSig = null;
  function _inventoryItemToPet(x) {
    if (!x || x.itemType !== "Pet") return null;
    const id = _s(x.id);
    if (!id) return null;
    return {
      id,
      itemType: "Pet",
      petSpecies: _s(x.petSpecies ?? x.data?.petSpecies),
      name: _sOpt(x.name ?? x.data?.name ?? null),
      xp: _n(x.xp ?? x.data?.xp),
      hunger: _n(x.hunger ?? x.data?.hunger),
      mutations: _sArr(x.mutations ?? x.data?.mutations),
      targetScale: Number.isFinite(x.targetScale ?? x.data?.targetScale) ? Number(x.targetScale ?? x.data?.targetScale) : void 0,
      abilities: _sArr(x.abilities ?? x.data?.abilities)
    };
  }
  function _activeSlotToPet(entry) {
    const slot = entry?.slot;
    if (!slot || typeof slot !== "object") return null;
    const id = _s(slot.id);
    if (!id) return null;
    return {
      id,
      itemType: "Pet",
      petSpecies: _s(slot.petSpecies),
      name: _sOpt(slot.name ?? null),
      xp: _n(slot.xp),
      hunger: _n(slot.hunger),
      mutations: _sArr(slot.mutations),
      targetScale: Number.isFinite(slot.targetScale) ? Number(slot.targetScale) : void 0,
      abilities: _sArr(slot.abilities)
    };
  }
  function _petSigStableNoXpNoHunger(p) {
    return JSON.stringify({
      id: p.id,
      itemType: "Pet",
      petSpecies: p.petSpecies,
      name: p.name ?? null,
      mutations: Array.isArray(p.mutations) ? p.mutations : [],
      targetScale: Number.isFinite(p.targetScale) ? p.targetScale : null,
      abilities: Array.isArray(p.abilities) ? p.abilities : []
    });
  }
  function _buildInvSigFromInventory(inv) {
    const out = /* @__PURE__ */ new Map();
    const items = Array.isArray(inv?.items) ? inv.items : Array.isArray(inv) ? inv : [];
    for (const it of items) {
      const p = _inventoryItemToPet(it);
      if (p) out.set(p.id, _petSigStableNoXpNoHunger(p));
    }
    return out;
  }
  function _buildActiveSig(list) {
    const out = /* @__PURE__ */ new Map();
    const arr = Array.isArray(list) ? list : [];
    for (const e of arr) {
      const p = _activeSlotToPet(e);
      if (p) out.set(p.id, _petSigStableNoXpNoHunger(p));
    }
    return out;
  }
  function _mapsEqual(a, b) {
    if (!a) return false;
    if (a.size !== b.size) return false;
    for (const [k, v] of b) if (a.get(k) !== v) return false;
    return true;
  }
  function _rebuildInvPets() {
    const map2 = /* @__PURE__ */ new Map();
    const items = Array.isArray(_invRaw?.items) ? _invRaw.items : Array.isArray(_invRaw) ? _invRaw : [];
    for (const it of items) {
      const p = _inventoryItemToPet(it);
      if (p && p.id) map2.set(p.id, p);
    }
    const act = Array.isArray(_activeRaw) ? _activeRaw : [];
    for (const e of act) {
      const p = _activeSlotToPet(e);
      if (p && p.id) map2.set(p.id, p);
    }
    _invPetsCache = Array.from(map2.values());
  }
  async function _startInventoryWatcher() {
    const unsub = await (async () => {
      try {
        const cur = await Atoms.inventory.myInventory.get();
        _invSig = _buildInvSigFromInventory(cur);
        _invRaw = cur;
        _rebuildInvPets();
      } catch {
      }
      return Atoms.inventory.myInventory.onChange((inv) => {
        const nextSig = _buildInvSigFromInventory(inv);
        if (_mapsEqual(_invSig, nextSig)) return;
        _invSig = nextSig;
        _invRaw = inv;
        _rebuildInvPets();
      });
    })();
    _invUnsub = () => {
      try {
        unsub();
      } catch {
      }
    };
  }
  async function _startActivePetsWatcher() {
    const unsub = await (async () => {
      try {
        const cur = await Atoms.pets.myPetInfos.get();
        _activeSig = _buildActiveSig(cur);
        _activeRaw = Array.isArray(cur) ? cur : [];
        _rebuildInvPets();
      } catch {
      }
      return Atoms.pets.myPetInfos.onChange((list) => {
        const nextSig = _buildActiveSig(list);
        if (_mapsEqual(_activeSig, nextSig)) return;
        _activeSig = nextSig;
        _activeRaw = Array.isArray(list) ? list : [];
        _rebuildInvPets();
      });
    })();
    _activeUnsub = () => {
      try {
        unsub();
      } catch {
      }
    };
  }
  async function _ensureInventoryWatchersStarted() {
    if (!_invUnsub) await _startInventoryWatcher();
    if (!_activeUnsub) await _startActivePetsWatcher();
    if (!_invPetsCache.length) {
      try {
        const [inv, active] = await Promise.all([
          Atoms.inventory.myInventory.get(),
          Atoms.pets.myPetInfos.get()
        ]);
        _invSig = _buildInvSigFromInventory(inv);
        _activeSig = _buildActiveSig(active);
        _invRaw = inv;
        _activeRaw = Array.isArray(active) ? active : [];
        _rebuildInvPets();
      } catch {
      }
    }
  }
  async function clearHandSelection() {
    try {
      await Atoms.inventory.setSelectedIndexToEnd.set(null);
    } catch (err) {
    }
    try {
      await Atoms.inventory.myPossiblyNoLongerValidSelectedItemIndex.set(null);
    } catch (err) {
    }
    try {
      await PlayerService.setSelectedItem(null);
    } catch (err) {
    }
    try {
      await PlayerService.dropObject();
    } catch (err) {
    }
  }
  async function _waitValidatedInventoryIndex(timeoutMs = 2e4) {
    await clearHandSelection();
    const t0 = performance.now();
    while (performance.now() - t0 < timeoutMs) {
      try {
        const modalVal = await Atoms.ui.activeModal.get();
        if (!isInventoryOpen(modalVal)) return null;
      } catch {
        return null;
      }
      try {
        const v = await Atoms.inventory.myValidatedSelectedItemIndex.get();
        if (typeof v === "number" && Number.isInteger(v) && v >= 0) return v;
      } catch {
      }
      await new Promise((r) => setTimeout(r, 80));
    }
    return null;
  }
  var _belowThreshold = /* @__PURE__ */ new Map();
  var DEFAULT_OVERRIDE = { enabled: false, thresholdPct: 10, crops: {} };
  var DEFAULT_UI = { selectedPetId: null };
  var _currentPets = [];
  var _userTriggerCb = null;
  function saveOverrides(map2) {
    try {
      localStorage.setItem(LS_OVERRIDES_KEY, JSON.stringify(map2));
    } catch (err) {
    }
  }
  function loadOverrides() {
    try {
      const raw = localStorage.getItem(LS_OVERRIDES_KEY);
      if (!raw) return {};
      const obj = JSON.parse(raw);
      const out = obj && typeof obj === "object" ? obj : {};
      return out;
    } catch (err) {
      return {};
    }
  }
  function saveUIState(next) {
    try {
      localStorage.setItem(LS_UI_KEY, JSON.stringify(next));
    } catch (err) {
    }
  }
  function loadUIState() {
    try {
      const raw = localStorage.getItem(LS_UI_KEY);
      if (!raw) return { ...DEFAULT_UI };
      const obj = JSON.parse(raw);
      const merged = { ...DEFAULT_UI, ...obj || {} };
      return merged;
    } catch (err) {
      return { ...DEFAULT_UI };
    }
  }
  function cloneOverride(o) {
    const src = o ?? DEFAULT_OVERRIDE;
    return {
      enabled: !!src.enabled,
      thresholdPct: Math.min(100, Math.max(1, Number(src.thresholdPct) || DEFAULT_OVERRIDE.thresholdPct)),
      crops: { ...src.crops || {} }
    };
  }
  function clampPct(n) {
    return Math.max(0, Math.min(100, n));
  }
  function getCompatibleCropsFromData(species) {
    const PC = petCatalog;
    const entry = PC?.[species];
    const raw = entry?.diet ?? entry?.compatibleCrops ?? entry?.crops ?? [];
    const arr = Array.isArray(raw) ? raw : [];
    return arr.filter((c) => typeof c === "string" && c.length > 0);
  }
  function getMaxHungerFromData(species) {
    const v = petCatalog?.[species]?.coinsToFullyReplenishHunger;
    if (typeof v === "number" && Number.isFinite(v) && v > 0) return v;
    return 3e3;
  }
  async function findPetById(petId) {
    try {
      const list = await PlayerService.getPets();
      const arr = Array.isArray(list) ? list : [];
      return arr.find((p) => String(p?.slot?.id || "") === String(petId)) ?? null;
    } catch {
      return null;
    }
  }
  function findFirstCompatibleInvItem(allowed, inv) {
    const arr = Array.isArray(inv) ? inv : [];
    for (const it of arr) {
      const species = String(it?.species || "");
      if (species && allowed.has(species)) return it;
    }
    return null;
  }
  function _emitTrigger(payload) {
    try {
      _userTriggerCb?.(payload);
    } catch {
    }
  }
  async function _evaluatePet(pet) {
    const petId = String(pet?.slot?.id || "");
    if (!petId) return;
    const ov = PetsService.getOverride(petId);
    if (!ov.enabled) {
      _belowThreshold.set(petId, false);
      return;
    }
    const hungerPct = PetsService.getHungerPctFor(pet);
    const thresholdPct = Math.max(1, Math.min(100, ov.thresholdPct | 0 || 10));
    const previouslyBelow = _belowThreshold.get(petId) === true;
    const nowBelow = hungerPct < thresholdPct;
    if (nowBelow && !previouslyBelow) {
      let allowedSet;
      try {
        allowedSet = await PetsService.getPetAllowedCrops(petId);
      } catch {
        const species = String(pet?.slot?.petSpecies || "");
        allowedSet = new Set(PetsService.getCompatibleCropsForSpecies(species));
      }
      const allowed = Array.from(allowedSet);
      let chosen = null;
      let didUnfavorite = false;
      try {
        const [invRaw, favIdsRaw] = await Promise.all([
          PlayerService.getCropInventoryState(),
          PlayerService.getFavoriteIds?.() ?? []
        ]);
        const inv = Array.isArray(invRaw) ? invRaw : [];
        const favSet = new Set(Array.isArray(favIdsRaw) ? favIdsRaw : []);
        const invNonFav = inv.filter((it) => !favSet.has(String(it?.id)));
        chosen = findFirstCompatibleInvItem(allowedSet, invNonFav);
        if (chosen?.id && PlayerService.feedPet) {
          try {
            await PlayerService.feedPet(petId, chosen.id);
          } catch {
          }
        }
      } catch {
      }
      _emitTrigger({
        pet,
        petId,
        species: String(pet?.slot?.petSpecies || ""),
        hungerPct,
        thresholdPct,
        allowedCrops: allowed,
        chosenItem: chosen,
        didUnfavorite
      });
    }
    _belowThreshold.set(petId, nowBelow);
  }
  async function _evaluateAll() {
    const arr = Array.isArray(_currentPets) ? _currentPets : [];
    for (const p of arr) {
      try {
        await _evaluatePet(p);
      } catch {
      }
    }
  }
  var PetsService = {
    /* --------- Player-facing (UI list/subscribe) --------- */
    getPets() {
      return PlayerService.getPets();
    },
    onPetsChange(cb) {
      return PlayerService.onPetsChange(cb);
    },
    onPetsChangeNow(cb) {
      return PlayerService.onPetsChangeNow(cb);
    },
    /* ------------------------- Abilities utils ------------------------- */
    getAbilityName(id) {
      return _abilityName(id);
    },
    getAbilityNameWithoutLevel(id) {
      return _abilityNameWithoutLevel(id);
    },
    /* ------------------------- Autofeed + per-pet UI state ------------------------- */
    setUIState(next) {
      const cur = loadUIState();
      const merged = { ...cur, ...next || {} };
      saveUIState(merged);
      return merged;
    },
    setSelectedPet(id) {
      return this.setUIState({ selectedPetId: id });
    },
    getSelectedPetId() {
      return loadUIState().selectedPetId ?? null;
    },
    getOverride(petId) {
      const all = loadOverrides();
      return cloneOverride(all[petId]);
    },
    setOverride(petId, patch) {
      const all = loadOverrides();
      const cur = cloneOverride(all[petId]);
      const next = {
        enabled: patch.enabled ?? cur.enabled,
        thresholdPct: Number.isFinite(patch.thresholdPct) ? Math.min(100, Math.max(1, Number(patch.thresholdPct))) : cur.thresholdPct,
        crops: { ...cur.crops, ...patch.crops || {} }
      };
      all[petId] = next;
      saveOverrides(all);
      void _evaluateAll();
      return next;
    },
    updateOverride(petId, fn) {
      const all = loadOverrides();
      const cur = cloneOverride(all[petId]);
      const next = cloneOverride(fn(cur));
      all[petId] = next;
      saveOverrides(all);
      void _evaluateAll();
      return next;
    },
    async setPetAutofeedEnabled(petId, enabled) {
      return this.setOverride(petId, { enabled: !!enabled });
    },
    getPetAutofeedEnabled(petId) {
      return this.getOverride(petId).enabled;
    },
    async setPetAutofeedThresholdPct(petId, pct) {
      const v = Math.min(100, Math.max(1, Math.floor(Number(pct) || 10)));
      return this.setOverride(petId, { thresholdPct: v });
    },
    getPetAutofeedThresholdPct(petId) {
      return this.getOverride(petId).thresholdPct;
    },
    async setPetAllowedCrop(petId, crop, allowed) {
      return this.updateOverride(petId, (cur) => {
        const next = cloneOverride(cur);
        const entry = next.crops[crop] ?? { allowed: true };
        next.crops[crop] = { allowed: allowed ?? entry.allowed };
        return next;
      });
    },
    async getPetAllowedCrops(petId) {
      const ov = this.getOverride(petId);
      const pet = await findPetById(petId);
      const species = pet?.slot?.petSpecies || "";
      const compatibles = this.getCompatibleCropsForSpecies(species);
      const allowed = /* @__PURE__ */ new Set();
      for (const c of compatibles) {
        const rule = ov.crops[c];
        if (rule ? !!rule.allowed : true) allowed.add(c);
      }
      return allowed;
    },
    getCompatibleCropsForSpecies(species) {
      return getCompatibleCropsFromData(species);
    },
    getMaxHungerForSpecies(species) {
      return getMaxHungerFromData(species);
    },
    getHungerPctFor(pet) {
      const cur = Number(pet?.slot?.hunger) || 0;
      const species = String(pet?.slot?.petSpecies || "");
      const max = this.getMaxHungerForSpecies(species);
      const pct = cur / max * 100;
      return +clampPct(pct).toFixed(1);
    },
    async startAutofeedWatcher(onTrigger) {
      _userTriggerCb = onTrigger ?? null;
      const stop = await PlayerService.onPetsChangeNow((arr) => {
        _currentPets = Array.isArray(arr) ? arr.slice() : [];
        void _evaluateAll();
      });
      return () => {
        try {
          stop();
        } catch {
        }
        _currentPets = [];
        _belowThreshold.clear();
        _userTriggerCb = null;
      };
    },
    /* ------------------------- Teams (UI-less core used by UI) ------------------------- */
    _teams: loadTeams(),
    _teamSubs: /* @__PURE__ */ new Set(),
    _notifyTeamSubs() {
      const snap = this.getTeams();
      this._teamSubs.forEach((fn) => {
        try {
          fn(snap);
        } catch {
        }
      });
    },
    getTeams() {
      return Array.isArray(this._teams) ? this._teams.map((t) => ({ ...t, slots: t.slots.slice(0, 3) })) : [];
    },
    onTeamsChange(cb) {
      this._teamSubs.add(cb);
      try {
        cb(this.getTeams());
      } catch {
      }
      return () => {
        this._teamSubs.delete(cb);
      };
    },
    async onTeamsChangeNow(cb) {
      const unsub = this.onTeamsChange(cb);
      try {
        cb(this.getTeams());
      } catch {
      }
      return unsub;
    },
    createTeam(name) {
      const t = { id: _uid(), name: name?.trim() || `Team ${this._teams.length + 1}`, slots: [null, null, null] };
      this._teams.push(t);
      saveTeams(this._teams);
      this._notifyTeamSubs();
      return t;
    },
    deleteTeam(teamId) {
      const i = this._teams.findIndex((t) => t.id === teamId);
      if (i < 0) return false;
      this._teams.splice(i, 1);
      saveTeams(this._teams);
      this._notifyTeamSubs();
      return true;
    },
    saveTeam(patch) {
      const i = this._teams.findIndex((t) => t.id === patch.id);
      if (i < 0) return null;
      const cur = this._teams[i];
      const next = {
        id: cur.id,
        name: typeof patch.name === "string" ? patch.name : cur.name,
        slots: Array.isArray(patch.slots) ? patch.slots.slice(0, 3) : cur.slots
      };
      this._teams[i] = next;
      saveTeams(this._teams);
      this._notifyTeamSubs();
      return next;
    },
    setTeamsOrder(ids) {
      const byId = new Map(this._teams.map((t) => [t.id, t]));
      const next = [];
      for (const id of ids) {
        const t = byId.get(id);
        if (t) {
          next.push(t);
          byId.delete(id);
        }
      }
      for (const rest of byId.values()) next.push(rest);
      this._teams = next;
      saveTeams(this._teams);
      this._notifyTeamSubs();
    },
    getTeamById(teamId) {
      const t = this._teams.find((t2) => t2.id === teamId) || null;
      return t ? { ...t, slots: t.slots.slice(0, 3) } : null;
    },
    getTeamSearch(teamId) {
      return _teamSearch[teamId] || "";
    },
    setTeamSearch(teamId, q) {
      _teamSearch[teamId] = (q || "").trim();
      _saveTeamSearchMap(_teamSearch);
    },
    /* ------------------------- Inventory filters + pickers ------------------------- */
    async getInventoryPets() {
      await _ensureInventoryWatchersStarted();
      return _invPetsCache.slice();
    },
    async buildFilteredInventoryForTeam(teamId, opts) {
      await _ensureInventoryWatchersStarted();
      const { mode, value } = _parseTeamSearch(this.getTeamSearch(teamId) || "");
      let list = await this.getInventoryPets();
      if (mode === "ability" && value) {
        const idSet = await _abilityNameToPresentIds(value);
        list = idSet.size ? list.filter((p) => Array.isArray(p.abilities) && p.abilities.some((a) => idSet.has(a))) : [];
      } else if (mode === "species" && value) {
        const vv = value.toLowerCase();
        list = list.filter((p) => (p.petSpecies || "").toLowerCase() === vv);
      } else if (value) {
        const q = value.toLowerCase();
        list = list.filter(
          (p) => _s(p.id).includes(q) || _s(p.petSpecies).includes(q) || _s(p.name).includes(q) || Array.isArray(p.abilities) && p.abilities.some((a) => _s(a).includes(q) || _s(_abilityName(a)).includes(q)) || Array.isArray(p.mutations) && p.mutations.some((m) => _s(m).includes(q))
        );
      }
      if (opts?.excludeIds?.size) {
        const ex = opts.excludeIds;
        list = list.filter((p) => !ex.has(p.id));
      }
      const items = list.map(_invPetToRawItem);
      let favoritedItemIds = [];
      try {
        const favAll = await Atoms.inventory.favoriteIds.get().catch(() => []);
        const keep = new Set(list.map((p) => p.id));
        favoritedItemIds = (favAll || []).filter((id) => keep.has(id));
      } catch {
      }
      return { items, favoritedItemIds };
    },
    async buildFilteredInventoryByQuery(query, opts) {
      await _ensureInventoryWatchersStarted();
      const q = (query || "").toLowerCase().trim();
      let list = await this.getInventoryPets();
      if (q) {
        list = list.filter(
          (p) => _s(p.id).includes(q) || _s(p.petSpecies).includes(q) || _s(p.name).includes(q) || Array.isArray(p.abilities) && p.abilities.some((a) => _s(a).includes(q) || _s(_abilityName(a)).includes(q)) || Array.isArray(p.mutations) && p.mutations.some((m) => _s(m).includes(q))
        );
      }
      if (opts?.excludeIds?.size) {
        const ex = opts.excludeIds;
        list = list.filter((p) => !ex.has(p.id));
      }
      const items = list.map(_invPetToRawItem);
      let favoritedItemIds = [];
      try {
        const favAll = await Atoms.inventory.favoriteIds.get().catch(() => []);
        const keep = new Set(list.map((p) => p.id));
        favoritedItemIds = (favAll || []).filter((id) => keep.has(id));
      } catch {
      }
      return { items, favoritedItemIds };
    },
    async chooseSlotPet(teamId, slotIndex, searchOverride) {
      const idx = Math.max(0, Math.min(2, Math.floor(slotIndex || 0)));
      const team = this.getTeamById(teamId);
      if (!team) return null;
      const exclude = /* @__PURE__ */ new Set();
      team.slots.forEach((id, i) => {
        if (i !== idx && id) exclude.add(String(id));
      });
      const payload = searchOverride && searchOverride.trim().length ? await this.buildFilteredInventoryByQuery(searchOverride, { excludeIds: exclude }) : await this.buildFilteredInventoryForTeam(teamId, { excludeIds: exclude });
      const items = Array.isArray(payload?.items) ? payload.items : [];
      if (!items.length) return null;
      await fakeInventoryShow(payload, { open: true });
      const selIndex = await _waitValidatedInventoryIndex(2e4);
      await closeInventoryPanel();
      if (selIndex == null || selIndex < 0 || selIndex >= items.length) return null;
      const chosenPet = _inventoryItemToPet(items[selIndex]);
      if (!chosenPet) return null;
      const next = team.slots.slice(0, 3);
      next[idx] = String(chosenPet.id);
      this.saveTeam({ id: team.id, slots: next });
      try {
        await clearHandSelection();
      } catch {
      }
      return chosenPet;
    },
    async pickPetViaFakeInventory(search) {
      const payload = await this.buildFilteredInventoryByQuery(search || "");
      const items = Array.isArray(payload?.items) ? payload.items : [];
      if (!items.length) return null;
      await fakeInventoryShow(payload, { open: true });
      const selIndex = await _waitValidatedInventoryIndex(2e4);
      await closeInventoryPanel();
      if (selIndex == null || selIndex < 0 || selIndex >= items.length) return null;
      await clearHandSelection();
      return _inventoryItemToPet(items[selIndex]);
    },
    /* ------------------------- Team switching ------------------------- */
    async useTeam(teamId) {
      const t = this.getTeams().find((tt) => tt.id === teamId) || null;
      if (!t) throw new Error("Team not found");
      const targetInvIds = (t.slots || []).filter((x) => typeof x === "string" && x.length > 0).slice(0, 3);
      const res = await _applyTeam(targetInvIds);
      markTeamAsUsed(teamId);
      return res;
    },
    /* ------------------------- Ability logs ------------------------- */
    _logs: [],
    _logsMax: 500,
    _seenPerfByPet: /* @__PURE__ */ new Map(),
    _logSubs: /* @__PURE__ */ new Set(),
    _logsCutoffMs: 0,
    _logsCutoffSkewMs: 1500,
    _logsStorageKey: "qws:pets:abilityLogs:v1",
    _logsSessionStart: Date.now(),
    _extractAbilityValue(abilityId, rawData) {
      const num = (value) => {
        const parsed = Number(value);
        return Number.isFinite(parsed) ? Math.max(0, parsed) : 0;
      };
      const data = rawData ?? {};
      const base = petAbilities[abilityId]?.baseParameters ?? {};
      switch (abilityId) {
        case "CoinFinderI":
        case "CoinFinderII":
        case "CoinFinderIII": {
          const value = data["coinsFound"] ?? data["coins"] ?? 0;
          return num(value);
        }
        case "SellBoostI":
        case "SellBoostII":
        case "SellBoostIII":
        case "SellBoostIV": {
          const value = data["bonusCoins"] ?? data["coinsEarned"] ?? 0;
          return num(value);
        }
        case "ProduceEater":
          return num(data["sellPrice"] ?? 0);
        case "EggGrowthBoost":
        case "EggGrowthBoostII":
        case "EggGrowthBoostIII": {
          const minutes = data["eggGrowthTimeReductionMinutes"] ?? data["reductionMinutes"] ?? base["eggGrowthTimeReductionMinutes"] ?? 0;
          return num(minutes) * 60 * 1e3;
        }
        case "PlantGrowthBoost":
        case "PlantGrowthBoostII": {
          const minutes = data["reductionMinutes"] ?? data["plantGrowthReductionMinutes"] ?? base["plantGrowthReductionMinutes"] ?? 0;
          return num(minutes) * 60 * 1e3;
        }
        case "PetXpBoost":
        case "PetXpBoostII": {
          const xp = data["bonusXp"] ?? base["bonusXp"] ?? 0;
          return num(xp);
        }
        case "PetHatchSizeBoost":
        case "PetHatchSizeBoostII": {
          const strength = data["strengthIncrease"] ?? 0;
          return num(strength);
        }
        case "HungerRestore":
        case "HungerRestoreII": {
          const pct = data["hungerRestoredPercentage"] ?? base["hungerRestorePercentage"] ?? 0;
          return num(pct);
        }
        default:
          return 0;
      }
    },
    async startAbilityLogsWatcher() {
      await _ensureInventoryWatchersStarted();
      const indexInfosByPetId = (list) => {
        const out = {};
        const arr = Array.isArray(list) ? list : [];
        for (const e of arr) {
          const id = String(e?.slot?.id ?? e?.id ?? "");
          if (id) out[id] = e;
        }
        return out;
      };
      let myInfosMap = {};
      try {
        myInfosMap = indexInfosByPetId(await Atoms.pets.myPetInfos.get());
      } catch {
      }
      let stopInfos = null;
      try {
        stopInfos = await Atoms.pets.myPetInfos.onChange((list) => {
          try {
            myInfosMap = indexInfosByPetId(list);
          } catch {
          }
        });
      } catch {
      }
      const extractFlat = (src) => {
        const out = {};
        if (!src || typeof src !== "object") return out;
        const obj = src;
        for (const petId of Object.keys(obj)) {
          const entry = obj[petId] ?? {};
          const lat = entry.lastAbilityTrigger ?? null;
          let rawH = entry.hungerPct ?? entry.hunger_percentage ?? entry.hunger ?? entry.stats?.hungerPct ?? entry.stats?.hunger?.pct ?? entry.stats?.hunger?.percent ?? null;
          if (rawH == null) {
            const info = myInfosMap[petId];
            rawH = info?.hungerPct ?? info?.hunger_percentage ?? info?.hunger ?? info?.slot?.hungerPct ?? info?.slot?.hunger ?? info?.stats?.hungerPct ?? info?.stats?.hunger?.pct ?? info?.stats?.hunger?.percent ?? null;
          }
          let hungerPct = Number.isFinite(Number(rawH)) ? Number(rawH) : null;
          if (hungerPct != null && hungerPct > 0 && hungerPct <= 1) hungerPct *= 100;
          out[petId] = {
            petId,
            abilityId: lat?.abilityId ?? null,
            performedAt: Number.isFinite(lat?.performedAt) ? lat.performedAt : null,
            data: lat?.data ?? null,
            position: entry.position ?? null,
            hungerPct
          };
        }
        return out;
      };
      try {
        this._ingestAbilityMap(extractFlat(await Atoms.pets.myPetSlotInfos.get()));
      } catch {
      }
      const stopSlots = await Atoms.pets.myPetSlotInfos.onChange((src) => {
        try {
          this._ingestAbilityMap(extractFlat(src));
        } catch {
        }
      });
      return () => {
        try {
          stopSlots();
        } catch {
        }
        try {
          stopInfos?.();
        } catch {
        }
      };
    },
    getAbilityLogs(opts) {
      const ids = opts?.abilityIds && opts.abilityIds.length ? new Set(opts.abilityIds) : null;
      const since = Number.isFinite(opts?.since) ? opts.since : 0;
      const lim = Math.max(0, Math.floor(opts?.limit ?? 0));
      let arr = this._logs.filter(
        (e) => (since ? e.performedAt >= since : true) && (ids ? ids.has(e.abilityId) : true)
      );
      arr = arr.sort((a, b) => b.performedAt - a.performedAt);
      return lim ? arr.slice(0, lim) : arr;
    },
    getAbilityLogsSessionStart() {
      return this._logsSessionStart;
    },
    onAbilityLogs(cb) {
      this._logSubs.add(cb);
      try {
        cb(this.getAbilityLogs());
      } catch {
      }
      return () => {
        this._logSubs.delete(cb);
      };
    },
    getSeenAbilityIds() {
      const set2 = /* @__PURE__ */ new Set();
      for (const e of this._logs) set2.add(e.abilityId);
      return Array.from(set2).sort();
    },
    clearAbilityLogs() {
      this._logs.length = 0;
      this._seenPerfByPet.clear();
      this._logsCutoffMs = Date.now();
      this._notifyLogSubs();
      this._persistAbilityLogs();
    },
    _notifyLogSubs() {
      const snap = this.getAbilityLogs();
      this._logSubs.forEach((fn) => {
        try {
          fn(snap);
        } catch {
        }
      });
    },
    _pushLog(e) {
      this._logs.push(e);
      if (this._logs.length > this._logsMax) {
        this._logs.splice(0, this._logs.length - this._logsMax);
      }
      this._notifyLogSubs();
      this._persistAbilityLogs();
    },
    _getLogsStorage() {
      if (typeof window === "undefined") return null;
      try {
        if (typeof window.localStorage === "undefined") return null;
        return window.localStorage;
      } catch {
        return null;
      }
    },
    _persistAbilityLogs() {
      const storage = this._getLogsStorage();
      if (!storage) return;
      try {
        const payload = {
          version: 1,
          cutoff: this._logsCutoffMs,
          logs: this._logs.map((entry) => ({
            petId: entry.petId,
            species: entry.species ?? null,
            name: entry.name ?? null,
            abilityId: entry.abilityId,
            abilityName: entry.abilityName,
            data: entry.data,
            performedAt: entry.performedAt,
            time12: entry.time12
          }))
        };
        storage.setItem(this._logsStorageKey, JSON.stringify(payload));
      } catch {
      }
    },
    _restoreAbilityLogsFromStorage() {
      const storage = this._getLogsStorage();
      if (!storage) return;
      try {
        const raw = storage.getItem(this._logsStorageKey);
        if (!raw) return;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object") return;
        const logsRaw = Array.isArray(parsed.logs) ? parsed.logs : [];
        const restored = [];
        for (const item of logsRaw) {
          if (!item || typeof item !== "object") continue;
          const abilityId = typeof item.abilityId === "string" ? String(item.abilityId) : "";
          const performedAt = Number(item.performedAt) || 0;
          if (!abilityId || !performedAt) continue;
          restored.push({
            petId: typeof item.petId === "string" ? String(item.petId) : "",
            species: typeof item.species === "string" && item.species ? String(item.species) : void 0,
            name: typeof item.name === "string" && item.name ? String(item.name) : void 0,
            abilityId,
            abilityName: typeof item.abilityName === "string" && item.abilityName ? String(item.abilityName) : abilityId,
            data: typeof item.data === "string" ? String(item.data) : item.data,
            performedAt,
            time12: typeof item.time12 === "string" && item.time12 ? String(item.time12) : new Date(performedAt).toLocaleTimeString("en-US", { hour: "numeric", minute: "2-digit", hour12: true })
          });
        }
        restored.sort((a, b) => a.performedAt - b.performedAt);
        this._logs = restored.slice(-this._logsMax);
        this._seenPerfByPet.clear();
        for (const entry of this._logs) {
          const prev = this._seenPerfByPet.get(entry.petId) || 0;
          if (entry.performedAt > prev) this._seenPerfByPet.set(entry.petId, entry.performedAt);
        }
        const cutoff = Number(parsed.cutoff);
        if (Number.isFinite(cutoff) && cutoff > 0) this._logsCutoffMs = cutoff;
      } catch {
      }
    },
    _ingestAbilityMap(map2) {
      if (!map2 || typeof map2 !== "object") return;
      const abilityDisplayName = (abilityId) => {
        const def = petAbilities[abilityId];
        return def?.name && def.name.trim() || abilityId;
      };
      const fmtTime12 = (ms) => new Date(ms).toLocaleTimeString("en-US", { hour: "numeric", minute: "2-digit", hour12: true });
      const fmtInt = (n) => Number.isFinite(Number(n)) ? Math.round(Number(n)).toLocaleString("en-US") : "0";
      const fmtPct0 = (n) => `${Number.isFinite(Number(n)) ? Number(n).toFixed(0) : "0"}%`;
      const fmtMin1 = (n) => `${Number.isFinite(Number(n)) ? Number(n).toFixed(1) : "0.0"} min`;
      const formatDetails = (abilityId, data) => {
        const d = data ?? {};
        const base = petAbilities[abilityId]?.baseParameters ?? {};
        switch (abilityId) {
          case "CoinFinderI":
          case "CoinFinderII":
          case "CoinFinderIII": {
            const coins = d["coinsFound"] ?? base["baseMaxCoinsFindable"];
            return `+ ${fmtInt(coins)} coins`;
          }
          case "SeedFinderI":
          case "SeedFinderII":
          case "SeedFinderIII":
          case "SeedFinderIV":
            return `x1 ${d["seedName"] ?? "\u2014"}`;
          case "SellBoostI":
          case "SellBoostII":
          case "SellBoostIII":
          case "SellBoostIV": {
            if (d["bonusCoins"] != null) return `Sale bonus: +${fmtInt(d["bonusCoins"])} coins`;
            const pct = base["cropSellPriceIncreasePercentage"];
            return pct != null ? `+ ${fmtPct0(pct)}` : "Sale bonus";
          }
          case "ProduceRefund": {
            const n = d["numItemsRefunded"];
            return n != null ? `+ ${fmtInt(n)} item(s)` : `Crops refunded`;
          }
          case "ProduceScaleBoost":
          case "ProduceScaleBoostII": {
            if (d["cropScaleIncreasePercentage"] != null) return `+ ${fmtPct0(d["cropScaleIncreasePercentage"])}`;
            const inc = base["cropScaleIncreasePercentage"];
            return inc != null ? `+ ${fmtPct0(inc)}` : "Produce bigger";
          }
          case "DoubleHarvest":
            return `+1 item`;
          case "ProduceEater": {
            const name = d["cropName"] ?? "\u2014";
            if (d["sellPrice"] != null) return `Eaten: ${name} (value ${fmtInt(d["sellPrice"])})`;
            const pct = base["cropSellPriceIncreasePercentage"];
            return pct != null ? `Eaten: ${name} (+ ${fmtPct0(pct)} price)` : `Eaten: ${name}`;
          }
          case "EggGrowthBoost":
          case "EggGrowthBoostII":
          case "EggGrowthBoostIII": {
            const mins = d["eggGrowthTimeReductionMinutes"] ?? base["eggGrowthTimeReductionMinutes"];
            return `- ${fmtMin1(mins)}`;
          }
          case "PlantGrowthBoost":
          case "PlantGrowthBoostII": {
            const mins = d["reductionMinutes"] ?? base["plantGrowthReductionMinutes"];
            return `- ${fmtMin1(mins)}`;
          }
          case "GoldGranter": {
            const target = d["cropName"] ?? "\u2014";
            return `${target}`;
          }
          case "RainbowGranter": {
            const target = d["cropName"] ?? "\u2014";
            return `${target}`;
          }
          case "ProduceMutationBoost":
          case "ProduceMutationBoostII":
          case "PetMutationBoost":
          case "PetMutationBoostII":
            return "\u2014";
          case "PetXpBoost":
          case "PetXpBoostII": {
            const xp = d["bonusXp"] ?? base["bonusXp"];
            return `+ ${fmtInt(xp)} XP`;
          }
          case "PetAgeBoost":
          case "PetAgeBoostII": {
            const xp = d["bonusXp"] ?? base["bonusXp"];
            const who = d["petName"] ?? "pet";
            return `+ ${fmtInt(xp)} XP (${who})`;
          }
          case "PetHatchSizeBoost":
          case "PetHatchSizeBoostII": {
            const who = d["petName"] ?? "pet";
            if (d["strengthIncrease"] != null) return `+${fmtInt(d["strengthIncrease"])} strength (${who})`;
            const pct = base["maxStrengthIncreasePercentage"];
            return pct != null ? `+ ${fmtPct0(pct)} (${who})` : `Strength increased (${who})`;
          }
          case "HungerRestore":
          case "HungerRestoreII": {
            const pct = d["hungerRestoredPercentage"] ?? base["hungerRestorePercentage"];
            const who = d["petName"] ?? "pet";
            return `(${who}): ${fmtPct0(pct)}`;
          }
          case "HungerBoost":
          case "HungerBoostII": {
            const pct = base["hungerDepletionRateDecreasePercentage"];
            return pct != null ? `- ${fmtPct0(pct)}` : "Hunger reduced";
          }
          case "PetRefund":
          case "PetRefundII": {
            const egg = d["eggName"] ?? null;
            return egg ? `x1 ${egg}` : `Pet refunded as egg`;
          }
          case "Copycat":
            return "\u2014";
          default: {
            const meta = petAbilities[abilityId];
            if (d && typeof d === "object" && Object.keys(d).length) return JSON.stringify(d);
            return meta?.description || "\u2014";
          }
        }
      };
      const EPS = 1e-6;
      for (const petId of Object.keys(map2)) {
        const entry = map2[petId];
        if (!entry || typeof entry !== "object") continue;
        const abilityId = entry.abilityId ?? null;
        const performedAtNum = Number(entry.performedAt) || 0;
        if (!abilityId || !performedAtNum) continue;
        const prev = this._seenPerfByPet.get(petId) || 0;
        if (performedAtNum <= prev) continue;
        if (this._logsCutoffMs && performedAtNum < this._logsCutoffMs - this._logsCutoffSkewMs) {
          this._seenPerfByPet.set(petId, performedAtNum);
          continue;
        }
        let hungerPct = Number.isFinite(Number(entry.hungerPct)) ? Number(entry.hungerPct) : null;
        if (hungerPct != null && hungerPct > 0 && hungerPct <= 1) hungerPct *= 100;
        if (hungerPct != null && hungerPct <= EPS) {
          this._seenPerfByPet.set(petId, performedAtNum);
          continue;
        }
        const pet = _invPetsCache.find((p) => String(p.id) === String(petId)) || null;
        const abilityIdStr = String(abilityId);
        const logLine = {
          petId,
          species: pet?.petSpecies || void 0,
          name: pet?.name ?? void 0,
          abilityId: abilityIdStr,
          abilityName: abilityDisplayName(abilityId),
          data: formatDetails(abilityIdStr, entry.data),
          performedAt: performedAtNum,
          time12: fmtTime12(performedAtNum)
        };
        this._seenPerfByPet.set(petId, performedAtNum);
        try {
          StatsService.incrementAbilityStat(abilityIdStr, "triggers");
          const abilityValue = this._extractAbilityValue(abilityIdStr, entry.data);
          if (abilityValue > 0) {
            StatsService.incrementAbilityStat(abilityIdStr, "totalValue", abilityValue);
          }
        } catch {
        }
        this._pushLog(logLine);
      }
    }
  };
  try {
    PetsService._restoreAbilityLogsFromStorage();
  } catch {
  }
  async function _getActivePetSlotIds() {
    try {
      const arr = await PlayerService.getPets();
      const list = Array.isArray(arr) ? arr : [];
      return list.map((p) => String(p?.slot?.id || "")).filter((id) => !!id).slice(0, 3);
    } catch {
      return [];
    }
  }
  async function _applyTeam(targetInvIds) {
    let activeSlots = await _getActivePetSlotIds();
    const targetSet = new Set(targetInvIds);
    const extras = activeSlots.filter((id) => !targetSet.has(id));
    const mustStore = Math.max(0, activeSlots.length - targetInvIds.length);
    if (mustStore > 0) {
      const toStore = extras.slice(0, mustStore);
      for (const itemId of toStore) {
        try {
          await PlayerService.storePet(itemId);
          activeSlots = activeSlots.filter((id) => id !== itemId);
        } catch {
        }
      }
    }
    const alreadyActive = /* @__PURE__ */ new Set();
    for (const invId of targetInvIds) if (activeSlots.includes(invId)) alreadyActive.add(invId);
    let swapped = 0, placed = 0, skipped = 0;
    if (alreadyActive.size) {
      activeSlots = activeSlots.filter((slotId) => !alreadyActive.has(slotId));
      skipped = alreadyActive.size;
    }
    const toDo = targetInvIds.filter((id) => !alreadyActive.has(id));
    for (const invId of toDo) {
      const slotId = activeSlots.shift();
      try {
        if (slotId) {
          await PlayerService.swapPet(slotId, invId);
          swapped++;
        } else {
          await PlayerService.placePet(invId, { x: 0, y: 0 }, "Boardwalk", 64);
          placed++;
        }
      } catch {
      }
    }
    return { swapped, placed, skipped };
  }

  // src/services/shops.ts
  var SHOP_KEYBINDS = [
    { id: "shops.seeds", modal: "seedShop" },
    { id: "shops.eggs", modal: "eggShop" },
    { id: "shops.decors", modal: "decorShop" },
    { id: "shops.tools", modal: "toolShop" }
  ];
  var shopKeybindsInstalled = false;
  function installShopKeybindsOnce() {
    if (shopKeybindsInstalled || typeof window === "undefined") return;
    shopKeybindsInstalled = true;
    window.addEventListener(
      "keydown",
      (event) => {
        if (shouldIgnoreKeydown(event)) return;
        for (const { id, modal } of SHOP_KEYBINDS) {
          if (!eventMatchesKeybind(id, event)) continue;
          event.preventDefault();
          event.stopPropagation();
          void Atoms.ui.activeModal.set(modal);
          break;
        }
      },
      true
    );
  }

  // src/ui/toast.ts
  async function sendToast(toast) {
    const sendAtom = getAtomByLabel("sendQuinoaToastAtom");
    if (sendAtom) {
      await jSet(sendAtom, toast);
      return;
    }
    const listAtom = getAtomByLabel("quinoaToastsAtom");
    if (!listAtom) throw new Error("Aucun atom de toast trouv\xE9");
    const prev = await jGet(listAtom).catch(() => []);
    const t = { isClosable: true, duration: 1e4, ...toast };
    if ("toastType" in t && t.toastType === "board") {
      t.id = t.id ?? (t.isStackable ? `quinoa-stackable-${Date.now()}-${Math.random()}` : "quinoa-game-toast");
    } else {
      t.id = t.id ?? "quinoa-game-toast";
    }
    await jSet(listAtom, [...prev, t]);
  }
  async function toastSimple(title, description, variant = "info", duration = 3500) {
    await sendToast({ title, description, variant, duration });
  }

  // src/core/audioPlayer.ts
  var AudioPlayer = class {
    constructor(opts = {}) {
      __publicField(this, "found", /* @__PURE__ */ new Set());
      __publicField(this, "meta", /* @__PURE__ */ new Map());
      __publicField(this, "groupsMap", /* @__PURE__ */ new Map());
      // config volume
      __publicField(this, "atomKey");
      __publicField(this, "min");
      __publicField(this, "max");
      __publicField(this, "gainFactor");
      // Howler cache local
      __publicField(this, "howler", null);
      // options
      __publicField(this, "minVariantsPerAutoGroup");
      this.atomKey = opts.atomKey ?? "soundEffectsVolumeAtom";
      this.min = opts.min ?? 1e-3;
      this.max = opts.max ?? 0.2000000000000001;
      this.gainFactor = opts.gainFactor ?? 1;
      this.minVariantsPerAutoGroup = opts.minVariantsPerAutoGroup ?? 2;
      if (opts.autoScan) void this.init();
    }
    /** Lance un scan initial et reconstruit les groupes auto. */
    async init() {
      await this.scanAll();
    }
    // ----------------- Utils -----------------
    abs(u) {
      try {
        return new URL(u, location.href).href;
      } catch {
        return u;
      }
    }
    isMP3(u) {
      return /\.mp3(?:[\?#][^\s'"]*)?$/i.test(u);
    }
    fileName(u) {
      try {
        return new URL(u, location.href).pathname.split("/").pop() || u;
      } catch {
        return String(u);
      }
    }
    logicalName(fileName) {
      return fileName.replace(/-[A-Za-z0-9_=-]{6,}(?=\.mp3$)/i, "");
    }
    clamp(x, a, b) {
      return Math.max(a, Math.min(b, x));
    }
    choose(arr) {
      return arr && arr.length ? arr[Math.random() * arr.length | 0] : void 0;
    }
    toKey(name) {
      return String(name || "").trim().toLowerCase();
    }
    add(u, sourceTag) {
      if (!u || !this.isMP3(u)) return;
      const url = this.abs(u);
      if (!this.found.has(url)) {
        this.found.add(url);
        const name = this.fileName(url);
        this.meta.set(url, { from: /* @__PURE__ */ new Set([sourceTag]), name, logicalName: this.logicalName(name) });
      } else {
        this.meta.get(url)?.from.add(sourceTag);
      }
    }
    refreshHowler() {
      this.howler = window.Howler && Array.isArray(window.Howler._howls) ? window.Howler : null;
      return this.howler;
    }
    sameAsset(a, b) {
      try {
        const A = new URL(a, location.href).href;
        const B = new URL(b, location.href).href;
        if (A === B) return true;
        const fn = (p) => new URL(p, location.href).pathname.split("/").pop();
        const la = this.logicalName(fn(A));
        const lb = this.logicalName(fn(B));
        return la === lb;
      } catch {
        return a === b;
      }
    }
    readAtomRaw() {
      const raw = localStorage.getItem(this.atomKey);
      if (raw == null) return null;
      try {
        const val = JSON.parse(raw);
        if (typeof val === "number") return val;
        const m = JSON.stringify(val).match(/-?\d+(?:\.\d+)?/);
        return m ? parseFloat(m[0]) : null;
      } catch {
        const m = String(raw).match(/-?\d+(?:\.\d+)?/);
        return m ? parseFloat(m[0]) : null;
      }
    }
    howlerMaster() {
      try {
        return window.Howler && typeof window.Howler.volume === "function" ? window.Howler.volume() : 1;
      } catch {
        return 1;
      }
    }
    // 0.001 est considéré comme un vrai mute (→ 0)
    finalVolumeObj() {
      let raw = this.readAtomRaw();
      if (raw == null) raw = this.max;
      const clamped = this.clamp(raw, this.min, this.max);
      const nearMute = Math.abs(clamped - this.min) < 1e-6 ? 0 : clamped;
      const vol = nearMute * this.howlerMaster() * this.gainFactor;
      return { raw, clamped, vol };
    }
    // ----------------- Scanners -----------------
    async scanPerformance() {
      performance.getEntriesByType("resource").map((e) => e.name).filter(Boolean).forEach((u) => this.add(u, "perf"));
    }
    async scanHowler() {
      this.refreshHowler();
      if (!this.howler) return;
      this.howler._howls.forEach((h) => {
        const src = h && (h._src || h._urls && h._urls[0]);
        if (src) this.add(src, "howler");
      });
    }
    async scanCaches() {
      if (!("caches" in window)) return;
      try {
        const keys = await caches.keys();
        for (const k of keys) {
          const c = await caches.open(k);
          const reqs = await c.keys();
          for (const r of reqs) {
            const u = r.url;
            if (this.isMP3(u)) this.add(u, `cache:${k}`);
          }
        }
      } catch {
      }
    }
    async fetchText(u) {
      try {
        const res = await fetch(u, { mode: "same-origin", credentials: "same-origin" });
        if (!res.ok) return "";
        const ct = res.headers.get("content-type") || "";
        if (!/javascript|ecmascript|css|html/i.test(ct)) return "";
        return await res.text();
      } catch {
        return "";
      }
    }
    extractMp3s(text) {
      if (!text) return [];
      const re = /["'`](\/?[^"'`)\s]+?\.mp3(?:\?[^"'`\s]*)?)["'`]/ig;
      const out = [];
      let m;
      while (m = re.exec(text)) out.push(m[1]);
      return out;
    }
    async scanResourcesForRefs() {
      const urls = /* @__PURE__ */ new Set();
      document.querySelectorAll('script[src],link[rel="stylesheet"][href]').forEach((el2) => {
        const u = el2.src || el2.href;
        try {
          const url = new URL(u, location.href);
          if (url.origin === location.origin) urls.add(url.href);
        } catch {
        }
      });
      urls.add(location.href);
      const texts = await Promise.all([...urls].map((u) => this.fetchText(u)));
      texts.forEach((t, i) => {
        for (const match of this.extractMp3s(t)) this.add(match, `ref:${[...urls][i]}`);
      });
    }
    async scanDOM() {
      document.querySelectorAll("audio[src]").forEach((a) => this.add(a.getAttribute("src") || "", "dom"));
      document.querySelectorAll("source[src]").forEach((s) => this.add(s.getAttribute("src") || "", "dom"));
      const html = document.documentElement?.outerHTML || "";
      for (const m of this.extractMp3s(html)) this.add(m, "html");
    }
    async scanAll() {
      this.found.clear();
      this.meta.clear();
      await Promise.all([
        this.scanPerformance(),
        this.scanHowler(),
        this.scanCaches(),
        this.scanDOM()
      ]);
      await this.scanResourcesForRefs();
      this.autoGroups({ overwrite: true });
      return this.urls();
    }
    // ----------------- Groupes -----------------
    inferGroupKey(logicalName) {
      const base = String(logicalName || "").replace(/\.mp3$/i, "");
      let m = base.match(/^([A-Za-z]+)[_\-]/);
      if (m) return m[1].toLowerCase();
      m = base.match(/^([A-Za-z]+)\d+$/);
      if (m) return m[1].toLowerCase();
      m = base.match(/^([A-Za-z]+)/);
      return m ? m[1].toLowerCase() : base.toLowerCase();
    }
    defineGroup(name, matcher) {
      const key2 = this.toKey(name);
      const set2 = /* @__PURE__ */ new Set();
      const items = this.urls().map((u) => [u, this.meta.get(u)]);
      const test = (url, meta) => {
        if (!matcher) return false;
        if (typeof matcher === "function") return !!matcher(url, meta);
        const ln = meta?.logicalName || meta?.name || url;
        if (matcher instanceof RegExp) return matcher.test(ln) || matcher.test(url);
        const txt = String(matcher).toLowerCase();
        return ln.toLowerCase().startsWith(txt) || url.toLowerCase().includes("/" + txt);
      };
      for (const [url, meta] of items)
        if (test(url, meta && { name: meta.name, logicalName: meta.logicalName })) set2.add(url);
      this.groupsMap.set(key2, set2);
      return [...set2];
    }
    undefineGroup(name) {
      this.groupsMap.delete(this.toKey(name));
    }
    // --- Unique implémentation publique ---
    autoGroups({ overwrite = false, minVariants = this.minVariantsPerAutoGroup } = {}) {
      this.rebuildAutoGroups(overwrite, minVariants);
      return this.groups();
    }
    // Helper privé appelé par autoGroups()
    rebuildAutoGroups(overwrite, minVariants) {
      const tmp = /* @__PURE__ */ new Map();
      for (const [url, m] of this.meta.entries()) {
        const grp = this.inferGroupKey(m?.logicalName || m?.name || url);
        if (!tmp.has(grp)) tmp.set(grp, /* @__PURE__ */ new Set());
        tmp.get(grp).add(url);
      }
      for (const [grp, set2] of tmp.entries()) {
        if (set2.size < minVariants) continue;
        if (overwrite || !this.groupsMap.has(grp)) this.groupsMap.set(grp, set2);
      }
    }
    groups() {
      const out = {};
      for (const [k, set2] of this.groupsMap.entries()) out[k] = [...set2];
      return out;
    }
    getGroup(name) {
      const set2 = this.groupsMap.get(this.toKey(name));
      return set2 ? [...set2] : [];
    }
    pick(name) {
      const g = this.getGroup(name);
      return this.choose(g);
    }
    // ----------------- Lecture -----------------
    findExistingHowlByUrl(url) {
      this.refreshHowler();
      if (!this.howler) return null;
      for (const h of this.howler._howls) {
        const src = h && (h._src || h._urls && h._urls[0]);
        if (src && this.sameAsset(src, url)) return h;
      }
      return null;
    }
    /** Volume calculé selon config + atom du jeu. */
    getGameSfxVolume() {
      return this.finalVolumeObj();
    }
    /** Ajoute un offset global (sans toucher à l’atom du jeu). */
    setGainFactor(g = 1) {
      this.gainFactor = +g || 1;
    }
    /** Permet d’adapter la clé et la plage de l’atom si ça change côté jeu. */
    setAtomConfig(key2 = "soundEffectsVolumeAtom", min = 1e-3, max = 0.2000000000000001) {
      this.atomKey = key2;
      this.min = min;
      this.max = max;
    }
    /** Joue une URL en respectant le volume du jeu et Howler si dispo. */
    playUrl(url) {
      const { vol } = this.finalVolumeObj();
      const existing = this.findExistingHowlByUrl(url);
      if (existing) {
        try {
          existing.play();
          return existing;
        } catch {
        }
      }
      const Howl = window.Howl && window.Howler ? window.Howl : null;
      if (Howl) {
        try {
          const h = new Howl({ src: [url], volume: vol });
          h.play();
          return h;
        } catch {
        }
      }
      try {
        const a = new Audio(url);
        a.volume = Math.max(0, Math.min(1, vol));
        void a.play().catch(() => {
        });
        return a;
      } catch {
        return null;
      }
    }
    /** Joue par motif (RegExp ou texte partiel). */
    playBy(matcher) {
      const list = this.urls();
      const re = matcher instanceof RegExp ? matcher : new RegExp(String(matcher).replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "i");
      const hit = list.find((u) => re.test(u));
      return hit ? this.playUrl(hit) : null;
    }
    /** Joue par nom logique exact si possible, sinon via motif. */
    play(nameOrRegex) {
      if (typeof nameOrRegex === "string") {
        const m = this.map();
        if (m[nameOrRegex]?.[0]) return this.playUrl(m[nameOrRegex][0]);
      }
      return this.playBy(nameOrRegex);
    }
    /** Joue une entrée d’un groupe (index fixe, ou aléatoire). */
    playGroup(name, opts = {}) {
      const { index, random = true, filter } = opts;
      let list = this.getGroup(name);
      if (!list.length) return null;
      if (typeof filter === "function") {
        list = list.filter((u) => {
          const m = this.meta.get(u);
          return filter(u, m && { name: m.name, logicalName: m.logicalName });
        });
        if (!list.length) return null;
      }
      const url = typeof index === "number" ? list[(index % list.length + list.length) % list.length] : random ? this.choose(list) : list[0];
      return this.playUrl(url);
    }
    /** Alias pratique pour jouer une variation aléatoire d’un groupe (ex: "harvest"). */
    playRandom(name) {
      return this.playGroup(name, { random: true });
    }
    // ----------------- Tables & export -----------------
    urls() {
      return [...this.found];
    }
    map() {
      const map2 = {};
      for (const [url, m] of this.meta.entries()) {
        const key2 = m.logicalName || m.name;
        (map2[key2] || (map2[key2] = [])).push(url);
      }
      return map2;
    }
    info() {
      return this.urls().map((u) => {
        const m = this.meta.get(u);
        return { url: u, name: m?.name, logicalName: m?.logicalName, sources: [...m?.from || []].join(",") };
      });
    }
    /** Exporte JSON (URLs + groupes). Retourne la string. */
    exportJSON() {
      return JSON.stringify({ urls: this.info(), groups: this.groups() }, null, 2);
    }
    /** Scan public de commodité. */
    async scan() {
      return this.scanAll();
    }
    /* Helpers */
    playHarvest() {
      return this.playGroup("harvest");
    }
    playPlantSeed() {
      return this.playGroup("plantseed");
    }
    playWaterPlant() {
      return this.playBy("water");
    }
    playDestroyPlant() {
      return this.playBy("Break_Dirt");
    }
    playDestroyStone() {
      return this.playBy("Break_Stone");
    }
    playSellNotification() {
      return this.playBy("Score_PlusOne");
    }
    playInfoNotification() {
      return this.playBy("Keyboard_Enter_01");
    }
    playBuy() {
      return this.playGroup("coinbuy");
    }
  };
  var audioPlayer = new AudioPlayer({ autoScan: true });
  window.__audioPlayer = audioPlayer;

  // src/utils/sellAllPets.ts
  var SELL_ALL_PETS_EVENT = "sell-all-pets:list";
  var DEFAULT_THEME = {
    text: "var(--chakra-colors-Neutral-TrueWhite, #FFFFFF)",
    bg: "var(--chakra-colors-Blue-Magic, #0067B4)",
    border: "var(--chakra-colors-Blue-Light, #48ADF4)",
    hoverBg: "var(--chakra-colors-Blue-Light, #48ADF4)",
    hoverBorder: "var(--chakra-colors-Blue-Baby, #25AAE2)",
    activeBg: "var(--chakra-colors-Blue-Dark, #264093)",
    ring: "var(--chakra-ring-color, rgba(66,153,225,0.6))"
  };
  var DEFAULTS = {
    rootSelector: ".McFlex.css-1wu1jyg",
    checkSelector: ".McFlex.css-bvyqr8",
    buttonSelectorWide: "button.chakra-button.css-1rizn4y, button.chakra-button, button.css-1rizn4y",
    buttonSelectorStrict: "button.chakra-button.css-1rizn4y",
    targetText: "Sell Pet",
    // Back-compat only
    injectText: "Sell all Pets",
    injectedClass: "tm-injected-sell-all",
    styleId: "tm-injected-sell-all-style"
  };
  function startInjectSellAllPets(options = {}) {
    if (!isBrowser()) return noSSRController();
    const ROOT_SEL = options.rootSelector ?? DEFAULTS.rootSelector;
    const CHECK_SEL = options.checkSelector ?? DEFAULTS.checkSelector;
    const BTN_WIDE = options.buttonSelectorWide ?? DEFAULTS.buttonSelectorWide;
    const BTN_STRICT = options.buttonSelectorStrict ?? DEFAULTS.buttonSelectorStrict;
    const BTN_TEXT = options.targetText ?? DEFAULTS.targetText;
    const INJ_TEXT = options.injectText ?? DEFAULTS.injectText;
    const INJ_CLASS = options.injectedClass ?? DEFAULTS.injectedClass;
    const THEME = options.theme ?? DEFAULT_THEME;
    const OBS_HIST = options.observeHistory ?? true;
    const logger = typeof options.log === "function" ? options.log : options.log ? (...a) => console.debug("[injectSellAllPets]", ...a) : () => {
    };
    const HANDLE = options.onClick ?? createDefaultClickHandler(logger);
    ensureStyle(INJ_CLASS, THEME);
    let running = true;
    let pending = false;
    const processAll = () => {
      if (!running || pending) return;
      pending = true;
      requestAnimationFrame(() => {
        try {
          document.querySelectorAll(ROOT_SEL).forEach((root) => processRoot(root));
        } finally {
          pending = false;
        }
      });
    };
    function processRoot(root) {
      const gate = root.querySelector(CHECK_SEL);
      if (!gate) {
        cleanup(root, INJ_CLASS);
        return;
      }
      const target = findTargetButton(root, BTN_WIDE, BTN_STRICT, BTN_TEXT);
      if (!target) {
        cleanup(root, INJ_CLASS);
        return;
      }
      ensureInjectedNextTo(target, INJ_CLASS, INJ_TEXT, (ev, ctx) => {
        safeInvokeClick(HANDLE, ev, ctx, logger);
      });
    }
    const mo = new MutationObserver(processAll);
    mo.observe(document.documentElement, { childList: true, subtree: true });
    processAll();
    let unhookHistory = null;
    if (OBS_HIST) {
      unhookHistory = hookHistory(processAll);
    }
    return {
      stop() {
        if (!running) return;
        running = false;
        mo.disconnect();
        unhookHistory?.();
        logger("stopped");
      },
      runOnce() {
        processAll();
      },
      isRunning() {
        return running;
      }
    };
  }
  async function runSellAllPetsFlow(logger = () => {
  }) {
    const pets = await runDefaultSellAllPetsAction(logger);
    if (pets.length === 0) return;
    await sellPetsFromInventory(pets, logger);
  }
  async function getUnfavoritedInventoryPets() {
    try {
      await ensureStore();
    } catch {
    }
    const [inventory, favoriteIds2] = await Promise.all([
      Atoms.inventory.myInventory.get().catch(() => null),
      Atoms.inventory.favoriteIds.get().catch(() => [])
    ]);
    const favSet = new Set(
      Array.isArray(favoriteIds2) ? favoriteIds2.filter((id) => typeof id === "string") : []
    );
    const items = Array.isArray(inventory?.items) ? inventory.items : [];
    const availablePets = [];
    items.forEach((item, index) => {
      if (!isInventoryPetItem(item)) return;
      if (favSet.has(item.id)) return;
      console.log("[sellAllPets] inventory index", index, item);
      availablePets.push({ ...item, inventoryIndex: index });
    });
    return availablePets;
  }
  function createDefaultClickHandler(logger) {
    return async () => {
      const pets = await runDefaultSellAllPetsAction(logger);
      if (pets.length === 0) return;
      await sellPetsFromInventory(pets, logger);
    };
  }
  async function runDefaultSellAllPetsAction(logger) {
    const pets = await getUnfavoritedInventoryPets();
    const detail = { pets, count: pets.length };
    globalThis.__sellAllPetsCandidates = pets;
    try {
      logger("collected-non-favorite-pets", detail);
    } catch {
    }
    try {
      globalThis.dispatchEvent?.(
        new CustomEvent(SELL_ALL_PETS_EVENT, { detail })
      );
    } catch {
    }
    return pets;
  }
  async function sellPetsFromInventory(pets, logger) {
    const toSell = pets.filter((pet) => typeof pet?.id === "string" && pet.id.trim().length > 0);
    if (toSell.length === 0) {
      try {
        logger("no-sellable-pets", { requested: pets.length });
      } catch {
      }
      try {
        globalThis.__sellAllPetsResult = { attempted: 0, sold: 0, failures: [] };
      } catch {
      }
      return;
    }
    const failures = [];
    let sold = 0;
    const totalValue = await computeTotalPetSellValue(toSell, logger);
    try {
      logger("sell-pets:total-value", { attempted: toSell.length, totalValue });
    } catch {
    }
    for (const pet of toSell) {
      try {
        logger("sell-pet:start", { id: pet.id, pet });
      } catch {
      }
      try {
        await PlayerService.sellPet(pet.id);
        sold += 1;
        StatsService.incrementShopStat("petsSoldCount");
        void (async () => {
          try {
            const total = await Atoms.pets.totalPetSellPrice.get();
            const value = Number(total);
            if (Number.isFinite(value) && value > 0) {
              StatsService.incrementShopStat("petsSoldValue", value);
            }
          } catch (error) {
            console.error("[SellPet] Unable to read pet sell price", error);
          }
        })();
        try {
          logger("sell-pet:success", { id: pet.id, pet });
        } catch {
        }
      } catch (error) {
        failures.push({ pet, error });
        try {
          logger("sell-pet:error", { id: pet.id, error, pet });
        } catch {
        }
      }
    }
    if (failures.length === 0) {
      toastSimple("Sell all Pets", `${sold} pets have been sold for ${totalValue} coins!`, "success");
    }
    try {
      globalThis.__sellAllPetsResult = { attempted: toSell.length, sold, failures };
    } catch {
    }
    audioPlayer.playSellNotification();
    try {
      logger("sell-pets:complete", { attempted: toSell.length, sold, failures });
    } catch {
    }
  }
  async function computeTotalPetSellValue(pets, logger) {
    if (!pets.length) return "";
    const selectionSnapshot = await captureInventorySelection();
    let total = 0;
    for (const pet of pets) {
      const index = getInventoryIndex(pet);
      if (index === null) continue;
      try {
        await Atoms.inventory.myPossiblyNoLongerValidSelectedItemIndex.set(index);
      } catch (error) {
        try {
          logger("sell-pet:selection-error", { id: pet.id, index, error, pet });
        } catch {
        }
        continue;
      }
      const value = await readSellPriceForSelection(index, pet, logger);
      if (value !== null) {
        total += value;
      }
    }
    await restoreInventorySelection(selectionSnapshot, logger);
    return total.toLocaleString("en-US");
  }
  async function captureInventorySelection() {
    try {
      const value = await Atoms.inventory.myPossiblyNoLongerValidSelectedItemIndex.get();
      if (typeof value === "number" && Number.isInteger(value) && value >= 0) {
        return { value, valid: true };
      }
      if (value === null) {
        return { value: null, valid: true };
      }
    } catch {
    }
    return { value: null, valid: false };
  }
  async function restoreInventorySelection(snapshot, logger) {
    if (!snapshot.valid) return;
    try {
      await Atoms.inventory.myPossiblyNoLongerValidSelectedItemIndex.set(snapshot.value);
    } catch (error) {
      try {
        logger("sell-pet:selection-restore-error", error);
      } catch {
      }
    }
  }
  function getInventoryIndex(pet) {
    const idx = pet.inventoryIndex;
    if (typeof idx === "number" && Number.isInteger(idx) && idx >= 0) return idx;
    return null;
  }
  async function readSellPriceForSelection(index, pet, logger, attempts = 3, delayMs = 50) {
    for (let attempt = 0; attempt < attempts; attempt++) {
      try {
        const value = await Atoms.pets.totalPetSellPrice.get();
        const numericValue = Number(value);
        if (Number.isFinite(numericValue)) {
          return numericValue;
        }
      } catch (error) {
        if (attempt === attempts - 1) {
          try {
            logger("sell-pet:price-read-error", { id: pet.id, index, error, pet });
          } catch {
          }
        }
      }
      if (attempt < attempts - 1) {
        await delay2(delayMs);
      }
    }
    try {
      logger("sell-pet:price-missing", { id: pet.id, index, pet });
    } catch {
    }
    return null;
  }
  function delay2(ms) {
    return new Promise((resolve2) => setTimeout(resolve2, ms));
  }
  function safeInvokeClick(handler, ev, ctx, logger) {
    try {
      const result = handler(ev, ctx);
      if (isPromiseLike(result)) {
        result.catch((err) => logClickError(err, logger));
      }
    } catch (err) {
      logClickError(err, logger);
    }
  }
  function logClickError(error, logger) {
    try {
      logger("sell-all-click-error", error);
    } catch {
    }
  }
  function isPromiseLike(value) {
    return !!value && (typeof value === "object" || typeof value === "function") && typeof value.then === "function";
  }
  function isInventoryPetItem(item) {
    return !!item && item.itemType === "Pet" && typeof item.id === "string";
  }
  function isBrowser() {
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function noSSRController() {
    return { stop() {
    }, runOnce() {
    }, isRunning: () => false };
  }
  function norm(s) {
    return (s ?? "").replace(/\s+/g, " ").trim();
  }
  function getLabel(el2) {
    const t = norm(el2.textContent);
    if (t) return t;
    const a = norm(el2.getAttribute("aria-label"));
    return a;
  }
  function getWords(label2) {
    return label2.trim().split(/\s+/).filter(Boolean);
  }
  function isSellTwoWordLabel(label2) {
    const words = getWords(label2);
    return words.length === 2 && /^sell$/i.test(words[0]);
  }
  function findTargetButton(scope, btnWide, btnStrict, _btnText) {
    const all = Array.from(/* @__PURE__ */ new Set([
      ...Array.from(scope.querySelectorAll(btnWide)),
      ...Array.from(scope.querySelectorAll(btnStrict))
    ])).filter((b) => b instanceof HTMLButtonElement).filter((b) => !b.classList.contains(DEFAULTS.injectedClass));
    const target = all.find((b) => isSellTwoWordLabel(getLabel(b)));
    return target ?? null;
  }
  function ensureInjectedNextTo(targetBtn, injectedClass, injectedText, onClick) {
    const parent = targetBtn.parentElement || targetBtn.closest(".McFlex, .css-0") || targetBtn.parentNode;
    if (!parent) return;
    let injected = parent.querySelector(`.${injectedClass}`);
    if (injected) {
      if (targetBtn.nextElementSibling !== injected) {
        parent.insertBefore(injected, targetBtn.nextSibling);
      }
      if (injected.textContent !== injectedText) injected.textContent = injectedText;
      return;
    }
    injected = document.createElement("button");
    injected.type = "button";
    injected.className = `${injectedClass} chakra-button`;
    injected.textContent = injectedText;
    injected.setAttribute("aria-label", injectedText);
    injected.title = injectedText;
    injected.style.marginLeft = "8px";
    const cs = getComputedStyle(parent);
    if (cs.display !== "flex") {
      injected.style.display = "inline-flex";
      injected.style.alignItems = "center";
    }
    injected.addEventListener("click", (ev) => onClick(ev, {
      host: targetBtn.closest(".McFlex.css-1wu1jyg"),
      targetBtn,
      injectedBtn: injected
    }));
    parent.insertBefore(injected, targetBtn.nextSibling);
  }
  function cleanup(root, injectedClass) {
    root.querySelectorAll(`.${injectedClass}`).forEach((n) => n.remove());
  }
  function ensureStyle(injectedClass, theme) {
    const STYLE_ID2 = `${injectedClass}-style`;
    if (document.getElementById(STYLE_ID2)) return;
    const css = `
.${injectedClass}{
  font-synthesis: none;
  -webkit-font-smoothing: antialiased;
  -webkit-text-size-adjust: 100%;
  cursor: pointer;
  display: inline-flex;
  appearance: none;
  align-items: center;
  justify-content: center;
  user-select: none;
  white-space: nowrap;
  vertical-align: middle;

  outline: transparent solid 2px;
  outline-offset: 2px;
  line-height: 1.2;

  border-radius: 15px;                        /* aligns with provided design */
  font-weight: 700;
  height: auto;
  min-width: var(--chakra-sizes-10, 2.5rem);
  box-shadow: rgba(0, 0, 0, 0.3) 0px 4px 12px;
  transform: translateY(0px);
  transition: 0.2s;

  border: 2px solid ${theme.border};
  color: ${theme.text};
  background: ${theme.bg};

  text-transform: none;
  overflow: hidden;
  font-size: 20px;
  padding-inline-start: var(--chakra-space-4, 1rem);
  padding-inline-end: var(--chakra-space-4, 1rem);
  padding-top: var(--chakra-space-3, 0.75rem);
  padding-bottom: var(--chakra-space-3, 0.75rem);

  -webkit-tap-highlight-color: transparent;
}
.${injectedClass}:hover{
  transform: translateY(-1px);
  background: ${theme.hoverBg};
  border-color: ${theme.hoverBorder};
}
.${injectedClass}:active{
  transform: translateY(1px);
  background: ${theme.activeBg};
}
.${injectedClass}:focus-visible{
  box-shadow: 0 0 0 3px ${theme.ring};
}
`.trim();
    const s = document.createElement("style");
    s.id = STYLE_ID2;
    s.textContent = css;
    document.head.appendChild(s);
  }
  function hookHistory(onNavigate) {
    const p = history.pushState?.bind(history);
    const r = history.replaceState?.bind(history);
    const wrap = (fn) => fn ? function(...args) {
      const ret = fn.apply(this, args);
      onNavigate();
      return ret;
    } : fn;
    if (p) history.pushState = wrap(p);
    if (r) history.replaceState = wrap(r);
    const onPop = () => onNavigate();
    window.addEventListener("popstate", onPop);
    return () => {
      if (p) history.pushState = p;
      if (r) history.replaceState = r;
      window.removeEventListener("popstate", onPop);
    };
  }

  // src/services/sell.ts
  var sellKeybindsInstalled = false;
  function installSellKeybindsOnce() {
    if (sellKeybindsInstalled || typeof window === "undefined") return;
    sellKeybindsInstalled = true;
    window.addEventListener(
      "keydown",
      (event) => {
        if (shouldIgnoreKeydown(event)) return;
        if (eventMatchesKeybind("sell.sell-all", event)) {
          event.preventDefault();
          event.stopPropagation();
          void PlayerService.sellAllCrops();
          return;
        }
        if (eventMatchesKeybind("sell.sell-all-pets", event)) {
          event.preventDefault();
          event.stopPropagation();
          void runSellAllPetsFlow();
        }
      },
      true
    );
  }

  // src/utils/audio.ts
  var EMBED_DEFAULT_MP3_BASE64 = "SUQzBAAAAAAAIlRTU0UAAAAOAAADTGF2ZjYxLjEuMTAwAAAAAAAAAAAAAAD/+1QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABJbmZvAAAADwAAAFIAAHvAAAQHCg0RERQXGh0gICMmKSwsMDM2OTw8P0JFSEhMT1JVWFhbXmFkZGdrbnF0dHd6fYCDg4aKjZCQk5aZnJ+foqaprKyvsrW4u7u+wcXIyMvO0dTX19rd4OTk5+rt8PPz9vn8/wAAAABMYXZjNjEuMy4AAAAAAAAAAAAAAAAkAkAAAAAAAAB7wKXVMdj/+5RkAAQADACAAgAACAGgEABgAAEHaUyIwIBLKM+o0SQQCSQDEIaNCM1/ySH1oT/q///zvyf9YG/SjE//w48Qevu9CaCJBDzvPQn6ORUIT2oyoUcWIDpVOp+BlKPfgK5H/0AoAQKo1/HXt//3//9mPXq7p1q7kX8///Orf/6nnckjI3QlZXFhG3V00IuCERBPt4qB84TVBEWrkSJvtJkEz0M3rvQfekFCTNggegdtW+E8vSBBntIAYny+IxOgyoQhc51CnI5z812/y4bOBinWP16+/0TiWf7f8wwdtV0l275xZRfkwiGI7856yFfOnZPHgXrL6OZaLBLf5CERxhRPInDTOuOwRV5CNxKN4VYJ9JLLcaBoI9rZ4afOcubE4URZc3Pfu3ubUJIOBwajID/BjwqJ9nY1e/3VnhgDV/BAgsL3wYA0ozmZes4Ds+pv5e9pBwtfdOIjLvP/Ek0977ltnPVZZSWHCur2ZbfxiL4FEB50+2frHL0heWUmm2PKNvz/+5RkdIiFHWOnkSx/oJrMNQIZj+ZN5Y7IwYTKwb0wWVgxpnkn96XYcbXn/r36LFjjB4vUSw6IYVpnVcZgSCcHQ4LhZLeXBWRIe/ArHjm4LgpULvCcNzvH+4DJhWRI9G9nXBoOCkJwZZKyxwKEgEwZbR2oVw0EMZJyAiAQDREz6EA4nyckjO4TbPd97e9uiCDGbEZ3Tu88Z/D2CBGdzyex/ZRDNdqIIP3tlEJvYMy+eTv/tEf8/c7Zafu3YhykHMCIMQ93RDN/eIjH2EOxBAwyJAetD7Dk7J5exIOtyYwHC9c+2jWiGe2QhECIBQ5k56I5n7i/QviUOBr08g4tDgAX8/+JQ4un4cDhH1/30nAAnPguu46IjgCE7u57miFym/oAAFR9TJ+e2j3UGUgVJ6y0aTCjEIo0DFwYyc+mFzaaOdIEEoZ8nPYZOekCD76QZO0bajGqOnm8PfIx7JZs2Pg41+Y+cH/7xu9/+COSNf0BR+YEY3wMsZJ9tZiD7+722P7/+5RkFA2SmGM7gCE08k/sV4kEI55MeZD+NCQAAVcxoAKCcAHbMs9MxV3u+9iMt0HPTghj3l3dEIeyGE9swYDpiw4ARJshGECB48wgaF7HcyFFEgAuY2zNSzeU3/NzkCBGNwKSwL5I/UtbG/8kYyWBDcGP/ecjFwDNL7vuaIW5lTTRHfdzQu+aU48JycyDsTxksLRzc0KhzQgAnlFhBi8BIuSpqXtWr/XP/fN6c/+0f/zH999f+33//z///NffaL//dPCbxxL9NM9Q6vacrZCvePmkU6yVPb6tHDs+4NmDjKNKFxwfw1kl2LkjIUPg5IIEEHqNQeg4G4jiHhwC8hQWB+Wn/+evXTt/2p//3r7r76v/z85kOq16503fnr2R5xVDDXoZJq63dY3MdjGLoqFzCpxAfigSS9jpYgVHjRWHmkBeL2MHCJQqe7PG44WKIxODwRBSPEyBAQoCDOBDThAAAAB1eqWyAjLzO9Kq/uP77r7Wkal8/q9/QUAlidP+qEH/+5RkE4AC+oFDzhSgAF8wKEDAlAAOgO1ruYeAEMPAooMAIABRcgp7rr6VW7H1sv5S5UZSJ3TmNmIY4mcpxFWHjZBqkcVFVMJCi93puoqVjDv////xit////+5RRVLtkWzJf//7ITZP2/3q6/107P+nIRu/siFRrJ1XZDKZhfIg9kIrKOM4dVGKNFh4pUzCYoEgOaKkD48XZ7OEgkAgIBw+UjCJzgQOKqgYeOCYmKv////+BlF/////3BBob5IT7PK6HR6Pa7IaEf/Uetc4NTnyXv2kYkV/xCcpBkOdnQwIS5U+aMkpfRzmJv6c1XhsTlPT/01jUSC2rcPH+v8a3FZ8R4sQ9xyOpNfO7/4pelKUjZtGg334Gv//qmvSt81+qYmFfvWmfBs0eV/+iqecPJf/////////////1///T37olUzfuX3ZEdyq/MqNUsrHbI7qrNkWpv////z/////5ShaqAIAAACKkkKjqNYHpHrgEqzZ2UlgRaLCUK7Yq40Mwz/+5RkD4L0FTtWV2YgBCngqIDhCAAPvO9FTbxWwLsQo0CTCTi44jkEoFzJBB6GiViZIqOWaBf0OwpSjeOUoOVIKefSRLpmOa58umTpo6Rso6QViiOaXR/FKk6gkjTQSZklqsk7PSXT7aVHpPWaol1FHMUg7BU7Ku4KxK9ook8WsmG4hEwNPO9f+QWbify5cH3kEwff6D/8P///+3/8vsvAZMSVD5eUKOGlHpCxI8HgGeFoAAARmsIS1GVk3gNDQUdjETBUEAg8SaZFqPy3VwpVONfJAOqSHAshgEWUkkVDUWdlNJVZ5wcOxTda23AuJBB+21vNYu8Rz0Mbol1hhjeTfkfwGBRXURITx3A1JNO13mwWmUyspK9+s30OJXBHDGMNtW8hzTCcAA1g89DhXXK/+qguFw2ShZNO99poP78REA4DT73rTBML99+R6uT/U65AggaH////////96FXzFWAAAARdDntlBrvNqD85WDjK8fMEAFGkzMHTA+lCNankkv/+5RkEI7ETUrOu4kWIC6kaTIBhw4PxPM4biR4gL2RZYj0lShlEKWaBQBeQCjQy+BA4FOFAzZIGa0XdQCg0CDQLgrPkGNgYigEeaT0tXHLvUNAMKikhehAPZUvKAS0+AoWE4nFIC5BE6x2bxTqpLi1LK1fS0yWkFOBGZFlEkQ/7M9d9SXYhzLDNONxkNABICcd1jZimHwBqDVv5yJw8MKECl1cWERKe8m48EoqN5iPW+n76zCtiyez2/7qUpQoMmiBZyaGG5wgIG7lMEHIwEMhoFmEvOEalkzNlcug68aMBhJOVAiAgcKANWmxQ0TXWbMgZ6gdLab77Kpxo0PU9jWGW4xyAQsvuqbnG6qKqFPicDg0hFblzgsQOP1A8P608ty8v1f4ZlATLHMEzgwzE06FUEakw6yeY4klIIYB+pTIT8sVzLuTJpafnSIYUEB5N7eddC8GSXjEUDB335QUun39IdYwY6qru/+pgAAAGpRTL7JKmZIFxudJm3SgY+AAkAj/+5RkC47DlzjOO4sdQC7jGXIxJ0wOBOM2bjCxQMkRJcj0nSjLAgMH60ewKQCMs/k06lSEa64okBHEh2Gf/UOvy/4nMkks8RCSYuji7a6SVN7ab7o4dGoYGxQs0pa2DsGC5AlUhXS55VT568lIu5QUEscRsQouh4SkTo5Jhgjq3ARoE2RDEyfRl4gh8SZfj1xBRGS6Ttt+I+4CldyTGQhDGu1ZQ9CVZgUArg76f/+luQPQoqIrmQgQ1w+jVU9KCeVAUZwCZhj7k2pTVTIac+7TqNFZOplgOFpcF5kvomSwAMDhRTbGR4IARzf5zb9Zpy77t9rmW7PbswHiQpXGNGUIMPKpNqopaM1Lu7saYodFY1AhCrEvdxwGI9TAiSeM1gBwH6KQkuJoYbyAEeDGSqeLgk8dHWkZJLaLKqja13UBgFJ9jtVEV/X79R8fGw/++z/0qoAwLVJHIq5BKmxlQ6zy85VQyZidohmpx1IpYjM4hF3EaOHjR9OMEzB9YAqvxYT/+5RkFwAjMzfW6wkbzjEESZc9J0oMcLNBrbBrgMwRZnD2FWBQIBVP5+8QYI7bz+5HQRGDt+FghrmFuYZDgmjiTUU6XKvIf/1AKbiz0zDZdkyIL269V8CdhAMAeyAoAARgD5Ph4fJjLJ/HWL08l8i5gaDQJkDDzO+UFy4+mhihARp+6tXTrv8k3yb/Z/0YAABBkJMfbiEqLiCNBVmYE4GgwocAtKMkBAJwjUTDQPu1GLw7GhCjLSy1OvGlHof7TvaZHrc5M6qmW7odOzLYx5tk3CwRaaQQ1JVUOBqHFTrmijhdgQHMWhbCJuzarFaXNSSUAAHSCOA+R7NAYQQ1vYxdwqLIkrWrqVJImk40Vqln6vlM1asNExH/u7dv34kYLBHf/V/RwAsUgoW/BorlgxGmiRQZOP5pYUFYXQ+MQA0wHIx5SscUAe+SLgeCUR6ae4NmKzaSmZONRrpWjN7X/mmBBrX6c5kW4V8aCGgqlJRVKYw1SuXq+5k4fTccab5J1pf/+5RkLgiDLSzPU4kUMjMiicoBhggMSN8/TaRtSL4M52jzCWCpvf9pXbq77Q3oACDhICcAF5EACJRuwYl8INt34iNBAsCsne4SBwQn/34GOMqTi4O3dEuXDX9DvksK3gghhUoB9+KBdYIPTsQ01tyN5ZA4EbAk4BOUmcYOaVygFkQrNogwhk1L4TnBWu6/SSoLiafvKRgwgiqF//+3d6fS4NwgyqbNSd1UhSuXCtvrSn4R6wXzwkHKfskveV7bnVfec7AwQGxqAPiCfQ4j621MhzBMabHQoOmtK5OrdLoJFaIqDCO026DRVesUWExH92a3fpXBB2kmzEkGmteaSGWzRHTBMV9v6UACxLKAN8F7on0AnmZLatH+UiIOQlNyxEuivPW4yqhepNK40haajFOxiBVZJqYXXDjIsUEwuH2SOt3fuF+Ip65+GGjyQUGo2KBMzj22OdcdajWAB5TCa3AHxoxdJB1AU50B596WQlKwIILVUWQeCoNNRVnDUj/rfU7/+5RkRoCDMTfTU0lC/DMEWeo8x1YM0Tc5rhxPQMkRpxzzCWD9Te54in/9P65lQeVAAAAAACzbsHCTmMDE42KBjfqGMYQJCcWoMOA0LUEaNtI2lNchUfpXMFY6Q8sOhQMrtICO5n3WgmJHE2RVosMLBThww1lo1JjYxVKyverWUnrZkjHuznV21RkZtbdd31bprS4V7z1IgC1qAPiwzRuhC6vjvLCDpj/HiiTgQAIsnOH7pgA3qLXs/WTT5qDKVAAYWKav10/36R6AAQUGjruHRfYGIIDYYI3poNCiwga+FgABI2UEV1AFImTZTNjklp+jz8pxMCxY+UKExdvnYwHFDGTeqlR+5xBqPGPTa6q44VnRUINS1a3qVeZOhUZaW96Wa20qq2xquWUJCxEEI4AACslpWmwAYRBKJn9ROMcvkOL1iw4omyl2B+N0sjjcakvZ2Y0MHo5Zmu+9txo7+vV/1wAAKpIpISSBgKHIRRBxIWdahm7B5ENNcDGgG8ZESzb/+5RkW4ADKk7O04wqwDKkOh0Bhw0M4Mk9raSw6MSRaTDDjp6qdPNxKCnRlEvW82mYTkXVSeDWyqciJhS5XC2eQpWP+zzFLUIi7OisMS827NVGQm79XD3561XidOozz/2oXMIva8p9rjO318rAAEbbanQJ2UAxPqVwu1l1EVd4wMwmD15ZA/zqipUDXViInDVv4oO1v01+uIX+Kf/oAQAEG5BDiyhAwxkOFhrogBl+qw8NhEDZgsBJgtAoYELDhtGMvoxwPBQB9hFo+eLC/7GY4L3sykw4CGtXueIKKJ/+Fbsymk7pn2mJ5oR+UOBF51aWBVh1BmKXLmxrYmOOGo3c10jBwAIMbrrlNYA4zg6KVLE9JBFUJChyAz/GiUe3aBRAGBt1/PrsZudN+qQMVxsQf6W9/rvagAJwASktEfUWEVuM3mw4u7wbfU50TzCgoMM7khqECPJTSaRCARhmj1UWpY3hLKnIIAb29g8M6v5+5WZt4e/mU0GiHALWy+kmK6P/+5RkcYADMyhMO69CwDKECq0JKGmM7KMzTj0JSM8RKvQUrZ6G7PylcjQ1qusf/NE8i/DUhvmpKNPVddr/dSo1JoAIGR2xyyQAdAIjOHMeYamVH0ESF2si4iC5z2LvPjc2v++HvnmuvmJefuYPikZuhL9H0enAFxwXpt+IyxohyjERk1CWNSpg4SvkS4FvGLtqJrpSUxlhy4xXURTeTHzEKf3aHX9X8vRrSSy3Y4pqJINtxRgVVvcjB/ozXNRxMl0hNpMgTY2m6iP+L168fQ1k+WdOs3+HP9fXfLAAotzaS6AAD+pvgQiU+5qIYDQaHkhGVcA8eDY9bz5hMW2tZakolszPeKxRHbdNMGN9gAEiAuS7YKUAACCNnA5OjrFNTjMIJgAARhACGJYaFgchZMv+71WZpICkfCgmTP1AeRxU3UMYff31W/Zd2377nutspmxjXL4SdFNSdx4OoSs+dYFwVLMBwo95RSMcAmv1PY9iA8Cz10AASORqV1gDJ3izvcD/+5RkhYADLS1O02xCwjHESs0hRrGM0KE5VcWAAM8RanaSgAb7Hv9cLhDDkNB8SQ1lKdv+nAkr//mXPVub+IRFe5KwRQhKeRYr/0UAABJ6j6ez+7a2CMMgQqLJmlVY2MVOkbCoMbQRRcADWJpdJIyJuXAYMEGAEswbVAWCAWDhthOg2CQamgLUA+UQeGZAOLgZQcAUMC2AGEAANAjQLzcaAWKFEkA302Ho6bjPCFScL47yBizxxilCAl4ckMwYFI+akyO4hyI1xYwy2OebmZcRupBA4ZIs6a00xzBzCIDLkC/61K0GHBKZPpqQIp/+93boMRcn4nc2NC+n////kTIoaMRQihoRcvusvm4AAABsn22m12gAAAAAHQckWNOGmpghn//0cBKTmyJm5F9F1FqUpNBnrkGUKpPlN0uDBu1vtw0jG3mE3l4rWWjLrxXbw61mXcFcGILSgAAAAAF3bHvl0mAIAABKYHphVKEsokGGgEjoI0QiXGIImWBhm6KBee7/+5RkmoAF/17X7maEhEyEOp3DPACZ0UVNua2AAHmE62sGEAIaM75mQEmftYGHTSh0iLzAYpBQaNFilgbZozklAkaBGDpvBjQWVeV4Y49y6pPgBQJDFPlhSGNq3W1qlrTlvFdrWq0WiUA5xmW52qGpIqTtjDB/X+jbi0IjBLW914Fq0luXfLZDUcwtu/jovte1JY05EZ/v//ItWrc1j/14anCoBF3jAQZK6RZd5Mx2SLaZLZ3/9xpcN2cv/6arZpcst/laq8fb/2QqAAeAgQJBIAAAAABXoDeCaPE9hAwtFl2fO/PUfK0l1YjE8ga7tYlBCJ8XYRk6jfL6lbCCjGWh2sB9wjAUUkgfR6o1ByzszMSguiRSCOafWNqK1oPqprooOtSblA+pFnMUqVF2Q2Rdv/UkZPWiv6XV+vq9F0nSzJEuoGRq5SRNFszJI2rrV/LyMJ1AG6VO1yE6WARqUPQ10eTKbu9bjOVBOcU6RSeHY+7msur/+8YwsIuDPooBb6//+5RkS4ADPVFa7z2gDDGDOcPsIAAMnUVdrCxReMORKnRTDlb/9fBgVQcUsjRYV0u2aU4QNLwCzl22E21P/GZxROAF1PZM1ikpsPlSAUWPokE38gTrQ+SYjGa16nN4nbxs+zK40OYCaVuzGfR//qYSMKbZi6M6s3/81DIAqygzGFqVSslqVajku+JbYBAoCkkriIFRrh52soZFA62tq27VE7CPmHYDnD67/DM6l82wcMmZdzkCBz/9jP//0IAQWASvWmS5PV9yY4LLhY0xSB2glVKVg7Dd51o8cSlswC45HBUM+hi+OCPxkWWnlkzL8j2YhjJ+ccrXdRAdunQesrbTMY9HGykILo3M+zuv29pdDNAx2ZSQ4ooHVKKDxVbicJRQh3j2FgMCS6oD9s9bO011dwBDy6yam7Zf2FiGIY3GxFM0QBNHqo/7ZFIdfb1tGECAc//NtT//1QAAAAAFFSChlzFAaVQVSAjGmXEihXE0/DBDjJjfDrR5xkIwCjCwCHj/+5RkYgADUFFTY0ssPjHkSdNhhVQNmSM3rhxUSMaQqrQ3nM4W8hhcahuhly9bUwpfU+5XED4QlySRCCNpSwaMpKU6jNkQoMhtvadLOQqzKSxtAZUEEmHO9K0f//6s2s6iZI+luBZze9wA1MhVuR1kDejimLFuQ8ies3SVcx9CgwKxkEbodcbF39tkep3+1JMee3f9gu/e63/6qoAAAAITaiSoVRMByk60GTwpTMO54KgALhMHNQL/siryjK7VuJKgAeGFUoNAwwAEQwrNk/WA15y/UKbGIwEg23IXGJgMrW62MKzi8HNhc3l7kug0OC6/i7mxoixNMcULgTiFSGqCu1ZpSLqSh2OVnsSO4UlEOSzjd8aMWtIf7+a6tEoQhBh88Ss6IObmqIqiSMYNHD2qSwielFi7V9hcAICAFpSKggMmGLeMkOlTeZV07Krqfrq6fSkoeR5Cs79NOqv///QjkYAAGYJzKbGEKb+MMaSyOBiVHgSMlBTMFMxA1PlykWz/+5RkcoQE7lJK051DwCZjGp0AxweT+TUiDvkPAMsianRwC8aYIEBZgUJxhSYYOHUGBFGAaOqbEgEM2YBgCsIdUwKABVbIlGX5CAAYCt6tOszFQ2KsZU9nuu7uPDwe5T1Z7JQHgtkVYkOA6oIxbJHxcMWfLNFO0bkTv/waWOuVRe/21+Tbe+eN6pLRbU+hlR9973NSgxwkI3jlqaomutdK44xVAAhCDEZGIwKFBkXFMfCEYmutEa9sxVHyYfm1q/9sjQ7b2WyFVIf+ZBhVuUWv///6ZwQ9h8t2Ib9NWBmN45tNqD2McQfCgQmCQUBXdQjJyYOR0FR4BVSgAXDJwgTC8BQSCYYGBKZtJAYmACAMYCIDDzteDAX2Bw7EKEaAXeKMRqCqjC2c1VG2oXLeTFkjQwMk0EekjdJYKz52aNzhgSTiizIiGoEozp6iVe6qdUW6lU5PNOxVPmqmJuf+Jm7673R7KTYm9Zi3JRuZaiKVAHjH5cmhZe36eX//7+2BEWL/+5RkVQyFOUXIA75bwjfGKfY8xVWWXWsgTvkPiR0iJeWECiBA+CoLUYhK82mO0eOabeSFKEhR0faogDFJY4uA4gv9BiUdSPS9O5Hb//6f8wiplkx/40YTNgIzMpFATMCrdMjCNNUKcNt08ARoAgQTNAUDFDKRrMhoKVEEWUtwYNxhofhg2BykTBOKNNgAB8wBwEBEAutZkJgFAEMie51GBp1RiLQw8E1AMBxdR1q2+anqejrS+nvbtd+/jnXeGnsVdIGgaALI2tRyUVlvLy1RSHLaIQQD4SA9iLFCYtxr15Gb9Nw+0Q7012OTD0OGQZiu6q1wMQtyC2xouOqDcaa6fuvDVcEEXbzY6dBuAA+2DGsOaWcaTg7k/L2kJ+kwKaL3s6VYN3oEUWXoESiHKIcgLOkGmyoTm1f+9wGxEajm6Tm7sAmEN6f//y4Vf////0RSIoQEFIgh7wsypjWGpUXEyWUsMBcLAKYZA6DXVCG6ftOpKCPgAIAgKgMIAFB0wOb/+5RkFowUE09KE6wtMDVGKq0F5QOQUTcmLph4QMkY6zQ3lOYU86Bttk7p94FVW400iiYxWtHEcXIK8aUW5iia8edWr//v/0MeXwYJ0RCrSrojIRdkmLtuHSDmHVmrtO3R/9dEK5rgdiEPTkuYrMoaYcUEj3fEWMf9UYIEIEkkkiAkFEttUZqM3G0Sn6GIYhxggCkMLnvW/EWy/66IYLe1CJ//+S40JHa2xyP+QgZwFN2XyCGbMtwwM11gFF8AoIAwGTBICDA5vyiBmJMZQhbQwCBowyHFVMYE8wAes9WBNkwqANyHw4Dnns0mcU1qW5XL7OIvBc7Vr/7ng3h/XiIoWOy3Zh08lKFCXh6H28nVvKCGpUjkyjQstY3nDL4XGhkRHmnpl/tbBeGA+5AQydjLNFAdnTclglCAiB0yXgziJseioX/bLEYDkZLvvOp4Kx5KLXxP//pEAGN////mhxN1Sf/zaoIAkzM66xgh7mtRcbWcZotagYUioBDEKYErZNf/+5RkDgAD3k3Ks50bwC9mOmoFIgOPATUoTnRPAL6Y6nSgD8a4cdxfvgwLGKhMgTBgXhVbzkoAWeMMlVKnBAu7taQ1uzFurOUlaP3vs9Pj2qlTpZhR4cHBGJXI+qZqVIuXPM8+yCUQiI2y3LZX//9L/GdFzzixpPKkpFnq4ZyELT/YP7MAMCLsQRAkcPDQxRnGh7VRQzv0XMZPMVUe6LKFGR0C0Wv1k2////2BAYrR//QMDwAMBBK8zBC9OTmE5C4A7MAIZEAJMLAkwfbRrttdYUvynBgWHRQLAAwGAkwLa05SA9lS76CaXPD2+YvljLpPnbgp4NzOFPziupWUQfKvKO5FipCs2a/ISZdkzIjIzixiOSDBJKwdm3/t3vMqXDOzJt6UWQGkwc79lYQIGZDakgbAwrBAQkbIiNEINh1RAMp/8+p1CCyf31JO/+vcgLjX/pBR//1tJBNgZsTCuxLbtbJBiM2lcKSToyC70FNES9gyRzNhuuPNkbTx1rLFrWr/+5RkEoATEE7XaeYVrjRjOn08yzmMURs1TaRwgL8RaCT0lK4pq6ma9YglAuM/p9bAk2nl7ZVOO7bDXEHKl1O6oSeis/IyJdwhYt1ZmRmpXe2v0WyC9ld4J1S/1ZGMGsOxiNAjFbVbhIFqxisQ5Ui1FDsK4NBGAYAMBrB+Cx08TRyjlnLtKv/uKYLEIX7Fm//5Sj//81gBgATTkcDqqSVIa+ID28YEzs/bqJDojhyimnL7atwbINALU1GixPguRMn0UxLuUobj4p6bEDftPKBw+XT7CmpkWDdMv/KZvKnXL1OWcY8/sP7c1XKl//nMi9JYx0EUK5WjNIYYCOPyvoAfpdgoNELQ5p1gNcqkydJmpYsjLdqRD9DuLAccQaT/9RMgv//IlS2eRaAAGAAXHIixA7XRwUBvZwBBhGkDPW4opJKM3G6SCCHoTkvwYQWx+y4i1j6nYIuyrohQgJq6pa9BtXHHu83x5oNRZ1ccv1qyFknnrbXd0tdcWY8JGposruX/+5RkLAADFTNO60gceDHmOq08xU2MxHsqTfEqyMSRKzUDFN7vXEzyx3YBhWdwGAvjWJG6IIAP86L0epC08dwRQbvNMIBm/9Tlz4OX4ZUlI/11HNl//QpGf///+c4DGdkgkWx/VpAx8A7me+8m/u5EWEoOJEgh+ymLbZwoqz5GRViFKWgXn50AC3HmjFcwjrXiSdIHMQcmr/Xl+maTqV3scyeNfAyt/77+4MS/0/+Hw/ffT//v05iIvLpGJcAmNPhKQ2tQ80zlK5GpNjtocAsdjeIABeKTNnORlAECbu/QlAsWYzHVDf6qd9P6NqQoac//lv//Eri4eWAAOACU5JExXtklARccjQdqx90U4RyOUZ7TLZYyqYVLLrAguk5nkz/AsUoJlBfgQ5H+RNXIybkNDBPaeoGOOpfCSvt+/QWnltEosYMLaGKRfCL3Nv/Xfrl6ubEaa1E177+K6wYB0C25HEgPtruLWlysUW26bluuiH3cle//N3dD6cYlAwDBn7b/+5RkRAADFTTO6zoZajOEam08xWmMUHkoLfEHgM6MaDTzChTJo/99aCI5/7Oysz//9ZtTi8hjcODBDWZs2eeHhAsBpMDQZLRrpwAqpUjydgCFil44BwBXTiAHjippbHYa+zx0Q8IhzmJDY13uppNZ3WpWYhRjQRUFUUWquHlEjQIYBUJPfniilE6OlTOy1Qesyv//cAIF6BicGJAP21nDkLil2mGRgtJmF8r29EpC9lVT/lmLkQn3p4UH+tYIkX/Jt//zP//QihU/vlQ7cA5zMWjjDrOGSqBhiAI/Ebjmms65BCsgAAE1C6opNRbU4Njo8xFNQYKmGoIcGHhyG3953uRSj1hL7VRjtb7DD5y9YLzBNY1RSPPCuPrFiB1oiONpOpFiI4CDe0nXFp2BcBwauXQMASsXM9hMDc8DXx9URUD0c1ot6OWTOJGAgla7IERZf8QTS7bE96kHv//BKCrPZ7yENkYQOAClMsghIKLAGLFIg7SeKjNh+25L6AAK9pb/+5RkW4gDGCHKi3xDlDGEap0F5R+MjIsqzfEOANUMaPQXoD70GSUBVkogPFPF6sGwPkjxilmokvMDbdLLeP77qiPqKXFMNBpiGGN1j0AgbDKqT+OPTiQgphi4gUGtoArYHNNDaSbZocIbSkQQAkmBcw4B9laQm57CIx3zI8ze2mI2woSbZirFFxFjmU83//djyAcxAQRHAb/+hCqAICkNpyNtIQW7yL06hOZO9jd7xUKUC9VB824XITc4WGqECKWKaJfAjNERoEQy7qLUWRlR/bSogSVSRqrDZBfySfXKmfkxziDDjOEesgsFCkY4tKnOUz/MQ+sDFU+SYl1JgDCdIBGlsqmBKScQcvA1zMR4YxaQjhVpBEWxqJ4OwLcxOt2bZIOMFwGd4lK/U7Z/+qd//+kCAS0pg/AXngh9OEizaj0SAywChxwYFuh71ArPs5IvoIDIGRoEMtDKC77uUtJKat3CHKfCjmJnFQMs+7roKrZH2+CQuEuwd2tEra0YnET/+5RkcgADBUDSawgcXDVh+f8F5g8MTI0ozfBuwNMJ6rQMJCbxUTKOJCLs8bF7rE0C4CkU+33//WG+t4JZboIALldHZiQcAUHXbExGKARITF2mecFzDmPWLKlR7enPICxgmvLvvUogED4Ef//LVQAQMAADXMYPsIzMHMkz6QjFZmZwkuLCUQLcWj1Oo8uYLABoyXCwjDhWAkTxB4V42s+OiIeeTUljDJmXvLQdcszm+ymd3yFn6l5mJCliJwHF2Gi/AOechf3p9NoQXYvoBOB6BjckAYG0SE3RxgLXTDnxMBHgMErnTnYWq/FXKITBAqDQpV9vb9b6UjUDwp///+z5wEjYNliAQKAAE25GxGoFEZYRVJswqQorOUPXMFIcmwostBWtYLJK1/KAgtw6RIKXFln1eP/f0gM2t7VkGze5eiyGCh2Oe075KT/S/th1SLzmJOKR4+PYaWWHWqR6221O9I00AeBoHHJYGgP/fuVBSB4Xn5cjkdDo4IKCOcicMn//+5RkiQAC+ChK44kcIDfEal0F5R2LxNMvrZhxAOGRKbWGFP6pv45VlubrtpCin++j6s3ZN0UcJCZn/+L///oVQAAgCBVcqSCgCZRFUKQRhiUKbqmYOQytvOMye+NVmoytxhTOUNQIQldSsFEiExAKmZk6oOQxk/z4YYbPgiYJUsk4xEkTtMdGU7fKpn71s3VQu6pV3Tvrt0r//7zvN/AZwBUDMNuWwIAf54ZJfytJFuE09PINAqWPFqfB9kayG9aWSb9OTQhG879dCCFp2V7u9Cigg+z/9zAIFAJLkkbQl8raWPkgcAoTai3dzBzEnfnXbkTROtc+OFiWULQsi/Q8vo+87W9BfzN8Tsb/9/bdo538smUWoHPm4tcaA852vIaQkn5p8rnxZw2XKmHv9b+f//j/1/7/QAGABSAE1spnnFAAoq9z7teiQk+yfavA0NtTVveQsVgH3HhSIeqodTEQ+k0t4rpOvkgLa5bcUD3/+hUCA/caaKnYPLTa1kzA3Zv/+5RkoAADBCxNaHoYejakSl08woeL6Is3rOjKqOeKJOQdJDiX1ZYFLUfdn/l8Dt2nlWQUrswDzJuUlj8dSd7HhiqvZt2fcGdNnf6gKnZBjdgRD3PIyMYqKtnUGtjU2OyuzW0221R2thDxK6WFKCROZ9Fa8WV/6tKBgFgkTlYQA+ZYwPA7qksrefop4tsKiOCYew1hMWe3W7+KB0h3YgALPv1cK9UpZtDMWYBMf//iMwCsqRpyxC1i4KbI+GFsyuB0JAxSIKEPjpFJJPATjBgCwxgIM+ybpQArbsqiXwFg1qJhTpsAimbzj5BR8+AjgZQtAuRHB2fcH1E1EyYLAuo2aJqVFKQEcQp1CWjMmq3oyPt3eLdAE2C17QyceOwuMyt6XReCzT2qHdrLpVETKDtXh1umCNTzUUgoN2n/dXxT8V/8JNbqNhWUMJHdc44YND1zEZVfo6JmOCphH6Ph6BHbi8TY0JCBhaNYEs4tmGjOkyenilWK22nhHh0DssEgwkH/+5RktYgTFzrJq2wUNDiESi09goOMiGMkTbDQQMaRZyQMID6iDFrkdn7xbr01NU3CQIMMY3OtDAGqfCbDpN4qeQ1JlSgMWCgJARqR5UhNPSbZqfY9QVpWOTRzmSlQBQIQBLAAa2wtS8+AMQA40ok7vKQoocfZ4ZS/7VJCQrEZyJpmXvIjAbewKEEaTNIs2/etqBJLX9NvAlZzKhcVWjGBRONHdPgLPJSBwdBs/Nvsj5Py8gjwyxImhOk15yIQRl4QgkiZn75mTl70np4YylX6drFYl90di5mkIim+Z0sCNOqErb1JJIy7Dyyczr5EIf/9ZAgGAKJ2oYAmmTiAzjGJokdEaNXKkuweR5kZAOpj2VBEUK50sP96VNV6LrROVhiX/+8gACAAAJKNtYwCSWyzJlnIYmgVWVJkRUSPXhKFvReGoEwvivcMcgbsMxGZlTZ9hxcL/8kh08yM/LqmdMqZfnCJyMzzshpxLzRizggaY0TLMB4MVE6EPcDQxrDWRU7/+5RkyoADlCbHg3xCUDSCeWxjKTkL7MsozZixQMaRJvQXiDxiAV6/6ABQ2gAC6wABOyvcCMCg5OqdYcUsnzKLWduuzqHZESSViAhVp0qpeR0MJk8qcpFrdgUAAwCJM9uEkWNDRraoZEaq7TJStKjiJuWDjvg+kiLosFVQCluClSEw/rYSBTx6rffBSJAr92TPluYy27TMOYMmHZNkvtvTxkVgGhTbF5qQtA7fR/cbUx5CMkhwymHqmt/yL7zzOP8nM5vKaKHBLY6vSvWqTC/7iwA8zAr8gfUCw4OHg3sCncUq27L0tblbaCO1kFpyjQiyZKX5Q1zB02uAwKA7P3rE1q6+aXuEBAOB9pB//pV6ldgxumMwGbcOZgtBA4BBYHjwxMEOEDkpia8ZqOMSGgQ45KBAZLRIywY6Do0sjoZ621AECVAG5H5kZKIkFbDejs6nSXycZyzkvtwuutPTeHl1DzIzJ8h2zSHFEktLMqRfS3GMGGZ1yjBoWHIUGq3D4pP/+5Rk3IITEDLK60MUcDFCWX0HAw4OcT0lTZhzgP8RpAmmFhCS7scLrCSaCCBIBQAHJogDhIqMDSjG0VkMLVkAsEbaBy6ET028JeKH2qDC0UAQG19bn2pTpTaPzNVQLlXP6nVjryQW7cDf/yrv//bABMQS1ARSJroaeicGLp7TRwFMOCzB6UByzlwFIm2rDQIpVEgJ2maAyyKV/p6QSympnCDac2WrbXYGHQS/3U0qy3eGffRJ52ZUWGc7naRIDUyiM9NqdY0pAwY0hXjhUBJQp7ByFBhpY/qQLUIyYUZTagrKCrg5qAAgAOv0QDRMBmUIotAkwmrKBioGqgezvNDjT7Dyt2a8VgQ4xQkLDApkDCS81h/YkmISrgUdPkECxZpy067ULj5xb//Z//////+hAAAgAAdTJXi4ogmhhBuASZAGLqUxY6DFseotL2tNDvrVbtBIxHjTQ9kVpOMYLydbkINZBB7rqRjSOBWTB6zMxQxQpT5tPSQ0p1+iqqNZzu//+5Rk5wgT1jtHA4kdMEJjGPZth4QO1M0fDaR0wSgRY+W0nhDYnRW7/boVR7WCB4SDagiM/bVv/69AAEAAwAH3CwgFj5n3hoZSkBwKLAgDOK9GHoxEcIqrGulNEUYAEoLlpJ+tgo6AsM1F8WSNRtC6i7RemTCNoe//r///sKTcjYvVRgaJRgF3CEUUbmuEkWk0+TRF93p+KM6YaMQxZKYG6lrSRyM7o5ZIgFeuq9vdrtfbLAm/IbCOZovcyhFTaGT5yUuTSjLOKZW+efBTAL3LY6YqquLf/9/rFzRCoMOENg/MFbZqIhZZEATCnWY++9I8sYYA8iBEcUBJdUrD/XD/NVAehXJbY4Dj0tlZbtfIA3/////Vb9P99ffd29JgQioF9/slFdBJuHQfpjA24pAS10ylxVNEww3IzHFC4iIIJEEznULFnUaM/PVJWMpWvBZkVQQZmrE9YhtRi/eKRr2Xh9/LJe89ypAkEiR8wIkLbI1Ir3o70gQAgAP2VCwoATX/+5Rk1gzTLTvJY2gU0EMiePlraUgLiO0qbSBxQQ+JY4WtsRgRoyRMbEOAZacwIsD/qcf1+pQ7BapJ5BOYSdAZYA2clg/q7dkajvdYJqEeiHNa9OeDLrppKKLAzP////1f6f//6UIQGIpELc0rLHZu8NaM5RQEAjIYKIQlIsXTlshp47DN4kKlm6sqxuuaiAJ8BjQJG92sOQ10T9C5ZgIn6NLVUFcT0N6oz6hqbIFYg1RWSQuTu7WilO6oQGGSTToIwQeJAACCBAC4vwITlWncabYafCb6RSxiuRkMcn4ChlpcJWqCCorREETE3VdYWYdYDhangXkaTdV+vMmn0LA25Kz4DWDf/+3/////+uoAjCAC1EkKF0BQobiN7w0T4OUrSEEHYu3lzMXKj0fZy286OMSbU4r62MjCxWhAFll3rY8iuZPlsb7TmNdIWDBc1LNVRHFfNY1EqeXVziwIn4RcfZYMSo0LkVAITsRW6so5hOJGoQ6j6vv1gCAQBgAbwIT/+5Rk34ASxz3QYeUcXExj+NZtgoYLwL8zrAkSoSQM5DWdoLBQOSH1JG8co1ipVXgqDIwNeswt3H7V2/4QCBhMGYgewVjcNU0O0sOwe5DyWLlPLr44BQNkGT1mdTjr+SOIAT////+/7v/oX9vt0T5NgTrM5tS2toUs8thJsVBtQf9qoUDFiGTa6OAIKh63Aj9RQqiVJJ6w/KrJaG7Rt0Wi7FJN//W/DIbMdvtNYZnfOuCRj+S2GrFilkB4DpiFLW95wWJLaTMnZk2UF9369VABCAC/iUg19H3AF0OQIx4kEMQYE/qL0EDPpCF5F3H7AnMbYBCSPwYnTdj9IStY8sVLaovm7EnkKMiJNVMKh7/+U////9f7E8apnyy6QEg7GltssbGVRKRPMZMuZqzSaQQ9KV+wqkcuVwA5MfJQqjfiNRiQkil8KMTG85VthlVubkqP/fa+76NDZr63I6qjZEGkqiGZShcLlRhB0oHykxWNaLrl9KKGYs+bMVpUAQAgCAj/+5Rk5wATUS1JUzpCQFOj6Mlrh0wL5L81rRhzIS6J4yGtsRiQP6Y0TJJn4+Ymhq5T3CoYZEFkaNL5XXuSMiC0+I2FaoDRqsCsd2XDhI+gSIeo0q9h4Gv9Mee9FbW+3Tl9H/2f/+//v2N+sAACgABJKJoWH+JWQFBGikiJDE1DVsjC8jvU7btNa5EXVqNbHX5FPDClMks+4yPy1RdhZ5lTK9kgzWG/T7dxp+bpF7z7MOst2vQQASX8u/Z/5w/Mnh1sgYQ09iab+QrSy0cU//7X9pUEZygBzohtkCZ4iDhQEWiGv2671x6AnuQPEIBbuF5ATEAOJRtyvjs6MaIZN9vkTLEgNy0NuYt933kf//////u21ruT/NbDxqoBDACk422IMVJnPOOIYMmmZqcCOcb6sv7SyuSvbOuWOUi34DkvUzsY+mrhDnijWtmZ/cPm5fbfpsjeTCYwGhwGppMEhQY1qGvHY9tCmLfFnO+b15IvxX/9f0IyXB4U7cs2pBB0YAr/+5Rk4IAC/y3NawYsyEujKOptJZIMtPslrSRwwSSJ4sGuPRgomKSh4P2/MXeB6gwNIyiIHgCSGCACDwE0jSjm3VZtlSlHZGdORZNQ63RVkwA7//////3L/iquY1BtOdJwBgCmQht0hm4okfJiZMeulL0eKhfqG1pWjM8jgRWHEglbCW+AvzlMkgK4MKRkI7MVUXOYcV216VEQ8YwXgZHIVtyKnzCIjEg+Dk4VcI2PcXExZ5lZ9DVvCfEONG7/9b9G62Za0hagATBAIy0SNXiRMBgmt4aW6mZAOimmCPwTmN3ftOyJJxNBfwL6gsOrnikauBfaQicsmnJp5FH//GuxocLHLI6WWL//UtXd9v7P/5BH/+/ZZEBzNjksjSEGUsmg1oqmN/nuWvOs8ErDgr8Mq0GgVWrGoJUjeIcujLORLqtblQuD3aHnAlARBnMmMBhHc1WOFGRGPhCWrKtMmxoNH2Dhc3HJvJ/10R185YnKPEKcmomjkiKsnUDBpMRMiVL/+5Rk4QgCwx9KUHkwcEoCmLBrjEYMzIsfjSUSQTiMo2mdmOgv1ehmXS90BIJNMQkCKKA5KK3P64mCKMWK1Af6eRfKUtw7VY29emIRQ/////0+3o/6bSXAayaWvKvYkAECgEBVcGEMEsQMmgO4ZcRHEv1LRWWPbrC6WmKAeyFu7jBROAhQBGRDEXq6OGPZD5EGAmPpczYJE4RmMwcpvuTSeUjEeFqGxM6GUDDIOKAoTHOAM2G1l5mNX/Qln+yzQ33pJqsMsTSDzVdDLt2KjodHwK6Tg4AZPTTsKvBwbc8qAgkmgYyWKQLZhLGEsiWJiCH42hIpH8hE3dex0oL+vyeEf///72/RX/dyNodkTSC6HFQzhuAFZNS0EslkjSG7mcmhjpEXMuKpBIkOqJi5tEcBeKdofC3SS7xG9zc71k9KcapqEKOwbxq50zVfzDB5COEgRtsK8y84DgFDCSiSD5IzPjVa4r6tN+qS5z6QcagYyaembgImsMCzClgJbFuFDcj/+5Rk44DSyCzRaeYcrEyCiLBrjEgMUKMhjSRwgU4NYoWuLSDh2ONgAQfL6skHZcZ4ASgcTltxLE5eZh+hh950xPk26+/rUf7d6P////r2fpqX/whzN6rxVIcAAwFP+gsuoMvCep+UGBMv504dKmY9tVlD8PHnDcQd4RokU5HWs2TxNuLRdeWGHpevvli/cT4X+hDYYCoPjn0fMs3zvnvlomWjEOYxSzLyTwEkUAiwIbmzKbWdnVT1/6md8ABTSH9HSMmFDDDwycKkJc8OHBlTI1OHl4u5L4809lSU4NujcgcUiz0ZnCkDIn1ias1yPJ5n7UV2o9PnTrH//dk///Y7/u7/qcL+ETq1ABAgAAUjjRFu2QkDehz5meO02OxQRnlCUzHopL/fePOyQgkTcNTVXE6t1ZGG7+aQKX6d2jZCiyu0HZw1SQtXiyWsW2wUChU2wDCxYyOAiGPQtPiJG+MR/+rZ/+oCAAbulhSHJBSOZJyz9LUBAQDpE6OKstyuM7T/+5Rk44CCqihRaeka/EwDGKBri0gMJKEhLLDQgTSRYyW0ihgeS0BgCOZAO5B8ThVl5MQyOGHqMD6bFtleVPs/ELP////6fs093etalsehrbSkIlVUsAVkwnSY3w9i27ivYKpjzcje6kinGUwyy8cHJww+0YaYhQOHbIvd0MHS6CoJJBM2ERAJTqDrCcspgPkkJUmqKIGqa8XXXZETizmq2a/d2f+VRrg63DhpvfRYhNOC4lDYwgkw8LO7EojYbGAg+DgWHAgZihnYIlsnFgSkzld+inkIN33rfzMMFHdb9SEFRH70PC3/////7l/n9rQKUZc8poVPpUoCQKyBk3QRpxtiFbpj4SYjVV0DqIv+9mFWKPuxJglcEuhqTD4o78qo4lRSWUAGQgQxOAMLt65kFJOyPRUuK0MsiKTKcMgrXnlGK3ykc8rPuflg1uRSSyu9sY73btzobx84leSQKAAYACIo2T/CwXLsGiUgUTIUPQEACrEf3cZG/DtUbloC2hD/+5Rk6YSy4ChI6yYcsEnieLVraUYKeE8gQ+TBwUcM4kGuCPhXkxBIQOxByFiQlCYRQIVHT+n1frdG1DP99Sv/6/sTtc/r7/9ruoBBCAlUCaYSK0T0DTF6BHnX4mWn8IUoHzwJGNRpsbJXTh0R5SguEAmKuNePfOYEg2V2O2Y6EGsl67tHSDD062HjMWhlRCKUXiATJAKwUFwVCSWygoYMESS7SYv2Ve2wUNVBHpPp03m9jVSDqoAgTOofokKx0/2REppK5gValJaLvbXitMpU9NYkfIwhutXQx+7NECrzz/QmXudv9Osl9f9X7df/f/crMdXtsakQVQAAEBQDdIX38JYpFRMtRMY4aczF7R0+T1rVJlSwyull7LxmmuQ0xDE4XRhxzEiWcErqMLY+14hgZ0ih+Zq2dZUA0qPAede1pdAylAuo8QIhwEHhxHAkXTu39//Q1Nf9SQIG59wqJ0sz3MwuaWYOh1BQtQhL1DbxRnLQCC17iwSKRQs4tNfiISj/+5Rk8YCDJzjGs1kZcEhkWOpowoQNeIkZLTDSQQSJZDGNMORAMmw2bDqjFlEnog6/cDHrYjd/Vq3f3XVdI3YUQ/Z8lZRZTd4MuogAFZA218cuhDE3cgHb04WZwCOuxfVAkexl89Oo+N0FMYZsFumebxhEotWQZtDATpcSoKBsMABbSAlbDrjyjRaG4+Fw2eMGdwdpZvejFc/6t4g9ez9swSfQhAEwhjTFQdJgI3UMFCdkqyTHggVoSNPe6bjmo4FQ9OlL4RtAdCr3bM8MrcOS1GIobtLUzcSwK30gxvvfG//r9v1OK9UVIW+vt2v1wuL7+YSixQAIAB2AKr8EusMcnOhmwbpnlQCv0QKRPdAMMQ9XssNVsS5FcYPQBksRWICqJCBQJspVrU0H1d+33UjPG6UkQLQOxBAdAzhwq4gdAQmgwKtFguijRTilqPv6RtqaDi7G0e/DimSVIEAYgCY4Eo7G9AYkEKiVnMKChzTAX1IYFeuVsKU1TnWAAqcBjij/+5Rk8giDACXHY08cAE6CaKVraToLNFMbLS0wAUGMoom2CkiDHOGLUFxzlisF9RrNx6D+3fWW/7/7f/+S02Chq/sRjFiA45Uwgw0UWu8BDAAr1CSQ+QQY2b0gYWI6C2UfAq3Iyz3PFJ7mMRpnOGGpFNAhdE8vVTVFXlSLKIFIO9ztgwiOuYksxEMrQBmJARGZpCLPy8fMOea7N22/R9/9913qnu3dTqbS1FkY5sFAoQ/wqAiAEEWWRV61X2uUDDFMkqsAKWFFQf5SKhXM7W1vT2K2HSOyxyHsn1gjN/Yv//t/Z1cpWqjYxsuvK3RwPloutsitZAiFVQIEICBAKR3RS2ZcIEwTH2RYCwlHAKaRPFK7kxTUatrsyoUSk1ANHiUV6RpGxoEmvOMelGUtysqDNppJcAEyqRKLtWUYRhpYmYLGQIRPPxT3OkEKHJn/r/YddSCeQW1SWseSFI8uX3QKUAp0fwUDC7zoemICIxEg5eajD348WHXgnGEBYGoAJmD/+5Rk84CTKx7GS0k0IE+ieKYHaQ4LFLEdLSRwgUKMokG3ihDvJIzd1cIvsusxwHbkXtu/Lf///i+3JI6H2XozwvUK0BR99oVY+sYDxFoEjP24QiVyaeB4ObMIDxOqUrACC9DMaVvjMtebIsRiRd4Rlo9cAQCID8IiLSguExSqlWtqZQINn/ycb9yx5D/UIqB6Ve4kj/CdSwHxRW0Jvln5wbvrh7K3uasr8Qkx/+0/670Dhi+uf2Xr/+J/HYvJm3liZiEFkDGVDAwvofFqIkkOScGBQbXD07OPxiQiAdbxdEcvD3QOlnD8msxUCw9O8nO7VJjlPp0Dv1/tV7fu7P/+Pmhr/uthttEKqgIFhLV9hYZGqc0QWMxKEuGZiwSKRYQnVWtQG69+fVUZ4BTUOOQeXzJozqGB7JwWzRBQrNWnQMxsmhmRxC9fHareElVjaroaNAZYBaXP8Y9C0po/yKXuUss2ldRko5bFEEF0BxbzYkB4AD5gqFggSdB8YUOogMj/+5Rk8gHDLhpFy0xMEEwiiJBrbCoOnIMSrbBxCRmJ4omssRgVHAAlKObzzEPxmGE1IJUrKrGlBoMTqRfdmkRVnKLgifIsHOKVodv//////6zvuue6tnovQ4LqlrpFlDmRw2kzMckVFU5zFAkyzLKDp9HmygV6EfAUEoLhePNEBgPylWkmjGUpqgjBgfJ0kwuEFibJRxWHckBWB2HW0QamDYaW6VLMA0aWu3ks1DtRUSyOVouDUDQ8cvC4VLEnJUCAaIB8ekkSGmUgAIQDGPDo4ZQAGlwZiQa9MhMEAHF4S/lz3OxGocGASvVkmV5hDRI+LwM/RgyJkTa8S6CUkjJ72Z3/////+j//a1O4A+GUQAOQZyJWAAgAqxxsi5mSHUBsWCjDfQazUcxIupDN7xxWBlM+IqZM8sn2DKs8NLSU6KtYHSNTHCc+MtJCHLUdtVSV+7+3JbMXb/Vu/3/SBANGAmJ8LEBt8YvphJMWlxbgKPjfEEyiW19pKQGyZhJW0Pj/+5Rk6QgTKy1Fq2kcJEejGLZpJYINzGUODb0wAS2KImG9JLBCPXYcOE14XiFjNdUxifndFUksb6VYv/69FX2//pR0l9fZykpeSxyhQ2UQvFATNKMQlMDIaTZkWSx9MUAwR8W5lSddyYQGqmgIUqzJgV9GnQPbDpFyYT7GJMTAQRv/aUfSjGHHr27vb9ziyD3zS/uri32GE29FwseWhwbFmFWirHARgtGvfgx0KSEdwiyIkmSMaSIQ9F8I1LsKHKHkHHKT1JqQyM1ng6VJBIXtlopIHrfP8zPBkrEb+G6f/lKq77VEEv2VexnZr/+jsorqAgEiAUMFFiEAyUNNZjRWle/ScRiAWGNjQXfhlnUfbViCmQAZSh8XRTwq6RJXYKRDLoUW7xBGn/BhJHNa+Sq7m9v/7uyOlWmTp/t/v/T/l86X36t/reyZPXqy2VjJK6LNSZUcO4Ag40DKIioqGNpk8IDAx3lgy6Jhw2AwaGc6aCHiQJLDlygQXgZIBiPx6dD/+5RE44iCPxPHUzpKoE4DKKZrKxwLEGUSTWzKwSOMoxmWGgC27DhqUL61VGJMls/64Z0SWUYYrbr/DaqXqQ37b32+3SnZSdnm743EQWcPTYLPGiIQjj5UNVAm5gqbAgQDnQrtF1qsTMgAfpp6Hc1LGswWoeWDxdAAjAUrCSYGB+ITzbfvXslXz09LUTVlh813jErT0V5L2X1XdPq6Ppc9rlNuJpm40pQXAjDBwo90A99DUpFU5RANtPMKUgRoKNIhFhnabbBFYIdhgMBWB02NsBSfWvZ+KIlK712lIwEn9ghtdhja3/9y5GL4Gy/5Q7s/012bkUuQGJ9z4wHaCQAIpHix8JmBikmTapq+xaEVeDxaeapIMgdao6SoumgJcyhxXYtioRobUJO2gHnSgHZ//1OpEclGALobQ7/93+7d+YzSmJL3PFhw5AgQ4PDZ5R49MJrvE4NSBqOkNMxgc8t4xbWHHDR6BgkWnMXgKkh5bSZrAWRmEuIPQGgyOSRB67H/+5Rk9YiDIWPEM2sUoF6jWIZthoQK3GMSTWWDgTeMYpmmChBBw3dHE4pLF5////r5Z3qSpl5T/XszdiLvRrMtbRWpFlobF+HxxEoUAiVgydBJQtKIty4K+AeVEYgMYoRMYMqOCsRDF0Lc1H51VI0BCEjACqkQAw1AwRqWFhStGdQZUH51/dyvFmP2AM8cfNixAk7Ykz9ti+lS2PHr81dCgMuNmb58uJrJQNKAygHmwoKioRoPGA3lVKt9eZ5opAWrw4iiMnyiFKKWYehRZHBlKAUw+xN4C05qaikxMaDU0YnYVrkhxqus50K2iX/sJI9fkNG3ai4l2t4pECkhyPSApRqWgREssD0kGABkCEjDdjjSskaH1KgMK4wj/HnV1QuUQgUQBYMYy+HaADgwQVKtYZ+hLOuyti4hmxhCaYWe7VUj+x+xn/Z55dtqpZtTk4rYSE97hEIVFg+IXPYoXAhMW4YEewfEnUYgRdSVkExg3ySbrymR0TPyydUZBAZsE1H/+5Rk747ywRlEE1lI8FtDKIJraVYMWGsOLWEowUIJ4gGtmVgxeclEiO3Vjocn1oGdZgj46stVf6tH1fFO6N/6Pq0PfC1qmvUrAWRz4nLiaWJgJJaAxjpVCwUsGjAxYOa77gIBMbiSankcginYaLqo3AwRZQNq/a152yZA+QALUSYL5hY/P/lb9hTTeyqx/so6WNchHGR7f+m/oJhNgpm6XS1RAiwwo8NARQgVBPVkIJmDb09IoxZlkqJiWBkWxaxi1Ncl8DF/yEOoADYkLJpc9elnDrOGCRzQTI2fowaxLxZaUVaknv/dTr55fg/1psImEYlWGQINcxg0Ci5asa1hc2KIDbBWgGUCFAA69S/2RhrJjBmQA09YVnwpBDi0midmejSfnWcgXMDoAM1HQQ36DEFBuAeoq5vrZdFdCf9KvG2UK3o9CfEdEy+z36E/2nxubHKw8IpDgCSN7OAI0MJvyLjhWepE/xAAqZoFEsyPNDoQDqaHDgSsJchQWAikbq3/+5RE6gxStxPDiHpgcE+ieIFrbEgLMGUQTeDKwW8J4dWuGcimvp+ub//b/t8jf2bkz7dqdv2fVrNpZVZKpTLV2+ipRdarsFVyUjPspHMx1OP7BGEOSIS4WmLACH+lEr2rEIS9REGSIEjJm3hyBqQUYa9fhUkpKd5otjfkM9mJMGVmn2EG2/Xt3v3//t/0Rk/2dvdrr69f0/zsyXrRsbc5lJp8teyb+T0r5LmbaepCIIZYAxuiiTqA3gaMBE2gLBjQQK4Y2HwNE+U9dGlh6GYpajAK0J/c5XdU5oeaQsuQafKzzP5f1jGnX6Nr/6G9cbr7OyT5FnYm1x4UQpZBJF6QgXkwVTFAdIMDptUquQ7SlVUToGiDIhZvDqrArNGh9PH9TVZfKVDW0EKmTz3qa8VL2II9qjqAaB8imxQVXt/imlJfravf36399vVvfq0a02JFTS0z9lwfFDGmTkFjo4kzMmB5ehJSFMG0ydmmL8FXpQjiW+acMzLYkxpDMWzdDUv/+5Rk6gCCNw/FyzphUFnMGHFnYh5MYY8MDRR3gWqM4dmNpHij2MfeYV1YRARP8/Jp/1//56/+/T/36f7fYlZ/r2R5lyW3Kzq6zV6F2nZWlKt6nM1B2WQ/M5CSrStQr4AOmtMrTpBEkmpxah7TzTSFhxIBhnNOPd182cIgcUXRXsDQfoNHZwqu5ttPT+gnq1L1lWPWfsSmz9iFH2EHEBM9RNbxHF3uDzCQTEQgEhORID9FQQHRm9EBQHocNWkLRRsFKX0rxymg564DFHb5NpP98TXHAxnY83xP6+u5tKx2ysVqJO/mP/T/0Fv1W19ljFxVygBDToGdOVIYlVZSbFSrDPt4DNJNyj0G35fdb5TRcoWwy5yJ+Q3VwWOYgznhNSUMzM+3d3e/Trfun9e357+9/9v5U//8mm7bb6dSdEJNqvVK3zURirR3ZVWpgnGZyJQDdQkFggyM1TRGIxtRAFBoUjTOwZxbUMy6nXmXXY+LEIczskl0svOQPbeeiqhqZQj/+5Rk6IwCYBPFEzoxYFwMOGFthZJKWE8SLWDK0R6J4umdDLCHKnnl9/9/6v///tr///p//fX37qnb6FYliqiXoVGXkdEPR9CqlbHDmdkGyBLIFJLxxuAmAACArKpJpKoBjqPfodoKS9eL6sOiYgfhBsaEoMY5WNRR3J1LhSa9GnGMH/tuen0dX61To2c6m/0XtjLJy0qmKFioXCQeEYneSARMoMAUTRA/RUWEhzKyMJCBHQSgGNZmAUB0MZtTLTVXq2CsQOxAAnl1OKr3MUCrVr19OiDvNETK84fPOJv9mSlhNxynTdOdo6UVMsuqxOXnHmWlxhwqk2ICZlld9WwlV0ghoKAZ+ZmQ0wLgxIgYaaDxzq7nY09JANeZS8yAMw5IHRYx9LnTY7B9MUEbQQMLPyor1Yn7f6/++dNE/p/6dP/9f3ullTedaf50k0PQu8hTPZnRURa3FVQjEe51EGAAAgSZA/IsQF8wRKapLmu4DgkGToC/HOkU/Hn4l1CuQUT/+5Rk9QjC4mDEM0YUol2sWHJtIpRKlGUQTSSwgWOJ4g2dMKgCQEp3WZy70tNhz6h58c837+++v6rfY/WnzGzuyfPQW0IYqtLyjSRgTimTCgUhssGWMBhQO2SVi1A1BgUxxeMt2OIIXDmYHnZucEAxeydEaxekQNkT6OLRIRaqQQ7nOt06Gxu9aIhT/Z39VxfVdVtNu459ouQFDrHKMjxVTRORIDGvMmASLERPEShUTPbqFU0nFABZK11UhYJMBcycQi3c68qZG+c8DH4aGReTIL2V8zY6YTuwWsiJWX5hm7rb3b12/2P7aNNNBp9zPeKqosMJfiiiI8LmwcBNrAeBpSZAChsjilIYUamarPdK25kzZSHI4zT9sqiGjUEo6qRxvRH5P8EAlvF/KXsFyxIGhYnFEKd6v+j/d/QL11ZypTnBivSt4FY4uowkaLuRIjRpBQe3MMuGhRIgASOUh0h0giQkRdSpGJW0ZniQyZRjK4BkAAYIvVdZC5Yh/LpQXUj/+5Rk7wyTBGPDC0wsIFNCeHlnZiwLIFEOTWUnAUcKIhmNsOCdt//////7vfHjsWYQUIWXCcIQkMeGhOKwgRDASDxQPHx6BIBVl4iRgKGa1UcUuTFJWuQxSUI/wqapX/UPERVn7Sy1gfbTollumcvBIGkSy4iJYqEAVf9V/+vWyt/k7/+nq/3b/+mj+j6/dX62ZER1RazMp1Vn46RnM1jJ0wJXLjAcSAkAKYE0DkteYM7DrXEbQp/CcLqzlBKaBXQODslBpcfAvNF7VIYacJBQQQaZmYD/t1+3/7f+7N9/T9/5/2/1/5NP7siNMlLa1M5+5LId0SjxMQcimd3HqePVbSQmICKhCHF5uRKaYmkQWikBhgkdw6mn260sfaKl4QAKXxjEAPmVeKQzqznVxgui3X5Zzoe0ef/+5CIbka3neeVf/GXrWl97c5/KJCMnRljMz7y6PTARxI0pnEZbq0BbS0YIcETkJycmGcFkAEAIBVFesuejC23EkRBaLW2Kex3/+5Rk7YzCkhPDk1lJYE5ieHBnaTgMIV0MTSRSSWivYYkNFHmSLCtLlpUnDuRpMfyXagjFvMzvVQt67//////R9qlc8ruskj1I5TQkHjIcOPC9qEgLAExERwZM1Cx9PMvmi4i8wEGBbNHqZqL+3mjtqXWgVGQxu8MtEluM2ebKlhmU37Mjr4Y2+4yvvf/W84FF77H4/VYNTyNtGM9Uz/ykfGVQoamIwBeLY0Vl18zNkKNMsKxBSZCrmopDjR8vOtQ5DhnxIWiFEAiYCJNvAtAY6ynEPMtCsLT871aMySTPwv4kFbMJz6PepHhVGO5B+Ves9f//////796b7tCvc1qUJTS+bJiAdlRiAE1VAbuJSjSc6xAxM1yWjv0IJ40ugSf5yGky39fYQNk6TUaHoN8uNHPGzIlEwfXaB0/JL1xQz9GqmvH5/b6WWueLV6DARUUSxJBbQEXBw1EoTFFhMSjHYB+14tPAzcQL3FqNYIJJEbYta3MZuuwpiQiJMJdi7ln/+5Rk7YzTYGDCi2EeYkKiiIEHKQ4OtY8ITYR5QP2J4kgcsDjlW1nYr6xzs5d3r/////0/31on9l0syUkfmUfa/jlkq7f3XYn2sFWssKgGPKtOU8XulKngGPR6/FO7eeUI4rUk4siXY6XJHT1Ka/Zh0TIRDR5A06f1X9U/+vv//9f//7//f/63fy/6eSFPt/eHKUT3OnGOyteMWQ8XQxlmpAymdjTjJQwYacsddghgx5PjVWxqXPSx5lpgpaDjsAJluBQx0NYMed/2j8JGyW2jrpevpY7/2Im3z//cO9anBwJvIvHiywwegQ2GhwUAYufCAnI1ACKtAUOSfzVTu8AfxMI6LdzA8KZpbNYUktHQIlFhYROEpGSBReDpIB7KYvnEZufyPx67PX0ShPR7G3V1bBZSFwEt26tmLGoACyRQmkLHXJTEAWZ/gPzkAKsVOg97qtzSwJMo1jvUPPk00oK4pIxK0YDNMJx8eMmdk2Y1JtQ51f3Dq+hWhOLa9fZlvXr/+5Rk6YjCuRHEM0xMAETKyIFoAshKxX0MLRR1yVGJocmNsOAti5cdeqmulJrH0MNCZYQMuOghORxVYvcIHc0Jxd9sIKLxyuHp964blsAxlrpMCo8CxWLJgFVCBG+hsri084vQnMMgGX379O/obq2S6+v+ZCyU6UT12Vcjfmf222Qqse2+dHaYk5rtEmMdmclTw6hGG8o5COMRzlItijnBxMKv6BvNMgabOOozl0g3DLsg2eRm3ymqS29bOZ4vWYIWRj45FM+GOyAhDAwzWEg/+366fei+/0/11Wr/9LvezJ+XV/3p1p/2dKKzI9XKtGQxuHdStRlZVVigk0K4hVeYCaxj6OJq4hDQZ5KVPjHoShUczNxGTIdVyvGKy1SmmLXNrFgabbkvKJ/5vas39rJ///26dU70tZOn+n2/r9luivR3YfTZxVV7mXXvFtxfTAqM8uAgbkAz4VQBkjSDRDCpFgUpQoXH11JuxEn1mXhYkMBgjciCHbJ7ISEsWQBcLV3/+5Rk9AiClBRDsy9MAEsieIJjSSoNdY8ILbCwgXEvYdmdCLHM/Xr//d/yL6tRtW8olesfdOBww9TCCSFSg+QBkEXHAmFXzdRo4QNOpDM/XY6NAUVwL6QivYyuJy8uQ2YmJGMRjQB55icu2r27tQPOwgdYIZqf1//f///0///v9dfm0vTZvVfbOfhlachDxTudL8G+HBqbrbVANaFNsNQFUIdHHuOSTgYrEzxoZKZqsqkRIIEppbhKI9KG7KowUYMACxcCPxO1uYc+C5Zy9jzAGrf+3+///////tr/z9uxq21+haZV7Feb5las7S90lHcqomUg7hIxGiWUH1RsMfKoFYU4Ko1RIeBqmLxmFyF+KR6Mo3YJQybkBGbsl3Q1A2vBmUR4zDVIU5xyvL7X+vf7p231XrqZ//vt/+/U7b6kStWardxBXRDvIxTi8c5JKMPpothiGR7IVAsguWKsOIRXMKgwMoBrBKQvGfDRyBLPYqoYkWEDP/XoprJs7ZGMgi//+5Rk7wySo1LDk0YUIk/CGHZjRhwLwY8KDRR1wV+wYUGhDvkT6h6duY519bjFn/t5/LfZ6/P+X5f/9//p/r96/jM7z7rmpERHlxUiIYkjQiXNpEKKbsW0YRkuMEMINIHagyHLSkSEy5B7WxNSApQmGQrHvthUpdlxTJQVCj5DjdT1yIfeSPchRH/b/9//Z20/Wv/6r+3r1/TT9H2T8l9ne6t3uqlRHZX1ZQ1rEQFOxR5OPN2FIxpEDmknICNtwWZ/IcZgFYurqlsU0pWBo58wGicO0A2kPdGhqORzonFfdRXn/Nf7ulD+78pXDk3Nyq2XhJIBe0u2VvcGgdGiwlWESAkeCGCnGyAQCV7SEUwte7OPewgmpfod2bL8LajAByi0C5pVN8th3IFAdBHrSxF30Cmm8q+qbYaASmPXo9njayYzevF06iY2UYY4nQsEk3vAEHVAGRYCWFEFAMpalEGukksXlN+zblK8HjiZi0FHwBwPLtsxZfdZ0sejrCLVK/r/+5Rk8AyDNWLCi0ksIlbL2GJkI75K2X0OTRhQiTsJ4h2MmRi2Uct00UzhRSlfe7MNJaqKb1gglVhUThwH1h8JrEiDQcJExAlVQdgphIAgRIbs1fEIDD4BxYxIqZ9a7cELjIYQju2Js9JUxpcbjvjynlYwaV/9va/3Z+23/7+n+ZdkT+del/fkRWVGSvLO35vR/o1+/29p5mvncwixkcqRerPLku72KSyehpUEFoAAAnj9EISahpUgDhdzfxsRWi0ci3vC/L3EbKmkG1lHNNn+nR0IZTLouv/r/9P1/9r/ujfv/98tbeqL0z96VMtKrd9ze+jV2vQZb2lPaMHJBSkGhgxuAAAIjpAq+Q2r2YSZaLJWjLFQ5ldX16m3hyf1MI1HBtcWvUuvK7jYInC32cU/W/VYo73C+9Z/Tt7iu+39S9VyjZNCosKMQPKuLH2mDJQMFZKdDYqPII9wH6U6SxNWABPsUeuWAwkWii1NXzia62tOWtETXjBKqIdOSZEMscL/+5Rk7IACag/EuDhIcFICOHYHKQ4M2YkILRTV2VcuYaGUihG/dW6t+r3d8mlur7H/JjK700tUl4hQ9tBc1RInGHA6ITAaEAUE4GICSb8ypKENDA4Kxd9QBQ0Ewx6JL6GvfquC77dQLSDAROMI0GVuTIK7AEEx/tO/ZX9TzfF9nalL0K+RS6MkIooY0XjhEEEhdDBQ0OLlCANmAGLmCQODRAYGk5CQB2o+ynj1U0Fh++txpbbU/L1qC4w/8HmInB3oQmptKypyqDcXu4TY1N+1O+h9Tv6v7//sqqQLulmng4dtYymKsQ0KY8IAgsN1AAYlKSNIDWZIkm2YWAE1iVMAFdSayjlNP8EQQ6D8iEwiQAcltHNV8VkPettbNpuPjUaXClAoihS5Orp/pU8bopqQVIMff9O0mulJNiHsQyJEQoRG4gBeElPLgLSUNYmQsISpRTFmvOrfjEUJMw8efcaChkoGx6yDc+8h7WbteD1yHHGEmb3s69P6Brf3tuUPxDn/+5Rk7ImCpxPDyywcEE+B+HJnRlQK3EUOzOknASyJ4h2NJOAYhWaKqHJaVWNMDCVig2NQ5qSGIj+A5UAhALZIlQv1MW5YypQyTuGYWVlExA0X7TgyixhgBDFFh8RGhq/XbTfVV1/1/0/09qKrbs1T5+vT1cryZ0mpXP6cuZFr9IyMO4l1hC6pO5ORAgS0QghmoIESeKQyE0mMGciU3G0SK9+A6qVTM+ypmzfFFDu7PwxCYMlJhYwKMCc5KE/rxkzUNQYaXB6ldvca4X+lEulKCYC1XVvHdC47ShBisUx1MSKKBVEst7XAcJDj7SBxBJUAAAl75DWbWCnZ5ACHTEsRNC1coWTncb92zIIfGFIsJBaF4YJosgsEyp4OP96nZDaN9SVSJRjskhqt791Owbv1aV20DeAyBBjSxE8YCpEBuDsDOJULIAmqm/YOzgQtFnATkL+CZC7nzOCnSZM1UEiR8oOMhnIRwENYIrKF/v9M1Lv//637J2rmZPpr/6f1723/+5Rk9wgCkxPE0xlJwEjhaIMHGggNvY8GLZRzwVCJohwdJDgq/RL/mpketpmau1X5mg0Rkd0KoUppIKUYEC7oYMCYsBlTPjV6L+LymItlbRzMPlTwspaU0owAJ+8IBsZTeOt05joqTBU+3Lp1p9n3/7f2/tXy/tv9idEt2rS2pfsDgw6nTpkRSmaVhcjz/IQcqGAEqBE8I+OAL9oQhA7ZIQlA42IwJkJSKBBI1FMXFZ7VXkENEZTGzCVsFQMutT1/nL1u/O56u/wyDf9fnzl/y7/z/6/35b3vS6xDVuQJXpqhZyLiCzKrg0HYhKHtA4McoWLAhS1KZfTBuMFyKgFpORogcrECijQOuWhe+AmsoykbIrH1aGToqogTYXY0hJ01I7irWZW1BC78/42R3KzzVrUnLaFoa9z+q4WQl9K37bHXh+Wh5AsoEVp1oB9MNCygCBBKsjRAkgW3I37LY1ZIn2rKPw0l/P6eleGcET7VgZUeEpOhYi6BrHDEK3EdaNP/+5Rk9gjClg9ESxpJUFZL2HMHQg5MCY8ILQh1wX+woQWwjvFJPIfoVst7N6G+jUxghH1UN3yY8uZHqGBU84JAAwkhLcNNAdAVydx6HvJbSeWtHc4hEWG6TWOKgp2tWbVyctYY5znP//aAv0RsiMvzy+///5v/+ROaOcGidfMliGdJEMjJNzMEoH9qoODQzC6GrZGS2mRJuoOHQYgZgijiqsKo6TLZmIpBUpUUWfgxYsfg0UZkONZZqlTFxl23GB5dXwpce1I6AVCnqjf/////Tt/r7L/0f/Ry4eVaKiw0spdSdI/OPkv9L8SlE9jFwcBJqQpIYAOdEkKcjA8ZmDsSVR/0CCZ8PFENIBXjr7JglQ0px3Nf2wzqExohKW0jmjrhhM/q319l+nb6mtrX172Ikpns3//zOn/v6UrTrRedl+2fQ7yISV8zOytRhJDxp31EBg7ohWO6adgDScMr7ZfGBI9Tx3PWbzvTEB3QGBnTpruOuZ7q2u55d2Ea/+f5eqL/+5Rk7wgClBREOw9KoEnBWJoHGQIMWYUITIR3iXyw4QGhDrH/n//Nr79+a88AdovyhRNfbmZ+Yenk3Q6qZb4Efkgh7mo4ZlSEArkVUEjCUznRUbQAtsCuzHeARDfvQ5IVRK6rW+YUzCXrutaXOjPlbIRowECun+RQu7Nqa/cm1KHtd3t1+hFKLXjJbU950yi28KMEj3EQWHDQgw840N8GXC0B8EoIMYZL8iMhUdyU1rsobpbkAKODoJ+Dr+eOH7piwkI0v/Xs//8v/zl1P/+WuufS8CnXPy0ff8jLPJEctLkOkMjxqY0M0LIgpvli1LNUqgAguOIAfoqIQ0MZwkTUaaCxyo9Gkxt1ewxXYaDfVaKV2Y58An3FjO9jKxGLrF6E11Xqk0XJaz2UOe7GvnHrThFIenJgc0vACg2hhwhSCSi7oZHmDJ4auO4BjZxC6DTyy5agy1HwtulvYSuQupOlQAERq+r+HO/lK7/7w7yBf785+nzL85bP9b/y37Nuf/D/+5RE7YzCglvDkFkQclwMOEFoI7xJcEcQYORBwVGv4UWQjrnOCfAKRyiCfEd/IOixRsZ1U1cQJ0OIW5A4sGNwox8IUPGjJEiBv0OTNAYQEXppeyZI8OPSV7tWVwmUxcKQw42QK7flXRi4GHFPLjWd8ERrWSZpP2RjS3uUgV3M3otd+6LKoAghSBjziioJFlqueLFVjMayOhMyBWYLhX9Z4kiIZYdZtWd5QXDTtQcQDEfoRc/+7w+lYpCkH//9////////7/53SsyfLy826Z/f/cqUJ+mZKUqnAdSTFSadJFtIZyZmqsMEZg44YNGMNlJMZsPIV25fWvTMRZK6LGjDDzegHVi0p32lxwjMW3jhzqIK/r9+//7P/+uze6+zU9lXd6EVa16ostmRkT51eQjj7O4Oh7MzBa07VnrauVt5Eo4yWKwCY5ZtwGIOsompbd9cSEmML/Vody/MRMhehDKKrG5NIhCFZb6NlE2f7m77iWVbAc81z/+roRu/67lo+xf/+5Rk9QjSoQ9DuxkyoFpsWFFoI77KED8Q7GkqgUEwoUGgjrnfF7d7L9rL2jRqQDvysaoGTDJJbVpLHHWI+mzyWpLYBZWvBwk0hYsNt6g9taWbc9GVv2deir5G0v7eRN/v2//rSmv2/zbV0ZDIzdpKq2LVFQ5qODIxyWBNCpcE+YJBB+UTRl2/oCqcDAzKhIGxCZLoBfSpCQ3dxyacukU2IJSo4pnS7v/T4U1nmeOXMX///L/7//zX85eeisg5BPRZ1oPDCQmtpxt23qPe9nrMKz5DSW/9Zmf7jSc/dZz3EiFIaoxVEoABAT/QP4z8mJAwoOZgeDX2XmTlY4fnH1VItLUdyhPK3r+95q5W/e+Zv/xcl13WdF/y/9Jxfl9en/y/lyM6OqkiyFpFBIjr8zScU0NIV+Itru6Y4oGQA3UKo4WLBQGtGRwYGDRxmJKH9puVo4h80p+ixSWvQzmeWuZarc/G7zdf/l5/v5ev//85+uXLFlAcv22s4E9PmbklsvL/+5Rk+wwDLWNBg0I18j0iCMoHEAgLWW8KTJhQiXoxoMGgmvEcT2Q1y6qhTIx3QxDPubNFUnQEBsEEEEqAZXSqeBhTvGM3B7H/XoiGN5Tt6vdd19mmSsOAFzorVim4opQICsliMf9divRvf/6fv/X3PZUS3/9KeH3mqdYqus87tuhktKmKoWqDoKUOpG6AgmCZA4JC8mpKQoDD9Eg4tMIDGlDpAPuFUjDwVIdJGHQc8QLK+UWWGcaZdKXlMNl1SPet5/z79v+fn5n/Bhakf0WfrrrP80vyv/+Rn7kcpUQtVXktmdOZIEhEbEQ2R5CYtrTppZnXRKYoY8TVTEFNRQhACvVISKFIckELuhpfBMselSOvalE4revx/AuOFtdJqxljWxzlVn+5c0QT+cpXXl/WVLL/785+zY/qWFqTvCvzPWdwxdKQqzNBJML1xsyhDtXHhI4Uw5BmQJAQgYSHguiA9AxYsjEIFGlGGlbm0BI9kYCJOeZ+fyRCd3vPymYL0ur/+5Rk+wDComHDyyEd8lxsaEJoI7wM3Y0GTJRzyV6xIUmAjvhxqTc+IKHbNP6vfWHD/6Pptt+2Tzm3/czr6qU6lG888BERkrZGiCNJ2IOOWofp3YZGZUks9d5HbblWRQRGobVAzAwZBRADHtjFQlSdDPafM1GFagFj32kKVlgnNHh1gokYsUEAtxc1VeK3i47EiGtWLsMiW8QBCIljZAtQ6Hbd23GE+Wep42sfwzkFPC1oEzyAzLtOLBUK3+yjmk61G6a3od5qFNzIUZajbbGWdu/Z1Cwhs6kFWPc1igqkDtVF2NmSFA41GIMUtGIIY8wmt8kMWruEIqyLUVv28s/vfMg+zP5rUuJ/WVrl/XmbMykydf5Vf7nn5J+ul/wZ3pvO58rvPKQ+iPmOAkVjxWnBycGJoukoZwgsHREgzKB3jGSIc+yy47ZmsiQC6SYKrP1e0sJadcLhwJ3Kmwxsc/weqsjDGfromdaX/bQrvRFsdO+RE0Ps7ulF6MymG7fkVHf/+5Rk7wADUmNBk0Ed0jdB+LcF4w4KvD0RQORBwQwH4lwMFDhV8u6b9vSD96IbuTDz3LUx0nvmXEPMbZWtzTYfaRpdiNZI8GNslIcwB+0C2QF3xwe97dHIC8ciwb3vHCBqkEEEZLilt4c5jvVtXLv/nX9Tkbvr+eX0Dy/5df9N/I59kJ3/Gvp/7vv5lTMxPJLGciz61yMr5ytVpEJgXSBzUBoRgsR+Z9xJaoY1OjwxpsKe4xIGFCVnJzeXcseW7X9/+z/83uUjNZ+ULw5f5z2Ti/ZylUw5fcXe8ZGJpGssC84zQLFy6cOnSLAzrDGLBssKSF3xM9UATf8hltTuLPIQESqJKsEfZSBO1tnAPI6pj4RRlV+8PFJkFXChqjcrbdXzeVi0jooZwS7EMFiQHeqH33vKChtcOxBfS606KMHCFgMNLCc0GDDP0Sjlujnbo9P0uJlzDIVcwnIAlF0vMEFg/F85nDmG6nYjlzlj/o7z/9fnsZfn7/rL7+LPS+NlnmT/+5RE/4zC9WJCk0EdYmqMeDJkRq4KUY8MTQR1wWIxYUmQjvlDBMCDCyGNqNbNxu1vuY/46E0bOTnYcjH64MKrmGfSOi8bqyVlokTCfW4/QAY1srfRfQHt6+zXRTUpMn7m/uNEoZhW0oFAi2pkLZm6fp9/X/9V/9vfr//9L9Ju7S2dfs6LuvmfnWrO19CFoh3rb5DFKhBAaiMjIGMOD+QN6SnpRaBUsnrNoOhjzlffPr14EiojlIiJdY1zf83WUiHRL/+O7y93n7r/I785/l/zg/5n8qUjXyXeSVyK859IjJ0UqZ9JkSs6Usqb3LDhiBLI1sqhUoxREBgr3OgngItZGYl2VypJHoVLFC0ZFNg/DdrVTD7jl5//r////l///T/Kee8fcwgRsvyU0qMfEPmUrpDtQ4t2GMU2KWChAkKewwkBFBCHEAwEcIAigCGAg0dbGiMOKd7SLaQ6z6QCn6TJsZ75TuDH4OCyYrDbYtwZynjPcSN0oOnhaD6EC0zekaP/+5RE8wjCjAxDsynCkGJseCBkJrwJ5YcMQORByU+xYYmQjrmU7oWwupKApP8gyLmUTe6ppQVBp5ZcxcVehFiCRS0UYEnc3BS7MGbFR0olBfkUjkXWk7UmsnhkDviiceISy7rmtYZ7KcNJffl3z/f/9/+8WWv+Ymb3f8y0pc2+fw519vPft86mi/Op9stszOb0CvJbM9VGklUYOqTJMwoO7LBZg5EZbHoefsLpGoyDmq0zCF9rqgVRmhpMs8d75kM5TN37dd/9v1v9v7/+///+1+ikYOS6dTK5GO2/Xb/M7Z71sqMzJamz7Bdvk4zq9syzWNt0b6gKoSMlagAicoGOa2Q5bPFdwlp0OlQodXlTLL4aq0xfxqFDjj9Oh2XL//PXc4ET9Z3y/X3Pjl5/fkS+bTizItTOlS9y3+rKkY6NQRCzuwhRJ0NkalDh3xAJmDHRIajDoJP2ncgeZXhKK9sBOvGR7V+LfLnvqy6Njiqwty5Uzzz5vgy76N/p////7///+5RE9Y0C2mLBg0EdclNh6JpgJoALVY8ITQTVwXExoQWBGrn/q/6ddt2pckvKrVkmV7vk4zNL7rS3ufZutVZMxlJHdsfTFTCOzCeToEcYMno8nlxTtIMuwtGB5IwwEFjMKt8xoGAO69hKRCiU3t5b/mqosgbX////////56/5fORSJgUBZax0iz3yPw8dzBVhB6gtn1F2yZ2vEiPY5qVB8o8EQABB1t6bFDwNpJhGzwtYaB0DZBS27daYjUrBBiLdzHetfjnkq5v////////+5/L54/NXxwSMz+AHw2O/jK35r1m00Fslhk5KbY2pc6XLm+O50xLRmsV09z04N9lokuEFohR6QM+CrYQxbx3uONvBj5EoQ+pVzwxv7/9jec2n71ZUC9GcL6o3aOsz/kWY5/qss7m5m7RmzLcUXOf40+vW1b/YfcTi93sTQbyzqGyY6NGsmczVRxfN3C1IkawAEECNtADW4800KuTG1ZgVVdf/W3CA4bWIROIEp0uzcjv/+5Rk8Ijy1mHCMwEc8ljsODBkRq5KjY0IDAR1yVKw4QGQmrlyjPFMxuq9VNX7H/+FHI1UKGjokQZAqoqeEp5UQCM3ya27I2AMeQbYRgg7pEgELBkq7K1D2s/wasYVkbhHQ7eSExBVvSQTt1fkLS14mS8h/pXey9l1LEtizd4YkVLOLpCgQvID+Q2VgHQ+WV5C10iAkWanq3K2p+GLQwcRYWL3dsjwzrEv/nl///L/9/f8sss3rCLL+3/32Nz2Q6V08zaKbEJyaE73YNnjiwa0YQtuqKzKDGCtgw4YYJEKEAIEpyREDeEACyjClRiRt0ZCIISaHnM9R5fTmPcOulABPM0uKEHCPyYzzvrtJJldGxF1/vFpuhm3UIzq1yLVMb1T2jdY6hxGTnlmVSQ4NtT6U9k7nwsjPaMryWc1epAawvZy1HKiXHaoD3TEpABoLUliIHe1W9OoGeeCriAlq79KYYVLZT+JoXmuHFgzcx2pKvfVUhizpWZL3tgSuha0NVf/+5Rk8AgDFGPBiyE1dEGhWIpg2FIITC0S58XkwV+xoQWQjngK0oatjUr991aMWTsa8gMJhoWCIHY8uBSuPXqUmMLBcaTUbviOMiVqW/oMq7OKYLDiw8C7/fM9V9GQam3/P6l/6l//zgL8+9k8qoj/PsNQWphuE8MsoU4bR6ZQIY/WfI6ISI4UICNKc3MNmw70OHAAj1SEMPQQsdq7aThB+Jb+HMkqBFKiPFrv4R5pTOYcHQhMHKdvb/X8uh+Qj/9//////wS7z/zyCMEi5kRUSMSRkAzJv5Xa4pszq739M8XKS3hE06S77Rue6yT0DlQPvUTiFaU03QpkDL+O+BtjB5vrHAv0WXapb+68AwxAiUseoiPpfxf5EvOv8//zryqnMzdNK/z/r3fdc89cnSszMe5UbRWapiFUznMtSuibGV3u5SmZDqHB4RnFzpRtogFwNcDyN+a5PAogR2c2w/eP52TDY7fQw2cqkuha0pptXc1zOoZSCwGV1Riw9elbRqH/+5Rk/oADZWNC0xkZUE0BaIph+CgL2Y0GDIR1iXEw4MGQmrnIoUw4MpMrUOLnSw1AROizHgZBcaWULEodBIgIG818KXhQYYQhPvo3g5ZHk2r0/em4Yd+XKaiRyzq9+Gsc7ucOT/r/f/ef/8/z/f/3JmWaMoLqMSzJCYrrnoMZpsvDItDQY+T3p6aw3imUPq97G5sOzJyQvrm8TD1mOxsgZxpVBFlgnmcgJgVOzubjUTvTQ9q/a4dSA94PsdpxS2dSzSYS6xZWinrVpOkW7UIRfAGQWfkJrdsWKlRYzAwuJioHAZgVaNUIMKySy5zCJCF52G2EBeuHPuX9YvU+kbFCAhShw5+OPfq2tfzX4/13/znr41Ov2XNe6/hUyIzbaJGAJAJIiNE1MZNw9Z2xbulMFy1mz0ZKkb1xLtIqwMvJzrbssw0uLv0QosYdBGoAIAPvUP1JH6TnZnlSqtC8EmFS/fdVpinpnnFhvedw5/55nl0Rojnmf998uHXa5k7eUiD/+5RE8gyCn2PCkwEscE9BeHMF+AwLlYkGLQTVySsGIhzw4UB8ym/yPy13K/8hSyL83RYX+RHkzpO9kdKKhHuqEZK+tZ4IrAGOCE26kiB34MctOZQGjqwcMpLtuLKCbBPgRziFb53v3WtTRCRrv+7RLVd+SZ/W3XrU3OeYgng2KiwAAwcD5Q25TTgMgB/Z6ndRTTUNuqFMIsCp8sa01GHUsiqMiGX949odI6/Z//7/6V/0///v+t+ttXLPz/Ne5r0prz54I8+O5tVPJVmwJFJLeHhw0fpbLUygt7g1UjIMJUxBTUVVEDelGlLzaNFaJDlIQIuNL/XrauS2jlgUCG0c8MN/h3uV7mv58eCtSRrLL/8vX1/+Po3cpknqd09RmYU0Zkoz+cpvGef5bbj1koXJNfY/Cmg76zmrc9zi30H6JlDcRTBjAMmnowfgvtuAyDWUzh8QwAQ65Z2X6zj0Jfx+yGKpbX3Y2akMsn3X/0eD5dfH/8Yuej83nO+dbv4vd+3/+5Rk+oCDLmPBCyE14FhMKGloI65IHC0Q7CHogVex4QmhDnj9f/vtOcp7nvCHzr5bvg3Ofrx0EO3ty2hzGNVZvM6Pk2OSraTQuXFiUtCXJGiAWPP2DpBcMzarA4y1980smGF6tFhhJG0NK0tdeFTToSSmRFwJCy0BMXdcuyvxk4rLuFXFndConVprFxVjlCgwRBqGyRoeoqaihEXJLRksZAkNZwEgL7A8pJeE63++UVJaIFy8FASo2K+mZ1aI5JFh/tWLrurU11ikf6sZXnuhPVsQXGklCBbHw0FGHRYQDfGNvMAnTOAgaUOQQ/iwFLhbzqzNaMiAdZ1bD8cMsfrLo/f+1hJ6rv1+frXl1L/8zCf8yMmzxmQJGFaZ2mm8/HfS9nUG+w5ana9zPUw27URztZ14g8WOJJECmCC7tFxX41YJhtNLnGBMQiJ2+d1aYXgwNhQYMxsU37wy3W5vuf5f8/+quc2v7+Dl54IJfLyESczA6EejYPy2zZxDU/n0z7H/+5Rk+4iDG2RBCyE14GEsiCFoJp4J9C0O4OHgQP+FYlwWYBBxMOdaS1Wz+zs5ypxcmajL2omcK55xEDacZQAw9Rtj4mEAolPSBWARXkUssubpZmcmKODnmlH/tNM81lny/Rv9a7///y/nXXNLVmpOT/z/LZS9q1LrnfohVNXevsgSrEU1Bhu+BCHCiQxLVHogKEUdxARxVHh7ClCzdDLJQJGVpCkhWDLrvL1V/J687SA2/dxx/+aum6Zye/5n685FOtZf/9oeXyy6vTfx/8Tx8r9VBrTFwnLXK2hGnHUVtJMFpKlIkDBziljpFMcZweooEZawOYbIekg1jBLXjiIMKdt+xhlMC1f/OtELEJgGIVNd13ffzFd6+1/tr3/383/+//dH/J6UZ0psXI7m8EWYrn7LyNrWKbG9R9mLZ9P73Mnztu+8gyRCtjqEaHNJ6TY1xKAALIB/Wy2AMCm7F7DiiupMpP5483lFH6Z53+81PNZuX/zP1/5n/nz73Lq+/57/+5RE/4zS5mLBkyE1cF8MWCFoJq5LYY0GTIRzwX+xYMWQorEF/+R3z+/pbTkfy71oFpIv5q9R7k4dUr1zClDM2BPQjMYIGHeC6CFFLvJldxnthah+ppu0oQoncu37V/uKHdoN/lfmLZStmv8/8zXU/z//y5/lmeU3D4eEu5f1bmzAyheUI5oRMa5UFeIY0ORdQghwgQabwIodw7uUuTWChtwOK/VetDcBPhkhGJIrwAVSZLPZ6/cbhl2Bgovy9hvwqze+f/y/1/+vnL1rMfpHVcxT863qunji/m5uofHKOqqiuyaidUSqIqUsgs4YeehdBxUl0IxVjxBWyKl5ewjJehDvCY2AIccZIGO5uLjgkAdFNYOwTI2y3cYegXcZ71Ua3J3FAES9+7YtTFatVvb++YRyrGqh+SsH54mg3UYNlg+5RCbUHEgOABQd+DVfiViAuEWFwjGKkeZ7rzl2XRQkQVZSaz5na/r/8+///8l//y93/0I7//vmXr2zLK5mnMP/+5Rk8g1C0mDBiyI1clWsaEZkI54LAY0GLIRzyYSx4IGgoniq7HuRq2xCrRscydAcAzjoEJAw40FuaCyAWBEYUdcoAVuNVboMHjzrZ4MhaSg+5/e4172V0QFjSfM8Nciak4rGCNq//XB1+f+v5H/WzzX8uGdh/T/rf+v0rGLg1LPM3Jvg5skfYRdBQSAmiOarQoVGBipTASgsfkA5qOqcgp9PGLU3BimP5fztBI6KJDjyLFrD/83+zlwjVJg6OM9Vy/Ly9vkcvWa+Xs/bMrFmvD3Uv/2UGUwZT30Lifk7hW0Z1UjFswmwzI0tGJscI6jKISreTRUmzAQM9htLTZioqToXv3nYlD95KbJ1TfNe5CLAP2fPf0v/+f1//P137vXy7nqp+WmOIfaa51HPwYly0fFZhOkGxLG25yGDbFlq2ZxitY1A4qbRixxR4T1JvebY0+E800qJfUSEcBPDb/lPyIX28EAZR9vtvhkYxL1fn/9f////88/7+dmH9W5x+sT/+5Rk64TCFgrEOwF6gFWsSEVkI55LDYcITIRzyWIx4QmQjniP/DFmXUHhpXgYKiwj0jItaDYoKCJwwYeA8MCCDGJuOoIQJFQEHjhJiW1NwKgKQTnbpNVZyKIIqeEtci87LqvPjrDXFvdx/v/r9eT//////////8X/O/34YjQv//nbVV62e+zRaNdv5k3Nlkv54MsiVZJ2XPNImgx6LJVuEpwRk5xtEkjOFydK6U44SZKtPgOpWFyUrA5KVwmCTAGQasapCi+pBXrShYhskHhSRHScOBoQjCMWFSqaA+hRJoD6EhSXc0qk25kNUMSzoQpY4x2EatYayUjWUjakatczs/X6ssMtcmvSZausPNb1Z7MvsZNtBRrR1vBf8Fl4/xpo2gYAPVqmZh3Zqv0o3AwpxomhWHeCsQjJYtDR7Oz09UeaGmZLiY9UBT1bvBXDXLaLg7lpUq79eJRnBoGZcjQTIU2QmlCpBRpZLpk6gKKER4ApYROtLHiXKhLWJYoV9Wv/+5RE9I8C3GLBgyFE8lsMeDBkI54KgY8CDATVwgApIWj0jpl1oLeWDtoUPes6hly6zueDsS8io9hriUNB3GPDCgoloBCgoCpRstUAnAQHUSTcAmVGcv2VV/9aWqqu212q5xjVZI4mG8LIwk8L0T/zXdc6WGAln0Kv8/jUBpZGq6nVUmNf89VL2oCVJjqk2qiS//YwrDQXEBQxI1VUaWqnglaJ0ZnIUsbjOFEozLLDhrJUFUmZpqv9Vv9mjF7HV2XZv9s/2Paeaw1JVh3NZ3alqp89m2L6vxi1jBjFS8S7FguQVjiwFeb/8O/5ZkxBTUUzLjEwMKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqr/+5Rk3QDBygs8yCEYED0hV4IEJgwLEY7GIYR+QVyl2chTDDGqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqo=";
  function clamp01(v) {
    return Math.max(0, Math.min(1, v));
  }
  function looksLikeDataURL(s) {
    return /^data:audio\/[a-z0-9.+-]+;base64,/i.test(s.trim());
  }
  function toDataUrl(dataOrBase64, mime = "audio/mpeg") {
    const s = (dataOrBase64 || "").trim();
    if (!s) return "";
    if (looksLikeDataURL(s)) return s;
    return `data:${mime};base64,${s}`;
  }
  var LS_SETTINGS_KEY = "qws:alerts:audio:settings:v1";
  var LS_LIBRARY_KEY = "qws:alerts:audio:library:v1";
  var AudioNotifier = class {
    constructor(opts) {
      // ===== Core state
      __publicField(this, "enabled", true);
      __publicField(this, "volume", 0.7);
      __publicField(this, "minPlayGapMs", 1200);
      __publicField(this, "lastPlayTs", 0);
      // ===== Sound Library (name -> dataURL)
      __publicField(this, "library", /* @__PURE__ */ new Map());
      __publicField(this, "defaultSoundName", null);
      // Legacy fallback (pour compat)
      __publicField(this, "defaultSoundDataUrl", null);
      // Playback logic
      __publicField(this, "mode", "oneshot");
      __publicField(this, "stopConf", { mode: "manual" });
      __publicField(this, "loopIntervalMs", 1500);
      __publicField(this, "weatherMode", "oneshot");
      __publicField(this, "weatherStopConf", { mode: "manual" });
      __publicField(this, "weatherLoopIntervalMs", 1500);
      __publicField(this, "loops", /* @__PURE__ */ new Map());
      __publicField(this, "oneshotQueue", []);
      __publicField(this, "oneshotQueueTimer", null);
      __publicField(this, "oneshotProcessing", false);
      __publicField(this, "weatherVolume", 0.7);
      __publicField(this, "weatherDefaultSoundName", null);
      // Optional purchase checker (for stop: purchase)
      __publicField(this, "purchaseChecker");
      // WebAudio priming (optional)
      __publicField(this, "audioCtx", null);
      __publicField(this, "primed", false);
      __publicField(this, "builtinDefault", null);
      __publicField(this, "suppressPersist", 0);
      if (opts?.minPlayGapMs != null) this.minPlayGapMs = Math.max(0, opts.minPlayGapMs | 0);
      if (opts?.volume != null) this.volume = clamp01(opts.volume);
      this.suppressPersist++;
      try {
        if (EMBED_DEFAULT_MP3_BASE64 && EMBED_DEFAULT_MP3_BASE64.trim() && EMBED_DEFAULT_MP3_BASE64.indexOf("TODO:") === -1) {
          const dataUrl = toDataUrl(EMBED_DEFAULT_MP3_BASE64);
          this.registerSound("Default", dataUrl);
          this.defaultSoundName = "Default";
          this.builtinDefault = { name: "Default", dataUrl };
        }
        if (opts?.defaultSound) {
          const du = toDataUrl(opts.defaultSound);
          this.defaultSoundDataUrl = du;
          this.registerSound("LegacyDefault", du);
          this.defaultSoundName = "LegacyDefault";
        }
      } finally {
        this.suppressPersist--;
      }
      this.loadFromStorage();
      this.ensureBuiltinPresent();
      if (this.ensureDefaultSoundValidity()) this.persistSettings();
    }
    ensureBuiltinPresent() {
      if (this.builtinDefault && !this.library.has(this.builtinDefault.name)) {
        this.library.set(this.builtinDefault.name, this.builtinDefault.dataUrl);
      }
    }
    ensureDefaultSoundValidity() {
      let changed = false;
      const fallback = () => {
        if (this.builtinDefault && this.library.has(this.builtinDefault.name)) {
          return this.builtinDefault.name;
        }
        const first = this.library.keys().next();
        return first.done ? null : first.value;
      };
      const ensureName = (current, prefer) => {
        if (current && this.library.has(current)) return current;
        if (prefer && this.library.has(prefer)) return prefer;
        return fallback();
      };
      const nextShops = ensureName(this.defaultSoundName);
      if (nextShops !== this.defaultSoundName) {
        this.defaultSoundName = nextShops;
        changed = true;
      }
      const nextWeather = ensureName(this.weatherDefaultSoundName, nextShops);
      if (nextWeather !== this.weatherDefaultSoundName) {
        this.weatherDefaultSoundName = nextWeather;
        changed = true;
      }
      return changed;
    }
    persistSettings() {
      if (this.suppressPersist > 0) return;
      try {
        const payload = {
          enabled: this.enabled,
          volume: this.volume,
          minPlayGapMs: this.minPlayGapMs,
          mode: this.mode,
          stop: this.stopConf,
          loopIntervalMs: this.loopIntervalMs,
          defaultSoundName: this.defaultSoundName,
          contexts: {
            shops: {
              volume: this.volume,
              mode: this.mode,
              stop: this.stopConf,
              loopIntervalMs: this.loopIntervalMs,
              defaultSoundName: this.defaultSoundName
            },
            weather: {
              volume: this.weatherVolume,
              mode: this.weatherMode,
              stop: this.weatherStopConf,
              loopIntervalMs: this.weatherLoopIntervalMs,
              defaultSoundName: this.weatherDefaultSoundName
            }
          }
        };
        localStorage.setItem(LS_SETTINGS_KEY, JSON.stringify(payload));
      } catch {
      }
    }
    persistLibrary() {
      if (this.suppressPersist > 0) return;
      try {
        const entries = [];
        for (const [name, data] of this.library.entries()) {
          if (this.builtinDefault && name === this.builtinDefault.name) continue;
          entries.push({ name, data });
        }
        localStorage.setItem(LS_LIBRARY_KEY, JSON.stringify(entries));
      } catch {
      }
    }
    loadFromStorage() {
      this.suppressPersist++;
      try {
        try {
          const raw = localStorage.getItem(LS_LIBRARY_KEY);
          if (raw) {
            const parsed = JSON.parse(raw);
            if (Array.isArray(parsed)) {
              this.library.clear();
              this.ensureBuiltinPresent();
              for (const entry of parsed) {
                const name = String(entry && entry.name || "").trim();
                const data = String(entry && entry.data || "").trim();
                if (!name || !data) continue;
                if (this.builtinDefault && name === this.builtinDefault.name) continue;
                this.library.set(name, looksLikeDataURL(data) ? data : toDataUrl(data));
              }
            }
          }
        } catch {
        }
        try {
          const raw = localStorage.getItem(LS_SETTINGS_KEY);
          if (raw) {
            const parsed = JSON.parse(raw);
            if (parsed && typeof parsed === "object") {
              if (typeof parsed.enabled === "boolean") this.enabled = parsed.enabled;
              if (typeof parsed.minPlayGapMs === "number") this.minPlayGapMs = Math.max(0, parsed.minPlayGapMs | 0);
              if (typeof parsed.volume === "number") this.volume = clamp01(parsed.volume);
              if (parsed.mode === "loop" || parsed.mode === "oneshot") this.mode = parsed.mode;
              if (parsed.stop && typeof parsed.stop === "object") {
                const stopMode = parsed.stop.mode;
                if (stopMode === "purchase") {
                  this.stopConf = { mode: "purchase" };
                } else if (stopMode === "manual") {
                  this.stopConf = { mode: "manual" };
                } else if (stopMode === "repeat") {
                  this.stopConf = { mode: "manual" };
                }
              }
              if (typeof parsed.loopIntervalMs === "number") this.loopIntervalMs = Math.max(150, parsed.loopIntervalMs | 0);
              if (typeof parsed.defaultSoundName === "string") {
                const nm = parsed.defaultSoundName.trim();
                this.defaultSoundName = nm ? nm : null;
              }
              let weatherVolumeLoaded = false;
              let weatherModeLoaded = false;
              let weatherStopLoaded = false;
              let weatherLoopLoaded = false;
              let weatherDefaultLoaded = false;
              const applyContext = (ctx, conf) => {
                if (!conf || typeof conf !== "object") return;
                const applyVolume = (value) => {
                  if (typeof value !== "number") return;
                  const normalized = clamp01(value);
                  if (ctx === "weather") {
                    this.weatherVolume = normalized;
                    weatherVolumeLoaded = true;
                  } else this.volume = normalized;
                };
                const applyMode = (value) => {
                  if (value === "loop" || value === "oneshot") {
                    if (ctx === "weather") {
                      this.weatherMode = value;
                      weatherModeLoaded = true;
                    } else this.mode = value;
                  }
                };
                const applyStop = (value) => {
                  if (!value || typeof value !== "object") return;
                  const mode = value.mode;
                  if (mode === "purchase") {
                    if (ctx === "weather") {
                      this.weatherStopConf = { mode: "purchase" };
                      weatherStopLoaded = true;
                    } else this.stopConf = { mode: "purchase" };
                  } else if (mode === "manual") {
                    if (ctx === "weather") {
                      this.weatherStopConf = { mode: "manual" };
                      weatherStopLoaded = true;
                    } else this.stopConf = { mode: "manual" };
                  } else if (mode === "repeat") {
                    if (ctx === "weather") {
                      this.weatherStopConf = { mode: "manual" };
                      weatherStopLoaded = true;
                    } else {
                      this.stopConf = { mode: "manual" };
                    }
                  }
                };
                const applyLoop = (value) => {
                  if (typeof value !== "number" || !Number.isFinite(value)) return;
                  const normalized = Math.max(150, Math.floor(value));
                  if (ctx === "weather") {
                    this.weatherLoopIntervalMs = normalized;
                    weatherLoopLoaded = true;
                  } else this.loopIntervalMs = normalized;
                };
                const applyDefault = (value) => {
                  if (typeof value !== "string") return;
                  const nm = value.trim();
                  if (ctx === "weather") {
                    this.weatherDefaultSoundName = nm ? nm : null;
                    weatherDefaultLoaded = true;
                  } else this.defaultSoundName = nm ? nm : null;
                };
                applyVolume(conf.volume);
                applyMode(conf.mode);
                applyStop(conf.stop);
                applyLoop(conf.loopIntervalMs);
                applyDefault(conf.defaultSoundName);
              };
              if (parsed.contexts && typeof parsed.contexts === "object") {
                applyContext("shops", parsed.contexts.shops);
                applyContext("weather", parsed.contexts.weather);
              }
              if (!weatherVolumeLoaded) this.weatherVolume = this.volume;
              if (!weatherModeLoaded) this.weatherMode = this.mode;
              if (!weatherStopLoaded) {
                this.weatherStopConf = this.stopConf.mode === "purchase" ? { mode: "purchase" } : { mode: "manual" };
              }
              if (!weatherLoopLoaded) this.weatherLoopIntervalMs = this.loopIntervalMs;
              if (!weatherDefaultLoaded) this.weatherDefaultSoundName = this.defaultSoundName;
            }
          }
        } catch {
        }
      } finally {
        this.suppressPersist--;
      }
    }
    isProtectedSound(name) {
      return !!(this.builtinDefault && this.builtinDefault.name === name);
    }
    // =========================
    // Sound Library API
    // =========================
    /** Add or replace a sound in the registry by name. Accepts dataURL or bare base64. */
    registerSound(name, dataOrBase64, mime) {
      const safeName = String(name || "").trim();
      if (!safeName) return;
      const dataUrl = toDataUrl(dataOrBase64, mime || "audio/mpeg");
      this.library.set(safeName, dataUrl);
      const prevDefault = this.defaultSoundName;
      const prevWeatherDefault = this.weatherDefaultSoundName;
      if (!this.defaultSoundName) this.defaultSoundName = safeName;
      if (!this.weatherDefaultSoundName) this.weatherDefaultSoundName = safeName;
      this.ensureBuiltinPresent();
      this.persistLibrary();
      if (prevDefault !== this.defaultSoundName || prevWeatherDefault !== this.weatherDefaultSoundName) {
        this.persistSettings();
      }
    }
    unregisterSound(name) {
      if (this.isProtectedSound(name)) return;
      const existed = this.library.delete(name);
      if (!existed) return;
      const prevDefault = this.defaultSoundName;
      const prevWeatherDefault = this.weatherDefaultSoundName;
      if (prevDefault === name) this.defaultSoundName = null;
      if (prevWeatherDefault === name) this.weatherDefaultSoundName = null;
      const changed = prevDefault === name || prevWeatherDefault === name || this.ensureDefaultSoundValidity();
      this.persistLibrary();
      if (changed) this.persistSettings();
    }
    listSounds() {
      return Array.from(this.library.keys());
    }
    setDefaultSoundByName(name, context = "shops") {
      if (!this.library.has(name)) return;
      if (context === "weather") {
        if (this.weatherDefaultSoundName === name) return;
        this.weatherDefaultSoundName = name;
      } else {
        if (this.defaultSoundName === name) return;
        this.defaultSoundName = name;
      }
      this.persistSettings();
    }
    resetLibrary(entries) {
      const prevDefault = this.defaultSoundName;
      const prevWeatherDefault = this.weatherDefaultSoundName;
      this.suppressPersist++;
      try {
        this.library.clear();
        this.ensureBuiltinPresent();
        const added = [];
        for (const e of entries) {
          const safeName = String(e?.name || "").trim();
          if (!safeName) continue;
          if (this.isProtectedSound(safeName)) continue;
          const dataUrl = looksLikeDataURL(e.data) ? e.data : toDataUrl(e.data);
          this.library.set(safeName, dataUrl);
          added.push(safeName);
        }
        if (added.length) {
          this.defaultSoundName = added[0];
          this.weatherDefaultSoundName = added[0];
        }
      } finally {
        this.suppressPersist--;
      }
      const changed = this.ensureDefaultSoundValidity() || prevDefault !== this.defaultSoundName || prevWeatherDefault !== this.weatherDefaultSoundName;
      this.persistLibrary();
      if (changed) this.persistSettings();
    }
    setNotificationBase64(dataUriOrBase64) {
      const du = dataUriOrBase64 && dataUriOrBase64.trim() ? looksLikeDataURL(dataUriOrBase64) ? dataUriOrBase64 : toDataUrl(dataUriOrBase64) : "";
      this.defaultSoundDataUrl = du || null;
      if (du) {
        this.registerSound("LegacyDefault", du);
        this.defaultSoundName = "LegacyDefault";
        this.weatherDefaultSoundName = "LegacyDefault";
      }
      this.persistSettings();
    }
    getDefaultSoundName(context = "shops") {
      if (context === "weather") {
        return this.weatherDefaultSoundName ?? this.defaultSoundName;
      }
      return this.defaultSoundName;
    }
    resolveToDataUrl(src, context) {
      if (!src) {
        const name = context === "weather" ? this.weatherDefaultSoundName ?? this.defaultSoundName : this.defaultSoundName;
        if (name && this.library.has(name)) return this.library.get(name);
        return this.defaultSoundDataUrl || null;
      }
      const s = src.trim();
      if (this.library.has(s)) return this.library.get(s);
      if (looksLikeDataURL(s)) return s;
      if (/^[A-Za-z0-9+/=\s]+$/.test(s) && s.length > 100) return toDataUrl(s);
      return null;
    }
    // =========================
    // Settings API (Playback)
    // =========================
    setEnabled(on) {
      const next = !!on;
      if (this.enabled === next) return;
      this.enabled = next;
      this.persistSettings();
    }
    isEnabled() {
      return this.enabled;
    }
    setMute(muted) {
      this.setEnabled(!muted);
    }
    isMuted() {
      return !this.enabled;
    }
    setVolume(v, context = "shops") {
      const next = clamp01(v);
      if (context === "weather") {
        if (this.weatherVolume === next) return;
        this.weatherVolume = next;
      } else {
        if (this.volume === next) return;
        this.volume = next;
      }
      this.forEachLoop(context, (st) => {
        st.volume = next;
      });
      this.persistSettings();
    }
    getVolume(context = "shops") {
      return context === "weather" ? this.weatherVolume : this.volume;
    }
    setMinPlayGap(ms) {
      const next = Math.max(0, ms | 0);
      if (this.minPlayGapMs === next) return;
      this.minPlayGapMs = next;
      this.persistSettings();
    }
    getMinPlayGap() {
      return this.minPlayGapMs;
    }
    setPlaybackMode(mode, context = "shops") {
      if (context === "weather") {
        if (this.weatherMode === mode) return;
        this.weatherMode = mode;
      } else {
        if (this.mode === mode) return;
        this.mode = mode;
      }
      this.persistSettings();
    }
    getPlaybackMode(context = "shops") {
      return context === "weather" ? this.weatherMode : this.mode;
    }
    setStopRepeat(repeats, context = "shops") {
      this.setStopManual(context);
    }
    setStopManual(context = "shops") {
      if (context === "weather") {
        if (this.weatherStopConf.mode === "manual") return;
        this.weatherStopConf = { mode: "manual" };
      } else {
        if (this.stopConf.mode === "manual") return;
        this.stopConf = { mode: "manual" };
      }
      this.forEachLoop(context, (st) => {
        st.baseStop = { mode: "manual" };
      });
      this.persistSettings();
    }
    setStopPurchase(context = "shops") {
      if (context === "weather") {
        if (this.weatherStopConf.mode === "purchase") return;
        this.weatherStopConf = { mode: "purchase" };
      } else {
        if (this.stopConf.mode === "purchase") return;
        this.stopConf = { mode: "purchase" };
      }
      this.forEachLoop(context, (st) => {
        st.baseStop = { mode: "purchase" };
      });
      this.persistSettings();
    }
    clearStopCondition(context = "shops") {
      this.setStopManual(context);
    }
    setLoopInterval(ms, context = "shops") {
      const next = Math.max(150, ms | 0);
      if (context === "weather") {
        if (this.weatherLoopIntervalMs === next) return;
        this.weatherLoopIntervalMs = next;
      } else {
        if (this.loopIntervalMs === next) return;
        this.loopIntervalMs = next;
      }
      this.forEachLoop(context, (st) => {
        st.baseLoopInterval = next;
      });
      this.persistSettings();
    }
    getLoopInterval(context = "shops") {
      return context === "weather" ? this.weatherLoopIntervalMs : this.loopIntervalMs;
    }
    setPurchaseChecker(fn) {
      this.purchaseChecker = fn;
    }
    getPlaybackSettings(context = "shops") {
      const volume = this.getVolume(context);
      const mode = this.getPlaybackMode(context);
      const stop = context === "weather" ? this.weatherStopConf : this.stopConf;
      const stopSnapshot = stop.mode === "purchase" ? { mode: "purchase" } : { mode: "manual" };
      const loopIntervalMs = this.getLoopInterval(context);
      const defaultSoundName = this.getDefaultSoundName(context);
      return {
        enabled: this.enabled,
        volume,
        minPlayGapMs: this.minPlayGapMs,
        mode,
        stop: stopSnapshot,
        loopIntervalMs,
        primed: this.primed,
        defaultSoundName,
        hasLegacyDefault: !!this.defaultSoundDataUrl,
        librarySize: this.library.size,
        libraryNames: this.listSounds()
      };
    }
    // =========================
    // Actions
    // =========================
    async notify(context = "shops") {
      const du = this.resolveToDataUrl(null, context);
      await this.playOnce(du, this.getVolume(context), context);
    }
    async playNotify(context = "shops") {
      await this.notify(context);
    }
    /**
     * Trigger using the current mode.
     * @param key  Unique key (e.g. item id). "global" if generic.
     * @param sound Optional: NAME from registry or a dataURL/bare base64 to override.
     */
    async trigger(key2 = "global", overrides = {}, context = "shops") {
      const normalizeSound = (raw) => {
        if (typeof raw !== "string") return void 0;
        const trimmed = raw.trim();
        return trimmed ? trimmed : void 0;
      };
      const normalizeStop = (raw) => {
        if (!raw) return null;
        if (raw.mode === "purchase") return { mode: "purchase" };
        if (raw.mode === "manual") return { mode: "manual" };
        if (raw.mode === "repeat") return { mode: "manual" };
        return { mode: "manual" };
      };
      const sound = normalizeSound(overrides.sound ?? null);
      const baseMode = this.getPlaybackMode(context);
      const mode = overrides.mode === "oneshot" || overrides.mode === "loop" ? overrides.mode : baseMode;
      const baseStopSource = context === "weather" ? this.weatherStopConf : this.stopConf;
      const baseStop = baseStopSource.mode === "purchase" ? { mode: "purchase" } : { mode: "manual" };
      const baseLoopInterval = this.getLoopInterval(context);
      const baseVolume = this.getVolume(context);
      if (mode === "oneshot") {
        this.stopLoop(key2);
        const du = this.resolveToDataUrl(sound ?? null, context);
        this.enqueueOneshot({ key: key2, dataUrl: du, volume: baseVolume, context });
        return;
      }
      this.stopLoop(key2);
      const stopOverride = normalizeStop(overrides.stop ?? null);
      const loopIntervalOverride = overrides.loopIntervalMs != null && Number.isFinite(overrides.loopIntervalMs) ? Math.max(150, Math.round(overrides.loopIntervalMs)) : null;
      const state2 = {
        key: key2,
        timer: null,
        plays: 0,
        soundOverride: sound,
        stopped: false,
        stopOverride,
        loopIntervalOverride,
        context,
        baseStop,
        baseLoopInterval,
        volume: baseVolume
      };
      this.loops.set(key2, state2);
      this.scheduleNext(state2, 0);
    }
    forEachLoop(context, fn) {
      for (const st of this.loops.values()) {
        if (st.context === context) fn(st);
      }
    }
    stopLoop(key2 = "global") {
      const st = this.loops.get(key2);
      if (!st) return;
      st.stopped = true;
      if (st.timer != null) {
        clearTimeout(st.timer);
        st.timer = null;
      }
      this.loops.delete(key2);
    }
    stopAllLoops(context) {
      if (context) {
        for (const [k, st] of this.loops) {
          if (st.context === context) this.stopLoop(k);
        }
        return;
      }
      for (const [k] of this.loops) this.stopLoop(k);
    }
    /** Prime audio once on a user gesture for stricter browsers. */
    async prime() {
      try {
        if (!this.audioCtx) this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (this.audioCtx.state === "suspended") await this.audioCtx.resume();
        const o = this.audioCtx.createOscillator();
        const g = this.audioCtx.createGain();
        g.gain.value = 1e-4;
        o.connect(g).connect(this.audioCtx.destination);
        o.start();
        o.stop(this.audioCtx.currentTime + 0.02);
        this.primed = true;
      } catch {
        this.primed = true;
      }
    }
    // =========================
    // Import / compression ≤ 200 KB
    // =========================
    async importFileAsSound(file, opts = {}) {
      const {
        name,
        maxBytes = 200 * 1024,
        maxSeconds = 10,
        bitrates = [48e3, 32e3, 2e4, 12e3, 8e3],
        maxInputBytes = 8 * 1024 * 1024
      } = opts;
      const notifyInvalid = (description) => {
        try {
          toastSimple("Audio import", description, "error").catch(() => {
          });
        } catch {
        }
      };
      let decoded = null;
      const ensureDecoded = async () => {
        if (!decoded) decoded = await this.decodeFileToBuffer(file);
        return decoded;
      };
      if (!file || !(file instanceof File)) throw new Error("No file provided.");
      const allowedMimeByExtension = /* @__PURE__ */ new Map([
        ["mp3", /* @__PURE__ */ new Set(["audio/mpeg", "audio/mp3"])],
        ["wav", /* @__PURE__ */ new Set(["audio/wav", "audio/x-wav", "audio/wave"])],
        ["ogg", /* @__PURE__ */ new Set(["audio/ogg"])]
      ]);
      const fileType = (file.type || "").toLowerCase();
      const fileExtension = (file.name?.split(".").pop() || "").toLowerCase();
      if (!fileExtension || !allowedMimeByExtension.has(fileExtension)) {
        notifyInvalid("Unsupported audio format. Allowed formats: MP3, WAV, OGG.");
        throw new Error(`Unsupported audio extension: ${fileExtension || "unknown"}`);
      }
      const allowedMimes = allowedMimeByExtension.get(fileExtension);
      if (!fileType || !allowedMimes.has(fileType)) {
        notifyInvalid("File extension and MIME type must match (MP3, WAV, OGG only).");
        throw new Error(
          fileType ? `MIME type ${fileType} is not valid for .${fileExtension} files.` : `Missing MIME type for .${fileExtension} files.`
        );
      }
      if (file.size > maxInputBytes) throw new Error(`Input file too large (${Math.round(file.size / 1024)}KB). Limit is ${Math.round(maxInputBytes / 1024)}KB.`);
      if (file.size <= maxBytes) {
        const buf = await ensureDecoded();
        if (buf.duration > maxSeconds) {
          const duration = buf.duration;
          const formattedLimit = maxSeconds.toFixed(1).replace(/\.0$/, "");
          const formattedDuration = duration.toFixed(1).replace(/\.0$/, "");
          notifyInvalid(`File duration is ${formattedDuration}s (limit: ${formattedLimit}s).`);
          throw new Error(`Audio duration ${formattedDuration}s exceeds limit of ${formattedLimit}s.`);
        }
        const dataUrl = await this.blobToDataURL(file);
        const finalName = this.uniqueName(name || file.name);
        this.registerSound(finalName, dataUrl);
        return { name: finalName, dataUrl, bytes: file.size, wasCompressed: false };
      }
      const mime = this.chooseAudioMime();
      const canEncode = !!mime && typeof MediaRecorder !== "undefined" && MediaRecorder.isTypeSupported?.(mime);
      if (!canEncode) throw new Error("Compression unavailable in this browser; file exceeds 200KB.");
      decoded = await ensureDecoded();
      if (decoded.duration > maxSeconds) {
        const duration = decoded.duration;
        const formattedLimit = maxSeconds.toFixed(1).replace(/\.0$/, "");
        const formattedDuration = duration.toFixed(1).replace(/\.0$/, "");
        notifyInvalid(`File duration is ${formattedDuration}s (limit: ${formattedLimit}s).`);
        throw new Error(`Audio duration ${formattedDuration}s exceeds limit of ${formattedLimit}s.`);
      }
      for (const br of bitrates) {
        const blob = await this.recordBufferToBlob(decoded, mime, br);
        if (blob.size <= maxBytes) {
          const dataUrl = await this.blobToDataURL(blob);
          const finalName = this.uniqueName(name || file.name);
          this.registerSound(finalName, dataUrl);
          return { name: finalName, dataUrl, bytes: blob.size, wasCompressed: true };
        }
      }
      notifyInvalid(`Unable to compress under ${Math.round(maxBytes / 1024)}KB. Try a shorter clip.`);
      throw new Error(`Could not compress under ${Math.round(maxBytes / 1024)}KB. Try a shorter clip.`);
    }
    // =========================
    // Internals
    // =========================
    async playOnce(dataUrl, volume, _context, opts = {}) {
      if (!this.enabled) return true;
      const now2 = Date.now();
      if (now2 - this.lastPlayTs < this.minPlayGapMs) return false;
      this.lastPlayTs = now2;
      if (!dataUrl) {
        if (this.primed && this.audioCtx) {
          try {
            const o = this.audioCtx.createOscillator();
            const g = this.audioCtx.createGain();
            g.gain.value = volume * 0.1;
            o.frequency.value = 880;
            o.connect(g).connect(this.audioCtx.destination);
            o.start();
            o.stop(this.audioCtx.currentTime + 0.06);
          } catch {
          }
        }
        return true;
      }
      try {
        const a = new Audio();
        a.src = dataUrl;
        a.volume = volume;
        a.muted = !this.enabled;
        a.crossOrigin = "anonymous";
        const awaitEnd = opts?.awaitEnd === true;
        let endPromise = null;
        let resolveEnd = null;
        if (awaitEnd) {
          endPromise = new Promise((resolve2) => {
            const cleanup2 = () => {
              a.removeEventListener("ended", cleanup2);
              a.removeEventListener("error", cleanup2);
              resolve2();
            };
            resolveEnd = cleanup2;
            a.addEventListener("ended", cleanup2);
            a.addEventListener("error", cleanup2);
          });
        }
        const p = a.play();
        if (p && typeof p.then === "function") await p.catch(() => {
          resolveEnd?.();
        });
        if (endPromise) await endPromise;
      } catch {
      }
      return true;
    }
    scheduleNext(state2, delayMs) {
      const run = async () => {
        if (state2.stopped) return;
        const stopConf = state2.stopOverride ?? state2.baseStop;
        if (stopConf.mode === "purchase" && this.purchaseChecker) {
          try {
            if (this.purchaseChecker(state2.key)) {
              this.stopLoop(state2.key);
              return;
            }
          } catch {
          }
        }
        const du = this.resolveToDataUrl(state2.soundOverride, state2.context);
        const played = await this.playOnce(
          du,
          state2.volume,
          state2.context,
          { awaitEnd: true }
        );
        if (played) state2.plays++;
        if (stopConf.mode === "repeat") {
          const max = Math.max(1, stopConf.repeats | 0);
          if (state2.plays >= max) {
            this.stopLoop(state2.key);
            return;
          }
        }
        const intervalBase = state2.loopIntervalOverride ?? state2.baseLoopInterval;
        const gap = Math.max(150, intervalBase | 0);
        state2.timer = setTimeout(() => this.scheduleNext(state2, 0), gap);
      };
      if (delayMs > 0) state2.timer = setTimeout(run, delayMs);
      else run().catch(() => {
      });
    }
    enqueueOneshot(entry) {
      if (entry.context === "weather") {
        const idx = this.oneshotQueue.findIndex((item) => item.context !== "weather");
        if (idx === -1) this.oneshotQueue.push(entry);
        else this.oneshotQueue.splice(idx, 0, entry);
      } else {
        this.oneshotQueue.push(entry);
      }
      this.scheduleOneshotProcessing();
    }
    scheduleOneshotProcessing() {
      if (!this.oneshotQueue.length) return;
      if (this.oneshotQueueTimer != null) return;
      const delta = Date.now() - this.lastPlayTs;
      const wait = Math.max(0, this.minPlayGapMs - delta);
      this.oneshotQueueTimer = window.setTimeout(() => {
        this.oneshotQueueTimer = null;
        if (this.oneshotProcessing) return;
        this.processOneshotQueue();
      }, wait);
    }
    processOneshotQueue() {
      if (this.oneshotProcessing) return;
      if (!this.oneshotQueue.length) return;
      const next = this.oneshotQueue.shift();
      this.oneshotProcessing = true;
      const run = async () => {
        let replay = false;
        try {
          const played = await this.playOnce(next.dataUrl, next.volume, next.context);
          replay = !played;
        } finally {
          this.oneshotProcessing = false;
          if (replay) this.enqueueOneshot(next);
          this.scheduleOneshotProcessing();
        }
      };
      run().catch(() => {
      });
    }
    // ===== Helpers import/compress =====
    chooseAudioMime() {
      const candidates = ["audio/webm;codecs=opus", "audio/ogg;codecs=opus", "audio/webm", "audio/ogg", "audio/mp4"];
      for (const m of candidates) {
        try {
          if (typeof MediaRecorder !== "undefined" && MediaRecorder.isTypeSupported?.(m)) return m;
        } catch {
        }
      }
      return null;
    }
    uniqueName(raw) {
      const base = String(raw || "Sound").replace(/\.[a-z0-9]+$/i, "").trim() || "Sound";
      if (!this.library.has(base)) return base;
      let i = 2;
      while (this.library.has(`${base} (${i})`)) i++;
      return `${base} (${i})`;
    }
    async blobToDataURL(blob) {
      return await new Promise((resolve2, reject) => {
        const fr = new FileReader();
        fr.onload = () => resolve2(String(fr.result));
        fr.onerror = reject;
        fr.readAsDataURL(blob);
      });
    }
    async decodeFileToBuffer(file) {
      const arrayBuf = await file.arrayBuffer();
      const Ctx = window.AudioContext || window.webkitAudioContext;
      const ctx = new Ctx();
      try {
        const buf = await new Promise((res, rej) => {
          ctx.decodeAudioData(arrayBuf.slice(0), res, rej);
        });
        await ctx.close().catch(() => {
        });
        return buf;
      } catch (e) {
        try {
          await ctx.close();
        } catch {
        }
        throw new Error("Failed to decode audio file.");
      }
    }
    async recordBufferToBlob(buffer, mime, bitsPerSecond) {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      const ctx = new Ctx();
      const dest = ctx.createMediaStreamDestination();
      const src = ctx.createBufferSource();
      src.buffer = buffer;
      const gain = ctx.createGain();
      gain.gain.value = 0.9;
      src.connect(gain).connect(dest);
      const chunks = [];
      const rec = new MediaRecorder(dest.stream, { mimeType: mime, bitsPerSecond });
      const recorded = new Promise((resolve2, reject) => {
        rec.ondataavailable = (e) => {
          if (e.data && e.data.size) chunks.push(e.data);
        };
        rec.onerror = (e) => reject(e.error || new Error("MediaRecorder error"));
        rec.onstop = () => {
          try {
            resolve2(new Blob(chunks, { type: mime }));
          } catch (err) {
            reject(err);
          }
        };
      });
      rec.start();
      src.start();
      await new Promise((res) => {
        src.onended = () => res();
      });
      rec.stop();
      const out = await recorded;
      try {
        await ctx.close();
      } catch {
      }
      return out;
    }
  };
  var audio = new AudioNotifier({
    minPlayGapMs: 1200,
    volume: 0.7
  });

  // src/core/sprite.ts
  var import_jszip = __toESM(require_jszip_min(), 1);
  function isImageUrl(u) {
    try {
      if (!u || u.startsWith("blob:")) return false;
      return /\.(png|jpe?g|gif|webp|svg|avif|bmp|ico|ktx2|basis)$/i.test(u);
    } catch {
      return false;
    }
  }
  function toAbs(u) {
    try {
      return new URL(u, location.href).href;
    } catch {
      return String(u);
    }
  }
  function fileBase(url) {
    const name = decodeURIComponent(url.split("/").pop() || "");
    return name.replace(/\.[a-z0-9]+$/i, "");
  }
  function isTilesUrl(u) {
    return /\/assets\/tiles\//i.test(u) || /(map|plants|allplants|items|seeds|pets|animations|mutations)\.(png|webp)$/i.test(u);
  }
  function isUiUrl(u) {
    return /\/assets\/ui\//i.test(u);
  }
  var SpritesCore = class {
    constructor(autoStart = true) {
      /** Configuration (ajuste à la volée si besoin) */
      __publicField(this, "cfg", {
        skipAlphaBelow: 1,
        blackBelow: 8,
        tolerance: 5e-3,
        ruleAllplants512: /allplants/i
      });
      __publicField(this, "initialized", false);
      __publicField(this, "onAssetCb");
      __publicField(this, "onMessageListener");
      // URLs récoltées
      __publicField(this, "ui", /* @__PURE__ */ new Set());
      __publicField(this, "tiles", /* @__PURE__ */ new Set());
      __publicField(this, "all", /* @__PURE__ */ new Set());
      // Caches de sprites découpés par feuille et par mode
      __publicField(this, "tileCacheBitmap", /* @__PURE__ */ new Map());
      __publicField(this, "tileCacheCanvas", /* @__PURE__ */ new Map());
      __publicField(this, "tileCacheDataURL", /* @__PURE__ */ new Map());
      // Images UI chargées
      __publicField(this, "uiCache", /* @__PURE__ */ new Map());
      // Hooks / sniffers
      __publicField(this, "observers", []);
      __publicField(this, "patched", {});
      __publicField(this, "blobText", /* @__PURE__ */ new WeakMap());
      if (autoStart) this.init();
    }
    init(opts) {
      if (opts?.config) Object.assign(this.cfg, opts.config);
      if (opts?.onAsset) this.onAssetCb = opts.onAsset;
      if (this.initialized) {
        console.debug("[Sprites] SpritesCore d\xE9j\xE0 initialis\xE9", {
          totals: {
            all: this.all.size,
            ui: this.ui.size,
            tiles: this.tiles.size
          }
        });
        return this;
      }
      console.debug("[Sprites] Initialisation des sniffers de sprites", {
        config: this.cfg
      });
      this.installMainSniffers();
      this.installWorkerHooks();
      this.onMessageListener = (e) => {
        const d = e.data;
        if (d && d.__awc && d.url) this.add(d.url, "worker");
      };
      pageWindow.addEventListener("message", this.onMessageListener, true);
      this.initialized = true;
      console.debug("[Sprites] SpritesCore initialis\xE9", {
        globals: {
          hasWindowSprites: Boolean(pageWindow.Sprites)
        }
      });
      return this;
    }
    /** Désinstalle les hooks et nettoie. */
    destroy() {
      if (!this.initialized) return;
      this.observers.forEach((o) => {
        try {
          o.disconnect();
        } catch {
        }
      });
      this.observers = [];
      if (this.patched.imgDesc) {
        Object.defineProperty(HTMLImageElement.prototype, "src", this.patched.imgDesc);
        this.patched.imgDesc = void 0;
      }
      if (this.patched.setAttr) {
        HTMLImageElement.prototype.setAttribute = this.patched.setAttr;
        this.patched.setAttr = void 0;
      }
      if (this.patched.Worker) {
        pageWindow.Worker = this.patched.Worker;
        if (pageWindow !== pageWindow) pageWindow.Worker = this.patched.Worker;
        this.patched.Worker = void 0;
      }
      if (this.patched.Blob) {
        pageWindow.Blob = this.patched.Blob;
        if (pageWindow !== pageWindow) pageWindow.Blob = this.patched.Blob;
        this.patched.Blob = void 0;
      }
      if (this.patched.createObjectURL) {
        const pageURL = pageWindow.URL ?? URL;
        pageURL.createObjectURL = this.patched.createObjectURL;
        if (pageWindow !== pageWindow) URL.createObjectURL = this.patched.createObjectURL;
        this.patched.createObjectURL = void 0;
      }
      if (this.onMessageListener) {
        pageWindow.removeEventListener("message", this.onMessageListener, true);
        this.onMessageListener = void 0;
      }
      this.initialized = false;
    }
    /* ===================== PUBLIC API ===================== */
    /** URLs collectées */
    lists() {
      return { all: [...this.all], ui: [...this.ui], tiles: [...this.tiles] };
    }
    /** Liste des tilesheets par catégorie de nom (regex sur l'URL) */
    listTilesByCategory(re) {
      return [...this.tiles].filter((u) => re.test(u));
    }
    listPlants() {
      const urls = new Set(this.listTilesByCategory(/plants/i));
      for (const url of this.listAllPlants()) urls.add(url);
      return [...urls];
    }
    listAllPlants() {
      return this.listTilesByCategory(this.cfg.ruleAllplants512);
    }
    listItems() {
      return this.listTilesByCategory(/items/i);
    }
    listSeeds() {
      return this.listTilesByCategory(/seeds/i);
    }
    listPets() {
      return this.listTilesByCategory(/pets/i);
    }
    listMap() {
      return this.listTilesByCategory(/map\.(png|webp)$/i);
    }
    /** Charge toutes les images UI (retourne Map<basename, HTMLImageElement>) */
    async loadUI() {
      const out = /* @__PURE__ */ new Map();
      for (const u of this.ui) {
        if (!this.uiCache.has(u)) {
          const im = await this.loadImage(u);
          this.uiCache.set(u, im);
        }
        out.set(fileBase(u), this.uiCache.get(u));
      }
      return out;
    }
    /** Charge & découpe les tilesheets (retourne Map<basename, TileInfo[]>) */
    async loadTiles(options = {}) {
      const {
        mode = "bitmap",
        includeBlanks = false,
        forceSize,
        onlySheets
      } = options;
      const out = /* @__PURE__ */ new Map();
      const list = onlySheets ? [...this.tiles].filter((u) => onlySheets.test(u)) : [...this.tiles];
      for (const u of list) {
        const base = fileBase(u);
        let cached;
        if (mode === "bitmap") cached = this.tileCacheBitmap.get(u);
        else if (mode === "canvas") cached = this.tileCacheCanvas.get(u);
        else cached = this.tileCacheDataURL.get(u);
        if (!cached) {
          const tiles = await this.sliceOne(u, { mode, includeBlanks, forceSize });
          if (mode === "bitmap") this.tileCacheBitmap.set(u, tiles);
          else if (mode === "canvas") this.tileCacheCanvas.set(u, tiles);
          else this.tileCacheDataURL.set(u, tiles);
          cached = tiles;
        }
        out.set(base, cached);
      }
      return out;
    }
    /** Raccourcis pratiques */
    async loadTilesAuto() {
      return this.loadTiles({ mode: "bitmap" });
    }
    async loadTiles256() {
      return this.loadTiles({ mode: "bitmap", forceSize: 256 });
    }
    async loadTiles512() {
      return this.loadTiles({ mode: "bitmap", forceSize: 512 });
    }
    /** Récupère un sprite précis (par feuille + index) */
    async getTile(sheetBase, index, mode = "bitmap") {
      const url = [...this.tiles].find((u) => fileBase(u) === sheetBase);
      if (!url) return null;
      const map2 = await this.loadTiles({ mode, onlySheets: new RegExp(sheetBase.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") + "\\.(png|webp)$", "i") });
      const tiles = map2.get(sheetBase) || [];
      const tile = tiles.find((t) => t.index === index);
      return tile ?? null;
    }
    /** Aplatis toutes les tiles en un seul tableau (utile pour un index global) */
    async flatTiles(options = {}) {
      const maps = await this.loadTiles(options);
      const all = [];
      maps.forEach((arr) => all.push(...arr));
      return all;
    }
    /** Exporte les UI en ZIP (brut, sans découpe) */
    async zipUI(name = "ui_assets.zip") {
      const zip = new import_jszip.default();
      const list = [...this.ui];
      let i = 0;
      for (const u of list) {
        try {
          const b = await this.fetchBlob(u);
          const fn = decodeURIComponent(u.split("/").pop() || "").replace(/\?.*$/, "");
          zip.file(fn, b);
        } catch {
        }
        if (++i % 10 === 0) console.log(`[zipUI] ${i}/${list.length}`);
      }
      await this.saveZip(zip, name);
    }
    /** Exporte les tiles découpées en ZIP (auto 256/512 selon règle allplants) */
    async zipTilesAuto(name = "tiles_auto.zip") {
      await this.zipTiles({ name, mode: "bitmap" });
    }
    /** Exporte les tiles en ZIP (forcé 256/512) */
    async zipTiles256(name = "tiles_256.zip") {
      await this.zipTiles({ name, mode: "bitmap", forceSize: 256 });
    }
    async zipTiles512(name = "tiles_512.zip") {
      await this.zipTiles({ name, mode: "bitmap", forceSize: 512 });
    }
    /** Exporte toutes les tiles découpées + les assets UI dans un seul ZIP */
    async zipAllSprites(name = "sprites_all.zip") {
      const zip = new import_jszip.default();
      const tilesFolder = zip.folder("tiles");
      const uiFolder = zip.folder("ui");
      if (tilesFolder) {
        for (const url of this.tiles) {
          try {
            const tiles = await this.sliceOne(url, {
              mode: "canvas",
              includeBlanks: false
            });
            if (!tiles.length) continue;
            const base = fileBase(url);
            const sheetFolder = tilesFolder.folder(base) ?? tilesFolder;
            let index = 0;
            for (const tile of tiles) {
              const canvas = tile.data;
              const tileIndex = ++index;
              const baseName = `tile_${String(tileIndex).padStart(4, "0")}`;
              const exportVariant = async (suffix, label2, factory) => {
                try {
                  const variantCanvas = factory();
                  const blob = await new Promise((resolve2, reject) => {
                    variantCanvas.toBlob((b) => {
                      if (!b) {
                        reject(new Error("toBlob returned null"));
                        return;
                      }
                      resolve2(b);
                    }, "image/png");
                  });
                  sheetFolder.file(`${baseName}${suffix}.png`, blob);
                } catch (error) {
                  console.warn("[Sprites] Failed to export tile", { url, label: label2, error });
                }
              };
              await exportVariant("", "base", () => canvas);
              await exportVariant("_gold", "gold", () => this.effectGold(tile));
              await exportVariant("_rainbow", "rainbow", () => this.effectRainbow(tile));
            }
          } catch (error) {
            console.warn("[Sprites] Failed to export sheet", { url, error });
          }
        }
      }
      if (uiFolder) {
        let fallbackIndex = 0;
        for (const url of this.ui) {
          try {
            const blob = await this.fetchBlob(url);
            const base = decodeURIComponent(url.split("/").pop() || "").replace(/\?.*$/, "");
            const fileName = base || `asset_${String(++fallbackIndex).padStart(4, "0")}.png`;
            uiFolder.file(fileName, blob);
          } catch (error) {
            console.warn("[Sprites] Failed to export UI asset", { url, error });
          }
        }
      }
      await this.saveZip(zip, name);
    }
    /** Vide les caches */
    clearCaches() {
      this.tileCacheBitmap.forEach((arr) => arr.forEach((t) => t.data.close?.()));
      this.tileCacheBitmap.clear();
      this.tileCacheCanvas.clear();
      this.tileCacheDataURL.clear();
      this.uiCache.clear();
    }
    /** Applique l’effet Gold sur une tuile — retourne un NOUVEAU canvas. */
    effectGold(tile, opts) {
      const srcCan = this.tileToCanvas(tile);
      const w = srcCan.width, h = srcCan.height;
      const out = document.createElement("canvas");
      out.width = w;
      out.height = h;
      const ctx = out.getContext("2d");
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(srcCan, 0, 0);
      const alpha = opts?.alpha ?? 0.7;
      const color = opts?.color ?? "rgb(255, 215, 0)";
      ctx.save();
      ctx.globalCompositeOperation = "source-atop";
      ctx.globalAlpha = alpha;
      ctx.fillStyle = color;
      ctx.fillRect(0, 0, w, h);
      ctx.restore();
      return out;
    }
    /** Applique l’effet Rainbow (dégradé masqué + blend 'color' si dispo, sinon 'source-atop') */
    /** Rainbow identique au jeu (masked + blend 'color' + angle 130°). */
    effectRainbow(tile, opts) {
      const srcCan = this.tileToCanvas(tile);
      const w = srcCan.width, h = srcCan.height;
      const out = document.createElement("canvas");
      out.width = w;
      out.height = h;
      const ctx = out.getContext("2d");
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(srcCan, 0, 0);
      const angle = opts?.angle ?? 130;
      const colors = opts?.colors ?? ["#FF1744", "#FF9100", "#FFEA00", "#00E676", "#2979FF", "#D500F9"];
      const tmp = document.createElement("canvas");
      tmp.width = w;
      tmp.height = h;
      const tctx = tmp.getContext("2d");
      tctx.imageSmoothingEnabled = false;
      const size = w;
      const rad = (angle - 90) * Math.PI / 180;
      const cx = w / 2, cy = h / 2;
      const x1 = cx - Math.cos(rad) * (size / 2);
      const y1 = cy - Math.sin(rad) * (size / 2);
      const x2 = cx + Math.cos(rad) * (size / 2);
      const y2 = cy + Math.sin(rad) * (size / 2);
      const grad = tctx.createLinearGradient(x1, y1, x2, y2);
      if (colors.length <= 1) {
        const c0 = colors[0] ?? "#ffffff";
        grad.addColorStop(0, c0);
        grad.addColorStop(1, c0);
      } else {
        colors.forEach((c, i) => grad.addColorStop(i / (colors.length - 1), c));
      }
      tctx.fillStyle = grad;
      tctx.fillRect(0, 0, w, h);
      tctx.globalCompositeOperation = "destination-in";
      tctx.drawImage(srcCan, 0, 0);
      tctx.globalCompositeOperation = "source-over";
      ctx.save();
      ctx.globalCompositeOperation = "color";
      ctx.drawImage(tmp, 0, 0);
      ctx.restore();
      return out;
    }
    /** Helper générique: applique "Gold" ou "Rainbow" selon le nom */
    effectApply(name, tile, opts) {
      return name === "Gold" ? this.effectGold(tile, opts) : this.effectRainbow(tile, opts);
    }
    /* ===================== INTERNE: chargement/découpe ===================== */
    async loadImage(url) {
      return await new Promise((res, rej) => {
        const im = new Image();
        im.crossOrigin = "anonymous";
        im.onload = () => res(im);
        im.onerror = rej;
        im.src = url;
      });
    }
    guessSize(url, img, forced) {
      if (forced) return forced;
      if (this.cfg.ruleAllplants512.test(url)) return 512;
      if (img.width % 256 === 0 && img.height % 256 === 0) return 256;
      if (img.width % 512 === 0 && img.height % 512 === 0) return 512;
      return 256;
    }
    isBlankOrBlack(data) {
      const aThr = this.cfg.skipAlphaBelow;
      const bThr = this.cfg.blackBelow;
      const tol = this.cfg.tolerance;
      const d = data.data;
      const maxColored = Math.ceil(d.length / 4 * tol);
      let colored = 0;
      for (let i = 0; i < d.length; i += 4) {
        const a = d[i + 3];
        if (a > aThr) {
          const r = d[i], g = d[i + 1], b = d[i + 2];
          if (r > bThr || g > bThr || b > bThr) {
            if (++colored > maxColored) return false;
          }
        }
      }
      return true;
    }
    async sliceOne(url, opts) {
      const img = await this.loadImage(url);
      const size = this.guessSize(url, img, opts.forceSize);
      const cols = Math.floor(img.width / size);
      const rows = Math.floor(img.height / size);
      const base = fileBase(url);
      const can = document.createElement("canvas");
      can.width = size;
      can.height = size;
      const ctx = can.getContext("2d", { willReadFrequently: true });
      ctx.imageSmoothingEnabled = false;
      const list = [];
      let idx = 0;
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          ctx.clearRect(0, 0, size, size);
          ctx.drawImage(img, col * size, row * size, size, size, 0, 0, size, size);
          let blank = false;
          try {
            const data = ctx.getImageData(0, 0, size, size);
            blank = this.isBlankOrBlack(data);
          } catch {
            blank = false;
          }
          if (!opts.includeBlanks && blank) {
            idx++;
            continue;
          }
          if (opts.mode === "bitmap") {
            const bmp = await createImageBitmap(can);
            list.push({ sheet: base, url, index: idx, col, row, size, data: bmp });
          } else if (opts.mode === "canvas") {
            const clone = document.createElement("canvas");
            clone.width = size;
            clone.height = size;
            clone.getContext("2d").drawImage(can, 0, 0);
            list.push({ sheet: base, url, index: idx, col, row, size, data: clone });
          } else {
            const dataURL = await new Promise((resolve2, reject) => {
              can.toBlob((blob) => {
                if (!blob) {
                  reject(new Error("toBlob returned null"));
                  return;
                }
                const fr = new FileReader();
                fr.onerror = reject;
                fr.onload = () => resolve2(fr.result);
                fr.readAsDataURL(blob);
              }, "image/png");
            });
            list.push({ sheet: base, url, index: idx, col, row, size, data: dataURL });
          }
          idx++;
        }
      }
      return list;
    }
    async zipTiles(opts) {
      const zip = new import_jszip.default();
      for (const u of this.tiles) {
        const tiles = await this.sliceOne(u, { mode: "canvas", includeBlanks: false, forceSize: opts.forceSize });
        const base = fileBase(u);
        let k = 0;
        for (const t of tiles) {
          const can = t.data;
          const blob = await new Promise((res) => can.toBlob((b) => res(b), "image/png"));
          zip.file(`${base}/tile_${String(++k).padStart(4, "0")}.png`, blob);
        }
      }
      await this.saveZip(zip, opts.name);
    }
    /** Teste si un mode de blend est supporté par le Canvas 2D */
    supportsBlend(op) {
      try {
        const c = document.createElement("canvas");
        c.width = c.height = 1;
        const g = c.getContext("2d");
        const before = g.globalCompositeOperation;
        g.globalCompositeOperation = op;
        const ok = g.globalCompositeOperation === op;
        g.globalCompositeOperation = before;
        return ok;
      } catch {
        return false;
      }
    }
    /** Convertit tile.data -> Canvas (ImageBitmap/Canvas). Refuse dataURL (string). */
    tileToCanvas(tile) {
      const src = tile.data;
      let w = tile.size, h = tile.size;
      const out = document.createElement("canvas");
      out.width = w;
      out.height = h;
      const ctx = out.getContext("2d");
      ctx.imageSmoothingEnabled = false;
      if (src instanceof HTMLCanvasElement) {
        w = src.width;
        h = src.height;
        out.width = w;
        out.height = h;
        ctx.drawImage(src, 0, 0);
      } else if (typeof ImageBitmap !== "undefined" && src instanceof ImageBitmap) {
        w = src.width;
        h = src.height;
        out.width = w;
        out.height = h;
        ctx.drawImage(src, 0, 0);
      } else if (typeof src === "string") {
        throw new Error("Sprites: tile.data est un dataURL (string). Recharge la tuile en mode 'canvas' ou 'bitmap'.");
      } else {
        ctx.drawImage(src, 0, 0);
      }
      return out;
    }
    /** Crée un gradient linéaire à un angle (deg) couvrant tout le canvas */
    makeAngleGradient(ctx, w, h, angleDeg) {
      const rad = angleDeg * Math.PI / 180;
      const cx = w / 2, cy = h / 2;
      const R = Math.hypot(w, h);
      const x0 = cx - Math.cos(rad) * R, y0 = cy - Math.sin(rad) * R;
      const x1 = cx + Math.cos(rad) * R, y1 = cy + Math.sin(rad) * R;
      return ctx.createLinearGradient(x0, y0, x1, y1);
    }
    /* ===================== SNIFFERS (UI + Tiles) ===================== */
    add(url, _why = "") {
      const abs = toAbs(url);
      if (!isImageUrl(abs) || this.all.has(abs)) return;
      if (isUiUrl(abs)) {
        this.ui.add(abs);
        this.all.add(abs);
        console.debug("[Sprites] Asset UI d\xE9tect\xE9", { url: abs, totals: this.ui.size });
        this.onAssetCb?.(abs, "ui");
      } else if (isTilesUrl(abs)) {
        this.tiles.add(abs);
        this.all.add(abs);
        console.debug("[Sprites] Tilesheet d\xE9tect\xE9", { url: abs, totals: this.tiles.size });
        this.onAssetCb?.(abs, "tiles");
      }
    }
    installMainSniffers() {
      try {
        const desc = Object.getOwnPropertyDescriptor(HTMLImageElement.prototype, "src");
        if (desc && !this.patched.imgDesc) {
          this.patched.imgDesc = desc;
          Object.defineProperty(HTMLImageElement.prototype, "src", {
            set: function(v) {
              pageWindow.Sprites?.add?.(v, "img");
              return desc.set.call(this, v);
            },
            get: desc.get,
            configurable: true,
            enumerable: desc.enumerable
          });
          const proto = HTMLImageElement.prototype;
          const nativeSetAttr = proto.setAttribute;
          this.patched.setAttr = nativeSetAttr;
          const self2 = this;
          proto.setAttribute = function(name, value) {
            try {
              if (String(name).toLowerCase() === "src" && typeof value === "string") {
                self2.add(value, "img-attr");
              }
            } catch {
            }
            return nativeSetAttr.call(this, name, value);
          };
        }
      } catch {
      }
      try {
        if ("PerformanceObserver" in pageWindow) {
          const po = new PerformanceObserver((list) => {
            list.getEntries().forEach((e) => this.add(e.name, "po"));
          });
          po.observe({ entryTypes: ["resource"] });
          this.observers.push(po);
        }
      } catch {
      }
    }
    workerPreludeSource() {
      return `
      (function(){
        const IMG=/\\.(png|jpe?g|gif|webp|svg|avif|bmp|ico|ktx2|basis)$/i;
        const isImg=(u)=>{ try{return IMG.test(u)&&!String(u).startsWith('blob:')}catch{return false} };
        const post=(o)=>{ try{ self.postMessage(Object.assign({__awc:1}, o)); }catch{} };

        const F=self.fetch;
        if(F){
          self.fetch=async function(...a){
            let u=a[0]; try{ u=typeof u==='string'?u:(u&&u.url)||u; }catch{}
            const r=await F.apply(this,a);
            try{
              const ct=(r.headers&&r.headers.get&&r.headers.get('content-type'))||'';
              if((u&&isImg(u)) || /^image\\//i.test(ct)) post({ url:(typeof u==='string'?u:(u&&u.url)||String(u)), src:'worker:fetch', ct });
            }catch{}
            return r;
          };
        }

        const CIB=self.createImageBitmap;
        if(CIB){
          self.createImageBitmap=async function(b,...rest){
            try{ if(b&&/^image\\//i.test(b.type)) post({ url:'blob://imagebitmap', src:'worker:cib', ct:b.type }); }catch{}
            return CIB.call(this,b,...rest);
          };
        }

        const IS=self.importScripts;
        if(IS){
          self.importScripts=function(...urls){
            try{ urls.forEach(u=>post({ url:u, src:'worker:importScripts' })); }catch{}
            return IS.apply(this,urls);
          };
        }
      })();
    `;
    }
    installWorkerHooks() {
      const pageGlobal = pageWindow;
      const sandboxGlobal = pageWindow;
      const isIsolated = pageWindow !== pageWindow;
      const NativeWorker2 = pageGlobal.Worker;
      const NativeBlob = pageGlobal.Blob;
      const pageURL = pageGlobal.URL ?? URL;
      const NativeCreate = pageURL.createObjectURL.bind(pageURL);
      if (!NativeBlob || !NativeWorker2) return;
      if (!this.patched.Blob) {
        this.patched.Blob = NativeBlob;
        const OriginalBlob = this.patched.Blob;
        const self2 = this;
        const PatchedBlob = function(parts = [], opts = {}) {
          const b = new OriginalBlob(parts, opts);
          const type = opts && opts.type || "";
          if (/javascript|ecmascript/i.test(type)) {
            let ok = true, txt = "";
            for (const p of parts) {
              if (typeof p === "string") txt += p;
              else {
                ok = false;
                break;
              }
            }
            if (ok) self2.blobText.set(b, txt);
          }
          return b;
        };
        pageGlobal.Blob = PatchedBlob;
        if (isIsolated) sandboxGlobal.Blob = PatchedBlob;
        pageGlobal.Blob.prototype = OriginalBlob.prototype;
        if (isIsolated) sandboxGlobal.Blob.prototype = OriginalBlob.prototype;
      }
      if (!this.patched.createObjectURL) {
        this.patched.createObjectURL = pageURL.createObjectURL;
        const prelude = this.workerPreludeSource();
        const self2 = this;
        const patchedCreateObjectURL = function(obj) {
          if (obj instanceof pageGlobal.Blob || obj instanceof Blob) {
            const type = (obj.type || "").toLowerCase();
            const txt = self2.blobText.get(obj) || "";
            const looksWorkerJS = /javascript/.test(type) || /onmessage|fetch\(|importScripts/.test(txt);
            if (looksWorkerJS && txt) {
              const patched = new NativeBlob([prelude + "\n" + txt + "\n//# sourceURL=sprites-blob.js"], { type: type || "application/javascript" });
              return NativeCreate(patched);
            }
          }
          return NativeCreate(obj);
        };
        pageURL.createObjectURL = patchedCreateObjectURL;
        if (isIsolated) URL.createObjectURL = patchedCreateObjectURL;
      }
      if (!this.patched.Worker) {
        this.patched.Worker = pageGlobal.Worker;
        const prelude = this.workerPreludeSource();
        const self2 = this;
        const PatchedWorker = function(url, opts) {
          try {
            const abs = new URL(String(url), location.href).href;
            if (!abs.startsWith("blob:")) {
              const isModule = opts && opts.type === "module";
              const src = isModule ? `${prelude}
import "${abs}";
//# sourceURL=sprites-wrapper-module.js` : `${prelude}
try{importScripts("${abs}")}catch(e){}
//# sourceURL=sprites-wrapper-classic.js`;
              const blob = new NativeBlob([src], { type: "text/javascript" });
              const u = NativeCreate(blob);
              const w2 = new self2.patched.Worker(u, isModule ? { type: "module" } : {});
              self2.attachWorkerListener(w2);
              return w2;
            }
          } catch {
          }
          const w = new self2.patched.Worker(url, opts);
          self2.attachWorkerListener(w);
          return w;
        };
        pageGlobal.Worker = PatchedWorker;
        if (isIsolated) sandboxGlobal.Worker = PatchedWorker;
        pageGlobal.Worker.toString = () => this.patched.Worker.toString();
        if (isIsolated) sandboxGlobal.Worker.toString = () => this.patched.Worker.toString();
      }
    }
    attachWorkerListener(w) {
      try {
        w.addEventListener("message", (e) => {
          const d = e.data;
          if (d && d.__awc && d.url) this.add(d.url, d.src || "worker");
        });
      } catch {
      }
    }
    /* ===================== Utils ZIP ===================== */
    async fetchBlob(u) {
      const r = await fetch(u, { credentials: "include" });
      if (!r.ok) throw new Error(`HTTP ${r.status} for ${u}`);
      return r.blob();
    }
    async saveZip(zip, name) {
      const blob = await zip.generateAsync({ type: "blob" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = name;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(a.href), 1e4);
    }
  };
  var sharedSpritesInstance = new SpritesCore(false);
  shareGlobal("Sprites", sharedSpritesInstance);
  var Sprites = sharedSpritesInstance;
  function initSprites(options) {
    const instance = Sprites.init(options);
    shareGlobal("Sprites", instance);
    console.debug("[Sprites] Instance globale disponible sur pageWindow.Sprites", {
      hasWindowProperty: "Sprites" in pageWindow,
      lists: instance.lists()
    });
    return instance;
  }
  shareGlobal("initSprites", initSprites);

  // src/utils/weatherSprites.ts
  var spriteConfig = /* @__PURE__ */ new WeakMap();
  var spriteSubscribers = /* @__PURE__ */ new Map();
  var spriteCache = /* @__PURE__ */ new Map();
  var spritePromises = /* @__PURE__ */ new Map();
  var listenerAttached = false;
  var animationBases = null;
  var weatherTileIndices = (() => {
    const map2 = /* @__PURE__ */ new Map();
    for (const [rawKey, rawValue] of Object.entries(tileRefsAnimations ?? {})) {
      const key2 = normalizeRawKey(rawKey);
      const index = toTileIndex(rawValue);
      if (key2 && index != null) {
        map2.set(key2, index);
      }
    }
    return map2;
  })();
  function normalizeRawKey(raw) {
    const str = typeof raw === "string" ? raw : String(raw ?? "");
    return str.trim().replace(/^Weather:/i, "").replace(/[^a-z0-9]+/gi, "").toLowerCase();
  }
  function toTileIndex(value) {
    const num = typeof value === "number" ? value : Number(value);
    if (!Number.isFinite(num)) return null;
    return num > 0 ? Math.trunc(num) - 1 : Math.trunc(num);
  }
  function resolveSpriteKey(raw) {
    if (raw == null) return null;
    const normalized = normalizeRawKey(raw);
    if (!normalized) return null;
    if (weatherTileIndices.has(normalized)) return normalized;
    return null;
  }
  function getAnimationBases() {
    if (animationBases) return animationBases;
    const bases = /* @__PURE__ */ new Set();
    try {
      const listFn = Sprites?.listTilesByCategory;
      if (typeof listFn === "function") {
        for (const url of listFn(/anim/i)) {
          if (typeof url !== "string" || !url.length) continue;
          const clean = url.split(/[?#]/)[0] ?? url;
          const file = clean.split("/").pop() ?? clean;
          bases.add(file.replace(/\.[^.]+$/, ""));
        }
      }
    } catch {
    }
    if (bases.size === 0) {
      ["animations", "Animations", "animation", "Animation"].forEach((base) => bases.add(base));
    }
    animationBases = [...bases];
    return animationBases;
  }
  function subscribeSprite(key2, el2, config) {
    let subs = spriteSubscribers.get(key2);
    if (!subs) {
      subs = /* @__PURE__ */ new Set();
      spriteSubscribers.set(key2, subs);
    }
    subs.add(el2);
    spriteConfig.set(el2, config);
  }
  function notifySpriteSubscribers(key2, src) {
    const subs = spriteSubscribers.get(key2);
    if (!subs) return;
    subs.forEach((el2) => {
      if (!el2.isConnected) {
        subs.delete(el2);
        spriteConfig.delete(el2);
        return;
      }
      applySprite(el2, src);
    });
    if (subs.size === 0) {
      spriteSubscribers.delete(key2);
    }
  }
  function ensureSpriteListener() {
    if (listenerAttached || typeof window === "undefined") return;
    listenerAttached = true;
    window.addEventListener("mg:sprite-detected", () => {
      spriteCache.clear();
      spritePromises.clear();
      animationBases = null;
      const keys = Array.from(spriteSubscribers.keys());
      keys.forEach((key2) => {
        void loadSprite(key2);
      });
    });
  }
  function applySprite(el2, src) {
    const cfg = spriteConfig.get(el2);
    if (!cfg) return;
    const { size, fallback, alt } = cfg;
    el2.innerHTML = "";
    el2.style.display = "inline-flex";
    el2.style.alignItems = "center";
    el2.style.justifyContent = "center";
    el2.style.width = `${size}px`;
    el2.style.height = `${size}px`;
    el2.style.flexShrink = "0";
    el2.style.position = "relative";
    el2.setAttribute("role", "img");
    if (src) {
      el2.removeAttribute("aria-label");
      el2.style.fontSize = "";
      const img = document.createElement("img");
      img.src = src;
      img.alt = alt;
      img.decoding = "async";
      img.loading = "lazy";
      img.draggable = false;
      img.style.width = "100%";
      img.style.height = "100%";
      img.style.objectFit = "contain";
      el2.appendChild(img);
    } else {
      el2.textContent = fallback;
      el2.style.fontSize = `${Math.max(10, Math.round(size * 0.72))}px`;
      if (alt) el2.setAttribute("aria-label", alt);
      else el2.removeAttribute("aria-label");
    }
  }
  async function fetchSprite(key2) {
    const index = weatherTileIndices.get(key2);
    if (index == null) return null;
    const bases = getAnimationBases();
    for (const base of bases) {
      try {
        const tile = await Sprites.getTile(base, index, "canvas");
        const canvas = tile?.data;
        if (!canvas || canvas.width <= 0 || canvas.height <= 0) continue;
        const copy2 = document.createElement("canvas");
        copy2.width = canvas.width;
        copy2.height = canvas.height;
        const ctx = copy2.getContext("2d");
        if (!ctx) continue;
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(canvas, 0, 0);
        return copy2.toDataURL();
      } catch {
      }
    }
    return null;
  }
  function loadSprite(key2) {
    if (typeof window === "undefined") {
      spriteCache.set(key2, null);
      notifySpriteSubscribers(key2, null);
      return Promise.resolve(null);
    }
    const cached = spriteCache.get(key2);
    if (cached !== void 0) {
      notifySpriteSubscribers(key2, cached);
      return Promise.resolve(cached);
    }
    const inflight = spritePromises.get(key2);
    if (inflight) return inflight;
    const promise = fetchSprite(key2).then((src) => {
      spriteCache.set(key2, src);
      spritePromises.delete(key2);
      notifySpriteSubscribers(key2, src);
      return src;
    }).catch(() => {
      spritePromises.delete(key2);
      return null;
    });
    spritePromises.set(key2, promise);
    return promise;
  }
  function getWeatherSpriteKey(raw) {
    return resolveSpriteKey(raw);
  }
  function createWeatherSprite(rawKey, options = {}) {
    const size = Math.max(12, options.size ?? 36);
    const fallback = String(options.fallback ?? "\u{1F326}");
    const alt = typeof options.alt === "string" ? options.alt : "";
    const el2 = document.createElement("span");
    spriteConfig.set(el2, { size, fallback, alt });
    if (typeof window === "undefined") {
      applySprite(el2, null);
      return el2;
    }
    ensureSpriteListener();
    const key2 = resolveSpriteKey(rawKey);
    if (!key2) {
      applySprite(el2, null);
      return el2;
    }
    subscribeSprite(key2, el2, { size, fallback, alt });
    applySprite(el2, spriteCache.get(key2) ?? null);
    void loadSprite(key2);
    return el2;
  }

  // src/services/notifier.ts
  var LS_PREFS_KEY = "qws:shop:notifs:v1";
  var LS_RULES_KEY = "qws:shop:notifs:rules.v1";
  var LS_WEATHER_PREFS_KEY = "qws:weather:notifs:v1";
  var LS_CONTEXT_DEFAULTS_KEY = "qws:notifier:loopDefaults.v1";
  var DISPLAY_RARITY = {
    [rarity.Common]: "Common",
    [rarity.Uncommon]: "Uncommon",
    [rarity.Rare]: "Rare",
    [rarity.Legendary]: "Legendary",
    [rarity.Mythic]: "Mythical",
    [rarity.Divine]: "Divine",
    [rarity.Celestial]: "Celestial"
  };
  var norm2 = (s) => String(s ?? "").toLowerCase();
  var formatRuleSummary = (rule) => {
    if (!rule) return "";
    const parts = [];
    if (rule.sound) {
      const names = audio.listSounds();
      const label2 = names.includes(rule.sound) ? rule.sound : rule.sound.length > 32 ? `${rule.sound.slice(0, 29)}\u2026` : rule.sound;
      parts.push(`Sound: ${label2}`);
    }
    if (rule.playbackMode === "oneshot") parts.push("Mode: One-shot");
    else if (rule.playbackMode === "loop") parts.push("Mode: Loop");
    if (rule.stopMode === "purchase") parts.push("Stop: Until purchase");
    else if (rule.stopMode === "manual") parts.push("Stop: Manual");
    if (rule.loopIntervalMs != null) {
      const raw = Number(rule.loopIntervalMs);
      if (Number.isFinite(raw)) {
        const ms = Math.max(1, Math.round(raw));
        const seconds = ms / 1e3;
        const label2 = seconds >= 1 ? `${(seconds >= 10 ? Math.round(seconds) : Math.round(seconds * 10) / 10).toFixed(seconds >= 10 ? 0 : 1)} s` : `${ms} ms`;
        parts.push(`Interval: ${label2}`);
      }
    }
    return parts.join(" \u2022 ");
  };
  var formatLastSeen = (timestamp, isCurrent) => {
    if (isCurrent) {
      const title = timestamp ? new Date(timestamp).toLocaleString() : "Currently active";
      return { label: "Now", title };
    }
    if (!timestamp) return { label: "Never", title: "Never seen" };
    const now2 = Date.now();
    const diff = Math.max(0, now2 - timestamp);
    let label2;
    if (diff < 45e3) label2 = "Just now";
    else if (diff < 9e4) label2 = "1 min ago";
    else if (diff < 60 * 60 * 1e3) {
      const mins = Math.round(diff / 6e4);
      label2 = `${mins} min${mins > 1 ? "s" : ""} ago`;
    } else if (diff < 36 * 60 * 60 * 1e3) {
      const hours = Math.round(diff / 36e5);
      label2 = `${hours} hour${hours > 1 ? "s" : ""} ago`;
    } else {
      const days = Math.round(diff / 864e5);
      label2 = `${days} day${days > 1 ? "s" : ""} ago`;
    }
    return { label: label2, title: new Date(timestamp).toLocaleString() };
  };
  var weatherStateSignature = (rows) => JSON.stringify(
    rows.map((r) => [r.id, r.notify ? 1 : 0, r.lastSeen || 0, r.isCurrent ? 1 : 0])
  );
  var formatWeatherMutation = (mutation) => {
    const parts = [mutation.name];
    if (mutation.multiplier != null) {
      const raw = Number(mutation.multiplier);
      if (Number.isFinite(raw)) {
        const rounded = Math.abs(raw - Math.round(raw)) < 0.01 ? Math.round(raw) : Math.round(raw * 100) / 100;
        parts[0] = `${parts[0]} \xD7${rounded}`;
      }
    }
    return parts.join(" ");
  };
  var normalizeNumber = (value) => {
    const num = typeof value === "number" ? value : Number(value);
    return Number.isFinite(num) ? num : void 0;
  };
  var normalizeCycle = (raw) => {
    if (!raw || typeof raw !== "object") return null;
    const rawKind = typeof raw.kind === "string" ? raw.kind.trim() : "";
    const kindLc = rawKind.toLowerCase();
    let kind = "unknown";
    if (kindLc === "weather" || kindLc === "lunar" || kindLc === "base") kind = kindLc;
    const meta = { kind, rawKind: rawKind || void 0 };
    const startWindowMin = normalizeNumber(raw.startWindowMin);
    if (startWindowMin !== void 0) meta.startWindowMin = startWindowMin;
    const startWindowMax = normalizeNumber(raw.startWindowMax);
    if (startWindowMax !== void 0) meta.startWindowMax = startWindowMax;
    const durationMinutes = normalizeNumber(raw.durationMinutes);
    if (durationMinutes !== void 0) meta.durationMinutes = durationMinutes;
    const periodMinutes = normalizeNumber(raw.periodMinutes);
    if (periodMinutes !== void 0) meta.periodMinutes = periodMinutes;
    return meta;
  };
  var normalizeMutations = (raw) => {
    if (!Array.isArray(raw)) return [];
    const items = [];
    for (const entry of raw) {
      if (!entry || typeof entry !== "object") continue;
      const name = typeof entry.name === "string" ? entry.name.trim() : "";
      if (!name) continue;
      const mutation = { name };
      const multiplier = normalizeNumber(entry.multiplier);
      if (multiplier !== void 0) mutation.multiplier = multiplier;
      const conditional = typeof entry.conditional === "string" ? entry.conditional.trim() : "";
      if (conditional) mutation.conditional = conditional;
      items.push(mutation);
    }
    return items;
  };
  var WEATHER_DEFS = (() => {
    const entries = [];
    for (const [rawName, rawValue] of Object.entries(weatherCatalog ?? {})) {
      const safeName = String(rawName || "").trim();
      if (!safeName) continue;
      const rawDisplayName = typeof rawValue?.displayName === "string" ? String(rawValue.displayName).trim() : "";
      const displayName = (rawDisplayName || safeName).replace(/([a-z])([A-Z])/g, "$1 $2").replace(/_/g, " ").replace(/\s+/g, " ").trim();
      const atomValue = typeof rawValue?.atomValue === "string" ? String(rawValue.atomValue).trim() : "";
      const spriteKey2 = getWeatherSpriteKey(safeName) ?? getWeatherSpriteKey(rawDisplayName) ?? null;
      const type = atomValue || displayName;
      const description = typeof rawValue?.description === "string" ? String(rawValue.description).trim() : null;
      const weightInCycle = normalizeNumber(rawValue?.weightInCycle);
      const cycle = normalizeCycle(rawValue?.cycle);
      const mutations = normalizeMutations(rawValue?.mutations);
      entries.push({
        id: `Weather:${safeName}`,
        name: displayName || safeName,
        atomValue,
        spriteKey: spriteKey2,
        type,
        description,
        cycle,
        weightInCycle: weightInCycle ?? null,
        mutations
      });
    }
    return entries;
  })();
  var WEATHER_BY_ID = /* @__PURE__ */ new Map();
  var WEATHER_BY_ATOM = /* @__PURE__ */ new Map();
  var WEATHER_BY_NAME = /* @__PURE__ */ new Map();
  for (const def of WEATHER_DEFS) {
    WEATHER_BY_ID.set(def.id, def);
    WEATHER_BY_NAME.set(def.name.toLowerCase(), def);
    WEATHER_BY_ATOM.set(def.atomValue.toLowerCase(), def);
    WEATHER_BY_NAME.set(def.id.slice("Weather:".length).toLowerCase(), def);
  }
  var _staticMeta = null;
  function buildStaticMeta() {
    if (_staticMeta) return _staticMeta;
    const map2 = /* @__PURE__ */ new Map();
    for (const [species, entry] of Object.entries(plantCatalog)) {
      if (entry?.seed) {
        const id = `Seed:${species}`;
        map2.set(id, {
          type: "Seed",
          name: entry.seed.name,
          rarity: DISPLAY_RARITY[entry.seed.rarity] ?? entry.seed.rarity
        });
      }
    }
    for (const [eggId, entry] of Object.entries(eggCatalog)) {
      const id = `Egg:${eggId}`;
      map2.set(id, {
        type: "Egg",
        name: entry.name,
        rarity: DISPLAY_RARITY[entry.rarity] ?? entry.rarity
      });
    }
    for (const [toolId, entry] of Object.entries(toolCatalog)) {
      const id = `Tool:${toolId}`;
      map2.set(id, {
        type: "Tool",
        name: entry.name,
        rarity: DISPLAY_RARITY[entry.rarity] ?? entry.rarity
      });
    }
    for (const [decorId, entry] of Object.entries(decorCatalog)) {
      const id = `Decor:${decorId}`;
      map2.set(id, {
        type: "Decor",
        name: entry.name,
        rarity: DISPLAY_RARITY[entry.rarity] ?? entry.rarity
      });
    }
    _staticMeta = map2;
    return map2;
  }
  var _prefs = /* @__PURE__ */ new Map();
  var _weatherPrefs = /* @__PURE__ */ new Map();
  var _weatherPrefsLoaded = false;
  var _contextDefaults = {};
  var _contextDefaultsLoaded = false;
  var _rules = /* @__PURE__ */ new Map();
  var _rulesLoaded = false;
  var _rulesSubs = /* @__PURE__ */ new Set();
  var _hasOwn = Object.prototype.hasOwnProperty;
  var _weatherState = null;
  var _weatherSig = null;
  var _weatherSubs = /* @__PURE__ */ new Set();
  var _currentWeatherId = null;
  var _currentWeatherValue = null;
  var _unsubWeather = null;
  function _ensureRulesLoaded() {
    if (_rulesLoaded) return;
    _rulesLoaded = true;
    _rules = /* @__PURE__ */ new Map();
    try {
      const raw = localStorage.getItem(LS_RULES_KEY);
      const obj = raw ? JSON.parse(raw) : null;
      if (obj && typeof obj === "object") {
        for (const [id, value] of Object.entries(obj)) {
          const norm3 = _normalizeRule(value);
          if (norm3) _rules.set(String(id), norm3);
        }
      }
    } catch {
      _rules = /* @__PURE__ */ new Map();
    }
  }
  function _normalizeRule(raw) {
    const patch = {};
    if (_hasOwn.call(raw ?? {}, "sound")) patch.sound = raw?.sound ?? null;
    if (_hasOwn.call(raw ?? {}, "playbackMode")) patch.playbackMode = raw?.playbackMode ?? null;
    if (_hasOwn.call(raw ?? {}, "stopMode")) patch.stopMode = raw?.stopMode ?? null;
    if (_hasOwn.call(raw ?? {}, "stopRepeats")) patch.stopRepeats = raw?.stopRepeats ?? null;
    if (_hasOwn.call(raw ?? {}, "loopIntervalMs")) patch.loopIntervalMs = raw?.loopIntervalMs ?? null;
    return _mergeRule(void 0, patch);
  }
  function _saveRules() {
    if (!_rulesLoaded) return;
    try {
      const obj = {};
      for (const [id, rule] of _rules.entries()) {
        obj[id] = { ...rule };
      }
      localStorage.setItem(LS_RULES_KEY, JSON.stringify(obj));
    } catch {
    }
  }
  function _ensureWeatherPrefsLoaded() {
    if (_weatherPrefsLoaded) return;
    _weatherPrefsLoaded = true;
    _weatherPrefs = /* @__PURE__ */ new Map();
    try {
      const raw = localStorage.getItem(LS_WEATHER_PREFS_KEY);
      if (!raw) return;
      const obj = JSON.parse(raw);
      if (obj && typeof obj === "object") {
        for (const [id, value] of Object.entries(obj)) {
          if (!id) continue;
          const pref = {};
          if (typeof value?.notify === "boolean") pref.notify = !!value.notify;
          if (typeof value?.lastSeen === "number" && Number.isFinite(value.lastSeen)) {
            pref.lastSeen = Number(value.lastSeen);
          }
          _weatherPrefs.set(String(id), pref);
        }
      }
    } catch {
      _weatherPrefs = /* @__PURE__ */ new Map();
    }
  }
  function _saveWeatherPrefs() {
    if (!_weatherPrefsLoaded) return;
    try {
      const obj = {};
      for (const [id, pref] of _weatherPrefs.entries()) {
        const entry = {};
        if (pref.notify) entry.notify = true;
        if (typeof pref.lastSeen === "number" && Number.isFinite(pref.lastSeen)) entry.lastSeen = pref.lastSeen;
        if (entry.notify || entry.lastSeen != null) obj[id] = entry;
      }
      localStorage.setItem(LS_WEATHER_PREFS_KEY, JSON.stringify(obj));
    } catch {
    }
  }
  function _getWeatherPref(id) {
    _ensureWeatherPrefsLoaded();
    const existing = _weatherPrefs.get(id);
    if (existing) return existing;
    const fresh = {};
    _weatherPrefs.set(id, fresh);
    return fresh;
  }
  function _ensureContextDefaultsLoaded() {
    if (_contextDefaultsLoaded) return;
    _contextDefaultsLoaded = true;
    _contextDefaults = {};
    try {
      const raw = localStorage.getItem(LS_CONTEXT_DEFAULTS_KEY);
      if (!raw) return;
      const obj = JSON.parse(raw);
      if (obj && typeof obj === "object") {
        for (const [context, value] of Object.entries(obj)) {
          const ctx = context;
          if (ctx !== "shops" && ctx !== "weather") continue;
          const modeRaw = value?.stopMode;
          const stopMode = modeRaw === "purchase" ? "purchase" : "manual";
          const repeatsRaw = Number(value?.stopRepeats);
          const stopRepeats = Number.isFinite(repeatsRaw) ? Math.max(1, Math.floor(repeatsRaw)) : null;
          const intervalRaw = Number(value?.loopIntervalMs);
          const playback = audio.getPlaybackSettings(ctx);
          const baseLoop = Number.isFinite(intervalRaw) ? intervalRaw : playback.loopIntervalMs;
          const loopIntervalMs = Math.max(150, Math.floor(baseLoop || 0));
          _contextDefaults[ctx] = { stopMode, stopRepeats, loopIntervalMs };
        }
      }
    } catch {
      _contextDefaults = {};
    }
  }
  function _saveContextDefaults() {
    if (!_contextDefaultsLoaded) return;
    try {
      const obj = {};
      for (const [ctx, value] of Object.entries(_contextDefaults)) {
        if (!value) continue;
        const loopIntervalMs = Math.max(150, Math.floor(value.loopIntervalMs | 0));
        const normalizedRepeats = value.stopRepeats != null ? Math.max(1, Math.floor(value.stopRepeats | 0)) : null;
        obj[ctx] = {
          stopMode: value.stopMode,
          stopRepeats: normalizedRepeats,
          loopIntervalMs
        };
      }
      localStorage.setItem(LS_CONTEXT_DEFAULTS_KEY, JSON.stringify(obj));
    } catch {
    }
  }
  function _getContextStopDefaultsInternal(context) {
    _ensureContextDefaultsLoaded();
    const stored = _contextDefaults[context];
    const playback = audio.getPlaybackSettings(context);
    const playbackLoop = Math.max(150, Math.floor(playback.loopIntervalMs || 0));
    const storedLoop = stored?.loopIntervalMs;
    const loopIntervalMs = Math.max(150, Math.floor(storedLoop ?? playbackLoop));
    const storedMode = stored?.stopMode === "purchase" ? "purchase" : null;
    const playbackMode = playback.stop.mode === "purchase" ? "purchase" : null;
    if (context === "shops") {
      const stopMode = storedMode ?? playbackMode ?? "purchase";
      return { stopMode, stopRepeats: null, loopIntervalMs };
    }
    return { stopMode: "manual", stopRepeats: null, loopIntervalMs };
  }
  function _notifyWeather() {
    if (!_weatherState) return;
    _weatherSubs.forEach((fn) => {
      try {
        fn(_weatherState);
      } catch {
      }
    });
  }
  function _recomputeWeatherState() {
    _ensureWeatherPrefsLoaded();
    const rows = WEATHER_DEFS.map((def) => {
      const pref = _getWeatherPref(def.id);
      const notify = !!pref.notify;
      const lastSeen = typeof pref.lastSeen === "number" && Number.isFinite(pref.lastSeen) ? pref.lastSeen : null;
      return {
        id: def.id,
        name: def.name,
        type: def.type,
        spriteKey: def.spriteKey,
        atomValue: def.atomValue,
        notify,
        lastSeen,
        isCurrent: def.id === _currentWeatherId,
        description: def.description,
        cycle: def.cycle ? { ...def.cycle } : null,
        weightInCycle: def.weightInCycle,
        mutations: def.mutations.map((mutation) => ({ ...mutation }))
      };
    });
    const sig = JSON.stringify(rows.map((r) => [r.id, r.notify ? 1 : 0, r.lastSeen || 0, r.isCurrent ? 1 : 0]));
    const changed = sig !== _weatherSig;
    _weatherSig = sig;
    _weatherState = {
      updatedAt: Date.now(),
      currentId: _currentWeatherId,
      rows
    };
    if (changed) _notifyWeather();
  }
  function _buildWeatherOverrides(id) {
    const overrides = {};
    const rule = _rules.get(id);
    if (rule?.sound) overrides.sound = rule.sound;
    overrides.mode = "oneshot";
    return overrides;
  }
  function _triggerWeatherNotification(id) {
    const def = WEATHER_BY_ID.get(id);
    if (!def) return;
    const overrides = _buildWeatherOverrides(id);
    audio.trigger(id, overrides, "weather").catch(() => {
    });
  }
  function _handleWeatherUpdate(raw, opts = {}) {
    const normalize3 = (value) => {
      if (value == null) return "";
      if (typeof value === "string") return value.trim();
      return String(value || "").trim();
    };
    const nextValue = normalize3(raw);
    if (!opts.force && _currentWeatherValue === nextValue) return;
    const lookupKey = nextValue.toLowerCase();
    let def = WEATHER_BY_ATOM.get(lookupKey) || WEATHER_BY_NAME.get(lookupKey);
    if (!def && lookupKey) {
      const noSpace = lookupKey.replace(/\s+/g, "");
      def = WEATHER_BY_NAME.get(noSpace);
    }
    const prevId = _currentWeatherId;
    const now2 = Date.now();
    if (def) {
      const pref = _getWeatherPref(def.id);
      pref.lastSeen = now2;
      _weatherPrefs.set(def.id, pref);
    }
    _currentWeatherId = def?.id ?? null;
    _currentWeatherValue = nextValue;
    if (_currentWeatherId) {
      StatsService.incrementWeatherStat(_currentWeatherId.replace("Weather:", ""));
    }
    if (prevId && prevId !== _currentWeatherId) {
      audio.stopLoop(prevId);
    }
    if (def && _getWeatherPref(def.id).notify) {
      _triggerWeatherNotification(def.id);
    }
    if (def) _saveWeatherPrefs();
    _recomputeWeatherState();
  }
  function _rulesEqual(a, b) {
    if (!a && !b) return true;
    if (!a || !b) return false;
    return a.sound === b.sound && a.playbackMode === b.playbackMode && a.stopMode === b.stopMode && a.loopIntervalMs === b.loopIntervalMs;
  }
  function _sanitizeSound(value) {
    if (typeof value !== "string") return void 0;
    const trimmed = value.trim();
    return trimmed ? trimmed : void 0;
  }
  function _sanitizePlaybackMode(value) {
    if (value == null) return void 0;
    const v = String(value);
    return v === "oneshot" || v === "loop" ? v : void 0;
  }
  function _sanitizeStopMode(value) {
    if (value == null) return void 0;
    const v = String(value);
    if (v === "purchase") return "purchase";
    return void 0;
  }
  function _sanitizeLoopInterval(value) {
    if (value == null) return void 0;
    const n = Number(value);
    if (!Number.isFinite(n)) return void 0;
    const normalized = Math.max(150, Math.floor(n));
    return normalized >= 150 ? normalized : void 0;
  }
  function _mergeRule(prev, patch) {
    const next = { ...prev ?? {} };
    if (_hasOwn.call(patch, "sound")) {
      const s = _sanitizeSound(patch.sound);
      if (s) next.sound = s;
      else delete next.sound;
    }
    if (_hasOwn.call(patch, "playbackMode")) {
      const mode = _sanitizePlaybackMode(patch.playbackMode);
      if (mode) next.playbackMode = mode;
      else delete next.playbackMode;
    }
    if (_hasOwn.call(patch, "stopMode")) {
      const mode = _sanitizeStopMode(patch.stopMode);
      if (mode) next.stopMode = mode;
      else delete next.stopMode;
      delete next.stopRepeats;
    }
    if (_hasOwn.call(patch, "stopRepeats")) {
      delete next.stopRepeats;
    }
    if (_hasOwn.call(patch, "loopIntervalMs")) {
      const interval = _sanitizeLoopInterval(patch.loopIntervalMs);
      if (interval != null) next.loopIntervalMs = interval;
      else delete next.loopIntervalMs;
    }
    return Object.keys(next).length ? next : null;
  }
  function _rulesSnapshot() {
    _ensureRulesLoaded();
    const out = {};
    for (const [id, rule] of _rules.entries()) {
      out[id] = {
        ...rule.sound ? { sound: rule.sound } : {},
        ...rule.playbackMode ? { playbackMode: rule.playbackMode } : {},
        ...rule.stopMode ? { stopMode: rule.stopMode } : {},
        ...rule.loopIntervalMs != null ? { loopIntervalMs: rule.loopIntervalMs } : {}
      };
    }
    return out;
  }
  function _emitRules() {
    if (!_rulesLoaded) return;
    const snap = _rulesSnapshot();
    _rulesSubs.forEach((fn) => {
      try {
        fn(snap);
      } catch {
      }
    });
  }
  function _loadPrefs() {
    try {
      const raw = localStorage.getItem(LS_PREFS_KEY);
      const obj = raw ? JSON.parse(raw) : {};
      const m = /* @__PURE__ */ new Map();
      if (obj && typeof obj === "object") {
        for (const [k, v] of Object.entries(obj)) {
          const n = Number(v) | 0;
          const popupBits = n & 1;
          if (k && popupBits !== void 0) m.set(String(k), popupBits);
        }
      }
      _prefs = m;
    } catch {
      _prefs = /* @__PURE__ */ new Map();
    }
  }
  function _savePrefs() {
    try {
      const obj = {};
      for (const [k, v] of _prefs) obj[k] = v & 1;
      localStorage.setItem(LS_PREFS_KEY, JSON.stringify(obj));
    } catch {
    }
  }
  var _getPrefBits = (id) => (_prefs.get(id) ?? 0) & 1;
  var _setPrefBits = (id, bits) => {
    if (!id) return;
    const masked = bits & 1;
    if (masked) _prefs.set(id, masked);
    else _prefs.delete(id);
    _savePrefs();
    _recomputeFromCacheAndNotify();
  };
  var _rowsById = /* @__PURE__ */ new Map();
  var _lastSig = "";
  var _state = null;
  var _unsubShops = null;
  var _unsubPurchases = null;
  var _subs = /* @__PURE__ */ new Set();
  var _toolInv = /* @__PURE__ */ new Map();
  var _unsubToolInv = null;
  var TOOL_CAPS = {
    Shovel: 1,
    WateringCan: 99
  };
  function _isToolCapReached(toolId) {
    const cap = TOOL_CAPS[toolId];
    if (!cap) return false;
    const q = _toolInv.get(toolId) || 0;
    return q >= cap;
  }
  function _updateToolInv(raw) {
    try {
      const arr = Array.isArray(raw) ? raw : [];
      _toolInv = new Map(arr.map((it) => [String(it.toolId), Number(it.quantity) || 0]));
    } catch {
      _toolInv = /* @__PURE__ */ new Map();
    }
    _recomputeFromCacheAndNotify();
  }
  function _resolveToolInvAtom() {
    const a = Atoms;
    return a.inventory?.myToolInventory ?? a.shop?.myToolInventory ?? a.myToolInventoryAtom ?? null;
  }
  function _computeSig(ids) {
    return ids.slice().sort().join("|");
  }
  var _purchasesSubs = /* @__PURE__ */ new Set();
  function _coercePurchases(raw) {
    const co = (sec) => ({
      createdAt: Number(sec?.createdAt) || 0,
      purchases: sec?.purchases && typeof sec.purchases === "object" ? sec.purchases : {}
    });
    return {
      seed: co(raw?.seed),
      egg: co(raw?.egg),
      tool: co(raw?.tool),
      decor: co(raw?.decor)
    };
  }
  function _notifyPurchases(raw) {
    const snap = _coercePurchases(raw);
    _purchasesSubs.forEach((fn) => {
      try {
        fn(snap);
      } catch {
      }
    });
  }
  var _shopsSubs = /* @__PURE__ */ new Set();
  function _coerceSnap(raw) {
    const co = (sec) => ({
      inventory: Array.isArray(sec?.inventory) ? sec.inventory : [],
      secondsUntilRestock: Number(sec?.secondsUntilRestock) || 0
    });
    return {
      seed: co(raw?.seed),
      egg: co(raw?.egg),
      tool: co(raw?.tool),
      decor: co(raw?.decor)
    };
  }
  function _notifyShops(raw) {
    const snap = _coerceSnap(raw);
    _shopsSubs.forEach((fn) => {
      try {
        fn(snap);
      } catch {
      }
    });
  }
  function _recomputeFromRaw(raw) {
    const staticMeta = buildStaticMeta();
    const sections = [
      { key: "seed", type: "Seed" },
      { key: "egg", type: "Egg" },
      { key: "tool", type: "Tool" },
      { key: "decor", type: "Decor" }
    ];
    const seen = /* @__PURE__ */ new Set();
    for (const { key: key2, type } of sections) {
      const sec = raw?.[key2] ?? {};
      const inv = Array.isArray(sec?.inventory) ? sec.inventory : [];
      for (const entry of inv) {
        const id = type === "Seed" ? `Seed:${entry.species}` : type === "Egg" ? `Egg:${entry.eggId}` : type === "Tool" ? `Tool:${entry.toolId}` : `Decor:${entry.decorId}`;
        seen.add(id);
        const meta = staticMeta.get(id);
        const bits = _getPrefBits(id);
        const popup = !!(bits & 1);
        const row = {
          id,
          type,
          name: meta?.name ?? id.split(":")[1] ?? id,
          rarity: meta?.rarity,
          popup,
          followed: popup
          // compat
        };
        _rowsById.set(id, row);
      }
    }
    for (const id of Array.from(_rowsById.keys())) {
      if (!seen.has(id)) _rowsById.delete(id);
    }
    const rows = Array.from(_rowsById.values());
    const followed = rows.reduce((n, r) => n + (r.followed ? 1 : 0), 0);
    const next = {
      updatedAt: Date.now(),
      rows,
      counts: { items: rows.length, followed }
    };
    const sig = _computeSig(rows.map((r) => r.id));
    const changed = sig !== _lastSig;
    _state = next;
    if (changed) {
      _lastSig = sig;
      _notify();
    } else {
    }
  }
  function _recomputeFromCacheAndNotify() {
    if (!_state) return;
    for (const [id, row] of _rowsById) {
      const bits = _getPrefBits(id);
      let popup = !!(bits & 1);
      if (id.startsWith("Tool:")) {
        const toolId = id.slice(5);
        if (_isToolCapReached(toolId)) {
          popup = false;
        }
      }
      row.popup = popup;
      row.followed = popup;
    }
    const rows = Array.from(_rowsById.values());
    const followed = rows.reduce((n, r) => n + (r.followed ? 1 : 0), 0);
    _state = {
      ..._state,
      updatedAt: Date.now(),
      rows,
      counts: { items: rows.length, followed }
    };
    _notify();
  }
  function _notify() {
    if (!_state) return;
    const snap = { ..._state, rows: _state.rows.slice() };
    _subs.forEach((fn) => {
      try {
        fn(snap);
      } catch {
      }
    });
  }
  var _started = false;
  async function _ensureStarted() {
    if (_started) {
      return;
    }
    _started = true;
    _loadPrefs();
    _ensureRulesLoaded();
    try {
      const cur = await Atoms.shop.shops.get();
      _recomputeFromRaw(cur);
      _notifyShops(cur);
    } catch (err) {
    }
    try {
      _unsubShops = await Atoms.shop.shops.onChange((next) => {
        try {
          _recomputeFromRaw(next);
        } catch {
        }
        try {
          _notifyShops(next);
        } catch {
        }
      });
    } catch (err) {
    }
    try {
      const curP = await Atoms.shop.myShopPurchases.get();
      _notifyPurchases(curP);
    } catch (err) {
    }
    try {
      _unsubPurchases = await Atoms.shop.myShopPurchases.onChange((next) => {
        try {
          _notifyPurchases(next);
        } catch {
        }
      });
    } catch (err) {
    }
    try {
      const invAtom = _resolveToolInvAtom();
      if (invAtom) {
        try {
          _updateToolInv(await invAtom.get());
        } catch (err) {
        }
        try {
          _unsubToolInv = await invAtom.onChange((next) => {
            try {
              _updateToolInv(next);
            } catch {
            }
          });
        } catch (err) {
        }
      }
    } catch (err) {
    }
    try {
      const weatherAtom = Atoms.data?.weather;
      if (weatherAtom) {
        try {
          _handleWeatherUpdate(await weatherAtom.get(), { force: true });
        } catch (err) {
        }
        try {
          _unsubWeather = await weatherAtom.onChange((next) => {
            try {
              _handleWeatherUpdate(next);
            } catch {
            }
          });
        } catch (err) {
        }
      } else {
      }
    } catch (err) {
    }
  }
  function _stop() {
    try {
      _unsubShops?.();
    } catch {
    }
    _unsubShops = null;
    try {
      _unsubPurchases?.();
    } catch {
    }
    _unsubPurchases = null;
    try {
      _unsubToolInv?.();
    } catch {
    }
    _unsubToolInv = null;
    try {
      _unsubWeather?.();
    } catch {
    }
    _unsubWeather = null;
    if (_currentWeatherId) {
      try {
        audio.stopLoop(_currentWeatherId);
      } catch {
      }
    }
    _currentWeatherId = null;
    _currentWeatherValue = null;
    _started = false;
  }
  var NotifierService = {
    // lifecycle
    async start() {
      await _ensureStarted();
      return () => _stop();
    },
    async get() {
      await _ensureStarted();
      if (!_state) {
        _recomputeFromRaw(await Atoms.shop.shops.get().catch(() => null));
      }
      return _state;
    },
    onChange(cb) {
      _subs.add(cb);
      return () => {
        _subs.delete(cb);
      };
    },
    async onChangeNow(cb) {
      await _ensureStarted();
      if (_state) cb(_state);
      else {
        try {
          _recomputeFromRaw(await Atoms.shop.shops.get());
        } catch {
        }
        if (_state) cb(_state);
      }
      return this.onChange(cb);
    },
    onShopsChange(cb) {
      _shopsSubs.add(cb);
      return () => {
        _shopsSubs.delete(cb);
      };
    },
    async onShopsChangeNow(cb) {
      await _ensureStarted();
      try {
        cb(_coerceSnap(await Atoms.shop.shops.get()));
      } catch {
      }
      return this.onShopsChange(cb);
    },
    onPurchasesChange(cb) {
      _purchasesSubs.add(cb);
      return () => {
        _purchasesSubs.delete(cb);
      };
    },
    async onPurchasesChangeNow(cb) {
      await _ensureStarted();
      try {
        cb(_coercePurchases(await Atoms.shop.myShopPurchases.get()));
      } catch {
      }
      return this.onPurchasesChange(cb);
    },
    async getWeatherState() {
      await _ensureStarted();
      if (!_weatherState) _recomputeWeatherState();
      return _weatherState;
    },
    onWeatherChange(cb) {
      _weatherSubs.add(cb);
      return () => {
        _weatherSubs.delete(cb);
      };
    },
    async onWeatherChangeNow(cb) {
      await _ensureStarted();
      if (!_weatherState) _recomputeWeatherState();
      if (_weatherState) cb(_weatherState);
      return this.onWeatherChange(cb);
    },
    getWeatherNotify(id) {
      if (!id) return false;
      return !!_getWeatherPref(id).notify;
    },
    setWeatherNotify(id, enabled) {
      if (!id) return;
      _ensureWeatherPrefsLoaded();
      const pref = _getWeatherPref(id);
      const next = !!enabled;
      if (!!pref.notify === next) return;
      pref.notify = next;
      _weatherPrefs.set(id, pref);
      _saveWeatherPrefs();
      if (!next) {
        try {
          audio.stopLoop(id);
        } catch {
        }
      } else if (_currentWeatherId === id) {
        _triggerWeatherNotification(id);
      }
      _recomputeWeatherState();
    },
    getContextStopDefaults(context) {
      return _getContextStopDefaultsInternal(context);
    },
    setContextStopDefaults(context, conf) {
      if (context !== "shops" && context !== "weather") return;
      _ensureContextDefaultsLoaded();
      const current = _getContextStopDefaultsInternal(context);
      const loopRaw = Number(conf?.loopIntervalMs);
      const loopIntervalMs = Number.isFinite(loopRaw) ? Math.max(150, Math.floor(loopRaw)) : current.loopIntervalMs;
      const normalizedMode = conf.stopMode === "purchase" ? "purchase" : "manual";
      const normalized = {
        stopMode: context === "weather" ? "manual" : normalizedMode,
        stopRepeats: null,
        loopIntervalMs
      };
      _contextDefaults[context] = normalized;
      _saveContextDefaults();
    },
    // prefs (popup only)
    getPref(id) {
      if (id.startsWith("Tool:")) {
        const toolId = id.slice(5);
        if (_isToolCapReached(toolId)) {
          return { popup: false, followed: false };
        }
      }
      const bits = _getPrefBits(id);
      const popup = !!(bits & 1);
      return { popup, followed: popup };
    },
    setPopup(id, enabled) {
      if (enabled && id.startsWith("Tool:") && _isToolCapReached(id.slice(5))) {
        return;
      }
      const bits = _getPrefBits(id);
      const next = enabled ? bits | 1 : bits & ~1;
      _setPrefBits(id, next);
    },
    setPrefs(id, prefs) {
      const bits = _getPrefBits(id);
      let next = bits;
      if (typeof prefs.popup === "boolean") next = prefs.popup ? next | 1 : next & ~1;
      _setPrefBits(id, next);
    },
    clearPrefs(id) {
      _setPrefBits(id, 0);
    },
    isIdCapped(id) {
      if (!id.startsWith("Tool:")) return false;
      return _isToolCapReached(id.slice(5));
    },
    // pure filter util (no side-effects)
    filterRows(rows, f) {
      let arr = rows.slice();
      const ft = f.type ?? "all";
      if (ft && ft !== "all") {
        arr = arr.filter((r) => r.type.toLowerCase() === ft);
      }
      const fr = f.rarity ?? "all";
      if (fr !== "all") {
        arr = arr.filter((r) => norm2(r.rarity) === fr);
      }
      return arr;
    },
    getRule(id) {
      if (!id) return null;
      _ensureRulesLoaded();
      const rule = _rules.get(id);
      if (!rule) return null;
      return {
        ...rule.sound ? { sound: rule.sound } : {},
        ...rule.playbackMode ? { playbackMode: rule.playbackMode } : {},
        ...rule.stopMode ? { stopMode: rule.stopMode } : {},
        ...rule.loopIntervalMs != null ? { loopIntervalMs: rule.loopIntervalMs } : {}
      };
    },
    getAllRules() {
      return _rulesSnapshot();
    },
    setRule(id, patch) {
      if (!id || !patch || typeof patch !== "object") return;
      _ensureRulesLoaded();
      const prev = _rules.get(id);
      const next = _mergeRule(prev, patch);
      if (_rulesEqual(prev, next)) return;
      if (next) _rules.set(id, next);
      else _rules.delete(id);
      _saveRules();
      _emitRules();
    },
    clearRule(id) {
      if (!id) return;
      _ensureRulesLoaded();
      const existed = _rules.delete(id);
      if (existed) {
        _saveRules();
        _emitRules();
      }
    },
    onRulesChange(cb) {
      _ensureRulesLoaded();
      _rulesSubs.add(cb);
      return () => {
        _rulesSubs.delete(cb);
      };
    },
    async onRulesChangeNow(cb) {
      await _ensureStarted();
      cb(_rulesSnapshot());
      return this.onRulesChange(cb);
    }
  };

  // src/utils/shopSprites.ts
  var spriteConfig2 = /* @__PURE__ */ new WeakMap();
  var spriteSubscribers2 = /* @__PURE__ */ new Map();
  var spriteCache2 = /* @__PURE__ */ new Map();
  var spritePromises2 = /* @__PURE__ */ new Map();
  var listenerAttached2 = false;
  var seedSheetBases = null;
  var eggSheetBases = null;
  var itemSheetBases = null;
  var decorSheetBases = null;
  var FALLBACK_BASES = {
    Seed: ["seeds", "Seeds"],
    Egg: ["pets", "Pets", "eggs", "Eggs"],
    Tool: ["items", "Items"],
    Decor: ["decor", "Decor"]
  };
  function spriteKey(type, id) {
    return `${type}::${id}`;
  }
  function parseSpriteKey(key2) {
    const idx = key2.indexOf("::");
    if (idx <= 0) return null;
    const type = key2.slice(0, idx);
    const id = key2.slice(idx + 2);
    if (!id) return null;
    if (type !== "Seed" && type !== "Egg" && type !== "Tool" && type !== "Decor") return null;
    return { type, id };
  }
  function defaultFallback(type) {
    switch (type) {
      case "Seed":
        return "\u{1F331}";
      case "Egg":
        return "\u{1F95A}";
      case "Tool":
        return "\u{1F9F0}";
      default:
        return "\u{1F3E0}";
    }
  }
  function normalizeBase(url) {
    const clean = url.split(/[?#]/)[0] ?? url;
    const file = clean.split("/").pop() ?? clean;
    return file.replace(/\.[^.]+$/, "");
  }
  function uniqueBases(urls, fallback) {
    const set2 = /* @__PURE__ */ new Set();
    for (const url of urls) {
      if (typeof url === "string" && url.length) {
        set2.add(normalizeBase(url));
      }
    }
    if (set2.size === 0) {
      for (const base of fallback) set2.add(base);
    }
    return [...set2];
  }
  function getSeedSheetBases() {
    if (seedSheetBases) return seedSheetBases;
    try {
      if (typeof Sprites.listSeeds === "function") {
        seedSheetBases = uniqueBases(Sprites.listSeeds(), FALLBACK_BASES.Seed);
        return seedSheetBases;
      }
    } catch {
    }
    seedSheetBases = [...FALLBACK_BASES.Seed];
    return seedSheetBases;
  }
  function getEggSheetBases() {
    if (eggSheetBases) return eggSheetBases;
    try {
      if (typeof Sprites.listPets === "function") {
        eggSheetBases = uniqueBases(Sprites.listPets(), FALLBACK_BASES.Egg);
        return eggSheetBases;
      }
    } catch {
    }
    eggSheetBases = [...FALLBACK_BASES.Egg];
    return eggSheetBases;
  }
  function getItemSheetBases() {
    if (itemSheetBases) return itemSheetBases;
    try {
      if (typeof Sprites.listItems === "function") {
        itemSheetBases = uniqueBases(Sprites.listItems(), FALLBACK_BASES.Tool);
        return itemSheetBases;
      }
    } catch {
    }
    itemSheetBases = [...FALLBACK_BASES.Tool];
    return itemSheetBases;
  }
  function getDecorSheetBases() {
    if (decorSheetBases) return decorSheetBases;
    try {
      if (typeof Sprites.listTilesByCategory === "function") {
        decorSheetBases = uniqueBases(Sprites.listTilesByCategory(/decor/i), FALLBACK_BASES.Decor);
        return decorSheetBases;
      }
    } catch {
    }
    decorSheetBases = [...FALLBACK_BASES.Decor];
    return decorSheetBases;
  }
  function getBases(type) {
    switch (type) {
      case "Seed":
        return getSeedSheetBases();
      case "Egg":
        return getEggSheetBases();
      case "Tool":
        return getItemSheetBases();
      case "Decor":
        return getDecorSheetBases();
    }
  }
  function toTileIndex2(tileRef) {
    if (tileRef == null) return null;
    const value = typeof tileRef === "number" && Number.isFinite(tileRef) ? tileRef : Number(tileRef);
    if (!Number.isFinite(value)) return null;
    if (value <= 0) return value;
    return value - 1;
  }
  function getTileRef(type, id) {
    switch (type) {
      case "Seed":
        return plantCatalog?.[id]?.seed?.tileRef ?? null;
      case "Egg":
        return eggCatalog?.[id]?.tileRef ?? null;
      case "Tool":
        return toolCatalog?.[id]?.tileRef ?? null;
      case "Decor":
        return decorCatalog?.[id]?.tileRef ?? null;
    }
  }
  function subscribeSprite2(key2, el2) {
    let subs = spriteSubscribers2.get(key2);
    if (!subs) {
      subs = /* @__PURE__ */ new Set();
      spriteSubscribers2.set(key2, subs);
    }
    subs.add(el2);
  }
  function unsubscribeIfDisconnected(key2, el2) {
    const subs = spriteSubscribers2.get(key2);
    if (!subs) return;
    if (!el2.isConnected) {
      subs.delete(el2);
      spriteConfig2.delete(el2);
    }
    if (subs.size === 0) {
      spriteSubscribers2.delete(key2);
    }
  }
  function applySprite2(el2, src) {
    const cfg = spriteConfig2.get(el2);
    if (!cfg) return;
    const { size, fallback, alt } = cfg;
    el2.innerHTML = "";
    el2.style.display = "inline-flex";
    el2.style.alignItems = "center";
    el2.style.justifyContent = "center";
    el2.style.width = `${size}px`;
    el2.style.height = `${size}px`;
    el2.style.flexShrink = "0";
    el2.style.position = "relative";
    el2.setAttribute("role", "img");
    if (src) {
      el2.removeAttribute("aria-label");
      el2.style.fontSize = "";
      const img = document.createElement("img");
      img.src = src;
      img.alt = alt;
      img.decoding = "async";
      img.loading = "lazy";
      img.draggable = false;
      img.style.width = "100%";
      img.style.height = "100%";
      img.style.objectFit = "contain";
      el2.appendChild(img);
    } else {
      el2.textContent = fallback;
      el2.style.fontSize = `${Math.max(10, Math.round(size * 0.72))}px`;
      el2.setAttribute("aria-label", alt || fallback);
    }
  }
  function notifySpriteSubscribers2(key2, src) {
    const subs = spriteSubscribers2.get(key2);
    if (!subs) return;
    subs.forEach((el2) => {
      if (!el2.isConnected) {
        unsubscribeIfDisconnected(key2, el2);
        return;
      }
      applySprite2(el2, src);
    });
  }
  function clearSheetCaches() {
    seedSheetBases = null;
    eggSheetBases = null;
    itemSheetBases = null;
    decorSheetBases = null;
  }
  async function fetchSprite2(type, id) {
    if (typeof window === "undefined") return null;
    if (typeof Sprites?.getTile !== "function") return null;
    const tileRef = getTileRef(type, id);
    const index = toTileIndex2(tileRef);
    if (index == null) return null;
    const bases = getBases(type);
    for (const base of bases) {
      try {
        const tile = await Sprites.getTile(base, index, "canvas");
        const canvas = tile?.data;
        if (!canvas || canvas.width <= 0 || canvas.height <= 0) continue;
        const copy2 = document.createElement("canvas");
        copy2.width = canvas.width;
        copy2.height = canvas.height;
        const ctx = copy2.getContext("2d");
        if (!ctx) continue;
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(canvas, 0, 0);
        return copy2.toDataURL();
      } catch {
      }
    }
    return null;
  }
  function ensureSpriteListener2() {
    if (listenerAttached2 || typeof window === "undefined") return;
    listenerAttached2 = true;
    window.addEventListener("mg:sprite-detected", () => {
      spriteCache2.clear();
      spritePromises2.clear();
      clearSheetCaches();
      const keys = Array.from(spriteSubscribers2.keys());
      keys.forEach((key2) => {
        const parsed = parseSpriteKey(key2);
        if (!parsed) return;
        void loadSprite2(parsed.type, parsed.id, key2);
      });
    });
  }
  function loadSprite2(type, id, key2 = spriteKey(type, id)) {
    if (typeof window === "undefined") {
      spriteCache2.set(key2, null);
      notifySpriteSubscribers2(key2, null);
      return Promise.resolve(null);
    }
    const cached = spriteCache2.get(key2);
    if (cached !== void 0) {
      notifySpriteSubscribers2(key2, cached);
      return Promise.resolve(cached);
    }
    const inflight = spritePromises2.get(key2);
    if (inflight) return inflight;
    const promise = fetchSprite2(type, id).then((src) => {
      spriteCache2.set(key2, src);
      spritePromises2.delete(key2);
      notifySpriteSubscribers2(key2, src);
      return src;
    }).catch(() => {
      spritePromises2.delete(key2);
      return null;
    });
    spritePromises2.set(key2, promise);
    return promise;
  }
  function createShopSprite(type, id, options = {}) {
    const size = Math.max(12, options.size ?? 36);
    const fallback = String(options.fallback ?? defaultFallback(type));
    const alt = typeof options.alt === "string" ? options.alt : "";
    const el2 = document.createElement("span");
    spriteConfig2.set(el2, { size, fallback, alt });
    if (typeof window === "undefined") {
      applySprite2(el2, null);
      return el2;
    }
    const key2 = spriteKey(type, id);
    subscribeSprite2(key2, el2);
    applySprite2(el2, spriteCache2.get(key2) ?? null);
    ensureSpriteListener2();
    void loadSprite2(type, id, key2);
    return el2;
  }

  // src/utils/catalogIndex.ts
  function seedNameFromSpecies(species, cat = plantCatalog) {
    const e = cat?.[species];
    return e?.seed?.name ?? e?.plant?.name ?? e?.crop?.name ?? void 0;
  }
  function eggNameFromId(eggId, cat = eggCatalog) {
    return cat?.[eggId]?.name ?? void 0;
  }
  function toolNameFromId(toolId, cat = toolCatalog) {
    return cat?.[toolId]?.name ?? void 0;
  }
  function decorNameFromId(decorId, cat = decorCatalog) {
    return cat?.[decorId]?.name ?? void 0;
  }

  // src/ui/menus/notificationOverlay.ts
  var style = (el2, s) => Object.assign(el2.style, s);
  var setProps = (el2, props) => {
    for (const [k, v] of Object.entries(props)) el2.style.setProperty(k, v);
  };
  function iconOf(id, size = 24) {
    const wrap = document.createElement("div");
    Object.assign(wrap.style, {
      width: `${size}px`,
      height: `${size}px`,
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      flex: `0 0 ${size}px`
    });
    const [rawType, rawId] = id.split(":");
    const type = rawType === "Seed" || rawType === "Egg" || rawType === "Tool" || rawType === "Decor" ? rawType : null;
    const fallback = type === "Seed" ? "\u{1F331}" : type === "Egg" ? "\u{1F95A}" : type === "Tool" ? "\u{1F9F0}" : type === "Decor" ? "\u{1F3E0}" : "\u{1F514}";
    if (type && rawId) {
      const sprite = createShopSprite(type, rawId, {
        size,
        fallback,
        alt: labelOf(id)
      });
      wrap.appendChild(sprite);
    } else {
      const span = document.createElement("span");
      span.textContent = fallback;
      span.style.fontSize = `${Math.max(10, size - 2)}px`;
      span.setAttribute("aria-hidden", "true");
      wrap.appendChild(span);
    }
    return wrap;
  }
  function labelOf(id) {
    const [type, raw] = id.split(":");
    switch (type) {
      case "Seed":
        return seedNameFromSpecies(raw) ?? raw;
      case "Egg":
        return eggNameFromId(raw) ?? raw;
      case "Tool":
        return toolNameFromId(raw) ?? raw;
      case "Decor":
        return decorNameFromId(raw) ?? raw;
      default:
        return raw;
    }
  }
  function purchasedCountForId(id, purchases) {
    if (!purchases) return 0;
    const [type, raw] = String(id).split(":");
    const sec = type === "Seed" ? purchases.seed : type === "Egg" ? purchases.egg : type === "Tool" ? purchases.tool : purchases.decor;
    if (!sec || !sec.purchases) return 0;
    const n = sec.purchases[raw];
    return typeof n === "number" && n > 0 ? n : 0;
  }
  var OverlayBarebone = class {
    constructor() {
      __publicField(this, "slot", document.createElement("div"));
      __publicField(this, "btn", document.createElement("button"));
      __publicField(this, "badge", document.createElement("span"));
      __publicField(this, "panel", document.createElement("div"));
      __publicField(this, "lastShops", null);
      __publicField(this, "lastPurch", null);
      // Suivi des IDs visibles dans l’overlay (pour loops & diff)
      __publicField(this, "prevOverlayIds", /* @__PURE__ */ new Set());
      __publicField(this, "currentOverlayIds", /* @__PURE__ */ new Set());
      __publicField(this, "rulesById", /* @__PURE__ */ new Map());
      __publicField(this, "shopUpdates", 0);
      __publicField(this, "purchasesUpdates", 0);
      __publicField(this, "bootArmed", false);
      __publicField(this, "justRestocked", false);
      __publicField(this, "mo", null);
      // Items à afficher dans l’overlay (déjà filtrés)
      __publicField(this, "rows", []);
      this.slot = this.createSlot();
      this.btn = this.createButton();
      this.ensureBellCSS();
      this.badge = this.createBadge();
      this.panel = this.createPanel();
      this.installScrollGuards(this.panel);
      let primedOnce = false;
      this.btn.onclick = async () => {
        if (!primedOnce) {
          primedOnce = true;
          try {
            await audio.prime();
          } catch {
          }
        }
        const on = this.panel.style.display !== "block";
        this.panel.style.display = on ? "block" : "none";
        if (on) this.renderPanel();
        this.updateBellWiggle();
      };
      this.slot.append(this.btn, this.badge, this.panel);
      this.attachLeftOfTargetCanvas();
      this.observeDomForRelocation();
      window.addEventListener("pointerdown", (e) => {
        if (this.panel.style.display !== "block") return;
        const t = e.target;
        if (!this.slot.contains(t)) this.panel.style.display = "none";
      });
      audio.setPurchaseChecker((itemId) => {
        if (!itemId) return false;
        if (this.currentOverlayIds.has(itemId)) return false;
        return purchasedCountForId(itemId, this.lastPurch) > 0;
      });
    }
    destroy() {
      try {
        this.mo?.disconnect();
      } catch {
      }
      try {
        this.slot.remove();
      } catch {
      }
      try {
        audio.stopAllLoops();
      } catch {
      }
    }
    ensureBellCSS() {
      if (document.getElementById("qws-bell-anim-css")) return;
      const style2 = document.createElement("style");
      style2.id = "qws-bell-anim-css";
      style2.textContent = `
@keyframes qwsBellShake {
  0% { transform: rotate(0deg); }
  10% { transform: rotate(-16deg); }
  20% { transform: rotate(12deg); }
  30% { transform: rotate(-10deg); }
  40% { transform: rotate(8deg); }
  50% { transform: rotate(-6deg); }
  60% { transform: rotate(4deg); }
  70% { transform: rotate(-2deg); }
  80% { transform: rotate(1deg); }
  100% { transform: rotate(0deg); }
}

/* Classe appliqu\xE9e sur le span cloche quand il y a des items dans l'overlay */
.qws-bell--wiggle {
  animation: qwsBellShake 1.2s ease-in-out infinite;
  transform-origin: 50% 0%;
  display: inline-block;
}

/* Respecte l'accessibilit\xE9 */
@media (prefers-reduced-motion: reduce) {
  .qws-bell--wiggle { animation: none !important; }
}
`;
      document.head.appendChild(style2);
    }
    /* ========= SETTERS (subs) ========= */
    setShops(s) {
      const prev = this.lastShops;
      this.lastShops = s;
      this.shopUpdates++;
      this.justRestocked = !!(prev && ((prev.seed?.secondsUntilRestock ?? 0) < (s.seed?.secondsUntilRestock ?? 0) || (prev.tool?.secondsUntilRestock ?? 0) < (s.tool?.secondsUntilRestock ?? 0) || (prev.egg?.secondsUntilRestock ?? 0) < (s.egg?.secondsUntilRestock ?? 0) || (prev.decor?.secondsUntilRestock ?? 0) < (s.decor?.secondsUntilRestock ?? 0)));
      this.recompute();
    }
    setPurchases(p) {
      this.lastPurch = p;
      this.purchasesUpdates++;
      this.recompute();
    }
    notifyStateUpdated() {
      void this.recompute();
    }
    setRules(rules) {
      this.rulesById.clear();
      for (const [id, rule] of Object.entries(rules)) {
        if (!id || !rule) continue;
        this.rulesById.set(id, { ...rule });
      }
      this.refreshActiveLoops();
    }
    /* ========= Core compute ========= */
    buildTriggerOverrides(rule) {
      if (!rule) return null;
      const overrides = {};
      if (rule.sound) overrides.sound = rule.sound;
      if (rule.playbackMode === "loop" || rule.playbackMode === "oneshot") {
        overrides.mode = rule.playbackMode;
      }
      if (rule.stopMode === "purchase") overrides.stop = { mode: "purchase" };
      else if (rule.stopMode === "manual") overrides.stop = { mode: "manual" };
      if (rule.loopIntervalMs != null && Number.isFinite(rule.loopIntervalMs)) {
        overrides.loopIntervalMs = Math.max(150, Math.floor(Number(rule.loopIntervalMs)));
      }
      return Object.keys(overrides).length ? overrides : null;
    }
    triggerMany(ids) {
      const entries = [];
      for (const id of ids) {
        const overrides = this.buildTriggerOverrides(this.rulesById.get(id)) ?? {};
        const mode = this.resolvePlaybackMode(id);
        const soundKey = overrides.sound ? `sound:${overrides.sound.trim().toLowerCase()}` : "sound:__default__";
        entries.push({ id, overrides, mode, soundKey });
      }
      if (!entries.length) return;
      const grouped = /* @__PURE__ */ new Map();
      for (const entry of entries) {
        const bucket = grouped.get(entry.soundKey) ?? { loops: [], oneshots: [] };
        if (entry.mode === "loop") bucket.loops.push(entry);
        else bucket.oneshots.push(entry);
        grouped.set(entry.soundKey, bucket);
      }
      for (const { loops, oneshots } of grouped.values()) {
        if (loops.length) {
          for (const entry of loops) {
            audio.trigger(entry.id, entry.overrides, "shops").catch(() => {
            });
          }
          continue;
        }
        if (oneshots.length) {
          const first = oneshots[0];
          audio.trigger(first.id, first.overrides, "shops").catch(() => {
          });
        }
      }
    }
    triggerWithRule(id) {
      this.triggerMany([id]);
    }
    resolvePlaybackMode(id) {
      const rule = this.rulesById.get(id);
      const baseMode = audio.getPlaybackMode("shops");
      if (!rule) return baseMode;
      if (rule.playbackMode === "loop") return "loop";
      if (rule.playbackMode === "oneshot") return "oneshot";
      if ((rule.stopMode || rule.loopIntervalMs != null) && baseMode === "loop") return "loop";
      return baseMode;
    }
    refreshActiveLoops() {
      if (!this.currentOverlayIds.size) return;
      const loopIds = [];
      for (const id of this.currentOverlayIds) {
        if (this.resolvePlaybackMode(id) === "loop") {
          audio.stopLoop(id);
          loopIds.push(id);
        }
      }
      if (loopIds.length) this.triggerMany(loopIds);
    }
    async recompute() {
      if (!this.lastShops || !this.lastPurch) return;
      const out = [];
      const consider = (id, initialStock, canSpawnHere) => {
        if (!canSpawnHere) return;
        const pref = NotifierService.getPref?.(id) || {};
        if (!pref.popup) return;
        const bought = purchasedCountForId(id, this.lastPurch);
        const remaining = Math.max(initialStock - bought, 0);
        if (remaining > 0) out.push({ id, qty: remaining });
      };
      for (const it of this.lastShops.seed.inventory) consider(`Seed:${it.species}`, it.initialStock, it.canSpawnHere);
      for (const it of this.lastShops.tool.inventory) consider(`Tool:${it.toolId}`, it.initialStock, it.canSpawnHere);
      for (const it of this.lastShops.egg.inventory) consider(`Egg:${it.eggId}`, it.initialStock, it.canSpawnHere);
      for (const it of this.lastShops.decor.inventory) consider(`Decor:${it.decorId}`, it.initialStock, it.canSpawnHere);
      this.rows = out;
      this.renderBadge();
      if (this.panel.style.display === "block") this.renderPanel();
      this.updateBellWiggle();
      const overlayIds = new Set(out.map((r) => r.id));
      this.currentOverlayIds = overlayIds;
      const shopEmpty = (this.lastShops.seed?.inventory?.length ?? 0) + (this.lastShops.tool?.inventory?.length ?? 0) + (this.lastShops.egg?.inventory?.length ?? 0) + (this.lastShops.decor?.inventory?.length ?? 0) === 0;
      const ready2 = this.shopUpdates >= 3 && this.purchasesUpdates >= 2 && !shopEmpty;
      if (!this.bootArmed) {
        if (!ready2) {
          this.prevOverlayIds = overlayIds;
          return;
        }
        this.bootArmed = true;
        if (overlayIds.size > 0) {
          this.triggerMany(overlayIds);
        }
        this.prevOverlayIds = overlayIds;
        this.justRestocked = false;
        return;
      }
      if (overlayIds.size === 0) {
        audio.stopAllLoops();
        this.prevOverlayIds = overlayIds;
        this.justRestocked = false;
        return;
      }
      if (this.justRestocked) {
        this.triggerMany(overlayIds);
        for (const oldId of this.prevOverlayIds) {
          if (!overlayIds.has(oldId)) audio.stopLoop(oldId);
        }
        this.prevOverlayIds = overlayIds;
        this.justRestocked = false;
        return;
      }
      const newIds = [];
      for (const id of overlayIds) {
        if (!this.prevOverlayIds.has(id)) {
          newIds.push(id);
        }
      }
      if (newIds.length) this.triggerMany(newIds);
      for (const oldId of this.prevOverlayIds) {
        if (!overlayIds.has(oldId)) {
          audio.stopLoop(oldId);
        }
      }
      this.prevOverlayIds = overlayIds;
      this.justRestocked = false;
    }
    /* ========= Render ========= */
    renderBadge() {
      const n = this.rows.length;
      this.badge.textContent = n ? String(n) : "";
      style(this.badge, { display: n ? "inline-flex" : "none" });
    }
    renderPanel() {
      this.panel.replaceChildren();
      const head = document.createElement("div");
      head.textContent = "Tracked items available";
      style(head, {
        fontWeight: "700",
        opacity: "0.9",
        padding: "4px 2px",
        borderBottom: "1px solid var(--qws-border-2, #ffffff14)",
        marginBottom: "4px"
      });
      this.panel.appendChild(head);
      if (!this.rows.length) {
        const empty = document.createElement("div");
        empty.textContent = "No tracked items are available.";
        style(empty, { opacity: "0.75", padding: "8px 2px" });
        this.panel.appendChild(empty);
        return;
      }
      for (const r of this.rows) {
        const row = document.createElement("div");
        Object.assign(row.style, {
          display: "grid",
          gridTemplateColumns: "24px 1fr max-content",
          alignItems: "center",
          gap: "8px",
          padding: "6px 4px",
          borderBottom: "1px solid var(--qws-border-2, #ffffff14)"
        });
        const icon = iconOf(r.id, 24);
        const title = document.createElement("div");
        title.textContent = labelOf(r.id);
        Object.assign(title.style, {
          fontWeight: "600",
          overflow: "hidden",
          textOverflow: "ellipsis",
          whiteSpace: "nowrap",
          color: "var(--qws-text, #e7eef7)"
        });
        const qty = document.createElement("div");
        qty.textContent = `\xD7${r.qty}`;
        Object.assign(qty.style, {
          fontVariantNumeric: "tabular-nums",
          opacity: "0.9",
          color: "var(--qws-text-dim, #b9c3cf)"
        });
        row.append(icon, title, qty);
        this.panel.appendChild(row);
      }
    }
    /* ========= DOM bits ========= */
    createSlot() {
      const d = document.createElement("div");
      d.id = "qws-notifier-slot";
      style(d, {
        position: "relative",
        display: "inline-flex",
        alignItems: "center",
        marginRight: "var(--chakra-space-2, 0.5rem)",
        pointerEvents: "auto",
        fontFamily: "var(--chakra-fonts-body, GreyCliff CF), system-ui, sans-serif",
        color: "var(--chakra-colors-chakra-body-text, #e7eef7)",
        userSelect: "none"
      });
      setProps(d, {
        "-webkit-font-smoothing": "antialiased",
        "-webkit-text-size-adjust": "100%",
        "text-rendering": "optimizeLegibility"
      });
      return d;
    }
    createButton() {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.setAttribute("aria-label", "Notifications");
      const bell = document.createElement("span");
      bell.className = "qws-bell";
      bell.textContent = "\u{1F514}";
      bell.setAttribute("aria-hidden", "true");
      style(btn, {
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        gap: "6px",
        height: "36px",
        padding: "0 12px",
        borderRadius: "var(--chakra-radii-button, 50px)",
        border: "1px solid var(--chakra-colors-chakra-border-color, #ffffff33)",
        background: "var(--qws-panel, #111823cc)",
        backdropFilter: "blur(var(--qws-blur, 8px))",
        color: "var(--qws-text, #e7eef7)",
        boxShadow: "var(--qws-shadow, 0 10px 36px rgba(0,0,0,.45))",
        cursor: "pointer",
        transition: "border-color var(--chakra-transition-duration-fast,150ms) ease",
        outline: "none",
        position: "relative"
      });
      setProps(btn, {
        "-webkit-backdrop-filter": "blur(var(--qws-blur, 8px))",
        "-webkit-tap-highlight-color": "transparent"
      });
      btn.appendChild(bell);
      btn.addEventListener("mouseenter", () => {
        btn.style.borderColor = "var(--qws-accent, #7aa2ff)";
      });
      btn.addEventListener("mouseleave", () => {
        btn.style.borderColor = "var(--chakra-colors-chakra-border-color, #ffffff33)";
      });
      return btn;
    }
    updateBellWiggle() {
      const bell = this.btn.querySelector(".qws-bell");
      if (!bell) return;
      const shouldWiggle = this.rows.length > 0 && this.panel.style.display !== "block";
      bell.classList.toggle("qws-bell--wiggle", shouldWiggle);
    }
    createBadge() {
      const badge = document.createElement("span");
      style(badge, {
        position: "absolute",
        top: "-6px",
        right: "-6px",
        minWidth: "18px",
        height: "18px",
        padding: "0 6px",
        borderRadius: "999px",
        background: "var(--chakra-colors-Red-Magic, #D02128)",
        color: "var(--chakra-colors-Neutral-TrueWhite, #fff)",
        fontSize: "12px",
        fontWeight: "700",
        display: "none",
        alignItems: "center",
        justifyContent: "center",
        border: "1px solid rgba(0,0,0,.35)",
        lineHeight: "18px",
        pointerEvents: "none"
      });
      return badge;
    }
    createPanel() {
      const panel = document.createElement("div");
      panel.setAttribute("role", "dialog");
      panel.setAttribute("aria-label", "Tracked items available");
      style(panel, {
        position: "absolute",
        top: "calc(100% + var(--chakra-space-2, 0.5rem))",
        right: "0",
        width: "min(280px, 70vw)",
        // ← largeur réduite (était 360px)
        maxHeight: "50vh",
        overflow: "auto",
        overscrollBehavior: "contain",
        // ← empêche le scroll de “remonter” au jeu
        touchAction: "pan-y",
        // ← gestes tactiles = scroll vertical, pas zoom/pan global
        borderRadius: "var(--chakra-radii-card, 12px)",
        border: "1px solid var(--qws-border, #ffffff22)",
        background: "var(--qws-panel, #111823cc)",
        backdropFilter: "blur(var(--qws-blur, 8px))",
        color: "var(--qws-text, #e7eef7)",
        boxShadow: "var(--qws-shadow, 0 10px 36px rgba(0,0,0,.45))",
        padding: "8px",
        display: "none",
        zIndex: "var(--chakra-zIndices-DialogModal, 7010)"
      });
      setProps(panel, { "-webkit-backdrop-filter": "blur(var(--qws-blur, 8px))" });
      return panel;
    }
    installScrollGuards(el2) {
      const stop = (e) => {
        e.stopPropagation();
      };
      el2.addEventListener("wheel", stop, { passive: true, capture: true });
      el2.addEventListener("mousewheel", stop, { passive: true, capture: true });
      el2.addEventListener("DOMMouseScroll", stop, { passive: true, capture: true });
      el2.addEventListener("touchmove", stop, { passive: true, capture: true });
    }
    /* ========= Anchoring ========= */
    findTargetCanvas() {
      try {
        const c1 = document.querySelector("span[tabindex] canvas");
        if (c1) return c1;
        const all = Array.from(document.querySelectorAll("canvas"));
        const candidates = all.map((c) => ({ c, r: c.getBoundingClientRect() })).filter(({ r }) => r.width <= 512 && r.height <= 512 && r.top < 300).sort((a, b) => a.r.left - b.r.left || a.r.top - b.r.top);
        return candidates[0]?.c ?? null;
      } catch {
        return null;
      }
    }
    findAnchorBlockFromCanvas(c) {
      try {
        const tabbable = c.closest("span[tabindex]");
        if (tabbable && tabbable.parentElement) return tabbable.parentElement;
        let cur = c;
        while (cur && cur.parentElement) {
          const p = cur.parentElement;
          const cs = getComputedStyle(p);
          if (cs.display.includes("flex") && p.children.length <= 3) return p;
          cur = p;
        }
        return null;
      } catch {
        return null;
      }
    }
    insertLeftOf(block, el2) {
      const parent = block.parentElement;
      if (!parent) return;
      if (!block.isConnected || !parent.isConnected) return;
      const cs = getComputedStyle(parent);
      const isFlex = cs.display.includes("flex");
      const dir = cs.flexDirection || "row";
      try {
        if (isFlex && dir.startsWith("row") && dir.endsWith("reverse")) {
          if (el2 !== block.nextSibling) parent.insertBefore(el2, block.nextSibling);
        } else {
          parent.insertBefore(el2, block);
        }
      } catch {
      }
    }
    attachLeftOfTargetCanvas() {
      try {
        const canvas = this.findTargetCanvas();
        const block = canvas ? this.findAnchorBlockFromCanvas(canvas) : null;
        if (!block || !block.parentElement || !block.isConnected) {
          let fixed = document.getElementById("qws-notifier-fallback");
          if (!fixed) {
            fixed = document.createElement("div");
            fixed.id = "qws-notifier-fallback";
            style(fixed, {
              position: "fixed",
              zIndex: "var(--chakra-zIndices-PresentableOverlay, 5100)",
              top: "calc(10px + var(--sait, 0px))",
              right: "calc(10px + var(--sair, 0px))"
            });
            document.body.appendChild(fixed);
          }
          if (!fixed.contains(this.slot)) fixed.appendChild(this.slot);
          return;
        }
        if (this.slot.parentElement !== block.parentElement || this.slot.nextElementSibling !== block && block.previousElementSibling !== this.slot) {
          this.insertLeftOf(block, this.slot);
        }
      } catch {
      }
    }
    observeDomForRelocation() {
      try {
        this.mo?.disconnect();
        this.mo = new MutationObserver(() => this.attachLeftOfTargetCanvas());
        this.mo.observe(document.body, { childList: true, subtree: true });
        this.attachLeftOfTargetCanvas();
      } catch {
      }
    }
  };
  async function renderOverlay() {
    const overlay = new OverlayBarebone();
    const unsubPurch = await NotifierService.onPurchasesChangeNow((p) => overlay.setPurchases(p));
    const unsubShops = await NotifierService.onShopsChangeNow((s) => overlay.setShops(s));
    const unsubState = await NotifierService.onChangeNow(() => overlay.notifyStateUpdated());
    const unsubRules = await NotifierService.onRulesChangeNow((rules) => overlay.setRules(rules));
    window.__qws_cleanup_notifier = () => {
      try {
        unsubShops();
      } catch {
      }
      try {
        unsubPurch();
      } catch {
      }
      try {
        unsubState();
      } catch {
      }
      try {
        unsubRules();
      } catch {
      }
      try {
        overlay.destroy();
      } catch {
      }
    };
  }

  // src/utils/shopUtility.ts
  var SHOP_TYPES = ["plant", "egg", "tool", "decor"];
  var BTN_CLASS = "romann-buyall-btn";
  var STYLE_ID = "tm-buyall-css";
  var ITEM_SELECTOR = "div.McFlex.css-1kkwxjt";
  var LIST_SELECTOR = "div.McFlex.css-1lfov12";
  var ROW_SELECTOR = "div.McFlex.css-b9riu6";
  var INDEX_ATTR = "data-tm-shop-index";
  var RESCAN_MS = 20;
  var LIST_HINT_ATTR = "data-tm-shop-type";
  var listTypeMemo = /* @__PURE__ */ new WeakMap();
  var SHOP_ATOMS = {
    plant: Atoms.shop.seedShop,
    egg: Atoms.shop.eggShop,
    tool: Atoms.shop.toolShop,
    decor: Atoms.shop.decorShop
  };
  var shopInventoryCache = {};
  var shopInventoryLengths = {};
  var shopInventoryInitStarted = false;
  var shopInventoryUnsubs = {};
  function stripDiacritics(s) {
    return s.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
  }
  function headingToShopType(txt) {
    const s = stripDiacritics(String(txt || "").toLowerCase());
    if (/\bdecor|decors|deco\b/.test(s)) return "decor";
    if (/\bseed|seeds|graine|graines\b/.test(s)) return "plant";
    if (/\begg|eggs|oeuf|oeufs\b/.test(s)) return "egg";
    if (/\btool|tools|outil|outils\b/.test(s)) return "tool";
    return null;
  }
  function findShopHeadingNear(listRoot) {
    const prev = listRoot.previousElementSibling?.querySelector?.(".chakra-text.css-1fq51pf");
    if (prev?.innerText?.trim()) return prev.innerText.trim();
    const parent = listRoot.parentElement;
    const direct = parent?.querySelector?.(":scope > .chakra-text.css-1fq51pf");
    if (direct?.innerText?.trim()) return direct.innerText.trim();
    let scope = parent ?? listRoot;
    for (let i = 0; i < 3 && scope; i++) {
      const cand = scope.querySelector(".chakra-text.css-1fq51pf");
      if (cand?.innerText?.trim()) return cand.innerText.trim();
      scope = scope.parentElement;
    }
    return null;
  }
  function extractInventoryId(shop, entry) {
    if (!entry) return null;
    if (shop === "plant") return entry?.species ? String(entry.species) : null;
    if (shop === "egg") return entry?.eggId ? String(entry.eggId) : null;
    if (shop === "tool") return entry?.toolId ? String(entry.toolId) : null;
    if (shop === "decor") return entry?.decorId ? String(entry.decorId) : null;
    return null;
  }
  function extractInventoryName(shop, entry) {
    if (!entry) return null;
    if (shop === "plant") return entry?.species ? String(entry.species) : null;
    if (shop === "egg") return entry?.eggId ? String(entry.eggId) : null;
    if (shop === "tool") return entry?.toolId ? String(entry.toolId) : null;
    if (shop === "decor") return entry?.decorId ? String(entry.decorId) : null;
    return null;
  }
  function normalizeInventory(shop, data) {
    const rawInventory = Array.isArray(data?.inventory) ? data.inventory : [];
    const normalized = [];
    for (const entry of rawInventory) {
      const id = extractInventoryId(shop, entry);
      if (!id) continue;
      normalized.push({ id, name: extractInventoryName(shop, entry), raw: entry });
    }
    return normalized;
  }
  function updateShopInventoryCache(shop, data) {
    const normalized = normalizeInventory(shop, data);
    shopInventoryCache[shop] = normalized;
    shopInventoryLengths[shop] = normalized.length;
  }
  async function initShopInventoryWatchers() {
    for (const shop of SHOP_TYPES) {
      const atom = SHOP_ATOMS[shop];
      console.log(await atom.get());
      if (!atom) continue;
      if (!shopInventoryInitStarted) return;
      try {
        updateShopInventoryCache(shop, await atom.get());
      } catch (error) {
        console.warn(`[TM] buyAll failed to fetch ${shop} inventory`, error);
      }
      if (!shopInventoryInitStarted) return;
      try {
        const unsub = await atom.onChange((next) => {
          updateShopInventoryCache(shop, next);
        });
        if (!shopInventoryInitStarted) {
          try {
            unsub();
          } catch (error) {
            console.warn(`[TM] buyAll failed to cancel stale ${shop} inventory watcher`, error);
          }
          return;
        }
        shopInventoryUnsubs[shop] = () => {
          try {
            unsub();
          } catch (err) {
            console.warn(`[TM] buyAll failed to unsubscribe ${shop} inventory`, err);
          }
        };
      } catch (error) {
        console.warn(`[TM] buyAll failed to subscribe to ${shop} inventory`, error);
      }
    }
  }
  function ensureShopInventories() {
    if (shopInventoryInitStarted) return;
    shopInventoryInitStarted = true;
    void initShopInventoryWatchers().catch((error) => {
      console.warn("[TM] buyAll inventory init error", error);
    });
  }
  function getInventoryEntry(shop, index) {
    const list = shopInventoryCache[shop];
    if (!list || index < 0 || index >= list.length) return null;
    return list[index] ?? null;
  }
  var DEFAULT_OVERRIDES = { tool: 3 };
  var PURCHASE_FNS = {
    plant: (id) => PlayerService.purchaseSeed(id),
    egg: (id) => PlayerService.purchaseEgg(id),
    tool: (id) => PlayerService.purchaseTool(id),
    decor: (id) => PlayerService.purchaseDecor(id)
  };
  function incrementShopPurchaseStat(shop) {
    switch (shop) {
      case "plant":
        StatsService.incrementShopStat("seedsBought");
        break;
      case "decor":
        StatsService.incrementShopStat("decorBought");
        break;
      case "egg":
        StatsService.incrementShopStat("eggsBought");
        break;
      case "tool":
        StatsService.incrementShopStat("toolsBought");
        break;
      default:
        break;
    }
  }
  async function purchaseRemainingItems(shop, itemId, remaining) {
    if (!shop || !itemId) return;
    const purchase = PURCHASE_FNS[shop];
    if (!purchase) return;
    const totalToBuy = typeof remaining === "number" ? Math.max(0, Math.floor(remaining)) : 0;
    if (totalToBuy <= 0) return;
    for (let bought = 0; bought < totalToBuy; bought += 1) {
      try {
        await purchase(itemId);
        incrementShopPurchaseStat(shop);
      } catch (error) {
        console.warn("[TM] buyAll purchase failed", { shop, itemId, attempt: bought + 1, error });
        break;
      }
    }
  }
  function getExpectedSizes() {
    const overrides = { ...DEFAULT_OVERRIDES, ...window.BuyAllConfig?.countOverride ?? {} };
    const sizes = {};
    for (const shop of SHOP_TYPES) {
      const cached = shopInventoryLengths[shop];
      console.log("cached: ", cached);
      if (typeof cached === "number") {
        sizes[shop] = cached;
      } else if (typeof overrides[shop] === "number") {
        sizes[shop] = overrides[shop];
      }
    }
    console.log("sizes: ", sizes);
    return sizes;
  }
  function detectShopByCount(total) {
    const sizes = getExpectedSizes();
    const matches = SHOP_TYPES.filter((t) => typeof sizes[t] === "number" && sizes[t] === total);
    console.log(matches);
    return matches.length === 1 ? matches[0] : null;
  }
  function detectShopFromHeadingOrCount(listRoot, total, sampleItemEl, idx0) {
    const memo = listTypeMemo.get(listRoot);
    if (memo) return memo;
    const attr = listRoot.getAttribute(LIST_HINT_ATTR);
    if (attr) return attr;
    const heading = findShopHeadingNear(listRoot);
    if (heading) {
      const t = headingToShopType(heading);
      if (t) {
        listRoot.setAttribute(LIST_HINT_ATTR, t);
        listTypeMemo.set(listRoot, t);
        return t;
      }
    }
    const byCount = detectShopByCount(total);
    if (byCount) {
      listRoot.setAttribute(LIST_HINT_ATTR, byCount);
      listTypeMemo.set(listRoot, byCount);
      return byCount;
    }
    return null;
  }
  function parseCompactNumber(s) {
    if (!s) return void 0;
    const txt = s.replace(/\u00A0|\u202F/g, " ").trim();
    const re = /(\d{1,3}(?:[ \u00A0\u202F.,]\d{3})+|\d+(?:[.,]\d+)?)(\s*[kKmMbBtT])?/g;
    let m;
    let lastNum = null;
    let lastSuf = null;
    while (m = re.exec(txt)) {
      lastNum = m[1];
      lastSuf = (m[2] || "").trim().toUpperCase() || null;
    }
    if (!lastNum) return void 0;
    if (lastSuf) {
      const base = Number(lastNum.replace(/[ \u00A0\u202F]/g, "").replace(",", "."));
      if (!Number.isFinite(base)) return void 0;
      const mult = lastSuf === "K" ? 1e3 : lastSuf === "M" ? 1e6 : lastSuf === "B" ? 1e9 : lastSuf === "T" ? 1e12 : 1;
      return Math.round(base * mult);
    }
    const hasThousandsSep = /[ \u00A0\u202F.,]\d{3}/.test(lastNum);
    if (hasThousandsSep) {
      const val = Number(lastNum.replace(/[ \u00A0\u202F.,]/g, ""));
      return Number.isFinite(val) ? val : void 0;
    } else {
      const val = Number(lastNum.replace(",", "."));
      return Number.isFinite(val) ? Math.round(val) : void 0;
    }
  }
  var lastShops = null;
  var lastPurchases = null;
  var shopsSubStarted = false;
  var purchasesSubStarted = false;
  function purchasedCountForId2(id, purchases) {
    if (!purchases) return 0;
    const [type, raw] = String(id).split(":");
    const section = type === "Seed" ? purchases.seed : type === "Egg" ? purchases.egg : type === "Tool" ? purchases.tool : purchases.decor;
    if (!section || !section.purchases) return 0;
    const n = section.purchases[raw];
    return typeof n === "number" && n > 0 ? n : 0;
  }
  function toNotifierItemId(shop, itemId) {
    if (!shop || !itemId) return null;
    const raw = String(itemId);
    switch (shop) {
      case "plant":
        return `Seed:${raw}`;
      case "egg":
        return `Egg:${raw}`;
      case "tool":
        return `Tool:${raw}`;
      case "decor":
        return `Decor:${raw}`;
      default:
        return null;
    }
  }
  function ensureNotifierSnapshots() {
    if (!shopsSubStarted) {
      shopsSubStarted = true;
      NotifierService.onShopsChangeNow((snap) => {
        lastShops = snap;
      }).catch((err) => {
        shopsSubStarted = false;
        console.warn("[TM] buyAll notifier shops subscription failed", err);
      });
    }
    if (!purchasesSubStarted) {
      purchasesSubStarted = true;
      NotifierService.onPurchasesChangeNow((snap) => {
        lastPurchases = snap;
      }).catch((err) => {
        purchasesSubStarted = false;
        console.warn("[TM] buyAll notifier purchases subscription failed", err);
      });
    }
  }
  function extractInitialStock(shop, rawId) {
    if (!shop || !rawId || !lastShops) return { initialStock: null, canSpawn: false };
    const byShop = shop === "plant" ? lastShops.seed?.inventory ?? [] : shop === "egg" ? lastShops.egg?.inventory ?? [] : shop === "tool" ? lastShops.tool?.inventory ?? [] : lastShops.decor?.inventory ?? [];
    const match = byShop.find((entry) => {
      if (!entry) return false;
      if (shop === "plant") return String(entry.species) === rawId;
      if (shop === "egg") return String(entry.eggId) === rawId;
      if (shop === "tool") return String(entry.toolId) === rawId;
      return String(entry.decorId) === rawId;
    });
    if (!match) return { initialStock: null, canSpawn: false };
    const initial = Number(match.initialStock);
    const normalized = Number.isFinite(initial) ? initial : null;
    const canSpawn = !!match.canSpawnHere;
    return { initialStock: normalized, canSpawn };
  }
  function getRemainingDetails(shop, itemId) {
    const notifierItemId = toNotifierItemId(shop, itemId);
    if (!notifierItemId) {
      return { notifierItemId: null, initialStock: null, purchased: null, remaining: null };
    }
    const rawId = notifierItemId.split(":")[1] ?? null;
    const { initialStock, canSpawn } = extractInitialStock(shop, rawId);
    if (initialStock == null) {
      return { notifierItemId, initialStock, purchased: null, remaining: null };
    }
    if (!canSpawn) {
      return { notifierItemId, initialStock, purchased: null, remaining: 0 };
    }
    const purchased = purchasedCountForId2(notifierItemId, lastPurchases);
    const remaining = Math.max(0, initialStock - purchased);
    return { notifierItemId, initialStock, purchased, remaining };
  }
  function isItemDisabled(itemEl) {
    if (!itemEl) return false;
    return !!itemEl.querySelector(".chakra-text.css-1ox18rb");
  }
  function getListItems(listRoot) {
    const direct = listRoot.querySelectorAll(`:scope > ${ITEM_SELECTOR}`);
    if (direct.length) return Array.from(direct);
    return Array.from(listRoot.querySelectorAll(ITEM_SELECTOR));
  }
  function parsePriceFromButton(btn) {
    if (!btn) return void 0;
    const label2 = btn.querySelector(".css-1uduba2");
    const raw = (label2?.innerText ?? btn.textContent ?? "").trim();
    return parseCompactNumber(raw);
  }
  function findRowForItem(itemEl) {
    const bySelector = itemEl.querySelector(ROW_SELECTOR);
    if (bySelector) return bySelector;
    const any = Array.from(itemEl.querySelectorAll("div")).find((d) => d.querySelectorAll("button.chakra-button").length >= 2);
    return any ?? null;
  }
  function ensureGlobalStyles() {
    if (document.getElementById(STYLE_ID)) return;
    const css = `
    .${BTN_CLASS}{
      background: var(--chakra-colors-Blue-Magic, #0067B4) !important;
      border-color: var(--chakra-colors-Blue-Dark, #264093) !important;
      color: #fff !important;
      border-width: 2px;
      border-radius: 5px;
      text-transform: uppercase;
      height: 40px;
      padding-inline: 24px;
      padding-top: 12px;
      padding-bottom: 12px;
      width: 100%;
    }
    .${BTN_CLASS}:hover{
      background: var(--chakra-colors-Blue-Light, #48ADF4) !important;
      border-color: var(--chakra-colors-Blue-Magic, #0067B4) !important;
    }
    .${BTN_CLASS}:focus-visible{
      outline: transparent solid 2px;
      outline-offset: 2px;
      box-shadow: var(--chakra-ring-offset-shadow, 0 0 #0000),
                  var(--chakra-ring-shadow, 0 0 #0000),
                  0 0 0 3px var(--chakra-ring-color, rgba(66,153,225,0.6));
    }
    /* \xC9tat disabled : couleurs/gris EXACTES demand\xE9es + blocage du hover */
    .${BTN_CLASS}[disabled],
    .${BTN_CLASS}[aria-disabled="true"]{
      background: var(--chakra-colors-Neutral-Grey) !important;
      border-color: var(--chakra-colors-Neutral-EarlGrey) !important;
      color: var(--chakra-colors-Neutral-EarlGrey) !important;
      opacity: 0.7 !important;
      cursor: not-allowed !important;
      box-shadow: none !important;
      pointer-events: none; /* pour l\u2019aria-disabled \xE9ventuel */
    }
    .${BTN_CLASS}[disabled]:hover,
    .${BTN_CLASS}[disabled]:focus,
    .${BTN_CLASS}[aria-disabled="true"]:hover,
    .${BTN_CLASS}[aria-disabled="true"]:focus{
      background: var(--chakra-colors-Neutral-Grey) !important;
      border-color: var(--chakra-colors-Neutral-EarlGrey) !important;
      color: var(--chakra-colors-Neutral-EarlGrey) !important;
      box-shadow: none !important;
    }
  `.trim();
    const style2 = document.createElement("style");
    style2.id = STYLE_ID;
    style2.textContent = css;
    document.head.appendChild(style2);
  }
  function createButton(templateBtn) {
    const btn = document.createElement("button");
    btn.type = "button";
    if (templateBtn?.className) {
      const classes = `${templateBtn.className} ${BTN_CLASS}`.replace(new RegExp(`\\b${BTN_CLASS}\\b`, "g"), "").trim();
      btn.className = `${classes} ${BTN_CLASS}`.trim();
    } else {
      btn.className = `chakra-button ${BTN_CLASS}`;
    }
    const flex = document.createElement("div");
    flex.className = "McFlex css-1fxg3mj";
    const label2 = document.createElement("span");
    label2.className = "css-1uduba2";
    label2.textContent = "Buy all";
    flex.appendChild(label2);
    btn.appendChild(flex);
    btn.addEventListener("click", (ev) => {
      console.log("test");
      ev.preventDefault();
      ev.stopPropagation();
      if (btn.disabled) return;
      const itemEl = btn.closest(ITEM_SELECTOR);
      console.log("itemEl ", itemEl);
      const listRoot = itemEl?.closest(LIST_SELECTOR) || document.body;
      console.log("listRoot ", listRoot);
      const items = getListItems(listRoot);
      console.log("items ", items);
      const total = items.length;
      console.log("total ", total);
      const attrIndex = itemEl?.getAttribute(INDEX_ATTR);
      console.log("attrIndex ", attrIndex);
      let idx0 = attrIndex != null && attrIndex !== "" ? Number.parseInt(attrIndex, 10) : -1;
      if (!Number.isFinite(idx0) || idx0 < 0) {
        idx0 = itemEl ? items.indexOf(itemEl) : -1;
      }
      const idx1 = idx0 >= 0 ? idx0 + 1 : -1;
      console.log("idx1 ", idx1);
      const shop = detectShopFromHeadingOrCount(listRoot, total, itemEl, idx0);
      console.log("shop ", shop);
      let itemId = null;
      let itemName = null;
      let reason = "none";
      let coinParsed;
      let creditParsed;
      console.log("shop: ", shop, " itemEl: ", itemEl);
      if (shop && itemEl) {
        const row = findRowForItem(itemEl);
        if (row) {
          const me = btn;
          const coinBtn = me.previousElementSibling;
          const creditBtn = me.nextElementSibling;
          coinParsed = parsePriceFromButton(coinBtn);
          creditParsed = parsePriceFromButton(creditBtn);
          const inventoryEntry = idx0 >= 0 ? getInventoryEntry(shop, idx0) : null;
          if (inventoryEntry) {
            itemId = inventoryEntry.id;
            itemName = inventoryEntry.name ?? inventoryEntry.id;
            reason = "inventory";
          } else if (idx0 >= 0 && typeof coinParsed === "number" && typeof creditParsed === "number") {
            reason = "index";
          }
        }
      }
      const remainingDetails = getRemainingDetails(shop ?? null, itemId);
      void purchaseRemainingItems(shop, itemId, remainingDetails.remaining);
      window.dispatchEvent(new CustomEvent("tm:buyAll", {
        detail: {
          index1: idx1,
          index0: idx0,
          total,
          shopType: shop,
          itemId,
          itemName,
          reason,
          coin: coinParsed,
          credit: creditParsed,
          element: itemEl,
          remaining: remainingDetails.remaining,
          notifierItemId: remainingDetails.notifierItemId
        }
      }));
    });
    return btn;
  }
  function insertIntoItem(itemEl) {
    const listRoot = itemEl.closest(LIST_SELECTOR);
    if (listRoot && !itemEl.hasAttribute(INDEX_ATTR)) {
      const items = getListItems(listRoot);
      const idx = items.indexOf(itemEl);
      if (idx >= 0) {
        itemEl.setAttribute(INDEX_ATTR, String(idx));
      }
    }
    const row = itemEl.querySelector(ROW_SELECTOR) || Array.from(itemEl.querySelectorAll("div")).find((d) => d.querySelectorAll("button.chakra-button").length >= 2);
    if (!row) return;
    const btns = row.querySelectorAll("button.chakra-button");
    if (btns.length < 2) return;
    let middle = row.querySelector(`button.${BTN_CLASS}`);
    if (!middle) {
      middle = createButton(btns[0]);
      row.insertBefore(middle, btns[1]);
    }
    const disabled = isItemDisabled(itemEl);
    middle.disabled = disabled;
    middle.setAttribute("aria-disabled", disabled ? "true" : "false");
  }
  function scan(root = document) {
    root.querySelectorAll(ITEM_SELECTOR).forEach(insertIntoItem);
  }
  var observer = null;
  var intervalId = null;
  function setupBuyAll() {
    ensureGlobalStyles();
    ensureNotifierSnapshots();
    ensureShopInventories();
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", () => scan());
    } else {
      scan();
    }
    observer = new MutationObserver((mutations) => {
      for (const m of mutations) {
        for (const n of m.addedNodes) {
          if (!(n instanceof Element)) continue;
          if (n.matches(ITEM_SELECTOR)) insertIntoItem(n);
          n.querySelectorAll?.(ITEM_SELECTOR).forEach(insertIntoItem);
        }
      }
    });
    const startObserver = () => observer.observe(document.body, { childList: true, subtree: true });
    if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", startObserver);
    else startObserver();
    startRescan();
  }
  function startRescan() {
    if (intervalId != null) return;
    intervalId = window.setInterval(() => scan(), RESCAN_MS);
  }
  function stopRescan() {
    if (intervalId != null) {
      window.clearInterval(intervalId);
      intervalId = null;
    }
  }
  document.addEventListener("visibilitychange", () => {
    if (document.hidden) stopRescan();
    else if (observer) startRescan();
  });
  var DEFAULTS2 = {
    containerSelector: ".McFlex.css-1lfov12",
    itemSelector: ".McFlex.css-1kkwxjt",
    flagSelector: ".chakra-text.css-pyjzrq"
  };
  function startReorderObserver(options = {}) {
    if (!isBrowser2()) {
      return {
        stop() {
        },
        runOnce() {
        },
        isRunning() {
          return false;
        }
      };
    }
    const CONTAINER_SEL = options.containerSelector ?? DEFAULTS2.containerSelector;
    const ITEM_SEL = options.itemSelector ?? DEFAULTS2.itemSelector;
    const FLAG_SEL = options.flagSelector ?? DEFAULTS2.flagSelector;
    const ROOT = options.root ?? document;
    const OBSERVE_HISTORY = options.observeHistory ?? true;
    const PREFER_DIRECT = options.preferDirectChildren ?? false;
    const logger = typeof options.log === "function" ? options.log : options.log ? (...args) => console.debug("[ReorderObserver]", ...args) : () => {
    };
    let running = true;
    let pending = false;
    function processAll() {
      if (!running || pending) return;
      pending = true;
      requestAnimationFrame(() => {
        try {
          const containers = queryAll(ROOT, CONTAINER_SEL);
          for (const c of containers) {
            reorderContainer(c, ITEM_SEL, FLAG_SEL, PREFER_DIRECT);
          }
        } finally {
          pending = false;
        }
      });
    }
    const observeTarget = ROOT.documentElement ?? ROOT;
    const mo = new MutationObserver(processAll);
    mo.observe(observeTarget, { childList: true, subtree: true });
    processAll();
    let unhookHistory = null;
    if (OBSERVE_HISTORY) {
      const { unhook } = hookHistory2(processAll);
      unhookHistory = unhook;
    }
    const controller = {
      stop() {
        if (!running) return;
        running = false;
        mo.disconnect();
        unhookHistory?.();
        unhookHistory = null;
        logger("Stopped.");
      },
      runOnce() {
        processAll();
      },
      isRunning() {
        return running;
      }
    };
    return controller;
  }
  function isBrowser2() {
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function queryAll(root, selector) {
    return Array.from(root.querySelectorAll(selector));
  }
  function supportsScope() {
    try {
      document.querySelector(":scope");
      return true;
    } catch {
      return false;
    }
  }
  function childrenOrDescendants(container, itemSel) {
    if (supportsScope()) {
      const direct = Array.from(container.querySelectorAll(`:scope > ${itemSel}`));
      if (direct.length > 0) return direct;
    }
    return Array.from(container.querySelectorAll(itemSel));
  }
  function reorderContainer(container, itemSel, flagSel, preferDirectChildren) {
    const items = preferDirectChildren ? Array.from(container.children).filter((n) => n instanceof Element && n.matches(itemSel)) : childrenOrDescendants(container, itemSel);
    if (items.length === 0) return;
    const withFlag = [];
    const withoutFlag = [];
    for (const el2 of items) {
      (el2.querySelector(flagSel) ? withFlag : withoutFlag).push(el2);
    }
    if (withFlag.length === 0) return;
    let seenRest = false;
    for (const el2 of items) {
      const flagged = !!el2.querySelector(flagSel);
      if (!flagged) seenRest = true;
      else if (seenRest) {
        const frag = document.createDocumentFragment();
        for (const e of withFlag) frag.appendChild(e);
        for (const e of withoutFlag) frag.appendChild(e);
        container.appendChild(frag);
        return;
      }
    }
  }
  function hookHistory2(onNavigate) {
    const origPush = history.pushState?.bind(history);
    const origReplace = history.replaceState?.bind(history);
    function wrap(fn) {
      if (!fn) return fn;
      const wrapped = function(...args) {
        const ret = fn.apply(this, args);
        onNavigate();
        return ret;
      };
      return wrapped;
    }
    const onPop = () => onNavigate();
    if (origPush) history.pushState = wrap(origPush);
    if (origReplace) history.replaceState = wrap(origReplace);
    window.addEventListener("popstate", onPop);
    return {
      unhook() {
        if (origPush) history.pushState = origPush;
        if (origReplace) history.replaceState = origReplace;
        window.removeEventListener("popstate", onPop);
      }
    };
  }

  // src/utils/calculators.ts
  var key = (s) => String(s ?? "").trim();
  function resolveSpeciesKey(species) {
    const wanted = key(species).toLowerCase();
    if (!wanted) return null;
    for (const k of Object.keys(plantCatalog)) {
      if (k.toLowerCase() === wanted) return k;
    }
    return null;
  }
  function findAnySellPriceNode(obj) {
    if (!obj || typeof obj !== "object") return null;
    if (typeof obj.baseSellPrice === "number" && Number.isFinite(obj.baseSellPrice)) {
      return obj.baseSellPrice;
    }
    for (const k of ["produce", "crop", "item", "items", "data"]) {
      if (obj[k]) {
        const v = findAnySellPriceNode(obj[k]);
        if (v != null) return v;
      }
    }
    try {
      const seen = /* @__PURE__ */ new Set();
      const stack = [obj];
      while (stack.length) {
        const cur = stack.pop();
        if (!cur || typeof cur !== "object" || seen.has(cur)) continue;
        seen.add(cur);
        if (typeof cur.baseSellPrice === "number") {
          const v = cur.baseSellPrice;
          if (Number.isFinite(v)) return v;
        }
        for (const v of Object.values(cur)) if (v && typeof v === "object") stack.push(v);
      }
    } catch {
    }
    return null;
  }
  function defaultGetBasePrice(species) {
    const spKey = resolveSpeciesKey(species);
    if (!spKey) return null;
    const node = plantCatalog[spKey];
    const cands = [
      node?.produce?.baseSellPrice,
      node?.crop?.baseSellPrice,
      node?.item?.baseSellPrice,
      node?.items?.Produce?.baseSellPrice
    ].filter((v) => typeof v === "number" && Number.isFinite(v));
    if (cands.length) return cands[0];
    return findAnySellPriceNode(node);
  }
  function applyRounding(v, mode = "round") {
    switch (mode) {
      case "floor":
        return Math.floor(v);
      case "ceil":
        return Math.ceil(v);
      case "none":
        return v;
      case "round":
      default:
        return Math.round(v);
    }
  }
  function friendBonusMultiplier(playersInRoom) {
    if (!Number.isFinite(playersInRoom)) return 1;
    const n = Math.max(1, Math.min(6, Math.floor(playersInRoom)));
    return 1 + (n - 1) * 0.1;
  }
  var COLOR_MULT = {
    Gold: 25,
    Rainbow: 50
  };
  var WEATHER_MULT = {
    Wet: 2,
    Chilled: 2,
    Frozen: 10
  };
  var TIME_MULT = {
    Dawnlit: 2,
    Dawnbound: 3,
    Amberlit: 5,
    Amberbound: 6
  };
  var WEATHER_TIME_COMBO = {
    "Wet+Dawnlit": 3,
    "Chilled+Dawnlit": 3,
    "Wet+Dawnbound": 4,
    "Chilled+Dawnbound": 4,
    "Wet+Amberlit": 6,
    "Chilled+Amberlit": 6,
    "Wet+Amberbound": 7,
    "Chilled+Amberbound": 7,
    "Frozen+Dawnlit": 11,
    "Frozen+Dawnbound": 12,
    "Frozen+Amberlit": 14,
    "Frozen+Amberbound": 15
  };
  function isColor(m) {
    return m === "Gold" || m === "Rainbow";
  }
  function isWeather(m) {
    return m === "Wet" || m === "Chilled" || m === "Frozen";
  }
  function isTime(m) {
    return m === "Dawnlit" || m === "Dawnbound" || m === "Amberlit" || m === "Amberbound";
  }
  function normalizeMutationName(m) {
    const s = key(m).toLowerCase();
    if (!s) return "";
    if (s === "amberglow" || s === "ambershine" || s === "amberlight") return "Amberlit";
    if (s === "dawn" || s === "dawnlight") return "Dawnlit";
    if (s === "gold") return "Gold";
    if (s === "rainbow") return "Rainbow";
    if (s === "wet") return "Wet";
    if (s === "chilled") return "Chilled";
    if (s === "frozen") return "Frozen";
    if (s === "dawnlit") return "Dawnlit";
    if (s === "dawnbound") return "Dawnbound";
    if (s === "amberlit") return "Amberlit";
    if (s === "dawncharged" || s === "dawnradiant" || s === "dawn-radiant" || s === "dawn charged") return "Dawnbound";
    if (s === "amberbound" || s === "ambercharged" || s === "amberradiant" || s === "amber-radiant" || s === "amber charged") return "Amberbound";
    return m;
  }
  function computeColorMultiplier(mutations) {
    if (!Array.isArray(mutations)) return 1;
    let best = 1;
    for (const raw of mutations) {
      const m = normalizeMutationName(raw);
      if (isColor(m)) {
        const mult = COLOR_MULT[m];
        if (mult > best) best = mult;
      }
    }
    return best;
  }
  function pickWeather(mutations) {
    if (!Array.isArray(mutations)) return null;
    let pick = null;
    for (const raw of mutations) {
      const m = normalizeMutationName(raw);
      if (isWeather(m)) {
        if (pick == null) {
          pick = m;
          continue;
        }
        if (WEATHER_MULT[m] > WEATHER_MULT[pick]) pick = m;
      }
    }
    return pick;
  }
  function pickTime(mutations) {
    if (!Array.isArray(mutations)) return null;
    let pick = null;
    for (const raw of mutations) {
      const m = normalizeMutationName(raw);
      if (isTime(m)) {
        if (pick == null) {
          pick = m;
          continue;
        }
        if (TIME_MULT[m] > TIME_MULT[pick]) pick = m;
      }
    }
    return pick;
  }
  function computeWeatherTimeMultiplier(weather2, time) {
    if (!weather2 && !time) return 1;
    if (weather2 && !time) return WEATHER_MULT[weather2];
    if (!weather2 && time) return TIME_MULT[time];
    const k = `${weather2}+${time}`;
    const combo = WEATHER_TIME_COMBO[k];
    if (typeof combo === "number") return combo;
    return Math.max(WEATHER_MULT[weather2], TIME_MULT[time]);
  }
  function mutationsMultiplier(mutations) {
    const color = computeColorMultiplier(mutations);
    const weather2 = pickWeather(mutations);
    const time = pickTime(mutations);
    const wt = computeWeatherTimeMultiplier(weather2, time);
    return color * wt;
  }
  function estimateProduceValue(species, scale, mutations, opts) {
    const getBase = opts?.getBasePrice ?? defaultGetBasePrice;
    const sXform = opts?.scaleTransform ?? ((_, s) => s);
    const round = opts?.rounding ?? "round";
    const base = getBase(species);
    if (!(Number.isFinite(base) && base > 0)) return 0;
    const sc = Number(scale);
    if (!Number.isFinite(sc) || sc <= 0) return 0;
    const effScale = sXform(species, sc);
    if (!Number.isFinite(effScale) || effScale <= 0) return 0;
    const mutMult = mutationsMultiplier(mutations);
    const friendsMult = friendBonusMultiplier(opts?.friendPlayers);
    const pre = base * effScale * mutMult * friendsMult;
    const out = Math.max(0, applyRounding(pre, round));
    return out;
  }
  function valueFromInventoryProduce(item, opts, playersInRoom) {
    if (!item || item.itemType !== "Produce") return 0;
    const merged = playersInRoom == null ? opts : { ...opts, friendPlayers: playersInRoom };
    return estimateProduceValue(item.species, item.scale, item.mutations, merged);
  }
  function valueFromGardenSlot(slot, opts, playersInRoom) {
    if (!slot) return 0;
    const merged = playersInRoom == null ? opts : { ...opts, friendPlayers: playersInRoom };
    return estimateProduceValue(slot.species, slot.targetScale, slot.mutations, merged);
  }
  function valueFromGardenPlant(plant, opts, playersInRoom) {
    if (!plant || plant.objectType !== "plant" || !Array.isArray(plant.slots)) return 0;
    const merged = playersInRoom == null ? opts : { ...opts, friendPlayers: playersInRoom };
    let sum = 0;
    for (const s of plant.slots) sum += valueFromGardenSlot(s, merged);
    return sum;
  }
  function sumInventoryValue(items, opts, playersInRoom) {
    if (!Array.isArray(items)) return 0;
    const merged = playersInRoom == null ? opts : { ...opts, friendPlayers: playersInRoom };
    let sum = 0;
    for (const it of items) {
      if (it?.itemType === "Produce") {
        sum += valueFromInventoryProduce(it, merged);
      }
    }
    return sum;
  }
  function sumGardenValue(garden2, opts, playersInRoom) {
    if (!garden2 || typeof garden2 !== "object") return 0;
    const merged = playersInRoom == null ? opts : { ...opts, friendPlayers: playersInRoom };
    let sum = 0;
    for (const k of Object.keys(garden2)) {
      const p = garden2[k];
      if (p?.objectType === "plant") {
        sum += valueFromGardenPlant(p, merged);
      }
    }
    return sum;
  }
  var DefaultPricing = Object.freeze({
    getBasePrice: defaultGetBasePrice,
    rounding: "round"
  });

  // src/utils/cropPrice.ts
  var isPlantObject2 = (o) => !!o && o.objectType === "plant";
  var defaultOrder2 = (n) => Array.from({ length: n }, (_, i) => i);
  var clamp2 = (n, min, max) => Math.max(min, Math.min(max, n));
  function startCropPriceWatcherViaGardenObject() {
    let cur = null;
    let players = void 0;
    let sortedIdx = null;
    let selectedIdx = null;
    let lastPrice = null;
    const listeners4 = /* @__PURE__ */ new Set();
    const notify = () => {
      for (const fn of listeners4) try {
        fn();
      } catch {
      }
    };
    let scheduled = false;
    const scheduleRecomputeAndNotify = () => {
      if (scheduled) return;
      scheduled = true;
      requestAnimationFrame(() => {
        scheduled = false;
        recomputeAndNotify();
      });
    };
    function getOrder() {
      const n = Array.isArray(cur?.slots) ? cur.slots.length : 0;
      if (!n) return [];
      return Array.isArray(sortedIdx) && sortedIdx.length === n ? sortedIdx : defaultOrder2(n);
    }
    function selectedOrderedPosition() {
      if (!isPlantObject2(cur)) return 0;
      const slots = cur.slots ?? [];
      const n = Array.isArray(slots) ? slots.length : 0;
      if (!n) return 0;
      const raw = Number.isFinite(selectedIdx) ? selectedIdx : 0;
      const clampedRaw = clamp2(raw, 0, n - 1);
      const ord = getOrder();
      const pos = ord.indexOf(clampedRaw);
      return pos >= 0 ? pos : 0;
    }
    function getOrderedSlots() {
      if (!isPlantObject2(cur)) return [];
      const slots = Array.isArray(cur.slots) ? cur.slots : [];
      const ord = getOrder();
      const out = [];
      for (const i of ord) if (slots[i] != null) out.push(slots[i]);
      return out;
    }
    function computeSelectedSlotPrice() {
      if (!isPlantObject2(cur)) return null;
      const ordered = getOrderedSlots();
      if (!ordered.length) return null;
      const pos = selectedOrderedPosition();
      const slot = ordered[clamp2(pos, 0, ordered.length - 1)];
      const val = valueFromGardenSlot(slot, DefaultPricing, players);
      return Number.isFinite(val) && val > 0 ? val : null;
    }
    function computeWholePlantPrice() {
      if (!isPlantObject2(cur)) return null;
      const v = valueFromGardenPlant(cur, DefaultPricing, players);
      return Number.isFinite(v) && v > 0 ? v : null;
    }
    function recomputeAndNotify() {
      const slotVal = computeSelectedSlotPrice();
      const next = slotVal ?? computeWholePlantPrice() ?? null;
      if (next !== lastPrice) {
        lastPrice = next;
        notify();
      }
    }
    (async () => {
      try {
        cur = await myCurrentGardenObject.get();
      } catch {
      }
      try {
        players = await numPlayers.get();
      } catch {
      }
      try {
        const v = await myCurrentSortedGrowSlotIndices.get();
        sortedIdx = Array.isArray(v) ? v.slice() : null;
      } catch {
      }
      try {
        selectedIdx = await myCurrentGrowSlotIndex.get();
      } catch {
      }
      numPlayers.onChange((n) => {
        players = n;
      });
      myCurrentSortedGrowSlotIndices.onChange((v) => {
        sortedIdx = Array.isArray(v) ? v.slice() : null;
      });
      myCurrentGardenObject.onChange((v) => {
        cur = v;
        scheduleRecomputeAndNotify();
      });
      myCurrentGrowSlotIndex.onChange((idx) => {
        selectedIdx = Number.isFinite(idx) ? idx : 0;
        scheduleRecomputeAndNotify();
      });
      recomputeAndNotify();
    })();
    return {
      get() {
        return lastPrice;
      },
      onChange(cb) {
        listeners4.add(cb);
        return () => listeners4.delete(cb);
      },
      stop() {
        listeners4.clear();
      }
    };
  }

  // src/utils/cropValues.ts
  var DEFAULTS3 = {
    rootSelector: ".McFlex.css-fsggty",
    innerSelector: ".McFlex.css-1omaybc, .McFlex.css-1c3sifn",
    markerClass: "tm-crop-price"
  };
  var OMA_SEL = ".McFlex.css-1omaybc";
  var ICON_CLASS = "tm-crop-price-icon";
  var LABEL_CLASS = "tm-crop-price-label";
  var LOCK_TEXT_SELECTOR = ":scope > .chakra-text.css-1uvlb8k";
  var TOOLTIP_ROOT_CLASS = "css-115gc9o";
  var LOCK_EMOJI = "\u{1F512}";
  var LOCK_BORDER_STYLE = "2px solid rgb(188, 53, 215)";
  var LOCK_BORDER_RADIUS = "15px";
  var LOCK_ICON_CLASS = "tm-locker-tooltip-lock-icon";
  var DATASET_KEY_COLOR = "tmLockerOriginalColor";
  var DATASET_KEY_DISPLAY = "tmLockerOriginalDisplay";
  var DATASET_KEY_ALIGN = "tmLockerOriginalAlign";
  var DATASET_KEY_TEXT = "tmLockerOriginalHtml";
  var DATASET_KEY_BORDER = "tmLockerOriginalBorder";
  var DATASET_KEY_BORDER_RADIUS = "tmLockerOriginalBorderRadius";
  var DATASET_KEY_POSITION = "tmLockerOriginalPosition";
  var DATASET_KEY_OVERFLOW = "tmLockerOriginalOverflow";
  var LOCK_PREFIX_REGEX = new RegExp(`^${LOCK_EMOJI}(?:\\u00A0|\\s|&nbsp;)*`);
  function startCropValuesObserverFromGardenAtom(options = {}) {
    if (typeof window === "undefined" || typeof document === "undefined") {
      return { stop() {
      }, runOnce() {
      }, isRunning: () => false };
    }
    const ROOT_SEL = options.rootSelector ?? DEFAULTS3.rootSelector;
    const INNER_SEL = options.innerSelector ?? DEFAULTS3.innerSelector;
    const MARKER = options.markerClass ?? DEFAULTS3.markerClass;
    const ROOT = options.root ?? document;
    const logger = typeof options.log === "function" ? options.log : options.log ? (...a) => console.debug("[AppendCropPrice/GO]", ...a) : () => {
    };
    const nfUS = new Intl.NumberFormat("en-US");
    const fmtCoins = (n) => nfUS.format(Math.max(0, Math.round(n)));
    let running = true;
    const priceWatcher = startCropPriceWatcherViaGardenObject();
    let lockerHarvestAllowed = null;
    let lockerOff = null;
    try {
      lockerHarvestAllowed = lockerService.getCurrentSlotSnapshot().harvestAllowed ?? null;
    } catch {
      lockerHarvestAllowed = null;
    }
    const writePriceOnce = () => {
      if (!running) return;
      const v = priceWatcher.get();
      const text = v == null ? "\u2014" : fmtCoins(v);
      queryAll2(ROOT, ROOT_SEL).forEach((rootEl) => {
        queryAll2(rootEl, INNER_SEL).forEach((inner) => {
          if (shouldSkipInner(inner, MARKER)) {
            removeMarker(inner, MARKER);
            updateLockEmoji(inner, false);
            return;
          }
          const locked = lockerHarvestAllowed === false;
          updateLockEmoji(inner, locked);
          ensureSpanAtEnd(inner, text, MARKER);
        });
      });
      logger("render", { value: v });
    };
    const subscribeLocker = () => {
      try {
        lockerOff = lockerService.onSlotInfoChange((event) => {
          lockerHarvestAllowed = event.harvestAllowed ?? null;
          writePriceOnce();
        });
      } catch {
        lockerOff = null;
      }
    };
    subscribeLocker();
    writePriceOnce();
    const off = priceWatcher.onChange(() => writePriceOnce());
    return {
      stop() {
        if (!running) return;
        running = false;
        off?.();
        if (typeof lockerOff === "function") {
          try {
            lockerOff();
          } catch {
          }
        }
        priceWatcher.stop();
        logger("stopped");
      },
      runOnce() {
        writePriceOnce();
      },
      isRunning() {
        return running;
      }
    };
  }
  function queryAll2(root, sel) {
    return Array.from(root.querySelectorAll(sel));
  }
  function shouldSkipInner(inner, markerClass) {
    if (!(inner instanceof Element)) return false;
    if (!inner.matches(OMA_SEL)) return false;
    const realChildren = getRealElementChildren(inner, markerClass);
    return realChildren.length === 1;
  }
  function getRealElementChildren(inner, markerClass) {
    const children = Array.from(inner.children);
    return children.filter(
      (el2) => !(el2.tagName === "SPAN" && el2.classList.contains(markerClass))
    );
  }
  function removeMarker(inner, markerClass) {
    const markers = inner.querySelectorAll(`:scope > span.${CSS.escape(markerClass)}`);
    markers.forEach((m) => m.remove());
  }
  function updateLockEmoji(inner, locked) {
    if (!(inner instanceof HTMLElement)) return;
    inner.querySelectorAll(":scope > span.tm-locker-lock-emoji").forEach((node) => node.remove());
    const textTarget = inner.querySelector(LOCK_TEXT_SELECTOR) ?? inner.querySelector(":scope > .chakra-text");
    const tooltipRoot = inner.closest(`.${TOOLTIP_ROOT_CLASS}`);
    if (!locked) {
      if (textTarget) {
        restoreTextContent(textTarget);
        restoreTextStyles(textTarget);
      }
      if (tooltipRoot) {
        restoreTooltipStyles(tooltipRoot);
        removeLockIcon(tooltipRoot);
      }
      return;
    }
    if (textTarget) {
      restoreTextContent(textTarget);
    }
    if (tooltipRoot) {
      storeOriginalTooltipStyles(tooltipRoot);
      applyLockedTooltipStyles(tooltipRoot);
      ensureLockIcon(tooltipRoot);
    }
  }
  function restoreTextStyles(textTarget) {
    restoreStyleFromDataset(textTarget, DATASET_KEY_COLOR, "color");
    restoreStyleFromDataset(textTarget, DATASET_KEY_DISPLAY, "display");
    restoreStyleFromDataset(textTarget, DATASET_KEY_ALIGN, "align-items");
  }
  function restoreTextContent(textTarget) {
    const originalHtml = textTarget.dataset[DATASET_KEY_TEXT];
    if (originalHtml !== void 0) {
      textTarget.innerHTML = originalHtml;
      delete textTarget.dataset[DATASET_KEY_TEXT];
      return;
    }
    const currentHtml = textTarget.innerHTML;
    const sanitizedHtml = stripLockPrefix(currentHtml);
    if (sanitizedHtml !== currentHtml) {
      textTarget.innerHTML = sanitizedHtml;
    }
  }
  function restoreStyleFromDataset(el2, datasetKey, cssProperty) {
    const datasetMap = el2.dataset;
    const originalValue = datasetMap[datasetKey];
    if (originalValue === void 0) return;
    if (originalValue) {
      el2.style.setProperty(cssProperty, originalValue);
    } else {
      el2.style.removeProperty(cssProperty);
    }
    delete datasetMap[datasetKey];
  }
  function storeOriginalTooltipStyles(tooltip) {
    if (tooltip.dataset[DATASET_KEY_BORDER] === void 0) {
      tooltip.dataset[DATASET_KEY_BORDER] = tooltip.style.border ?? "";
    }
    if (tooltip.dataset[DATASET_KEY_BORDER_RADIUS] === void 0) {
      tooltip.dataset[DATASET_KEY_BORDER_RADIUS] = tooltip.style.borderRadius ?? "";
    }
    if (tooltip.dataset[DATASET_KEY_OVERFLOW] === void 0) {
      tooltip.dataset[DATASET_KEY_OVERFLOW] = tooltip.style.overflow ?? "";
    }
  }
  function applyLockedTooltipStyles(tooltip) {
    tooltip.style.border = LOCK_BORDER_STYLE;
    tooltip.style.borderRadius = LOCK_BORDER_RADIUS;
    tooltip.style.overflow = "visible";
    const computedPosition = typeof window !== "undefined" ? window.getComputedStyle(tooltip).position : tooltip.style.position || "static";
    if (computedPosition === "static") {
      if (tooltip.dataset[DATASET_KEY_POSITION] === void 0) {
        tooltip.dataset[DATASET_KEY_POSITION] = tooltip.style.position ?? "";
      }
      tooltip.style.position = "relative";
    }
  }
  function restoreTooltipStyles(tooltip) {
    const originalBorder = tooltip.dataset[DATASET_KEY_BORDER];
    if (originalBorder !== void 0) {
      if (originalBorder) {
        tooltip.style.border = originalBorder;
      } else {
        tooltip.style.removeProperty("border");
      }
      delete tooltip.dataset[DATASET_KEY_BORDER];
    } else {
      tooltip.style.removeProperty("border");
    }
    const originalBorderRadius = tooltip.dataset[DATASET_KEY_BORDER_RADIUS];
    if (originalBorderRadius !== void 0) {
      if (originalBorderRadius) {
        tooltip.style.borderRadius = originalBorderRadius;
      } else {
        tooltip.style.removeProperty("border-radius");
      }
      delete tooltip.dataset[DATASET_KEY_BORDER_RADIUS];
    } else {
      tooltip.style.removeProperty("border-radius");
    }
    const originalOverflow = tooltip.dataset[DATASET_KEY_OVERFLOW];
    if (originalOverflow !== void 0) {
      if (originalOverflow) {
        tooltip.style.overflow = originalOverflow;
      } else {
        tooltip.style.removeProperty("overflow");
      }
      delete tooltip.dataset[DATASET_KEY_OVERFLOW];
    } else {
      tooltip.style.removeProperty("overflow");
    }
    const originalPosition = tooltip.dataset[DATASET_KEY_POSITION];
    if (originalPosition !== void 0) {
      if (originalPosition) {
        tooltip.style.position = originalPosition;
      } else {
        tooltip.style.removeProperty("position");
      }
      delete tooltip.dataset[DATASET_KEY_POSITION];
    } else if (tooltip.style.position === "relative") {
      tooltip.style.removeProperty("position");
    }
  }
  function ensureLockIcon(tooltip) {
    let icon = tooltip.querySelector(`:scope > span.${LOCK_ICON_CLASS}`);
    if (!icon) {
      icon = document.createElement("span");
      icon.className = LOCK_ICON_CLASS;
      tooltip.append(icon);
    }
    icon.textContent = LOCK_EMOJI;
    icon.style.position = "absolute";
    icon.style.top = "0";
    icon.style.right = "0";
    icon.style.left = "";
    icon.style.transform = "translate(50%, -50%)";
    icon.style.fontSize = "18px";
    icon.style.padding = "2px 8px";
    icon.style.borderRadius = "999px";
    icon.style.border = "none";
    icon.style.background = "transparent";
    icon.style.color = "white";
    icon.style.pointerEvents = "none";
    icon.style.userSelect = "none";
    icon.style.zIndex = "1";
  }
  function removeLockIcon(tooltip) {
    tooltip.querySelectorAll(`:scope > span.${LOCK_ICON_CLASS}`).forEach((node) => node.remove());
  }
  function stripLockPrefix(content) {
    return content.replace(LOCK_PREFIX_REGEX, "");
  }
  function ensureSpanAtEnd(inner, text, markerClass) {
    const spans = Array.from(
      inner.querySelectorAll(`:scope > span.${CSS.escape(markerClass)}`)
    );
    let span = spans[0] ?? null;
    for (let i = 1; i < spans.length; i++) spans[i].remove();
    if (!span) {
      span = document.createElement("span");
      span.className = markerClass;
    }
    span.style.display = "block";
    span.style.marginTop = "6px";
    span.style.fontWeight = "700";
    span.style.color = "#FFD84D";
    span.style.fontSize = "14px";
    let icon = span.querySelector(`:scope > img.${ICON_CLASS}`);
    if (!icon) {
      icon = document.createElement("img");
      icon.className = ICON_CLASS;
      icon.alt = "";
      icon.setAttribute("aria-hidden", "true");
      icon.style.width = "18px";
      icon.style.height = "18px";
      icon.style.display = "inline-block";
      icon.style.verticalAlign = "middle";
      icon.style.marginRight = "6px";
      icon.style.userSelect = "none";
      icon.style.pointerEvents = "none";
      span.insertBefore(icon, span.firstChild);
    }
    if (icon.src !== coin.img64) icon.src = coin.img64;
    let label2 = span.querySelector(`:scope > span.${LABEL_CLASS}`);
    if (!label2) {
      label2 = document.createElement("span");
      label2.className = LABEL_CLASS;
      label2.style.display = "inline";
      span.appendChild(label2);
    }
    if (label2.textContent !== text) label2.textContent = text;
    if (inner.lastElementChild !== span) inner.appendChild(span);
  }

  // src/utils/api.ts
  function detectEnvironment() {
    const isInIframe = (() => {
      try {
        return window.top !== window.self;
      } catch {
        return true;
      }
    })();
    const refHost = safeHost(document.referrer);
    const parentLooksDiscord = isInIframe && !!refHost && /(^|\.)discord(app)?\.com$/i.test(refHost);
    const host = location.hostname;
    const surface = parentLooksDiscord ? "discord" : "web";
    const platform = /Android|iPhone|iPad|Mobile/i.test(navigator.userAgent) ? "mobile" : "desktop";
    return {
      surface,
      host,
      origin: location.origin,
      isInIframe,
      platform
    };
  }
  function isDiscordSurface() {
    return detectEnvironment().surface === "discord";
  }
  function buildRoomApiUrl(roomIdOrCode, endpoint = "info") {
    return `${location.origin}/api/rooms/${encodeURIComponent(roomIdOrCode)}/${endpoint}`;
  }
  async function httpGetWithFetch(url, headers, timeoutMs = 1e4) {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), timeoutMs);
    try {
      const res = await fetch(url, {
        method: "GET",
        credentials: "include",
        headers,
        signal: controller.signal
      });
      const body = await res.text();
      return { status: res.status, ok: res.ok, body };
    } finally {
      clearTimeout(timeout);
    }
  }
  function httpGetWithGM(url, headers, timeoutMs = 1e4) {
    return new Promise((resolve2, reject) => {
      if (typeof GM_xmlhttpRequest !== "function") {
        reject(new Error("GM_xmlhttpRequest is not available"));
        return;
      }
      GM_xmlhttpRequest({
        method: "GET",
        url,
        headers,
        timeout: timeoutMs,
        onload: (response) => resolve2({
          status: response.status,
          ok: response.status >= 200 && response.status < 300,
          body: response.responseText
        }),
        onerror: (error) => reject(error),
        ontimeout: () => reject(new Error("GM_xmlhttpRequest timed out"))
      });
    });
  }
  async function requestRoomEndpoint(roomIdOrCode, options = {}) {
    const endpoint = options.endpoint ?? "info";
    const url = buildRoomApiUrl(roomIdOrCode, endpoint);
    const headers = {};
    if (options.jwt) {
      headers["Authorization"] = `Bearer ${options.jwt}`;
    }
    let rawResponse;
    if (options.preferGM && typeof GM_xmlhttpRequest === "function") {
      rawResponse = await httpGetWithGM(url, headers, options.timeoutMs);
    } else {
      try {
        rawResponse = await httpGetWithFetch(url, headers, options.timeoutMs);
      } catch (error) {
        if (typeof GM_xmlhttpRequest === "function") {
          rawResponse = await httpGetWithGM(url, headers, options.timeoutMs);
        } else {
          throw error;
        }
      }
    }
    let parsed;
    try {
      parsed = JSON.parse(rawResponse.body);
    } catch {
    }
    return { url, ...rawResponse, parsed };
  }
  function safeHost(url) {
    if (!url) return null;
    try {
      return new URL(url).hostname;
    } catch {
      return null;
    }
  }
  function buildSoftJoinUrl(roomCode) {
    const merged = new URLSearchParams(location.search);
    const url = new URL(location.href);
    url.pathname = `/r/${encodeURIComponent(roomCode)}`;
    url.search = merged.toString();
    return url.toString();
  }
  function buildHardJoinUrl(roomCode) {
    return buildSoftJoinUrl(roomCode);
  }
  function joinRoom(roomCode, options = {}) {
    const env = detectEnvironment();
    const isDiscord = env.surface === "discord";
    const preferSoft = options.preferSoft ?? !isDiscord;
    const hardIfSoftFails = options.hardIfSoftFails ?? true;
    if (isDiscord) {
      if (options.siteFallbackOnDiscord) {
        const fallback = `https://magiccircle.gg/r/${encodeURIComponent(roomCode)}`;
        if (options.openInNewTab) {
          window.open(fallback, "_blank", "noopener,noreferrer");
        } else {
          location.assign(fallback);
        }
        return {
          ok: true,
          mode: "site-fallback",
          url: fallback,
          message: "Discord activity does not support room switching by code, redirecting to the official site."
        };
      }
      return {
        ok: false,
        mode: "discord-unsupported",
        message: "Discord activity does not support joining a room by code. Open the website or use an activity invite."
      };
    }
    const softUrl = buildSoftJoinUrl(roomCode);
    if (preferSoft) {
      try {
        const url = new URL(softUrl);
        if (url.origin === location.origin) {
          history.replaceState({}, "", url.pathname + (url.search || "") + (url.hash || ""));
          window.dispatchEvent(new PopStateEvent("popstate", { state: {} }));
          console.log("[joinRoom] soft \u2192", url.toString());
          return { ok: true, mode: "soft", url: url.toString() };
        }
      } catch {
      }
      if (!hardIfSoftFails) {
        return {
          ok: false,
          mode: "noop",
          url: softUrl,
          message: "Soft navigation failed because the origins differ."
        };
      }
    }
    const hardUrl = buildHardJoinUrl(roomCode);
    console.log("[joinRoom] hard \u2192", hardUrl);
    location.assign(hardUrl);
    return { ok: true, mode: "hard", url: hardUrl };
  }

  // src/utils/version.ts
  var REPO_OWNER = "Ariedam64";
  var REPO_NAME = "MagicGarden-modMenu";
  var REPO_BRANCH = "main";
  var SCRIPT_FILE_PATH = "quinoa-ws.min.user.js";
  var RAW_BASE_URL = `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}`;
  var COMMITS_API_URL = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/commits/${REPO_BRANCH}`;
  async function fetchTextWithFetch(url, options) {
    const response = await fetch(url, { cache: "no-store", ...options });
    if (!response.ok) {
      throw new Error(`Failed to load remote resource: ${response.status} ${response.statusText}`);
    }
    return await response.text();
  }
  async function fetchTextWithGM(url, options) {
    return new Promise((resolve2, reject) => {
      const xhr = typeof GM_xmlhttpRequest === "function" ? GM_xmlhttpRequest : typeof GM !== "undefined" && typeof GM.xmlHttpRequest === "function" ? GM.xmlHttpRequest : null;
      if (!xhr) return reject(new Error("GM_xmlhttpRequest not available"));
      xhr({
        method: "GET",
        url,
        headers: options?.headers,
        onload: (res) => {
          if (res.status >= 200 && res.status < 300) resolve2(res.responseText);
          else reject(new Error(`GM_xhr failed: ${res.status}`));
        },
        onerror: (e) => reject(e)
      });
    });
  }
  async function fetchText(url, options) {
    const preferGM = isDiscordSurface();
    const hasGM = typeof GM_xmlhttpRequest === "function" || typeof GM !== "undefined" && typeof GM.xmlHttpRequest === "function";
    if (preferGM && hasGM) {
      return await fetchTextWithGM(url, options);
    }
    try {
      return await fetchTextWithFetch(url, options);
    } catch (error) {
      if (hasGM) {
        return await fetchTextWithGM(url, options);
      }
      throw error;
    }
  }
  async function fetchLatestCommitSha() {
    try {
      const responseText = await fetchText(COMMITS_API_URL, {
        headers: { Accept: "application/vnd.github+json" }
      });
      const data = JSON.parse(responseText);
      if (data && typeof data.sha === "string" && data.sha.trim().length > 0) {
        return data.sha.trim();
      }
    } catch (error) {
      console.warn("[MagicGarden] Failed to resolve latest commit SHA:", error);
    }
    return null;
  }
  async function fetchScriptSource() {
    const commitSha = await fetchLatestCommitSha();
    const scriptUrl = commitSha ? `${RAW_BASE_URL}/${commitSha}/${SCRIPT_FILE_PATH}` : `${RAW_BASE_URL}/refs/heads/${REPO_BRANCH}/${SCRIPT_FILE_PATH}?t=${Date.now()}`;
    return await fetchText(scriptUrl);
  }
  async function fetchRemoteVersion() {
    try {
      const scriptSource = await fetchScriptSource();
      const meta = extractUserscriptMetadata(scriptSource);
      if (!meta) {
        throw new Error("Metadata block not found in remote script");
      }
      const version = meta.get("version")?.[0];
      const download = meta.get("downloadurl")?.[0] ?? meta.get("updateurl")?.[0];
      return {
        version,
        download
      };
    } catch (error) {
      console.error("Unable to retrieve remote version:", error);
      return null;
    }
  }
  function extractUserscriptMetadata(source) {
    const headerMatch = source.match(/\/\/ ==UserScript==([\s\S]*?)\/\/ ==\/UserScript==/);
    if (!headerMatch) {
      return null;
    }
    const metaBlock = headerMatch[1];
    const entries = metaBlock.matchAll(/^\/\/\s*@([^\s]+)\s+(.+)$/gm);
    const meta = /* @__PURE__ */ new Map();
    for (const [, rawKey, rawValue] of entries) {
      const key2 = rawKey.trim().toLowerCase();
      const value = rawValue.trim();
      if (!key2) continue;
      const current = meta.get(key2);
      if (current) {
        current.push(value);
      } else {
        meta.set(key2, [value]);
      }
    }
    return meta;
  }
  function getLocalVersion() {
    if (typeof GM_info !== "undefined" && GM_info?.script?.version) {
      return GM_info.script.version;
    }
    return void 0;
  }

  // src/core/dom.ts
  var ready = new Promise((res) => {
    if (document.readyState !== "loading") res();
    else addEventListener("DOMContentLoaded", () => res(), { once: true });
  });
  function addStyle(css) {
    const s = document.createElement("style");
    s.textContent = css;
    document.head.appendChild(s);
    return s;
  }
  function toPredicate(selOrFn) {
    if (typeof selOrFn === "function") return selOrFn;
    if (typeof selOrFn === "string") return (el2) => el2.matches?.(selOrFn) ?? false;
    throw new Error("Selector or predicate required");
  }
  function onAdded(selOrFn, cb, { root = document, callForExisting = true } = {}) {
    const pred = toPredicate(selOrFn);
    const seen = /* @__PURE__ */ new WeakSet();
    const consider = (el2) => {
      if (seen.has(el2)) return;
      if (pred(el2)) {
        seen.add(el2);
        cb(el2);
      }
    };
    if (callForExisting && "querySelectorAll" in root) {
      root.querySelectorAll("*").forEach(consider);
    }
    const obs = new MutationObserver((muts) => {
      for (const m of muts) for (const n of Array.from(m.addedNodes)) {
        if (n.nodeType !== 1) continue;
        const el2 = n;
        consider(el2);
        el2.querySelectorAll?.("*").forEach(consider);
      }
    });
    obs.observe(root, { childList: true, subtree: true });
    return { disconnect: () => obs.disconnect() };
  }

  // src/utils/petPanelEnhancer.ts
  var PANEL_SELECTOR = ".css-ycloo9";
  var FEED_BUTTON_CLASS = "tm-feed-from-inventory-btn";
  var FEED_ROW_CLASS = "tm-feed-from-inventory-row";
  var started = false;
  function startPetPanelEnhancer() {
    if (started) return;
    started = true;
    if (typeof document === "undefined") {
      return;
    }
    onAdded(PANEL_SELECTOR, (node) => {
      if (!(node instanceof HTMLElement)) return;
      enhancePanel(node);
    });
  }
  function enhancePanel(root) {
    try {
      ensureFeedButton(root);
    } catch (err) {
      console.warn("[PetPanel] Failed to inject feed button", err);
    }
  }
  function ensureFeedButton(root) {
    if (root.querySelector(`.${FEED_BUTTON_CLASS}`)) return;
    const templateBtn = root.querySelector("button.chakra-button");
    const btn = createStyledButton(templateBtn, "INSTANT FEED");
    btn.classList.add(FEED_BUTTON_CLASS);
    btn.setAttribute("aria-label", "Feed pet from inventory");
    btn.title = "Feed pet from inventory";
    btn.style.width = "100%";
    btn.style.minWidth = "100%";
    btn.style.alignContent = "center";
    btn.style.alignItems = "center";
    btn.style.padding = "6px 14px";
    btn.style.fontSize = "13px";
    btn.style.border = "2px solid #FFC83D";
    btn.style.color = "rgb(205 200 193)";
    btn.style.borderRadius = "10px";
    btn.style.height = "40px";
    btn.addEventListener("click", () => {
      void handleFeedClick(btn);
    });
    const row = document.createElement("div");
    row.classList.add("McFlex", FEED_ROW_CLASS);
    row.style.marginTop = "8px";
    row.style.justifyContent = "center";
    row.style.width = "100%";
    row.style.flexDirection = "column";
    row.style.alignItems = "stretch";
    row.style.gap = "8px";
    row.appendChild(btn);
    const feedFromInventoryBtn = createStyledButton(
      templateBtn,
      "FEED FROM INVENTORY"
    );
    feedFromInventoryBtn.style.width = "100%";
    feedFromInventoryBtn.style.minWidth = "100%";
    feedFromInventoryBtn.style.alignContent = "center";
    feedFromInventoryBtn.style.alignItems = "center";
    feedFromInventoryBtn.style.marginTop = "8px";
    feedFromInventoryBtn.style.padding = "6px 14px";
    feedFromInventoryBtn.style.fontSize = "13px";
    feedFromInventoryBtn.style.border = "2px solid #BA5E1E";
    feedFromInventoryBtn.style.color = "rgb(205 200 193)";
    feedFromInventoryBtn.style.borderRadius = "10px";
    feedFromInventoryBtn.style.height = "40px";
    row.appendChild(feedFromInventoryBtn);
    feedFromInventoryBtn.addEventListener("click", () => {
      void handleInventoryPreviewClick(feedFromInventoryBtn);
    });
    const actions = root.querySelector(".McFlex.css-cabebk");
    const abilities = root.querySelector(".McFlex.css-1hd05pq");
    if (actions && abilities && abilities.parentElement === actions.parentElement) {
      abilities.parentElement.insertBefore(row, abilities);
    } else if (actions?.parentElement) {
      actions.parentElement.insertBefore(row, actions.nextSibling);
    } else {
      root.appendChild(row);
    }
  }
  function createStyledButton(template, label2) {
    const btn = document.createElement("button");
    btn.type = "button";
    if (template?.className) {
      btn.className = template.className;
    } else {
      btn.className = "chakra-button";
    }
    const wrapper = document.createElement("div");
    wrapper.className = template?.firstElementChild instanceof HTMLElement ? template.firstElementChild.className : "McFlex";
    const textEl = document.createElement("p");
    const templateText = template?.querySelector(".chakra-text");
    textEl.className = templateText instanceof HTMLElement ? templateText.className : "chakra-text";
    textEl.textContent = label2;
    wrapper.appendChild(textEl);
    btn.appendChild(wrapper);
    return btn;
  }
  async function handleFeedClick(btn) {
    const prevDisabled = btn.disabled;
    btn.disabled = true;
    try {
      const petId = await getExpandedPetId();
      if (!petId) {
        await toastSimple("Feed from inventory", "No expanded pet detected.", "error");
        return;
      }
      const pet = await findPetById2(petId);
      if (!pet) {
        await toastSimple("Feed from inventory", "Unable to resolve expanded pet.", "error");
        return;
      }
      const species = String(pet?.slot?.petSpecies || "");
      const compatibleList = PetsService.getCompatibleCropsForSpecies(species) ?? [];
      const compatible = new Set(compatibleList.map((item) => String(item || "")));
      if (!compatible.size) {
        await toastSimple("Feed from inventory", "No compatible crops for this pet.", "info");
        return;
      }
      const inventory = await PlayerService.getCropInventoryState();
      const items = Array.isArray(inventory) ? inventory : [];
      const favoriteSet = await PlayerService.getFavoriteIdSet().catch(() => /* @__PURE__ */ new Set());
      const chosen = items.find((item) => {
        const speciesId = String(item?.species || "");
        if (!speciesId || !compatible.has(speciesId)) return false;
        const id = String(item?.id || "");
        return id && !favoriteSet.has(id);
      });
      const chosenId = String(chosen?.id || "");
      if (!chosenId) {
        await toastSimple(
          "Feed from inventory",
          "No compatible crops in inventory (excluding favorites).",
          "info"
        );
        return;
      }
      const previousHungerPct = getHungerPctForPet(pet);
      await PlayerService.feedPet(petId, chosenId);
      const hungerPct = await waitForHungerIncrease(petId, previousHungerPct, {
        initialDelay: 150
      });
      const hungerSuffix = hungerPct != null ? ` Hunger: ${formatHungerPct(hungerPct)}%.` : "";
      const cropName = String(chosen?.species || "crop");
      const petLabel = pet?.slot?.name || species || petId;
      await toastSimple(
        "Feed from inventory",
        `Fed ${petLabel} with ${cropName}.${hungerSuffix}`,
        "success"
      );
    } catch (err) {
      console.error("[Pet panel] Failed to feed pet from inventory", err);
      await toastSimple(
        "Feed from inventory",
        err instanceof Error ? err.message : "Failed to feed pet.",
        "error"
      );
    } finally {
      btn.disabled = prevDisabled;
    }
  }
  async function handleInventoryPreviewClick(btn) {
    const prevDisabled = btn.disabled;
    let shouldCloseInventory = false;
    btn.disabled = true;
    try {
      const petId = await getExpandedPetId();
      if (!petId) {
        await toastSimple("Feed from inventory", "No expanded pet detected.", "error");
        return;
      }
      const pet = await findPetById2(petId);
      if (!pet) {
        await toastSimple("Feed from inventory", "Unable to resolve expanded pet.", "error");
        return;
      }
      const species = String(pet?.slot?.petSpecies || "");
      let lastKnownHungerPct = getHungerPctForPet(pet);
      const allowed = await getAllowedCrops(petId, species);
      if (!allowed.size) {
        await toastSimple("Feed from inventory", "No compatible crops for this pet.", "info");
        return;
      }
      const inventory = await PlayerService.getCropInventoryState();
      const items = Array.isArray(inventory) ? inventory : [];
      const favoriteSet = await PlayerService.getFavoriteIdSet().catch(() => /* @__PURE__ */ new Set());
      const filtered = items.filter((item) => {
        const speciesId = String(item?.species || "");
        if (!speciesId || !allowed.has(speciesId)) return false;
        const id = String(item?.id || "");
        return id && !favoriteSet.has(id);
      });
      if (!filtered.length) {
        await toastSimple("Feed from inventory", "No compatible crops in inventory.", "info");
        return;
      }
      const computeFavoritedIds = (items2) => {
        const allowedIds = /* @__PURE__ */ new Set();
        for (const item of items2) {
          const id = String(item?.id || "");
          if (id) allowedIds.add(id);
        }
        return Array.from(favoriteSet).filter((id) => allowedIds.has(id));
      };
      await clearHandSelection().catch(() => {
      });
      let visibleItems = filtered.slice();
      let favoritedItemIds = computeFavoritedIds(visibleItems);
      await fakeInventoryShow({ items: visibleItems, favoritedItemIds }, { open: true });
      const label2 = pet?.slot?.name || species || petId;
      await toastSimple(
        "Feed from inventory",
        `Showing ${visibleItems.length} compatible crop(s) for ${label2}. Select a crop to feed it immediately.`,
        "info"
      );
      while (true) {
        const selectedIndex = await waitForFakeInventorySelection(2e4);
        if (selectedIndex == null) {
          await toastSimple("Feed from inventory", "No crop selected.", "info");
          break;
        }
        if (selectedIndex < 0 || selectedIndex >= visibleItems.length) {
          await toastSimple("Feed from inventory", "Invalid crop selection.", "error");
          await clearHandSelection().catch(() => {
          });
          continue;
        }
        const chosen = visibleItems[selectedIndex];
        const chosenId = String(chosen?.id || "");
        if (!chosenId) {
          await toastSimple("Feed from inventory", "Invalid crop selection.", "error");
          await clearHandSelection().catch(() => {
          });
          continue;
        }
        const hungerPctBeforeFeed = lastKnownHungerPct;
        await PlayerService.feedPet(petId, chosenId);
        const hungerPct = await waitForHungerIncrease(petId, hungerPctBeforeFeed, {
          initialDelay: 200
        });
        if (hungerPct != null) {
          lastKnownHungerPct = hungerPct;
        }
        const hungerSuffix = hungerPct != null ? ` Hunger: ${formatHungerPct(hungerPct)}%.` : "";
        const cropName = String(chosen?.species || "crop");
        const petLabel = pet?.slot?.name || species || petId;
        await toastSimple(
          "Feed from inventory",
          `Fed ${petLabel} with ${cropName}.${hungerSuffix}`,
          "success"
        );
        const hungerFull = hungerPct != null && hungerPct >= 99.9;
        if (hungerFull) {
          shouldCloseInventory = true;
          try {
            await closeInventoryPanel();
          } catch {
          }
          break;
        }
        let invItems = null;
        try {
          const nextInventory = await PlayerService.getCropInventoryState();
          invItems = Array.isArray(nextInventory) ? nextInventory : null;
        } catch {
          invItems = null;
        }
        let nextVisible = invItems?.filter((item) => {
          const speciesId = String(item?.species || "");
          if (!speciesId || !allowed.has(speciesId)) return false;
          const id = String(item?.id || "");
          return id && !favoriteSet.has(id);
        }) ?? null;
        const removeChosenLocally = () => visibleItems.filter((item) => String(item?.id || "") !== chosenId);
        if (!nextVisible) {
          nextVisible = removeChosenLocally();
        } else {
          const stillContainsChosen = nextVisible.some(
            (item) => String(item?.id || "") === chosenId
          );
          if (stillContainsChosen) {
            nextVisible = removeChosenLocally();
          }
        }
        visibleItems = nextVisible;
        if (!visibleItems.length) {
          await toastSimple("Feed from inventory", "No compatible crops in inventory.", "info");
          shouldCloseInventory = true;
          try {
            await closeInventoryPanel();
          } catch {
          }
          break;
        }
        favoritedItemIds = computeFavoritedIds(visibleItems);
        await fakeInventoryShow({ items: visibleItems, favoritedItemIds }, { open: false });
        await clearHandSelection().catch(() => {
        });
      }
    } catch (err) {
      console.error("[Pet panel] Failed to handle inventory feed", err);
      await toastSimple(
        "Feed from inventory",
        err instanceof Error ? err.message : "Failed to feed pet from inventory.",
        "error"
      );
    } finally {
      try {
        await clearHandSelection();
      } catch {
      }
      if (shouldCloseInventory) {
        try {
          await closeInventoryPanel();
        } catch {
        }
      }
      btn.disabled = prevDisabled;
    }
  }
  async function getExpandedPetId() {
    try {
      const raw = await Atoms.pets.expandedPetSlotId.get();
      const id = typeof raw === "string" ? raw.trim() : "";
      return id.length ? id : null;
    } catch {
      return null;
    }
  }
  async function findPetById2(petId) {
    try {
      const list = await PetsService.getPets();
      const arr = Array.isArray(list) ? list : [];
      return arr.find((p) => String(p?.slot?.id || "") === petId) ?? null;
    } catch (err) {
      console.warn("[Pet panel] Failed to fetch pets", err);
      return null;
    }
  }
  async function getAllowedCrops(petId, species) {
    const defaults = PetsService.getCompatibleCropsForSpecies(species) ?? [];
    return new Set(defaults);
  }
  function formatHungerPct(pct) {
    if (!Number.isFinite(pct)) return "";
    const clamped = Math.max(0, Math.min(100, pct));
    const rounded = Math.round(clamped * 10) / 10;
    return Number.isInteger(rounded) ? String(rounded) : rounded.toFixed(1);
  }
  var HUNGER_EPSILON = 0.05;
  var HUNGER_TIMEOUT_MS = 4e3;
  var HUNGER_POLL_INTERVAL_MS = 120;
  function isPetInfo(value) {
    if (!value || typeof value !== "object") return false;
    const slot = value.slot;
    return !!slot && typeof slot === "object";
  }
  function getHungerPctForPet(pet) {
    if (!isPetInfo(pet)) return null;
    try {
      const hungerPct = PetsService.getHungerPctFor(pet);
      return typeof hungerPct === "number" && Number.isFinite(hungerPct) ? hungerPct : null;
    } catch {
      return null;
    }
  }
  async function getPetHungerPct(petId) {
    try {
      const updatedPet = await findPetById2(petId);
      return getHungerPctForPet(updatedPet);
    } catch {
      return null;
    }
  }
  async function waitForHungerIncrease(petId, previousPct, options = {}) {
    const { initialDelay = 0, timeout = HUNGER_TIMEOUT_MS, interval = HUNGER_POLL_INTERVAL_MS } = options;
    if (initialDelay > 0) {
      await delay3(initialDelay);
    }
    const start = typeof performance !== "undefined" && typeof performance.now === "function" ? performance.now() : Date.now();
    let lastResult = null;
    while (true) {
      const pct = await getPetHungerPct(petId);
      if (pct != null) {
        lastResult = pct;
        if (previousPct == null || pct >= Math.min(100, previousPct + HUNGER_EPSILON) || pct >= 99.9) {
          return pct;
        }
      }
      const now2 = typeof performance !== "undefined" && typeof performance.now === "function" ? performance.now() : Date.now();
      if (now2 - start >= timeout) {
        return lastResult;
      }
      if (interval > 0) {
        await delay3(interval);
      }
    }
  }
  function delay3(ms) {
    return new Promise((resolve2) => setTimeout(resolve2, ms));
  }
  async function waitForFakeInventorySelection(timeoutMs = 2e4) {
    const start = performance.now();
    while (performance.now() - start < timeoutMs) {
      try {
        const modalVal = await Atoms.ui.activeModal.get();
        if (!isInventoryOpen(modalVal)) return null;
      } catch {
        return null;
      }
      try {
        const value = await Atoms.inventory.myPossiblyNoLongerValidSelectedItemIndex.get();
        if (typeof value === "number" && Number.isInteger(value) && value >= 0) {
          return value;
        }
      } catch {
      }
      await new Promise((resolve2) => setTimeout(resolve2, 80));
    }
    return null;
  }

  // src/utils/inventorySelectionLogger.ts
  var started2 = false;
  var cachedItems = [];
  var currentIndex = null;
  var lastLoggedQuantity = void 0;
  var desiredButtonQuantity = null;
  var buttonDiscoveryObserver = null;
  var buttonVisibilityObserver = null;
  function getActionButton() {
    if (typeof document === "undefined") return null;
    const primaryButton = document.querySelector(
      "button.chakra-button.css-1f6o5y1"
    );
    if (primaryButton) return primaryButton;
    const growButtons = Array.from(
      document.querySelectorAll(
        "button.chakra-button.css-h3d7a8"
      )
    );
    return growButtons.find(
      (button) => (button.textContent ?? "").includes("Grow")
    ) ?? null;
  }
  function applyQuantityToButton(button, quantity) {
    const quantityContainer = button.querySelector(".css-telpzl");
    const readButtonLabel = () => {
      const clone = button.cloneNode(true);
      clone.querySelectorAll(".css-telpzl").forEach((element) => element.remove());
      return (clone.textContent ?? "").replace(/\s+/g, " ").trim();
    };
    const ensureBaseLabel = () => {
      const existing = button.dataset.baseLabel ?? "";
      const lastQuantity = button.dataset.lastQuantity;
      const currentLabel = readButtonLabel();
      const normalizedCurrentLabel = (() => {
        if (!currentLabel) return "";
        if (lastQuantity && lastQuantity.length > 0) {
          const withSpace = ` \xD7${lastQuantity}`;
          if (currentLabel.endsWith(withSpace)) {
            return currentLabel.slice(0, -withSpace.length).replace(/\s+$/, "");
          }
          const withoutSpace = `\xD7${lastQuantity}`;
          if (currentLabel.endsWith(withoutSpace)) {
            return currentLabel.slice(0, -withoutSpace.length).replace(/\s+$/, "");
          }
        }
        return currentLabel;
      })();
      if (normalizedCurrentLabel && normalizedCurrentLabel !== existing) {
        button.dataset.baseLabel = normalizedCurrentLabel;
        return normalizedCurrentLabel;
      }
      if (!existing && normalizedCurrentLabel) {
        button.dataset.baseLabel = normalizedCurrentLabel;
        return normalizedCurrentLabel;
      }
      return existing;
    };
    const setButtonLabel = (label2) => {
      const contentNode = Array.from(button.childNodes).find((node) => {
        if (quantityContainer && node === quantityContainer) return false;
        const text = node.textContent ?? "";
        return text.trim().length > 0;
      });
      if (contentNode) {
        contentNode.textContent = label2;
        return;
      }
      const referenceNode = quantityContainer ?? button.firstChild;
      button.insertBefore(document.createTextNode(label2), referenceNode ?? null);
    };
    const baseLabel = ensureBaseLabel();
    if (quantityContainer) {
      quantityContainer.textContent = "";
      quantityContainer.style.marginLeft = "";
      quantityContainer.style.display = "none";
    }
    if (quantity == null) {
      button.dataset.lastQuantity = "";
      setButtonLabel(baseLabel);
      return;
    }
    const labelWithQuantity = baseLabel ? `${baseLabel} \xD7${quantity}` : `\xD7${quantity}`;
    button.dataset.lastQuantity = String(quantity);
    setButtonLabel(labelWithQuantity);
  }
  function ensureButtonVisibilityObserver(button) {
    if (typeof IntersectionObserver === "undefined") return;
    if (!buttonVisibilityObserver) {
      buttonVisibilityObserver = new IntersectionObserver((entries) => {
        entries.filter((entry) => entry.isIntersecting).forEach((entry) => {
          applyQuantityToButton(entry.target, desiredButtonQuantity);
        });
      });
    } else {
      buttonVisibilityObserver.disconnect();
    }
    buttonVisibilityObserver.observe(button);
  }
  function ensureButtonDiscoveryObserver() {
    if (typeof document === "undefined") return;
    if (buttonDiscoveryObserver || typeof MutationObserver === "undefined") return;
    const target = document.body;
    if (!target) return;
    buttonDiscoveryObserver = new MutationObserver(() => {
      const button = getActionButton();
      if (!button) return;
      ensureButtonVisibilityObserver(button);
      applyQuantityToButton(button, desiredButtonQuantity);
    });
    buttonDiscoveryObserver.observe(target, { childList: true, subtree: true });
  }
  function updateButtonQuantity(quantity) {
    if (typeof document === "undefined") return;
    desiredButtonQuantity = quantity;
    const button = getActionButton();
    if (!button) {
      ensureButtonDiscoveryObserver();
      return;
    }
    ensureButtonVisibilityObserver(button);
    applyQuantityToButton(button, quantity);
  }
  function normalizeItems(snapshot) {
    if (!snapshot || !Array.isArray(snapshot.items)) return [];
    return snapshot.items.slice();
  }
  function extractQuantity(index) {
    if (index == null || index < 0 || index >= cachedItems.length) return null;
    const raw = cachedItems[index];
    if (!raw) return null;
    const qty = Number(raw.quantity);
    return Number.isFinite(qty) ? qty : null;
  }
  function logQuantity(force = false) {
    if (currentIndex == null) {
      updateButtonQuantity(null);
      lastLoggedQuantity = null;
      return;
    }
    const qty = extractQuantity(currentIndex);
    if (!force && qty === lastLoggedQuantity) return;
    if (qty == null) {
      console.log(`[InventorySelection] Quantit\xE9 inconnue pour l'index ${currentIndex}.`);
    } else {
      console.log(`[InventorySelection] Quantit\xE9 de l'item s\xE9lectionn\xE9 (${currentIndex}) : ${qty}`);
    }
    updateButtonQuantity(qty);
    lastLoggedQuantity = qty;
  }
  async function readInventory() {
    try {
      return await Atoms.inventory.myInventory.get();
    } catch (error) {
      console.warn("[InventorySelection] Impossible de r\xE9cup\xE9rer l'inventaire", error);
      return null;
    }
  }
  async function readSelectedIndex() {
    try {
      const value = await Atoms.inventory.myPossiblyNoLongerValidSelectedItemIndex.get();
      return typeof value === "number" ? value : null;
    } catch (error) {
      console.warn("[InventorySelection] Impossible de r\xE9cup\xE9rer l'index s\xE9lectionn\xE9", error);
      return null;
    }
  }
  async function startSelectedInventoryQuantityLogger() {
    if (started2) return;
    started2 = true;
    cachedItems = normalizeItems(await readInventory());
    currentIndex = await readSelectedIndex();
    logQuantity(true);
    try {
      await Atoms.inventory.myInventory.onChange((next) => {
        cachedItems = normalizeItems(next);
        logQuantity();
      });
    } catch (error) {
      console.warn("[InventorySelection] \xC9chec de l'abonnement \xE0 myInventory", error);
    }
    try {
      await Atoms.inventory.myPossiblyNoLongerValidSelectedItemIndex.onChange((next) => {
        if (typeof next === "number") {
          currentIndex = next;
        } else {
          currentIndex = null;
        }
        lastLoggedQuantity = null;
        logQuantity(true);
      });
    } catch (error) {
      console.warn("[InventorySelection] \xC9chec de l'abonnement \xE0 myPossiblyNoLongerValidSelectedItemIndex", error);
    }
  }

  // src/utils/checkModal.ts
  var DEFAULTS4 = {
    intervalMs: 6e4,
    log: false
  };
  var normalize = (s) => (s || "").replace(/\s+/g, " ").trim();
  var reGameUpdate = /game\s*update\s+ava?ilab?le/i;
  var reDailyBread = /your\s+daily\s+bread/i;
  var log = (enabled, ...args) => {
    if (enabled) console.log("[checkModal]", ...args);
  };
  var reloadScheduled = false;
  var schedulePageReload = (doLog) => {
    if (reloadScheduled) return;
    reloadScheduled = true;
    log(doLog, "Game Update: \u267B\uFE0F rechargement de la page dans un instant...");
    pageWindow.setTimeout(() => {
      log(doLog, "Game Update: \u{1F504} rechargement maintenant.");
      pageWindow.location.reload();
    }, 500);
  };
  var isVisible = (el2) => {
    if (!el2 || !(el2 instanceof HTMLElement)) return false;
    const rect = el2.getBoundingClientRect();
    if (rect.width <= 0 || rect.height <= 0) return false;
    const cs = getComputedStyle(el2);
    if (cs.display === "none" || cs.visibility === "hidden" || parseFloat(cs.opacity) === 0) return false;
    let cur = el2;
    while (cur) {
      const cs2 = getComputedStyle(cur);
      if (cs2.display === "none" || cs2.visibility === "hidden") return false;
      cur = cur.parentElement;
    }
    return true;
  };
  function findGameUpdateModal() {
    const sections = document.querySelectorAll(
      'section.chakra-modal__content[role="dialog"], section.chakra-modal__content[role="alertdialog"]'
    );
    for (const sec of sections) {
      const header = sec.querySelector("header.chakra-modal__header");
      const txt = normalize(header?.textContent || sec.textContent || "");
      if (reGameUpdate.test(txt)) return sec;
    }
    return null;
  }
  function findBreadModal() {
    const sections = document.querySelectorAll(
      'section.chakra-modal__content[role="dialog"], section.chakra-modal__content[role="alertdialog"]'
    );
    for (const sec of sections) {
      const txt = normalize(sec.textContent || "");
      if (!reDailyBread.test(txt)) continue;
      let btn = sec.querySelector("button.chakra-button.css-1o32am8");
      if (!btn) {
        const candidates = sec.querySelectorAll("button");
        btn = Array.from(candidates).find((b) => /claim/i.test(normalize(b.textContent))) ?? null;
      }
      if (btn) return { section: sec, button: btn };
    }
    return null;
  }
  var clickedBreadButtons = /* @__PURE__ */ new WeakSet();
  function clickBreadIfVisible(btn, doLog) {
    if (clickedBreadButtons.has(btn)) {
      log(doLog, "Bread: bouton d\xE9j\xE0 cliqu\xE9 (guard).");
      return false;
    }
    const ariaDisabled = btn.getAttribute("aria-disabled");
    if (btn.disabled || ariaDisabled === "true") {
      log(doLog, "Bread: bouton d\xE9sactiv\xE9.");
      return false;
    }
    if (!isVisible(btn)) {
      log(doLog, "Bread: bouton non visible.");
      return false;
    }
    btn.click();
    clickedBreadButtons.add(btn);
    log(doLog, "Bread: \u2705 click() envoy\xE9.");
    return true;
  }
  function checkOnce(opts) {
    const { log: doLog } = { ...DEFAULTS4, ...opts };
    const gameUpdateSec = findGameUpdateModal();
    const gameUpdateFound = !!gameUpdateSec;
    if (gameUpdateFound) {
      log(doLog, "Game Update: \u2705 d\xE9tect\xE9.", gameUpdateSec);
      schedulePageReload(doLog);
    }
    const found = findBreadModal();
    const breadFound = !!found;
    let breadClicked = false;
    if (found) {
      log(doLog, "Daily Bread: \u2705 d\xE9tect\xE9.", found.section);
      breadClicked = clickBreadIfVisible(found.button, doLog);
    }
    if (!gameUpdateFound && !breadFound) log(doLog, "Rien d\xE9tect\xE9 pour l\u2019instant.");
    return { gameUpdateFound, breadFound, breadClicked };
  }
  function startModalObserver(options) {
    const { intervalMs, log: doLog } = { ...DEFAULTS4, ...options };
    let stopped = false;
    const tick = () => {
      if (stopped) return { gameUpdateFound: false, breadFound: false, breadClicked: false };
      return checkOnce({ log: doLog });
    };
    tick();
    const timer = pageWindow.setInterval(tick, intervalMs);
    const stop = () => {
      if (stopped) return;
      stopped = true;
      pageWindow.clearInterval(timer);
      log(doLog, "\u23F9\uFE0F Observateur arr\xEAt\xE9.");
    };
    log(doLog, `\u25B6\uFE0F Observateur d\xE9marr\xE9 (intervalle: ${intervalMs} ms).`);
    return { stop, tick };
  }
  var exposed = {
    startModalObserver,
    checkOnce,
    findGameUpdateModal,
    findBreadModal
  };
  shareGlobal("CheckModal", exposed);

  // src/utils/petCalcul.ts
  var SEC_PER_HOUR = 3600;
  var XP_STRENGTH_MAX = 30;
  var BASE_STRENGTH_FLOOR = 30;
  var getCatalogEntry = (species) => {
    if (!species) return null;
    const entry = petCatalog[species];
    return entry ?? null;
  };
  var getMutationEntry = (mutation) => {
    if (!mutation) return null;
    const entry = mutationCatalog[mutation];
    return entry ?? null;
  };
  var getTargetScale = (pet) => {
    const raw = pet?.targetScale;
    return typeof raw === "number" && Number.isFinite(raw) ? raw : 1;
  };
  var getXp = (pet) => {
    const raw = pet?.xp;
    return typeof raw === "number" && Number.isFinite(raw) ? Math.max(0, raw) : 0;
  };
  var getPetMaxStrength = (pet) => {
    const entry = getCatalogEntry(pet?.petSpecies ?? "");
    if (!entry) return 0;
    const maxScale = typeof entry.maxScale === "number" && entry.maxScale > 1 ? entry.maxScale : 1;
    const targetScale = getTargetScale(pet);
    const ratio = maxScale > 1 ? (targetScale - 1) / (maxScale - 1) : 0;
    const raw = ratio * 20 + 80;
    const strength = Math.floor(Number.isFinite(raw) ? raw : 0);
    return Math.max(strength, 0);
  };
  var getBaseStrength = (maxStrength) => {
    const base = maxStrength - BASE_STRENGTH_FLOOR;
    return Math.max(base, 0);
  };
  var getPetStrength = (pet) => {
    const entry = getCatalogEntry(pet?.petSpecies ?? "");
    if (!entry) return 0;
    const hoursToMature = typeof entry.hoursToMature === "number" && entry.hoursToMature > 0 ? entry.hoursToMature : 1;
    const maxStrength = getPetMaxStrength(pet);
    if (maxStrength <= 0) return 0;
    const xpRate = getXp(pet) / (hoursToMature * SEC_PER_HOUR);
    const xpComponent = Math.min(Math.floor(xpRate * XP_STRENGTH_MAX), XP_STRENGTH_MAX);
    const baseStrength = getBaseStrength(maxStrength);
    const strength = Math.min(baseStrength + xpComponent, maxStrength);
    return Math.max(strength, 0);
  };
  var getPetCoinMultiplier = (pet) => {
    const mutations = Array.isArray(pet?.mutations) ? pet.mutations : [];
    return mutations.reduce((acc, mutation) => {
      const entry = getMutationEntry(mutation);
      const multiplier = entry?.coinMultiplier;
      if (typeof multiplier === "number" && Number.isFinite(multiplier) && multiplier > 0) {
        return acc * multiplier;
      }
      return acc;
    }, 1);
  };
  var getPetValue = (pet) => {
    const entry = getCatalogEntry(pet?.petSpecies ?? "");
    if (!entry) return 0;
    const maturitySellPrice = typeof entry.maturitySellPrice === "number" ? entry.maturitySellPrice : 0;
    const maxStrength = getPetMaxStrength(pet);
    if (maxStrength <= 0) return 0;
    const strength = getPetStrength(pet);
    const targetScale = getTargetScale(pet);
    const coinMultiplier = getPetCoinMultiplier(pet);
    const raw = maturitySellPrice * (strength / maxStrength) * targetScale * coinMultiplier;
    if (!Number.isFinite(raw)) return 0;
    return Math.round(Math.max(raw, 0));
  };
  var getPetInfo = (pet) => ({
    value: getPetValue(pet),
    strength: getPetStrength(pet),
    maxStrength: getPetMaxStrength(pet),
    coinMultiplier: getPetCoinMultiplier(pet)
  });

  // src/utils/inventoryValue.ts
  var INVENTORY_VALUE_CATEGORIES = [
    {
      itemType: "Seed",
      identifierKey: "species",
      resolveCoinPrice: (identifier) => {
        if (!identifier) return null;
        const entry = plantCatalog[identifier];
        const price = entry?.seed?.coinPrice;
        return getFiniteNumber(price);
      },
      logKey: "seeds",
      emptyLogMessage: "[InventorySorting] Aucune seed trouv\xE9e dans l'inventaire pour le calcul de valeur.",
      createEntry: (identifier, quantity, coinPrice, value) => ({
        species: identifier,
        quantity,
        coinPrice,
        value
      })
    },
    {
      itemType: "Tool",
      identifierKey: "toolId",
      resolveCoinPrice: (identifier) => {
        if (!identifier) return null;
        const entry = toolCatalog[identifier];
        const price = entry?.coinPrice;
        return getFiniteNumber(price);
      },
      logKey: "tools",
      emptyLogMessage: "[InventorySorting] Aucun tool trouv\xE9 dans l'inventaire pour le calcul de valeur.",
      createEntry: (identifier, quantity, coinPrice, value) => ({
        toolId: identifier,
        quantity,
        coinPrice,
        value
      })
    },
    {
      itemType: "Egg",
      identifierKey: "eggId",
      resolveCoinPrice: (identifier) => {
        if (!identifier) return null;
        const entry = eggCatalog[identifier];
        const price = entry?.coinPrice;
        return getFiniteNumber(price);
      },
      logKey: "eggs",
      emptyLogMessage: "[InventorySorting] Aucun egg trouv\xE9 dans l'inventaire pour le calcul de valeur.",
      createEntry: (identifier, quantity, coinPrice, value) => ({
        eggId: identifier,
        quantity,
        coinPrice,
        value
      })
    },
    {
      itemType: "Decor",
      identifierKey: "decorId",
      resolveCoinPrice: (identifier) => {
        if (!identifier) return null;
        const entry = decorCatalog[identifier];
        const price = entry?.coinPrice;
        return getFiniteNumber(price);
      },
      logKey: "decors",
      emptyLogMessage: "[InventorySorting] Aucun decor trouv\xE9 dans l'inventaire pour le calcul de valeur.",
      createEntry: (identifier, quantity, coinPrice, value) => ({
        decorId: identifier,
        quantity,
        coinPrice,
        value
      })
    }
  ];
  var currentSnapshot = null;
  var watcherPromise = null;
  var unsubscribe = null;
  var computeCounter = 0;
  var listeners3 = /* @__PURE__ */ new Set();
  function getFiniteNumber(value) {
    if (typeof value === "number") {
      return Number.isFinite(value) ? value : null;
    }
    if (typeof value === "string" && value.trim()) {
      const parsed = Number(value);
      return Number.isFinite(parsed) ? parsed : null;
    }
    return null;
  }
  function extractItems(inventory) {
    if (!inventory || typeof inventory !== "object") return null;
    const items = inventory.items;
    if (!Array.isArray(items)) return [];
    return items;
  }
  function toNormalizedIdentifier(raw) {
    if (typeof raw === "string") {
      const trimmed = raw.trim();
      return trimmed ? trimmed : null;
    }
    if (typeof raw === "number") {
      return Number.isFinite(raw) ? String(raw) : null;
    }
    return null;
  }
  function getInventoryValueCategoryByItemType(itemType) {
    return INVENTORY_VALUE_CATEGORIES.find((config) => config.itemType === itemType);
  }
  function computeInventoryItemValue(item, context = {}) {
    if (!item || typeof item !== "object") return null;
    const rawType = typeof item?.itemType === "string" ? item.itemType.trim() : "";
    if (!rawType) return null;
    switch (rawType) {
      case "Pet": {
        const info = getPetInfo(item);
        const value = info.value;
        return typeof value === "number" && Number.isFinite(value) ? value : null;
      }
      case "Plant": {
        const slots = Array.isArray(item?.slots) ? item.slots : [];
        const playersInRoom = context.playersInRoom ?? void 0;
        let total = 0;
        for (const slot of slots) {
          const slotSpecies = typeof slot?.species === "string" ? slot.species : null;
          const rawTarget = slot?.targetScale;
          const target = Number.isFinite(rawTarget) ? rawTarget : Number(rawTarget);
          const targetScale = Number.isFinite(target) ? target : null;
          const mutations = Array.isArray(slot?.mutations) ? slot.mutations.filter((m) => typeof m === "string") : [];
          if (!slotSpecies || targetScale == null) continue;
          const value = estimateProduceValue(slotSpecies, targetScale, mutations, {
            friendPlayers: playersInRoom
          });
          if (typeof value === "number" && Number.isFinite(value)) {
            total += value;
          }
        }
        return total;
      }
      case "Produce": {
        const playersInRoom = context.playersInRoom ?? void 0;
        const value = valueFromInventoryProduce(item, void 0, playersInRoom);
        return typeof value === "number" && Number.isFinite(value) ? value : null;
      }
      default: {
        const category = getInventoryValueCategoryByItemType(rawType);
        if (!category) return null;
        const identifier = toNormalizedIdentifier(item?.[category.identifierKey]);
        const quantity = getFiniteNumber(item?.quantity);
        const coinPrice = category.resolveCoinPrice(identifier);
        if (quantity == null || coinPrice == null) return null;
        const value = coinPrice * quantity;
        return Number.isFinite(value) ? value : null;
      }
    }
  }
  function computePetValues(items) {
    const pets = items.filter((item) => {
      const type = typeof item?.itemType === "string" ? item.itemType.trim() : "";
      return type === "Pet";
    });
    const entries = pets.map((pet) => {
      const info = getPetInfo(pet);
      const id = typeof pet?.id === "string" ? pet.id : null;
      const name = typeof pet?.name === "string" && pet.name.trim() ? pet.name : null;
      const species = typeof pet?.petSpecies === "string" ? pet.petSpecies : null;
      return {
        id,
        name,
        petSpecies: species,
        value: info.value,
        strength: info.strength,
        maxStrength: info.maxStrength,
        coinMultiplier: info.coinMultiplier
      };
    });
    const totalValue = entries.reduce(
      (acc, entry) => acc + (Number.isFinite(entry.value) ? entry.value : 0),
      0
    );
    return { totalValue, pets: entries };
  }
  function computePlantValues(items, playersInRoom) {
    const plants = items.filter((item) => {
      const type = typeof item?.itemType === "string" ? item.itemType.trim() : "";
      return type === "Plant";
    });
    const entries = plants.map((plant) => {
      const id = typeof plant?.id === "string" ? plant.id : null;
      const species = typeof plant?.species === "string" ? plant.species : null;
      const plantedAt = Number.isFinite(plant?.plantedAt) ? plant.plantedAt : null;
      const maturedAt = Number.isFinite(plant?.maturedAt) ? plant.maturedAt : null;
      const slots = Array.isArray(plant?.slots) ? plant.slots : [];
      const slotEntries = slots.map((slot) => {
        const slotSpecies = typeof slot?.species === "string" ? slot.species : null;
        const targetScaleRaw = slot?.targetScale;
        const targetScale = Number.isFinite(targetScaleRaw) ? targetScaleRaw : Number(targetScaleRaw);
        const scaleValue = Number.isFinite(targetScale) ? targetScale : null;
        const mutations = Array.isArray(slot?.mutations) ? slot.mutations.filter((m) => typeof m === "string") : [];
        const value2 = slotSpecies && scaleValue != null ? estimateProduceValue(slotSpecies, scaleValue, mutations, {
          friendPlayers: playersInRoom
        }) : 0;
        return {
          species: slotSpecies,
          targetScale: scaleValue,
          mutations,
          value: value2
        };
      });
      const value = slotEntries.reduce(
        (acc, entry) => acc + (Number.isFinite(entry.value) ? entry.value : 0),
        0
      );
      return {
        id,
        species,
        plantedAt,
        maturedAt,
        value,
        slots: slotEntries
      };
    });
    const totalValue = entries.reduce(
      (acc, entry) => acc + (Number.isFinite(entry.value) ? entry.value : 0),
      0
    );
    return {
      totalValue,
      playersInRoom: Number.isFinite(playersInRoom) ? playersInRoom : null,
      plants: entries
    };
  }
  function computeCropValues(items, playersInRoom) {
    const crops = items.filter((item) => {
      const type = typeof item?.itemType === "string" ? item.itemType.trim() : "";
      return type === "Produce";
    });
    const entries = crops.map((crop) => {
      const id = typeof crop?.id === "string" ? crop.id : null;
      const species = typeof crop?.species === "string" ? crop.species : null;
      const rawScale = crop?.scale;
      const scale = Number.isFinite(rawScale) ? rawScale : Number(rawScale);
      const scaleValue = Number.isFinite(scale) ? scale : null;
      const mutations = Array.isArray(crop?.mutations) ? crop.mutations.filter((m) => typeof m === "string") : [];
      const value = valueFromInventoryProduce(crop, void 0, playersInRoom);
      return {
        id,
        species,
        scale: scaleValue,
        mutations,
        value
      };
    });
    const totalValue = entries.reduce(
      (acc, entry) => acc + (Number.isFinite(entry.value) ? entry.value : 0),
      0
    );
    return { totalValue, crops: entries };
  }
  function computeMiscValues(items) {
    const aggregated = {
      seeds: { totalValue: 0, items: [] },
      tools: { totalValue: 0, items: [] },
      eggs: { totalValue: 0, items: [] },
      decors: { totalValue: 0, items: [] }
    };
    for (const config of INVENTORY_VALUE_CATEGORIES) {
      const filteredItems = items.filter((item) => {
        const type = typeof item?.itemType === "string" ? item.itemType.trim() : "";
        return type === config.itemType;
      });
      const entries = filteredItems.map((item) => {
        const rawIdentifier = item?.[config.identifierKey];
        const identifier = toNormalizedIdentifier(rawIdentifier);
        const rawQuantity = item?.quantity;
        const quantity = getFiniteNumber(rawQuantity);
        const coinPrice = config.resolveCoinPrice(identifier);
        const value = quantity != null && coinPrice != null ? coinPrice * quantity : null;
        return config.createEntry(identifier, quantity, coinPrice, value);
      });
      const totalValue = entries.reduce((acc, entry) => {
        const entryValue = entry.value;
        return typeof entryValue === "number" && Number.isFinite(entryValue) ? acc + entryValue : acc;
      }, 0);
      aggregated[config.logKey] = { totalValue, items: entries };
    }
    return aggregated;
  }
  async function resolvePlayersInRoom() {
    try {
      const rawPlayers = await Atoms.server.numPlayers.get();
      return Number.isFinite(rawPlayers) ? rawPlayers : void 0;
    } catch {
      return void 0;
    }
  }
  async function computeSnapshotFromInventory(inventory) {
    const items = extractItems(inventory);
    if (items === null) return null;
    const safeItems = items ?? [];
    const playersInRoom = await resolvePlayersInRoom();
    return {
      pets: computePetValues(safeItems),
      plants: computePlantValues(safeItems, playersInRoom),
      crops: computeCropValues(safeItems, playersInRoom),
      misc: computeMiscValues(safeItems)
    };
  }
  function notifyListeners(snapshot) {
    for (const listener of listeners3) {
      try {
        listener(snapshot);
      } catch (error) {
        console.warn("[InventoryValue] Listener error", error);
      }
    }
  }
  async function refreshSnapshot(nextInventory) {
    const computeId = ++computeCounter;
    try {
      const snapshot = await computeSnapshotFromInventory(nextInventory);
      if (computeId !== computeCounter) return;
      currentSnapshot = snapshot;
      notifyListeners(currentSnapshot);
    } catch (error) {
      if (computeId !== computeCounter) return;
      currentSnapshot = null;
      console.warn("[InventoryValue] Impossible de calculer la valeur de l'inventaire", error);
    }
  }
  async function ensureInventoryValueWatcher() {
    if (watcherPromise) return watcherPromise;
    watcherPromise = (async () => {
      try {
        const inventory = await Atoms.inventory.myInventory.get();
        await refreshSnapshot(inventory);
      } catch (error) {
        currentSnapshot = null;
        console.warn("[InventoryValue] Impossible de r\xE9cup\xE9rer l'inventaire initial", error);
      }
      try {
        unsubscribe = await Atoms.inventory.myInventory.onChange((next) => {
          void refreshSnapshot(next);
        });
      } catch (error) {
        console.warn("[InventoryValue] Impossible de s'abonner \xE0 myInventory", error);
      }
    })();
    return watcherPromise;
  }
  function getInventoryValueSnapshot() {
    return currentSnapshot;
  }
  function onInventoryValueChange(listener) {
    listeners3.add(listener);
    return () => {
      listeners3.delete(listener);
    };
  }

  // src/utils/inventorySorting.ts
  var DEFAULTS5 = {
    gridSelector: "div.McGrid.css-tqc83y",
    filtersBlockSelector: ".McGrid.css-o1vp12",
    closeButtonSelector: "button.css-vuqwsg",
    checkboxSelector: "label.chakra-checkbox.css-1v6h4z7",
    checkboxLabelSelector: ".chakra-checkbox__label",
    injectDarkStyles: true
  };
  var INVENTORY_SEARCH_INPUT_SELECTOR = "input.chakra-input.css-8e1l1i";
  var BASE_SORT = ["alpha", "qty", "rarity", "value"];
  var ORDER = [
    "none",
    "alpha",
    "qty",
    "rarity",
    "value",
    "size",
    "mutations",
    "strength"
  ];
  var SORT_STORAGE_KEY = "mg-mod.inventory.sortKey";
  var SORT_KEY_SET = new Set(ORDER);
  var SORT_DIRECTION_STORAGE_KEY = "mg-mod.inventory.sortDirection";
  var SORT_DIRECTION_SET = /* @__PURE__ */ new Set(["asc", "desc"]);
  var DEFAULT_DIRECTION_LABEL = "Order:";
  var DIRECTION_LABELS_DEFAULT = {
    asc: "Ascending",
    desc: "Descending"
  };
  var getPetAbilityDisplayName = (abilityId) => {
    if (typeof abilityId !== "string") return null;
    const trimmedId = abilityId.trim();
    if (!trimmedId) return null;
    const ability = petAbilities[trimmedId] ?? null;
    const name = ability?.name;
    if (typeof name !== "string") return null;
    const trimmedName = name.trim();
    return trimmedName ? trimmedName : null;
  };
  var INVENTORY_VALUE_VISIBILITY_STORAGE_KEY = "mg-mod.inventory.showValues";
  var loadPersistedInventoryValueVisibility = () => {
    if (typeof window === "undefined") return null;
    try {
      const stored = window.localStorage?.getItem(INVENTORY_VALUE_VISIBILITY_STORAGE_KEY) ?? null;
      if (stored === "1") return true;
      if (stored === "0") return false;
      return null;
    } catch (error) {
      console.warn(
        "[InventorySorting] Impossible de lire la pr\xE9f\xE9rence d'affichage des valeurs d'inventaire",
        error
      );
      return null;
    }
  };
  var persistInventoryValueVisibility = (visible) => {
    if (typeof window === "undefined") return;
    try {
      window.localStorage?.setItem(INVENTORY_VALUE_VISIBILITY_STORAGE_KEY, visible ? "1" : "0");
    } catch (error) {
      console.warn(
        "[InventorySorting] Impossible de sauvegarder la pr\xE9f\xE9rence d'affichage des valeurs d'inventaire",
        error
      );
    }
  };
  var shouldDisplayInventoryValues = true;
  var setShouldDisplayInventoryValues = (visible) => {
    shouldDisplayInventoryValues = visible;
  };
  var getShouldDisplayInventoryValues = () => shouldDisplayInventoryValues;
  var DEFAULT_DIRECTION_BY_SORT_KEY = {
    none: "asc",
    alpha: "asc",
    qty: "desc",
    rarity: "asc",
    value: "desc",
    size: "desc",
    mutations: "desc",
    strength: "desc"
  };
  var DIRECTION_ORDER = ["asc", "desc"];
  var isPersistedSortKey = (value) => typeof value === "string" && SORT_KEY_SET.has(value);
  var isPersistedSortDirection = (value) => typeof value === "string" && SORT_DIRECTION_SET.has(value);
  var loadPersistedSortKey = () => {
    if (typeof window === "undefined") return null;
    try {
      const stored = window.localStorage?.getItem(SORT_STORAGE_KEY) ?? null;
      return isPersistedSortKey(stored) ? stored : null;
    } catch (error) {
      console.warn("[InventorySorting] Impossible de lire la valeur de tri persist\xE9e", error);
      return null;
    }
  };
  var persistSortKey = (value) => {
    if (typeof window === "undefined") return;
    try {
      window.localStorage?.setItem(SORT_STORAGE_KEY, value);
    } catch (error) {
      console.warn("[InventorySorting] Impossible de sauvegarder la valeur de tri", error);
    }
  };
  var loadPersistedSortDirection = () => {
    if (typeof window === "undefined") return null;
    try {
      const stored = window.localStorage?.getItem(SORT_DIRECTION_STORAGE_KEY) ?? null;
      return isPersistedSortDirection(stored) ? stored : null;
    } catch (error) {
      console.warn("[InventorySorting] Impossible de lire l'ordre de tri persist\xE9", error);
      return null;
    }
  };
  var persistSortDirection = (value) => {
    if (typeof window === "undefined") return;
    try {
      window.localStorage?.setItem(SORT_DIRECTION_STORAGE_KEY, value);
    } catch (error) {
      console.warn("[InventorySorting] Impossible de sauvegarder l'ordre de tri", error);
    }
  };
  var MAP_EXTRA_BY_FILTER_DEFAULT = {
    // seed/tool/ decor = tri de base
    seed: [],
    tool: [],
    decor: [],
    // crop/plant = base + size/mutations
    crop: ["size", "mutations"],
    produce: ["size", "mutations"],
    plant: [],
    // pet = base + size/mutations/strength
    pet: ["mutations", "strength"]
  };
  var FILTER_CONTEXT_ITEM_TYPES_CACHE = /* @__PURE__ */ new Map();
  var FILTER_CONTEXT_LISTENERS = /* @__PURE__ */ new Set();
  var addFilterContextListener = (listener) => {
    FILTER_CONTEXT_LISTENERS.add(listener);
    return () => {
      FILTER_CONTEXT_LISTENERS.delete(listener);
    };
  };
  var notifyFilterContextListeners = (contextKey) => {
    FILTER_CONTEXT_LISTENERS.forEach((listener) => {
      try {
        listener(contextKey);
      } catch (error) {
        console.warn("[InventorySorting] Listener de contexte de filtre en erreur", error);
      }
    });
  };
  var LABEL_BY_VALUE_DEFAULT = {
    none: "None",
    alpha: "A\u2013Z",
    qty: "Quantity",
    rarity: "Rarity",
    value: "Values",
    size: "Size",
    mutations: "Mutations",
    strength: "Strength"
  };
  var INVENTORY_BASE_INDEX_DATASET_KEY = "tmInventoryBaseIndex";
  var INVENTORY_ITEMS_CONTAINER_SELECTOR = ".McFlex.css-ofw63c";
  var INVENTORY_VALUE_CONTAINER_SELECTOR = ".McFlex.css-1p00rng";
  var INVENTORY_VALUE_ELEMENT_CLASS = "tm-inventory-item-value";
  var INVENTORY_VALUE_TEXT_CLASS = `${INVENTORY_VALUE_ELEMENT_CLASS}__text`;
  var INVENTORY_VALUE_DATASET_KEY = "tmInventoryValue";
  var FILTERED_VALUE_LOADING = "\u2026";
  var FILTERED_VALUE_UNKNOWN = "\u2014";
  var VALUE_SUMMARY_ICON_CLASS = "tm-value-toggle__summary-icon";
  var VALUE_SUMMARY_TEXT_CLASS = "tm-value-toggle__summary-text";
  var VALUE_SUMMARY_ICON_SRC = (() => {
    const src = coin?.img64 ?? "";
    if (typeof src !== "string" || !src) {
      return "";
    }
    return src.startsWith("data:") ? src : `data:image/png;base64,${src}`;
  })();
  function createDomSnapshot(entries) {
    return entries.map((entry) => entry.wrapper);
  }
  function haveDomEntriesChanged(previous, nextEntries) {
    if (!previous) return true;
    if (previous.length !== nextEntries.length) return true;
    for (let i = 0; i < nextEntries.length; i++) {
      if (previous[i] !== nextEntries[i].wrapper) {
        return true;
      }
    }
    return false;
  }
  var debounce = (fn, wait = 120) => {
    let t;
    return (...args) => {
      if (t) window.clearTimeout(t);
      t = window.setTimeout(() => fn(...args), wait);
    };
  };
  function isVisible2(el2) {
    if (!el2 || !document.contains(el2)) return false;
    const r = el2.getBoundingClientRect();
    const cs = getComputedStyle(el2);
    if (cs.display === "none" || cs.visibility === "hidden" || cs.opacity === "0") return false;
    return r.width > 0 && r.height > 0;
  }
  var labelIsChecked = (el2) => el2.matches("[data-checked]") || !!el2.querySelector("[data-checked]");
  var normalize2 = (s) => (s ?? "").trim().toLowerCase();
  var createFilterContextKey = (filters, search) => {
    const normalizedFilters = filters.map((value) => normalize2(value)).filter((value) => value && value !== "all");
    normalizedFilters.sort();
    const normalizedSearch = normalize2(search);
    return `${normalizedFilters.join("|")}::${normalizedSearch}`;
  };
  var areSetsEqual = (a, b) => {
    if (a === b) return true;
    if (!a || !b || a.size !== b.size) return false;
    for (const value of a) {
      if (!b.has(value)) return false;
    }
    return true;
  };
  var getCachedItemTypesForKey = (contextKey) => {
    return FILTER_CONTEXT_ITEM_TYPES_CACHE.get(contextKey) ?? null;
  };
  var getCachedItemTypesForContext = (filters, search) => {
    const key2 = createFilterContextKey(filters, search);
    return getCachedItemTypesForKey(key2);
  };
  var setCachedItemTypesForKey = (contextKey, types) => {
    const normalizedTypes = /* @__PURE__ */ new Set();
    types.forEach((type) => {
      const normalizedType = normalize2(type);
      if (normalizedType) {
        normalizedTypes.add(normalizedType);
      }
    });
    const previous = FILTER_CONTEXT_ITEM_TYPES_CACHE.get(contextKey) ?? null;
    if (previous && areSetsEqual(previous, normalizedTypes)) {
      return;
    }
    FILTER_CONTEXT_ITEM_TYPES_CACHE.set(contextKey, normalizedTypes);
    notifyFilterContextListeners(contextKey);
  };
  var getInventorySearchInput = (grid) => {
    if (!grid) return null;
    const input = grid.querySelector(INVENTORY_SEARCH_INPUT_SELECTOR);
    return input ?? null;
  };
  var getInventorySearchQuery = (grid) => {
    const input = getInventorySearchInput(grid);
    return typeof input?.value === "string" ? input.value : "";
  };
  var getNormalizedInventorySearchQuery = (grid) => normalize2(getInventorySearchQuery(grid));
  var logFilteredInventorySearchResults = async (grid, filters, searchQuery) => {
    if (!grid) return;
    try {
      const inventory = await Atoms.inventory.myInventory.get();
      if (!inventory || typeof inventory !== "object") {
        console.log("[InventorySorting] Inventaire introuvable pour le log de recherche.");
        return;
      }
      const items = Array.isArray(inventory.items) ? inventory.items : [];
      const { filteredItems } = filterInventoryItems(items, filters, searchQuery);
      const container = getInventoryItemsContainer(grid);
      const entries = container ? getInventoryDomEntries(container) : [];
      console.log("[InventorySorting] R\xE9sultats filtr\xE9s (recherche) :", filteredItems);
      console.log(
        "[InventorySorting] Nombre d'\xE9l\xE9ments DOM pour la recherche :",
        entries.length
      );
    } catch (error) {
      console.warn(
        "[InventorySorting] Impossible de journaliser les r\xE9sultats filtr\xE9s de la recherche",
        error
      );
    }
  };
  var RARITY_ORDER = [
    rarity.Common,
    rarity.Uncommon,
    rarity.Rare,
    rarity.Legendary,
    rarity.Mythic,
    rarity.Divine,
    rarity.Celestial
  ].filter(Boolean);
  var RARITY_RANK = (() => {
    const entries = /* @__PURE__ */ new Map();
    RARITY_ORDER.forEach((label2, index) => {
      const key2 = normalize2(label2);
      if (key2) {
        entries.set(key2, index);
      }
    });
    const mythicIndex = entries.get(normalize2(rarity.Mythic));
    if (typeof mythicIndex === "number") {
      entries.set(normalize2("Mythic"), mythicIndex);
    }
    return entries;
  })();
  var getRarityRank = (value) => {
    const key2 = normalize2(value);
    if (!key2) return RARITY_ORDER.length;
    return RARITY_RANK.get(key2) ?? RARITY_ORDER.length;
  };
  var SPECIES_FIELDS = [
    "species",
    "seedSpecies",
    "plantSpecies",
    "cropSpecies",
    "baseSpecies",
    "seedKey"
  ];
  var normalizeSpeciesKey3 = (value) => value.toLowerCase().replace(/['’`]/g, "").replace(/\s+/g, "").replace(/-/g, "").replace(/(seed|plant|baby|fruit|crop)$/i, "");
  var MAX_SCALE_BY_SPECIES3 = (() => {
    const map2 = /* @__PURE__ */ new Map();
    const register = (key2, value) => {
      if (typeof key2 !== "string") return;
      const normalized = normalizeSpeciesKey3(key2.trim());
      if (!normalized || map2.has(normalized)) return;
      map2.set(normalized, value);
    };
    for (const [species, entry] of Object.entries(plantCatalog)) {
      const maxScale = Number(entry?.crop?.maxScale);
      if (!Number.isFinite(maxScale) || maxScale <= 0) continue;
      register(species, maxScale);
      register(entry?.seed?.name, maxScale);
      register(entry?.plant?.name, maxScale);
      register(entry?.crop?.name, maxScale);
    }
    return map2;
  })();
  var lookupMaxScale3 = (species) => {
    if (typeof species !== "string") return null;
    const normalized = normalizeSpeciesKey3(species.trim());
    if (!normalized) return null;
    const value = MAX_SCALE_BY_SPECIES3.get(normalized);
    return typeof value === "number" && Number.isFinite(value) && value > 0 ? value : null;
  };
  var clampNumber2 = (value, min, max) => Math.max(min, Math.min(max, value));
  var scaleToPercent = (scale, maxScale) => {
    if (!Number.isFinite(scale)) return 50;
    const MIN_PERCENT = 50;
    const MAX_PERCENT = 100;
    const MIN_SCALE = 1;
    const safeScale = Math.max(MIN_SCALE, scale);
    if (typeof maxScale === "number" && Number.isFinite(maxScale) && maxScale > MIN_SCALE) {
      const limited2 = Math.min(maxScale, safeScale);
      const ratio2 = (limited2 - MIN_SCALE) / (maxScale - MIN_SCALE);
      const pct2 = MIN_PERCENT + ratio2 * (MAX_PERCENT - MIN_PERCENT);
      return clampNumber2(Math.round(pct2), MIN_PERCENT, MAX_PERCENT);
    }
    const FALLBACK_MAX_SCALE = 2;
    const limited = Math.min(FALLBACK_MAX_SCALE, safeScale);
    const ratio = (limited - MIN_SCALE) / (FALLBACK_MAX_SCALE - MIN_SCALE);
    const pct = MIN_PERCENT + ratio * (MAX_PERCENT - MIN_PERCENT);
    return clampNumber2(Math.round(pct), MIN_PERCENT, MAX_PERCENT);
  };
  var collectSpeciesCandidates = (source, out) => {
    if (!source || typeof source !== "object") return;
    for (const field of SPECIES_FIELDS) {
      const raw = source[field];
      if (typeof raw === "string") {
        const value = raw.trim();
        if (value) out.add(value);
      }
    }
  };
  var computeSizePercentFromScale = (speciesCandidates, scale) => {
    if (!Number.isFinite(scale)) return null;
    let maxScale = null;
    for (const candidate of speciesCandidates) {
      maxScale = lookupMaxScale3(candidate);
      if (maxScale != null) break;
    }
    return scaleToPercent(scale, maxScale);
  };
  var getInventoryItemSizePercent = (item) => {
    if (!item || typeof item !== "object") return null;
    const candidates = /* @__PURE__ */ new Set();
    collectSpeciesCandidates(item, candidates);
    collectSpeciesCandidates(item.item, candidates);
    collectSpeciesCandidates(item.data, candidates);
    const rawType = typeof item.itemType === "string" ? item.itemType : "";
    const type = rawType.trim();
    if (type === "Crop" || type === "Produce") {
      const scale = Number(item.scale);
      return computeSizePercentFromScale(candidates, scale);
    }
    return null;
  };
  var collectMutations = (source, out) => {
    if (!source || typeof source !== "object") return;
    const rawMutations = source.mutations;
    if (Array.isArray(rawMutations)) {
      for (const mutation of rawMutations) {
        if (typeof mutation === "string" && mutation.trim()) {
          out.push(mutation.trim());
        }
      }
    }
    const slots = source.slots;
    if (Array.isArray(slots)) {
      for (const slot of slots) {
        collectMutations(slot, out);
      }
    }
  };
  var getInventoryItemMutations = (item) => {
    if (!item || typeof item !== "object") return [];
    const mutations = [];
    collectMutations(item, mutations);
    collectMutations(item.item, mutations);
    collectMutations(item.data, mutations);
    return mutations;
  };
  var FILTER_LABEL_TO_ITEM_TYPES = {
    crop: ["Produce"],
    crops: ["Produce"],
    produce: ["Produce"],
    seed: ["Seed"],
    seeds: ["Seed"],
    plant: ["Plant"],
    plants: ["Plant"],
    pet: ["Pet"],
    pets: ["Pet"],
    tool: ["Tool"],
    tools: ["Tool"],
    decor: ["Decor"],
    decors: ["Decor"],
    decoration: ["Decor"],
    decorations: ["Decor"],
    egg: ["Egg"],
    eggs: ["Egg"]
  };
  var ITEM_TYPE_TO_FILTER_KEYS = (() => {
    const mapping = /* @__PURE__ */ new Map();
    for (const [filterKey, itemTypes] of Object.entries(FILTER_LABEL_TO_ITEM_TYPES)) {
      for (const itemType of itemTypes) {
        const normalizedType = normalize2(itemType);
        if (!normalizedType) continue;
        const set2 = mapping.get(normalizedType) ?? /* @__PURE__ */ new Set();
        set2.add(filterKey);
        mapping.set(normalizedType, set2);
      }
    }
    const result = {};
    mapping.forEach((value, key2) => {
      result[key2] = Array.from(value);
    });
    return result;
  })();
  var getExtrasForFilterKey = (filterKey, mapExtraByFilter) => {
    if (!filterKey) return [];
    const direct = mapExtraByFilter[filterKey];
    if (Array.isArray(direct) && direct.length) {
      return direct;
    }
    if (filterKey.endsWith("s")) {
      const singular = filterKey.slice(0, -1);
      if (singular) {
        const singularMatch = mapExtraByFilter[singular];
        if (Array.isArray(singularMatch) && singularMatch.length) {
          return singularMatch;
        }
      }
    }
    return [];
  };
  var getExtrasForItemType = (itemType, mapExtraByFilter) => {
    const normalizedType = normalize2(itemType);
    if (!normalizedType) return [];
    const extras = /* @__PURE__ */ new Set();
    const direct = mapExtraByFilter[normalizedType];
    if (Array.isArray(direct)) {
      direct.forEach((value) => extras.add(value));
    }
    const relatedFilterKeys = ITEM_TYPE_TO_FILTER_KEYS[normalizedType] ?? [];
    for (const filterKey of relatedFilterKeys) {
      const values = mapExtraByFilter[filterKey];
      if (Array.isArray(values)) {
        values.forEach((value) => extras.add(value));
      }
    }
    return Array.from(extras);
  };
  function filterLabelToItemTypes(filter) {
    const key2 = normalize2(filter);
    if (!key2 || key2 === "all") return [];
    const mapped = FILTER_LABEL_TO_ITEM_TYPES[key2];
    if (mapped) return mapped;
    const singular = key2.endsWith("s") ? key2.slice(0, -1) : key2;
    if (!singular) return [];
    const itemType = singular.charAt(0).toUpperCase() + singular.slice(1);
    return itemType ? [itemType] : [];
  }
  function inventoryItemMatchesSearchQuery(item, normalizedQuery) {
    if (!normalizedQuery) return true;
    const visited = /* @__PURE__ */ new Set();
    const matchesValue = (value) => {
      if (value == null) return false;
      if (typeof value === "string") {
        return normalize2(value).includes(normalizedQuery);
      }
      if (typeof value === "number" || typeof value === "boolean") {
        return normalize2(String(value)).includes(normalizedQuery);
      }
      if (Array.isArray(value)) {
        for (const entry of value) {
          if (matchesValue(entry)) {
            return true;
          }
        }
        return false;
      }
      if (typeof value === "object") {
        if (visited.has(value)) {
          return false;
        }
        visited.add(value);
        for (const [key2, entry] of Object.entries(value)) {
          if (key2 === "itemType") {
            continue;
          }
          if (key2 === "abilities") {
            if (Array.isArray(entry)) {
              for (const abilityId of entry) {
                const abilityName = getPetAbilityDisplayName(abilityId);
                if (abilityName && matchesValue(abilityName)) {
                  return true;
                }
              }
            }
            continue;
          }
          if (matchesValue(entry)) {
            return true;
          }
        }
      }
      return false;
    };
    const abilityNames = Array.isArray(item?.abilities) ? item.abilities.map((abilityId) => getPetAbilityDisplayName(abilityId)).filter((name) => typeof name === "string" && !!name) : [];
    const candidates = [
      getInventoryItemName(item),
      typeof item?.species === "string" ? item.species : null,
      typeof item?.seedSpecies === "string" ? item.seedSpecies : null,
      typeof item?.plantSpecies === "string" ? item.plantSpecies : null,
      typeof item?.petSpecies === "string" ? item.petSpecies : null,
      typeof item?.eggId === "string" ? item.eggId : null,
      typeof item?.decorId === "string" ? item.decorId : null,
      typeof item?.toolId === "string" ? item.toolId : null,
      typeof item?.id === "string" ? item.id : null,
      ...abilityNames
    ];
    for (const candidate of candidates) {
      if (matchesValue(candidate)) {
        return true;
      }
    }
    return matchesValue(item);
  }
  function attachItemValues(items) {
    const snapshot = getInventoryValueSnapshot();
    const playersInRoom = snapshot?.plants?.playersInRoom ?? null;
    for (const item of items) {
      if (!item || typeof item !== "object") continue;
      const value = computeInventoryItemValue(item, { playersInRoom });
      item.value = value ?? null;
    }
  }
  function filterInventoryItems(items, filters, searchQuery) {
    const normalizedFilters = filters.map((f) => normalize2(f)).filter(Boolean);
    const itemTypes = /* @__PURE__ */ new Set();
    let recognized = false;
    for (const filter of normalizedFilters) {
      const mappedTypes = filterLabelToItemTypes(filter);
      if (mappedTypes.length) {
        recognized = true;
        for (const type of mappedTypes) {
          if (type) itemTypes.add(type);
        }
      }
    }
    const keepAll = !recognized;
    const filteredByType = keepAll ? items.slice() : items.filter((item) => {
      const type = typeof item?.itemType === "string" ? item.itemType.trim() : "";
      return type ? itemTypes.has(type) : false;
    });
    const normalizedSearch = normalize2(searchQuery);
    const filteredItems = normalizedSearch ? filteredByType.filter((item) => inventoryItemMatchesSearchQuery(item, normalizedSearch)) : filteredByType;
    attachItemValues(filteredItems);
    const detectedItemTypes = /* @__PURE__ */ new Set();
    for (const item of filteredItems) {
      const type = typeof item?.itemType === "string" ? item.itemType.trim() : "";
      if (type) {
        detectedItemTypes.add(type);
      }
    }
    const contextKey = createFilterContextKey(filters, normalizedSearch);
    setCachedItemTypesForKey(contextKey, detectedItemTypes);
    return { filteredItems, keepAll, itemTypes, detectedItemTypes };
  }
  function getInventoryItemsContainer(grid) {
    return grid.querySelector(INVENTORY_ITEMS_CONTAINER_SELECTOR);
  }
  function getInventoryDomEntries(container) {
    const entries = [];
    const children = Array.from(container.children);
    for (const child of children) {
      if (!(child instanceof HTMLElement)) continue;
      if (child.matches(".css-vmnhaw")) {
        entries.push({ wrapper: child, card: child });
        continue;
      }
      const card = child.querySelector(".css-vmnhaw");
      if (card instanceof HTMLElement) {
        entries.push({ wrapper: child, card });
      }
    }
    return entries;
  }
  var INVENTORY_COMPACT_VALUE_UNITS = [
    { threshold: 1e12, suffix: "T" },
    { threshold: 1e9, suffix: "B" },
    { threshold: 1e6, suffix: "M" },
    { threshold: 1e3, suffix: "K" }
  ];
  var INVENTORY_FULL_VALUE_FORMATTER = typeof Intl !== "undefined" && typeof Intl.NumberFormat === "function" ? new Intl.NumberFormat(void 0, { maximumFractionDigits: 2, minimumFractionDigits: 0 }) : null;
  var formatInventoryItemCompactValue = (value) => {
    const abs = Math.abs(value);
    for (const { threshold, suffix } of INVENTORY_COMPACT_VALUE_UNITS) {
      if (abs >= threshold) {
        const scaled = value / threshold;
        const formatted = scaled.toFixed(1).replace(/\.0$/, "");
        return `${formatted}${suffix}`;
      }
    }
    return INVENTORY_FULL_VALUE_FORMATTER ? INVENTORY_FULL_VALUE_FORMATTER.format(value) : String(value);
  };
  var formatInventoryItemFullValue = (value) => INVENTORY_FULL_VALUE_FORMATTER ? INVENTORY_FULL_VALUE_FORMATTER.format(value) : String(value);
  var getInventoryItemValue = (item) => {
    if (!item || typeof item !== "object") return null;
    const raw = item.value;
    if (typeof raw === "number" && Number.isFinite(raw)) return raw;
    if (typeof raw === "string" && raw.trim()) {
      const parsed = Number(raw);
      return Number.isFinite(parsed) ? parsed : null;
    }
    return null;
  };
  var getValueSummaryElement = (wrap) => {
    if (!wrap) return null;
    const summary = wrap.__valueSummary ?? null;
    return summary ?? wrap.querySelector(".tm-value-toggle__summary");
  };
  var ensureValueSummaryContent = (summary) => {
    if (!summary.style.gap) {
      summary.style.gap = "0.25rem";
    }
    if (VALUE_SUMMARY_ICON_SRC) {
      let iconEl = summary.querySelector(`.${VALUE_SUMMARY_ICON_CLASS}`);
      if (!iconEl) {
        iconEl = document.createElement("img");
        iconEl.className = VALUE_SUMMARY_ICON_CLASS;
        iconEl.alt = "";
        iconEl.decoding = "async";
        iconEl.src = VALUE_SUMMARY_ICON_SRC;
        Object.assign(iconEl.style, {
          width: "1.2rem",
          height: "1.2rem",
          flexShrink: "0",
          objectFit: "contain"
        });
        summary.insertBefore(iconEl, summary.firstChild);
      } else if (iconEl.src !== VALUE_SUMMARY_ICON_SRC) {
        iconEl.src = VALUE_SUMMARY_ICON_SRC;
      }
    }
    let textEl = summary.querySelector(`.${VALUE_SUMMARY_TEXT_CLASS}`);
    if (!textEl) {
      textEl = document.createElement("span");
      textEl.className = VALUE_SUMMARY_TEXT_CLASS;
      textEl.style.fontWeight = "700";
      textEl.style.color = "inherit";
      summary.appendChild(textEl);
    }
    return textEl;
  };
  var setValueSummaryText = (summary, text, title) => {
    if (!summary) return;
    const textEl = ensureValueSummaryContent(summary);
    textEl.textContent = text;
    if (title) {
      summary.title = title;
    } else {
      summary.removeAttribute("title");
    }
  };
  async function updateFilteredInventoryValueSummary(wrap, filters, searchQuery) {
    if (!wrap) return;
    const summary = getValueSummaryElement(wrap);
    if (!summary) return;
    const token = Symbol("value-summary");
    wrap.__valueSummaryToken = token;
    setValueSummaryText(summary, FILTERED_VALUE_LOADING);
    try {
      const inventory = await Atoms.inventory.myInventory.get();
      if (wrap.__valueSummaryToken !== token) {
        return;
      }
      if (!inventory || typeof inventory !== "object") {
        setValueSummaryText(summary, FILTERED_VALUE_UNKNOWN);
        return;
      }
      const items = Array.isArray(inventory.items) ? inventory.items : [];
      const { filteredItems } = filterInventoryItems(items, filters, searchQuery);
      if (!filteredItems.length) {
        setValueSummaryText(summary, "0", "0");
        return;
      }
      let totalValue = 0;
      let hasValue = false;
      for (const item of filteredItems) {
        const value = getInventoryItemValue(item);
        if (typeof value === "number" && Number.isFinite(value)) {
          totalValue += value;
          hasValue = true;
        }
      }
      if (!hasValue) {
        setValueSummaryText(summary, FILTERED_VALUE_UNKNOWN);
        return;
      }
      const compact = formatInventoryItemCompactValue(totalValue);
      const full = formatInventoryItemFullValue(totalValue);
      setValueSummaryText(summary, compact, full);
    } catch (error) {
      console.warn("[InventorySorting] Impossible de calculer la valeur filtr\xE9e", error);
      if (wrap.__valueSummaryToken !== token) {
        return;
      }
      setValueSummaryText(summary, FILTERED_VALUE_UNKNOWN);
    }
  }
  function updateInventoryCardValue(card, rawValue) {
    const container = card.querySelector(INVENTORY_VALUE_CONTAINER_SELECTOR);
    const existing = card.dataset[INVENTORY_VALUE_DATASET_KEY];
    if (!container) {
      if (existing != null) {
        delete card.dataset[INVENTORY_VALUE_DATASET_KEY];
      }
      return;
    }
    const currentEl = container.querySelector(`.${INVENTORY_VALUE_ELEMENT_CLASS}`);
    if (!getShouldDisplayInventoryValues()) {
      if (currentEl?.parentElement) {
        currentEl.parentElement.removeChild(currentEl);
      }
      if (existing != null) {
        delete card.dataset[INVENTORY_VALUE_DATASET_KEY];
      }
      return;
    }
    if (typeof rawValue !== "number" || !Number.isFinite(rawValue)) {
      if (currentEl?.parentElement) {
        currentEl.parentElement.removeChild(currentEl);
      }
      if (existing != null) {
        delete card.dataset[INVENTORY_VALUE_DATASET_KEY];
      }
      return;
    }
    const compactValue = formatInventoryItemCompactValue(rawValue);
    const fullValue = formatInventoryItemFullValue(rawValue);
    let target = currentEl;
    if (!target) {
      target = document.createElement("div");
      target.className = INVENTORY_VALUE_ELEMENT_CLASS;
    }
    Object.assign(target.style, {
      fontSynthesis: "none",
      WebkitFontSmoothing: "antialiased",
      WebkitTextSizeAdjust: "100%",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "flex-start",
      gap: "0.15rem",
      marginTop: "3px",
      fontFamily: 'var(--chakra-fonts-body, "GreyCliff CF", sans-serif)',
      fontWeight: "700",
      fontSize: "0.65rem",
      lineHeight: "1",
      textTransform: "none",
      color: "var(--chakra-colors-Yellow-Magic, #F3D32B)"
    });
    let textEl = target.querySelector(`.${INVENTORY_VALUE_TEXT_CLASS}`);
    if (!textEl) {
      target.textContent = "";
      textEl = document.createElement("span");
      textEl.className = INVENTORY_VALUE_TEXT_CLASS;
      textEl.style.display = "inline-flex";
      textEl.style.alignItems = "center";
      textEl.style.color = "inherit";
      target.appendChild(textEl);
    }
    textEl.textContent = compactValue;
    target.title = fullValue;
    card.dataset[INVENTORY_VALUE_DATASET_KEY] = String(rawValue);
    if (target.parentElement !== container || target !== container.lastElementChild) {
      container.appendChild(target);
    }
  }
  function assignBaseIndexesToEntries(entries) {
    entries.forEach((entry, index) => {
      entry.wrapper.dataset[INVENTORY_BASE_INDEX_DATASET_KEY] = String(index);
      entry.card.dataset[INVENTORY_BASE_INDEX_DATASET_KEY] = String(index);
    });
  }
  function readBaseIndex(entry) {
    const raw = entry.wrapper.dataset[INVENTORY_BASE_INDEX_DATASET_KEY] ?? entry.card.dataset[INVENTORY_BASE_INDEX_DATASET_KEY];
    if (raw == null) return null;
    const value = Number(raw);
    return Number.isFinite(value) ? value : null;
  }
  var stringOrEmpty = (value) => typeof value === "string" ? value.trim() : "";
  var pickNestedString = (source, path) => {
    let current = source;
    for (const key2 of path) {
      if (!current || typeof current !== "object") {
        return "";
      }
      current = current[key2];
    }
    return stringOrEmpty(current);
  };
  var pickFirstNestedString = (source, paths) => {
    for (const path of paths) {
      const value = pickNestedString(source, path);
      if (value) return value;
    }
    return "";
  };
  var plantCatalogEntry = (identifier) => plantCatalog[identifier];
  var petCatalogEntry = (identifier) => petCatalog[identifier];
  var eggCatalogEntry = (identifier) => eggCatalog[identifier];
  var toolCatalogEntry = (identifier) => toolCatalog[identifier];
  var decorCatalogEntry = (identifier) => decorCatalog[identifier];
  var SEED_NAME_PATHS = [
    ["seed", "name"],
    ["plant", "name"],
    ["crop", "name"]
  ];
  var SEED_RARITY_PATHS = [
    ["seed", "rarity"],
    ["crop", "rarity"],
    ["plant", "rarity"]
  ];
  var CROP_NAME_PATHS = [
    ["crop", "name"],
    ["plant", "name"],
    ["seed", "name"]
  ];
  var CROP_RARITY_PATHS = [
    ["crop", "rarity"],
    ["plant", "rarity"],
    ["seed", "rarity"]
  ];
  var PLANT_NAME_PATHS = [
    ["plant", "name"],
    ["crop", "name"],
    ["seed", "name"]
  ];
  var PLANT_RARITY_PATHS = [
    ["plant", "rarity"],
    ["crop", "rarity"],
    ["seed", "rarity"]
  ];
  var createPlantLookup = (identifierField, namePaths, rarityPaths) => ({
    identifierField,
    getEntry: plantCatalogEntry,
    getNamePaths: namePaths,
    getRarityPaths: rarityPaths
  });
  var CATALOG_LOOKUPS = {
    Seed: createPlantLookup("species", SEED_NAME_PATHS, SEED_RARITY_PATHS),
    Crop: createPlantLookup("species", CROP_NAME_PATHS, CROP_RARITY_PATHS),
    Produce: createPlantLookup("species", CROP_NAME_PATHS, CROP_RARITY_PATHS),
    Plant: createPlantLookup("species", PLANT_NAME_PATHS, PLANT_RARITY_PATHS),
    Pet: {
      identifierField: "petSpecies",
      getEntry: petCatalogEntry,
      getNamePaths: [["name"]],
      getRarityPaths: [["rarity"]]
    },
    Egg: {
      identifierField: "eggId",
      getEntry: eggCatalogEntry,
      getNamePaths: [["name"]],
      getRarityPaths: [["rarity"]]
    },
    Tool: {
      identifierField: "toolId",
      getEntry: toolCatalogEntry,
      getNamePaths: [["name"]],
      getRarityPaths: [["rarity"]]
    },
    Decor: {
      identifierField: "decorId",
      getEntry: decorCatalogEntry,
      getNamePaths: [["name"]],
      getRarityPaths: [["rarity"]]
    }
  };
  var getCatalogLookup = (type) => CATALOG_LOOKUPS[type] ?? null;
  var getInventoryItemName = (item) => {
    if (!item || typeof item !== "object") return "";
    const type = stringOrEmpty(item.itemType);
    const lookup = getCatalogLookup(type);
    if (lookup) {
      const identifier = readNestedStringField(item, lookup.identifierField) ?? "";
      if (identifier) {
        const entry = lookup.getEntry(identifier);
        const catalogName = lookup.getNamePaths ? pickFirstNestedString(entry, lookup.getNamePaths) : "";
        if (catalogName) {
          return catalogName;
        }
        return identifier;
      }
    }
    const fallbackName = stringOrEmpty(item.name);
    if (fallbackName) return fallbackName;
    const fallbackId = stringOrEmpty(item.id);
    if (fallbackId) return fallbackId;
    return type;
  };
  var QUANTITY_ONE_TYPES = /* @__PURE__ */ new Set(["Produce", "Crop", "Plant", "Pet"]);
  var getInventoryItemQuantity = (item) => {
    if (!item || typeof item !== "object") return 0;
    const rawType = typeof item.itemType === "string" ? item.itemType : "";
    const type = rawType.trim();
    if (QUANTITY_ONE_TYPES.has(type)) {
      return 1;
    }
    const rawQuantity = item.quantity;
    const quantity = Number(rawQuantity);
    if (Number.isFinite(quantity) && quantity >= 0) {
      return quantity;
    }
    return 0;
  };
  var getInventoryItemRarity = (item) => {
    if (!item || typeof item !== "object") return "";
    const type = stringOrEmpty(item.itemType);
    const lookup = getCatalogLookup(type);
    if (!lookup || !lookup.getRarityPaths?.length) {
      return "";
    }
    const identifier = readNestedStringField(item, lookup.identifierField) ?? "";
    if (!identifier) return "";
    const entry = lookup.getEntry(identifier);
    return pickFirstNestedString(entry, lookup.getRarityPaths);
  };
  var readNestedValue = (item, field, parser) => {
    if (!item || typeof item !== "object") return null;
    const sources = [item, item.item, item.data];
    for (const source of sources) {
      if (!source || typeof source !== "object") continue;
      const raw = source[field];
      const parsed = parser(raw);
      if (parsed != null) return parsed;
    }
    return null;
  };
  var readNestedStringField = (item, field) => readNestedValue(item, field, (value) => {
    if (typeof value !== "string") return null;
    const trimmed = value.trim();
    return trimmed ? trimmed : null;
  });
  var readNestedNumberField = (item, field) => readNestedValue(item, field, (value) => {
    if (typeof value === "number" && Number.isFinite(value)) return value;
    if (typeof value === "string" && value.trim()) {
      const parsed = Number(value);
      return Number.isFinite(parsed) ? parsed : null;
    }
    return null;
  });
  var PET_STATS_BY_SPECIES = (() => {
    const map2 = /* @__PURE__ */ new Map();
    const register = (key2, maxScale, hoursToMature) => {
      if (typeof key2 !== "string") return;
      const normalized = normalizeSpeciesKey3(key2);
      if (!normalized || map2.has(normalized)) return;
      map2.set(normalized, { maxScale, hoursToMature });
    };
    for (const [species, entry] of Object.entries(petCatalog)) {
      const maxScale = Number(entry?.maxScale);
      const hoursToMature = Number(entry?.hoursToMature);
      if (!Number.isFinite(maxScale) || maxScale <= 1) continue;
      if (!Number.isFinite(hoursToMature) || hoursToMature <= 0) continue;
      register(species, maxScale, hoursToMature);
      register(entry?.name, maxScale, hoursToMature);
    }
    return map2;
  })();
  var lookupPetStats = (species) => {
    if (typeof species !== "string") return null;
    const normalized = normalizeSpeciesKey3(species);
    if (!normalized) return null;
    return PET_STATS_BY_SPECIES.get(normalized) ?? null;
  };
  var getPetStrength2 = (item) => {
    if (!item || typeof item !== "object") return null;
    const rawType = typeof item.itemType === "string" ? item.itemType : "";
    const type = rawType.trim();
    if (type !== "Pet") return null;
    const rawXp = readNestedNumberField(item, "xp");
    const xp = typeof rawXp === "number" && Number.isFinite(rawXp) ? rawXp : 0;
    const rawTargetScale = readNestedNumberField(item, "targetScale");
    const targetScale = typeof rawTargetScale === "number" && Number.isFinite(rawTargetScale) ? rawTargetScale : 1;
    const speciesCandidates = /* @__PURE__ */ new Set();
    const maybePetSpecies = readNestedStringField(item, "petSpecies");
    if (maybePetSpecies) speciesCandidates.add(maybePetSpecies);
    const maybeSpecies = readNestedStringField(item, "species");
    if (maybeSpecies) speciesCandidates.add(maybeSpecies);
    const maybeName = readNestedStringField(item, "name");
    if (maybeName) speciesCandidates.add(maybeName);
    let stats = null;
    for (const candidate of speciesCandidates) {
      stats = lookupPetStats(candidate);
      if (stats) break;
    }
    if (!stats) return null;
    const { maxScale, hoursToMature } = stats;
    if (!Number.isFinite(maxScale) || maxScale <= 1) return null;
    if (!Number.isFinite(hoursToMature) || hoursToMature <= 0) return null;
    const safeXp = Math.max(0, xp);
    const xpDenominator = hoursToMature * 3600;
    const xpComponent = xpDenominator > 0 ? Math.min(Math.floor(safeXp / xpDenominator * 30), 30) : 0;
    const minScale = 1;
    const clampedScale = clampNumber2(targetScale, minScale, maxScale);
    const scaleDenominator = maxScale - minScale;
    const scaleComponent = scaleDenominator > 0 ? Math.floor((clampedScale - minScale) / scaleDenominator * 20 + 80) : 80;
    const combined = xpComponent + scaleComponent - 30;
    return clampNumber2(combined, 0, 100);
  };
  var compareByNameThenTypeThenId = (a, b) => {
    const nameA = getInventoryItemName(a);
    const nameB = getInventoryItemName(b);
    if (nameA && nameB) {
      const cmp = nameA.localeCompare(nameB, void 0, { sensitivity: "base" });
      if (cmp !== 0) return cmp;
    }
    if (!nameA && nameB) return 1;
    if (nameA && !nameB) return -1;
    const typeA = typeof a?.itemType === "string" ? a.itemType : "";
    const typeB = typeof b?.itemType === "string" ? b.itemType : "";
    const typeCmp = typeA.localeCompare(typeB, void 0, { sensitivity: "base" });
    if (typeCmp !== 0) return typeCmp;
    const idA = typeof a.id === "string" ? a.id : "";
    const idB = typeof b.id === "string" ? b.id : "";
    return idA.localeCompare(idB, void 0, { sensitivity: "base" });
  };
  function sortInventoryItems(items, sortKey, direction) {
    const sorted = items.slice();
    const isDesc = direction === "desc";
    switch (sortKey) {
      case "alpha":
        sorted.sort((a, b) => {
          const cmp = compareByNameThenTypeThenId(a, b);
          return isDesc ? -cmp : cmp;
        });
        break;
      case "qty":
        sorted.sort((a, b) => {
          const qtyA = getInventoryItemQuantity(a);
          const qtyB = getInventoryItemQuantity(b);
          if (qtyA !== qtyB) {
            const cmp = qtyA - qtyB;
            return isDesc ? -cmp : cmp;
          }
          return compareByNameThenTypeThenId(a, b);
        });
        break;
      case "rarity":
        sorted.sort((a, b) => {
          const rarityA = getInventoryItemRarity(a);
          const rarityB = getInventoryItemRarity(b);
          const rankA = getRarityRank(rarityA);
          const rankB = getRarityRank(rarityB);
          if (rankA !== rankB) {
            const cmp = rankA - rankB;
            return isDesc ? -cmp : cmp;
          }
          const cmpRarity = rarityA.localeCompare(rarityB, void 0, { sensitivity: "base" });
          if (cmpRarity !== 0) return cmpRarity;
          return compareByNameThenTypeThenId(a, b);
        });
        break;
      case "value":
        sorted.sort((a, b) => {
          const rawValueA = a?.value;
          const rawValueB = b?.value;
          const hasA = typeof rawValueA === "number" && Number.isFinite(rawValueA);
          const hasB = typeof rawValueB === "number" && Number.isFinite(rawValueB);
          if (hasA && hasB && rawValueA !== rawValueB) {
            const cmp = rawValueA - rawValueB;
            return isDesc ? -cmp : cmp;
          }
          if (hasA && !hasB) return isDesc ? -1 : 1;
          if (!hasA && hasB) return isDesc ? 1 : -1;
          return compareByNameThenTypeThenId(a, b);
        });
        break;
      case "size":
        sorted.sort((a, b) => {
          const sizeA = getInventoryItemSizePercent(a);
          const sizeB = getInventoryItemSizePercent(b);
          const hasA = typeof sizeA === "number" && Number.isFinite(sizeA);
          const hasB = typeof sizeB === "number" && Number.isFinite(sizeB);
          if (hasA && hasB && sizeA !== sizeB) {
            const cmp = sizeA - sizeB;
            return isDesc ? -cmp : cmp;
          }
          if (hasA && !hasB) return isDesc ? -1 : 1;
          if (!hasA && hasB) return isDesc ? 1 : -1;
          return compareByNameThenTypeThenId(a, b);
        });
        break;
      case "mutations":
        sorted.sort((a, b) => {
          const mutationsA = getInventoryItemMutations(a);
          const mutationsB = getInventoryItemMutations(b);
          const countA = mutationsA.length;
          const countB = mutationsB.length;
          if (countA !== countB) {
            const cmp = countA - countB;
            return isDesc ? -cmp : cmp;
          }
          if (countA > 0 && countB > 0) {
            const labelA = mutationsA.slice().sort((x, y) => x.localeCompare(y, void 0, { sensitivity: "base" })).join("\0");
            const labelB = mutationsB.slice().sort((x, y) => x.localeCompare(y, void 0, { sensitivity: "base" })).join("\0");
            const cmp = labelA.localeCompare(labelB, void 0, { sensitivity: "base" });
            if (cmp !== 0) return cmp;
          }
          return compareByNameThenTypeThenId(a, b);
        });
        break;
      case "strength":
        sorted.sort((a, b) => {
          const strengthA = getPetStrength2(a);
          const strengthB = getPetStrength2(b);
          const hasA = typeof strengthA === "number" && Number.isFinite(strengthA);
          const hasB = typeof strengthB === "number" && Number.isFinite(strengthB);
          if (hasA && hasB && strengthA !== strengthB) {
            const cmp = strengthA - strengthB;
            return isDesc ? -cmp : cmp;
          }
          if (hasA && !hasB) return isDesc ? -1 : 1;
          if (!hasA && hasB) return isDesc ? 1 : -1;
          return compareByNameThenTypeThenId(a, b);
        });
        break;
      default:
        break;
    }
    return sorted;
  }
  async function logInventoryForFilters(filters, sortKey, direction, searchQuery) {
    try {
      const inventory = await Atoms.inventory.myInventory.get();
      if (!inventory || typeof inventory !== "object") {
        console.log("[InventorySorting] Inventaire introuvable pour le log des filtres.");
        return;
      }
      const items = Array.isArray(inventory.items) ? inventory.items : [];
      const { filteredItems, keepAll, itemTypes } = filterInventoryItems(items, filters, searchQuery);
      const resolvedDirection = sortKey ? (direction && DIRECTION_ORDER.includes(direction) ? direction : DEFAULT_DIRECTION_BY_SORT_KEY[sortKey]) ?? "asc" : direction && DIRECTION_ORDER.includes(direction) ? direction : "asc";
      const itemsForLog = sortKey ? sortInventoryItems(filteredItems, sortKey, resolvedDirection) : filteredItems.slice();
      const descriptor = keepAll ? "toutes cat\xE9gories" : `types: ${Array.from(itemTypes).join(", ") || "(aucun)"}`;
      const sortDescriptor = sortKey ? `tri: ${sortKey} (${resolvedDirection})` : "tri: (non sp\xE9cifi\xE9)";
      const searchDescriptor = searchQuery ? `recherche: "${searchQuery}"` : "recherche: (vide)";
      console.log(
        `[InventorySorting] myInventory filtr\xE9 (${descriptor}, ${sortDescriptor}, ${searchDescriptor}).`
      );
    } catch (error) {
      console.warn("[InventorySorting] Impossible de r\xE9cup\xE9rer myInventory pour le log", error);
    }
  }
  function createDefaultApplySorting(cfg) {
    const stateByGrid = /* @__PURE__ */ new WeakMap();
    const ensureState = async (grid, filters, entries, searchQuery) => {
      const filtersKey = JSON.stringify({ filters });
      const state2 = stateByGrid.get(grid);
      const hasAllBaseIndexes = entries.every((e) => readBaseIndex(e) != null);
      const searchChanged = state2 ? state2.searchQuery !== searchQuery : false;
      const entryCountChanged = state2 ? state2.entryCount !== entries.length : false;
      const filtersChanged = state2 ? state2.filtersKey !== filtersKey : false;
      const baseLengthChanged = state2 ? state2.baseItems.length !== entries.length : false;
      const needsRebuild = !state2 || filtersChanged || entryCountChanged || baseLengthChanged || !hasAllBaseIndexes || searchChanged;
      if (state2 && !needsRebuild) {
        state2.entryByBaseIndex.clear();
        for (const entry of entries) {
          const baseIndex = readBaseIndex(entry);
          if (baseIndex != null) {
            state2.entryByBaseIndex.set(baseIndex, entry);
          }
        }
        state2.filtersKey = filtersKey;
        state2.searchQuery = searchQuery;
        state2.entryCount = entries.length;
        return state2;
      }
      try {
        const inventory = await Atoms.inventory.myInventory.get();
        if (!inventory || typeof inventory !== "object") {
          console.log("[InventorySorting] Inventaire introuvable pour le tri DOM.");
          return null;
        }
        const items = Array.isArray(inventory.items) ? inventory.items : [];
        const { filteredItems } = filterInventoryItems(items, filters, searchQuery);
        if (filteredItems.length !== entries.length) {
          console.warn(
            `[InventorySorting] Nombre d'\xE9l\xE9ments filtr\xE9s (${filteredItems.length}) diff\xE9rent du DOM (${entries.length}). R\xE9organisation annul\xE9e.`
          );
          return null;
        }
        assignBaseIndexesToEntries(entries);
        const newState = {
          filtersKey,
          searchQuery,
          entryCount: entries.length,
          baseItems: filteredItems.slice(),
          entryByBaseIndex: /* @__PURE__ */ new Map()
        };
        entries.forEach((entry, index) => {
          newState.entryByBaseIndex.set(index, entry);
        });
        stateByGrid.set(grid, newState);
        return newState;
      } catch (error) {
        console.warn("[InventorySorting] Impossible de r\xE9cup\xE9rer myInventory pour le tri DOM", error);
        return null;
      }
    };
    return async (grid, sortKey, direction) => {
      if (typeof document === "undefined") return;
      const container = getInventoryItemsContainer(grid);
      if (!container) return;
      const entries = getInventoryDomEntries(container);
      if (!entries.length) return;
      const filters = getActiveFiltersFromGrid(
        grid,
        cfg.checkboxSelector,
        cfg.checkboxLabelSelector
      );
      const searchQuery = getNormalizedInventorySearchQuery(grid);
      const state2 = await ensureState(grid, filters, entries, searchQuery);
      if (!state2) return;
      const baseIndexByItem = /* @__PURE__ */ new Map();
      state2.baseItems.forEach((item, index) => {
        baseIndexByItem.set(item, index);
      });
      const effectiveDirection = direction && DIRECTION_ORDER.includes(direction) ? direction : DEFAULT_DIRECTION_BY_SORT_KEY[sortKey] ?? "asc";
      const desiredItems = !sortKey || sortKey === "none" ? state2.baseItems.slice() : sortInventoryItems(state2.baseItems, sortKey, effectiveDirection);
      const desiredEntries = [];
      const usedEntries = /* @__PURE__ */ new Set();
      for (const item of desiredItems) {
        const baseIndex = baseIndexByItem.get(item);
        if (baseIndex == null) continue;
        const entry = state2.entryByBaseIndex.get(baseIndex);
        if (!entry || usedEntries.has(entry)) continue;
        const value = getInventoryItemValue(item);
        updateInventoryCardValue(entry.card, value);
        desiredEntries.push(entry);
        usedEntries.add(entry);
      }
      if (desiredEntries.length !== entries.length) {
        console.warn(
          `[InventorySorting] Impossible de r\xE9ordonner l'inventaire : correspondances insuffisantes (${desiredEntries.length}/${entries.length}).`
        );
        return;
      }
      const fragment = document.createDocumentFragment();
      desiredEntries.forEach((entry) => {
        fragment.appendChild(entry.wrapper);
      });
      container.appendChild(fragment);
      state2.entryByBaseIndex.clear();
      desiredEntries.forEach((entry) => {
        const baseIndex = readBaseIndex(entry);
        if (baseIndex != null) {
          state2.entryByBaseIndex.set(baseIndex, entry);
        }
      });
    };
  }
  function getActiveFiltersFromGrid(grid, checkboxSelector, checkboxLabelSelector) {
    return Array.from(grid.querySelectorAll(checkboxSelector)).filter(labelIsChecked).map(
      (lbl) => (lbl.querySelector(checkboxLabelSelector)?.textContent ?? "").trim()
    ).filter(Boolean);
  }
  function computeSortOptions(activeFilters, labelByValue = LABEL_BY_VALUE_DEFAULT, mapExtraByFilter = MAP_EXTRA_BY_FILTER_DEFAULT, searchQuery = "") {
    const normalizedFilters = activeFilters.map((value) => (value ?? "").trim().toLowerCase()).filter(Boolean);
    const normalizedSearch = normalize2(searchQuery);
    const intersectSets = (sets) => {
      if (!sets.length) return null;
      let intersection = new Set(sets[0]);
      for (let i = 1; i < sets.length; i++) {
        const current = sets[i];
        intersection = new Set([...intersection].filter((value) => current.has(value)));
      }
      return intersection;
    };
    const filterSets = normalizedFilters.map(
      (filterKey) => /* @__PURE__ */ new Set([...BASE_SORT, ...getExtrasForFilterKey(filterKey, mapExtraByFilter)])
    );
    const detectedItemTypes = getCachedItemTypesForContext(activeFilters, normalizedSearch);
    const typeSets = [];
    if (detectedItemTypes && detectedItemTypes.size) {
      detectedItemTypes.forEach((itemType) => {
        const extras = getExtrasForItemType(itemType, mapExtraByFilter);
        typeSets.push(/* @__PURE__ */ new Set([...BASE_SORT, ...extras]));
      });
    }
    const allowedFromFilters = intersectSets(filterSets);
    const allowedFromTypes = intersectSets(typeSets);
    let allowed = null;
    if (allowedFromFilters && allowedFromTypes) {
      allowed = new Set([...allowedFromFilters].filter((value) => allowedFromTypes.has(value)));
    } else if (allowedFromFilters) {
      allowed = new Set(allowedFromFilters);
    } else if (allowedFromTypes) {
      allowed = new Set(allowedFromTypes);
    }
    if (!allowed || !allowed.size) {
      allowed = new Set(BASE_SORT);
    }
    const values = ORDER.filter((value) => value === "none" || allowed.has(value));
    return values.map((value) => ({ value, label: labelByValue[value] || value }));
  }
  function isMacOsPlatform() {
    if (typeof navigator === "undefined") return false;
    const nav = navigator;
    const platform = nav.userAgentData?.platform || nav.platform || "";
    if (platform && /mac/i.test(platform)) {
      return true;
    }
    const userAgent = typeof nav.userAgent === "string" ? nav.userAgent : "";
    return /mac os x/i.test(userAgent);
  }
  function shouldUseCustomSelectStyles() {
    return !isMacOsPlatform();
  }
  function injectDarkSelectStyles(id = "inv-sort-dark-styles") {
    if (document.getElementById(id)) return;
    const css = `
    .tm-sort-select {
      color: #e7eef7 !important;
      background-color: rgba(17,17,17,0.98) !important;
      border: 1px solid rgba(255,255,255,0.25) !important;
      outline: none !important;
      -webkit-appearance: none;
      appearance: none;
      color-scheme: dark;
      padding-right: 28px !important;
    }
    .tm-sort-select:focus { box-shadow: 0 0 0 2px rgba(122,162,255,.35); }
    .tm-sort-select option { color: #e7eef7; background-color: #111; }
    .tm-sort-select option:checked { background-color: #222; }
    .tm-sort-select option:hover   { background-color: #1a1a1a; }
    .tm-select-wrap { position: relative; display: inline-flex; align-items: center; }
    .tm-select-arrow {
      position: absolute; right: 10px; top: 50%;
      transform: translateY(-50%);
      pointer-events: none; display: inline-flex; align-items: center; justify-content: center;
    }
    .tm-select-arrow svg { display: block; }
  `;
    const style2 = document.createElement("style");
    style2.id = id;
    style2.textContent = css;
    document.head.appendChild(style2);
  }
  function createSortingBar(useCustomSelectStyles) {
    const wrap = document.createElement("div");
    wrap.className = "tm-sort-wrap";
    Object.assign(wrap.style, {
      display: "block",
      width: "100%",
      margin: "0",
      padding: "0",
      position: "relative",
      flex: "0 0 auto",
      minHeight: "0",
      contain: "layout style"
    });
    const bar = document.createElement("div");
    bar.className = "tm-sorting-bar";
    Object.assign(bar.style, {
      display: "flex",
      alignItems: "center",
      flexWrap: "wrap",
      gap: "8px",
      marginTop: "10px",
      paddingTop: "8px",
      borderTop: "1px solid rgba(255,255,255,0.12)",
      width: "100%",
      boxSizing: "border-box",
      position: "relative",
      flex: "0 0 auto",
      height: "auto",
      minHeight: "0",
      maxHeight: "none",
      alignSelf: "stretch"
    });
    const label2 = document.createElement("span");
    label2.textContent = "Sort by:";
    Object.assign(label2.style, { font: "inherit", opacity: "0.8", flex: "0 0 auto" });
    const selectWrap = document.createElement("div");
    selectWrap.className = "tm-select-wrap";
    const select2 = document.createElement("select");
    select2.className = "tm-sort-select tm-sort-select--key";
    if (useCustomSelectStyles) {
      Object.assign(select2.style, {
        padding: "6px 10px",
        border: "1px solid rgba(255,255,255,0.25)",
        borderRadius: "6px",
        background: "rgba(17,17,17,0.98)",
        color: "#e7eef7",
        cursor: "pointer",
        flex: "0 0 auto",
        width: "auto",
        outline: "none",
        appearance: "none"
      });
      select2.style.setProperty("-webkit-appearance", "none");
    }
    const arrow = document.createElement("span");
    arrow.className = "tm-select-arrow";
    arrow.innerHTML = `
    <svg width="12" height="8" viewBox="0 0 12 8" aria-hidden="true">
      <path d="M1 1l5 5 5-5" stroke="white" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
  `;
    if (useCustomSelectStyles) {
      selectWrap.append(select2, arrow);
    } else {
      selectWrap.append(select2);
    }
    bar.append(label2, selectWrap);
    const directionLabel = document.createElement("span");
    directionLabel.className = "tm-direction-label";
    directionLabel.textContent = DEFAULT_DIRECTION_LABEL;
    Object.assign(directionLabel.style, {
      font: "inherit",
      opacity: "0.8",
      flex: "0 0 auto"
    });
    const directionWrap = document.createElement("div");
    directionWrap.className = "tm-select-wrap";
    const directionSelect = document.createElement("select");
    directionSelect.className = "tm-sort-select tm-direction-select";
    const canStyleDirectionSelect = useCustomSelectStyles && !isMacOsPlatform();
    if (canStyleDirectionSelect) {
      Object.assign(directionSelect.style, {
        padding: "6px 10px",
        border: "1px solid rgba(255,255,255,0.25)",
        borderRadius: "6px",
        background: "rgba(17,17,17,0.98)",
        color: "#e7eef7",
        cursor: "pointer",
        flex: "0 0 auto",
        width: "auto",
        outline: "none",
        appearance: "none"
      });
      directionSelect.style.setProperty("-webkit-appearance", "none");
    }
    const directionArrow = document.createElement("span");
    directionArrow.className = "tm-select-arrow";
    directionArrow.innerHTML = `
    <svg width="12" height="8" viewBox="0 0 12 8" aria-hidden="true">
      <path d="M1 1l5 5 5-5" stroke="white" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
  `;
    if (canStyleDirectionSelect) {
      directionWrap.append(directionSelect, directionArrow);
    } else {
      directionWrap.append(directionSelect);
    }
    bar.append(directionLabel, directionWrap);
    const divider = document.createElement("span");
    divider.className = "tm-value-toggle__divider";
    Object.assign(divider.style, {
      alignSelf: "stretch",
      width: "1px",
      minHeight: "24px",
      background: "rgba(255,255,255,0.15)",
      flex: "0 0 auto",
      opacity: "0.5"
    });
    const valueToggleLabel = document.createElement("label");
    valueToggleLabel.className = "tm-value-toggle";
    Object.assign(valueToggleLabel.style, {
      display: "inline-flex",
      alignItems: "center",
      gap: "8px",
      font: "inherit",
      opacity: "0.9",
      cursor: "pointer",
      flex: "0 0 auto"
    });
    const valueToggleControl = document.createElement("span");
    valueToggleControl.className = "tm-value-toggle__control";
    Object.assign(valueToggleControl.style, {
      position: "relative",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      width: "36px",
      height: "20px",
      flex: "0 0 auto"
    });
    const valueToggleInput = document.createElement("input");
    valueToggleInput.type = "checkbox";
    valueToggleInput.className = "tm-value-toggle__checkbox";
    Object.assign(valueToggleInput.style, {
      position: "absolute",
      inset: "0",
      margin: "0",
      opacity: "0",
      cursor: "pointer"
    });
    const switchTrack = document.createElement("span");
    switchTrack.className = "tm-value-toggle__switch";
    Object.assign(switchTrack.style, {
      position: "relative",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "flex-start",
      width: "100%",
      height: "100%",
      borderRadius: "999px",
      background: "rgba(255,255,255,0.25)",
      transition: "background 120ms ease",
      padding: "2px",
      boxSizing: "border-box"
    });
    const switchThumb = document.createElement("span");
    switchThumb.className = "tm-value-toggle__thumb";
    Object.assign(switchThumb.style, {
      width: "16px",
      height: "16px",
      borderRadius: "50%",
      background: "#111",
      boxShadow: "0 1px 3px rgba(0,0,0,0.35)",
      transform: "translateX(0)",
      transition: "transform 120ms ease, background 120ms ease"
    });
    switchTrack.appendChild(switchThumb);
    valueToggleControl.append(valueToggleInput, switchTrack);
    const valueToggleText = document.createElement("span");
    valueToggleText.className = "tm-value-toggle__label";
    valueToggleText.textContent = "Show values";
    Object.assign(valueToggleText.style, {
      font: "inherit",
      color: "inherit"
    });
    valueToggleLabel.append(valueToggleControl, valueToggleText);
    const valueSummaryText = document.createElement("span");
    valueSummaryText.className = "tm-value-toggle__summary";
    Object.assign(valueSummaryText.style, {
      font: "inherit",
      color: "var(--chakra-colors-Yellow-Magic, #F3D32B)",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "flex-end",
      flex: "1 1 auto",
      whiteSpace: "nowrap",
      marginLeft: "auto",
      textAlign: "right",
      gap: "0.25rem"
    });
    setValueSummaryText(valueSummaryText, FILTERED_VALUE_LOADING);
    bar.append(divider, valueToggleLabel, valueSummaryText);
    const syncValueToggleVisual = (checked) => {
      switchTrack.style.background = checked ? "var(--chakra-colors-Yellow-Magic, #F3D32B)" : "rgba(255,255,255,0.25)";
      switchThumb.style.transform = checked ? "translateX(16px)" : "translateX(0)";
      valueToggleLabel.setAttribute("data-checked", checked ? "true" : "false");
      valueToggleLabel.setAttribute("role", "switch");
      valueToggleLabel.setAttribute("aria-checked", checked ? "true" : "false");
    };
    valueToggleInput.addEventListener("change", () => {
      syncValueToggleVisual(valueToggleInput.checked);
    });
    wrap.__syncValueToggle = syncValueToggleVisual;
    syncValueToggleVisual(valueToggleInput.checked);
    wrap.appendChild(bar);
    return {
      wrap,
      bar,
      select: select2,
      directionSelect,
      directionLabel,
      valueToggleInput,
      valueToggleLabel,
      valueSummary: valueSummaryText
    };
  }
  function ensureSortingBar(grid, cfg, useCustomSelectStyles, labelByValue, directionLabelText, onChange, showValues, onToggleValues) {
    const filtersBlock = grid.querySelector(cfg.filtersBlockSelector);
    if (!filtersBlock) return null;
    const closeBtnInBlock = filtersBlock.querySelector(cfg.closeButtonSelector);
    const closeBtn = closeBtnInBlock || grid.querySelector(cfg.closeButtonSelector);
    let wrap = filtersBlock.querySelector(":scope > .tm-sort-wrap");
    let select2;
    let directionSelect;
    let directionLabelEl = null;
    let valueToggleInput = null;
    let valueSummaryEl = null;
    if (!wrap) {
      const ui = createSortingBar(useCustomSelectStyles);
      wrap = ui.wrap;
      select2 = ui.select;
      directionSelect = ui.directionSelect;
      directionLabelEl = ui.directionLabel;
      valueToggleInput = ui.valueToggleInput;
      valueSummaryEl = ui.valueSummary;
      wrap.__grid = grid;
      wrap.__valueSummary = valueSummaryEl ?? null;
      if (closeBtn && closeBtn.parentElement) {
        closeBtn.insertAdjacentElement("afterend", wrap);
      } else {
        filtersBlock.appendChild(wrap);
      }
      if (directionLabelEl) {
        directionLabelEl.textContent = directionLabelText;
      }
      if (valueToggleInput) {
        valueToggleInput.checked = showValues;
        valueToggleInput.addEventListener("change", () => {
          const nextVisible = valueToggleInput ? valueToggleInput.checked : false;
          wrap.__showValues = nextVisible;
          onToggleValues(nextVisible);
        });
      }
      select2.addEventListener("change", () => {
        const value = select2.value;
        wrap.__prevValue = value;
        const direction = directionSelect?.value || "asc";
        const currentGrid = wrap.__grid;
        const activeFilters = currentGrid ? getActiveFiltersFromGrid(
          currentGrid,
          cfg.checkboxSelector,
          cfg.checkboxLabelSelector
        ) : [];
        const searchQuery = getNormalizedInventorySearchQuery(currentGrid);
        console.log("[InventorySorting] Tri s\xE9lectionn\xE9 :", value);
        void logInventoryForFilters(activeFilters, value, direction, searchQuery);
        onChange(value, direction, activeFilters, searchQuery);
      });
      directionSelect.addEventListener("change", () => {
        const direction = directionSelect.value;
        wrap.__prevDirection = direction;
        const value = select2?.value || "none";
        const currentGrid = wrap.__grid;
        const activeFilters = currentGrid ? getActiveFiltersFromGrid(
          currentGrid,
          cfg.checkboxSelector,
          cfg.checkboxLabelSelector
        ) : [];
        const searchQuery = getNormalizedInventorySearchQuery(currentGrid);
        console.log("[InventorySorting] Ordre de tri s\xE9lectionn\xE9 :", direction);
        void logInventoryForFilters(activeFilters, value, direction, searchQuery);
        onChange(value, direction, activeFilters, searchQuery);
      });
    } else {
      const maybeSelect = wrap.querySelector("select.tm-sort-select--key");
      const maybeDirectionSelect = wrap.querySelector("select.tm-direction-select");
      if (!maybeSelect || !maybeDirectionSelect) return null;
      select2 = maybeSelect;
      directionSelect = maybeDirectionSelect;
      directionLabelEl = wrap.querySelector(".tm-direction-label");
      valueToggleInput = wrap.querySelector('label.tm-value-toggle input[type="checkbox"]');
      valueSummaryEl = wrap.querySelector(".tm-value-toggle__summary");
      wrap.__valueSummary = valueSummaryEl ?? null;
      if (directionLabelEl) {
        directionLabelEl.textContent = directionLabelText;
      }
      if (closeBtn && closeBtn.parentElement && closeBtn.nextElementSibling !== wrap) {
        closeBtn.insertAdjacentElement("afterend", wrap);
      } else if (!closeBtn && wrap.parentElement !== filtersBlock) {
        filtersBlock.appendChild(wrap);
      }
    }
    if (valueToggleInput) {
      valueToggleInput.checked = showValues;
    }
    const syncValueToggle = wrap.__syncValueToggle;
    if (syncValueToggle) {
      syncValueToggle(valueToggleInput?.checked ?? showValues);
    }
    wrap.__grid = grid;
    wrap.__showValues = valueToggleInput?.checked ?? showValues;
    return { wrap, select: select2, directionSelect, valueToggleInput, valueSummary: valueSummaryEl };
  }
  function renderSelectOptions(select2, options, prevValue) {
    const prev = prevValue ?? select2.value;
    select2.innerHTML = "";
    for (const opt of options) {
      const o = document.createElement("option");
      o.value = opt.value;
      o.textContent = opt.label;
      select2.appendChild(o);
    }
    if (options.some((o) => o.value === "none")) {
      select2.value = "none";
    }
    if (prev && options.some((o) => o.value === prev) && prev !== "none") {
      select2.value = prev;
    }
  }
  function renderDirectionOptions(select2, labels, prevValue) {
    const prev = prevValue ?? select2.value ?? null;
    select2.innerHTML = "";
    for (const value of DIRECTION_ORDER) {
      const option = document.createElement("option");
      option.value = value;
      option.textContent = labels[value] ?? value;
      select2.appendChild(option);
    }
    if (prev && DIRECTION_ORDER.includes(prev)) {
      select2.value = prev;
    } else {
      select2.value = DIRECTION_ORDER[0];
    }
  }
  function attachInventorySorting(userConfig = {}) {
    const cfg = {
      ...DEFAULTS5,
      ...userConfig
    };
    const mapExtraByFilter = { ...MAP_EXTRA_BY_FILTER_DEFAULT, ...cfg.mapExtraByFilter || {} };
    const labelByValue = { ...LABEL_BY_VALUE_DEFAULT, ...cfg.labelByValue || {} };
    const directionLabelText = cfg.directionLabel ?? DEFAULT_DIRECTION_LABEL;
    const directionLabelByValue = {
      ...DIRECTION_LABELS_DEFAULT,
      ...cfg.directionLabelByValue || {}
    };
    const defaultDirectionBySortKey = {
      ...DEFAULT_DIRECTION_BY_SORT_KEY,
      ...cfg.defaultDirectionBySortKey || {}
    };
    const useCustomSelectStyles = shouldUseCustomSelectStyles();
    if (cfg.injectDarkStyles && useCustomSelectStyles) injectDarkSelectStyles();
    const applySorting = cfg.applySorting ?? createDefaultApplySorting(cfg);
    let showInventoryValues = loadPersistedInventoryValueVisibility() ?? true;
    setShouldDisplayInventoryValues(showInventoryValues);
    let grid = null;
    let currentWrap = null;
    let currentSelect = null;
    let currentDirectionSelect = null;
    let currentValueToggle = null;
    let stopValueSummaryListener = null;
    let lastLoggedFilters = null;
    let lastAppliedFiltersKey = null;
    let lastAppliedSortKey = null;
    let lastAppliedDirection = null;
    let shouldEnsureInventoryValueWatcherOnNextVisible = true;
    let lastSortedDomSnapshot = null;
    let lastComputedFilterContextKey = null;
    let stopFilterContextListener = null;
    let lastRenderedInventoryEntryCount = null;
    const updateDomSnapshotForGrid = (target) => {
      if (!target) {
        lastSortedDomSnapshot = null;
        return;
      }
      const container = getInventoryItemsContainer(target);
      if (!container) {
        lastSortedDomSnapshot = null;
        return;
      }
      const entries = getInventoryDomEntries(container);
      lastSortedDomSnapshot = createDomSnapshot(entries);
    };
    const applySortingWithSnapshot = (target, sortKey, direction) => Promise.resolve(applySorting(target, sortKey, direction)).then(() => {
      updateDomSnapshotForGrid(target);
    });
    const obs = new MutationObserver((muts) => {
      const relevant = muts.some(
        (m) => m.type === "attributes" ? ["data-checked", "style", "class", "hidden", "aria-hidden"].includes(m.attributeName || "") : m.type === "childList"
      );
      if (relevant) refresh();
    });
    const setGrid = (next) => {
      if (grid === next) return;
      obs.disconnect();
      grid = next;
      lastLoggedFilters = null;
      lastAppliedFiltersKey = null;
      lastAppliedSortKey = null;
      lastSortedDomSnapshot = null;
      lastComputedFilterContextKey = null;
      lastRenderedInventoryEntryCount = null;
      shouldEnsureInventoryValueWatcherOnNextVisible = true;
      if (!grid && stopValueSummaryListener) {
        stopValueSummaryListener();
        stopValueSummaryListener = null;
      }
      if (!grid && stopFilterContextListener) {
        stopFilterContextListener();
        stopFilterContextListener = null;
      }
      if (grid) {
        obs.observe(grid, {
          subtree: true,
          childList: true,
          attributes: true,
          attributeFilter: ["data-checked", "style", "class", "hidden", "aria-hidden"]
        });
      }
    };
    const bodyObserver = new MutationObserver(() => {
      const hasCurrent = !!(grid && document.contains(grid));
      if (!hasCurrent && grid) {
        setGrid(null);
      }
      const current = hasCurrent ? grid : null;
      const next = document.querySelector(cfg.gridSelector);
      if (next !== current) {
        setGrid(next);
        if (next) {
          update();
        }
      }
    });
    const resolveGrid = () => {
      if (grid && document.contains(grid)) return grid;
      const next = document.querySelector(cfg.gridSelector);
      if (next !== grid) {
        setGrid(next);
      }
      return grid && document.contains(grid) ? grid : null;
    };
    const applyCurrentSorting = () => {
      const targetGrid = resolveGrid();
      if (!targetGrid) return;
      const sortKey = currentSelect?.value ?? "none";
      const fallbackDirection = defaultDirectionBySortKey[sortKey] ?? DEFAULT_DIRECTION_BY_SORT_KEY[sortKey] ?? "asc";
      const direction = currentDirectionSelect?.value ?? fallbackDirection;
      void applySortingWithSnapshot(targetGrid, sortKey, direction);
    };
    const update = () => {
      const targetGrid = resolveGrid();
      if (!targetGrid || !isVisible2(targetGrid)) {
        shouldEnsureInventoryValueWatcherOnNextVisible = true;
        return;
      }
      setShouldDisplayInventoryValues(showInventoryValues);
      if (shouldEnsureInventoryValueWatcherOnNextVisible) {
        shouldEnsureInventoryValueWatcherOnNextVisible = false;
        void ensureInventoryValueWatcher().catch((error) => {
          console.warn(
            "[InventorySorting] Impossible d'initialiser la surveillance de la valeur de l'inventaire",
            error
          );
        });
      }
      const mount = ensureSortingBar(
        targetGrid,
        cfg,
        useCustomSelectStyles,
        labelByValue,
        directionLabelText,
        (value, direction, filters, searchQuery) => {
          lastAppliedSortKey = value;
          lastAppliedDirection = direction;
          const filtersKey = JSON.stringify({ filters: filters ?? [], search: searchQuery ?? "" });
          lastAppliedFiltersKey = filtersKey;
          persistSortKey(value);
          persistSortDirection(direction);
          cfg.onSortChange?.(value, direction);
          void applySortingWithSnapshot(targetGrid, value, direction);
        },
        showInventoryValues,
        (visible) => {
          showInventoryValues = visible;
          setShouldDisplayInventoryValues(visible);
          persistInventoryValueVisibility(visible);
          if (currentValueToggle) {
            currentValueToggle.checked = visible;
          }
          applyCurrentSorting();
        }
      );
      if (!mount) return;
      currentWrap = mount.wrap;
      currentSelect = mount.select;
      currentDirectionSelect = mount.directionSelect;
      currentValueToggle = mount.valueToggleInput ?? null;
      if (!stopValueSummaryListener) {
        stopValueSummaryListener = onInventoryValueChange(() => {
          const sourceGrid = resolveGrid();
          if (!sourceGrid || !currentWrap) return;
          const filtersForSummary = getActiveFiltersFromGrid(
            sourceGrid,
            cfg.checkboxSelector,
            cfg.checkboxLabelSelector
          );
          const searchForSummary = getNormalizedInventorySearchQuery(sourceGrid);
          void updateFilteredInventoryValueSummary(
            currentWrap,
            filtersForSummary,
            searchForSummary
          );
        });
      }
      const activeFilters = getActiveFiltersFromGrid(
        targetGrid,
        cfg.checkboxSelector,
        cfg.checkboxLabelSelector
      );
      const container = getInventoryItemsContainer(targetGrid);
      const currentEntries = container ? getInventoryDomEntries(container) : [];
      const inventoryEntryCountChanged = lastRenderedInventoryEntryCount === null || lastRenderedInventoryEntryCount !== currentEntries.length;
      const shouldRenderSelectOptions = inventoryEntryCountChanged || !currentSelect?.options?.length;
      const shouldRenderDirectionOptions = inventoryEntryCountChanged || !currentDirectionSelect?.options?.length;
      const domChangedSinceLastSort = haveDomEntriesChanged(lastSortedDomSnapshot, currentEntries);
      const currentDomSnapshot = createDomSnapshot(currentEntries);
      const searchQueryForGrid = getNormalizedInventorySearchQuery(targetGrid);
      lastComputedFilterContextKey = createFilterContextKey(activeFilters, searchQueryForGrid);
      if (!stopFilterContextListener) {
        stopFilterContextListener = addFilterContextListener((contextKey) => {
          if (contextKey === lastComputedFilterContextKey) {
            setTimeout(refresh, 0);
          }
        });
      }
      void updateFilteredInventoryValueSummary(currentWrap, activeFilters, searchQueryForGrid);
      const serializedFilters = JSON.stringify({
        filters: activeFilters,
        search: searchQueryForGrid
      });
      const filtersChanged = serializedFilters !== lastAppliedFiltersKey;
      if (serializedFilters !== lastLoggedFilters) {
        lastLoggedFilters = serializedFilters;
        console.log("[InventorySorting] Filtres actifs :", activeFilters);
        const currentSortKey = currentSelect?.value ?? void 0;
        const currentDirection = currentDirectionSelect?.value ?? void 0;
        void logInventoryForFilters(
          activeFilters,
          currentSortKey,
          currentDirection,
          searchQueryForGrid
        );
      }
      const options = computeSortOptions(
        activeFilters,
        labelByValue,
        mapExtraByFilter,
        searchQueryForGrid
      );
      const wrapPrevValue = typeof currentWrap.__prevValue === "string" ? currentWrap.__prevValue : null;
      const persistedSortKey = loadPersistedSortKey();
      const preferredValue = (wrapPrevValue && options.some((o) => o.value === wrapPrevValue) ? wrapPrevValue : null) || (persistedSortKey && options.some((o) => o.value === persistedSortKey) ? persistedSortKey : null);
      if (shouldRenderSelectOptions) {
        renderSelectOptions(currentSelect, options, preferredValue);
        lastRenderedInventoryEntryCount = currentEntries.length;
      }
      currentWrap.__prevValue = currentSelect.value;
      const appliedSortKey = currentSelect.value;
      const wrapPrevDirection = typeof currentWrap.__prevDirection === "string" ? currentWrap.__prevDirection : null;
      const persistedDirection = loadPersistedSortDirection();
      const fallbackDirection = defaultDirectionBySortKey[appliedSortKey] ?? DEFAULT_DIRECTION_BY_SORT_KEY[appliedSortKey] ?? "asc";
      const preferredDirection = (wrapPrevDirection && DIRECTION_ORDER.includes(wrapPrevDirection) ? wrapPrevDirection : null) || (persistedDirection && DIRECTION_ORDER.includes(persistedDirection) ? persistedDirection : null) || fallbackDirection;
      let appliedDirection;
      if (currentDirectionSelect) {
        if (shouldRenderDirectionOptions) {
          renderDirectionOptions(currentDirectionSelect, directionLabelByValue, preferredDirection);
        }
        if (preferredDirection && DIRECTION_ORDER.includes(preferredDirection) && currentDirectionSelect.value !== preferredDirection) {
          currentDirectionSelect.value = preferredDirection;
        }
        appliedDirection = currentDirectionSelect.value;
        if (!DIRECTION_ORDER.includes(appliedDirection)) {
          appliedDirection = fallbackDirection;
          currentDirectionSelect.value = fallbackDirection;
        }
        currentWrap.__prevDirection = appliedDirection;
      } else {
        appliedDirection = fallbackDirection;
      }
      const sortChanged = appliedSortKey !== lastAppliedSortKey || appliedDirection !== lastAppliedDirection;
      const shouldApplySorting = sortChanged || filtersChanged && domChangedSinceLastSort;
      if (shouldApplySorting) {
        lastAppliedSortKey = appliedSortKey;
        lastAppliedDirection = appliedDirection;
        lastAppliedFiltersKey = serializedFilters;
        persistSortKey(appliedSortKey);
        persistSortDirection(appliedDirection);
        cfg.onSortChange?.(appliedSortKey, appliedDirection);
        void applySortingWithSnapshot(targetGrid, appliedSortKey, appliedDirection);
      } else {
        if (filtersChanged) {
          lastAppliedFiltersKey = serializedFilters;
          console.log(
            "[InventorySorting] Filtres modifi\xE9s mais la liste DOM est inchang\xE9e, tri non r\xE9appliqu\xE9."
          );
        }
        lastSortedDomSnapshot = currentDomSnapshot;
      }
    };
    const refresh = debounce(update, 120);
    const changeHandler = (e) => {
      const target = e.target;
      if (!target) return;
      const within = target.closest(cfg.gridSelector);
      const currentGrid = resolveGrid();
      if (e.type === "input" && target instanceof HTMLInputElement && target.matches(INVENTORY_SEARCH_INPUT_SELECTOR) && within && within === currentGrid) {
        console.log("[InventorySorting] Texte de recherche modifi\xE9 :", target.value);
        const activeFilters = getActiveFiltersFromGrid(
          currentGrid,
          cfg.checkboxSelector,
          cfg.checkboxLabelSelector
        );
        const normalizedSearch = getNormalizedInventorySearchQuery(currentGrid);
        void logFilteredInventorySearchResults(currentGrid, activeFilters, normalizedSearch);
      }
      if (within && within === currentGrid) {
        setTimeout(refresh, 0);
      }
    };
    const startObservers = () => {
      const root = document.body || document.documentElement;
      if (root) {
        bodyObserver.observe(root, { childList: true, subtree: true });
      }
      setGrid(document.querySelector(cfg.gridSelector));
      document.addEventListener("change", changeHandler, true);
      document.addEventListener("input", changeHandler, true);
      update();
    };
    startObservers();
    return {
      destroy() {
        obs.disconnect();
        bodyObserver.disconnect();
        document.removeEventListener("change", changeHandler, true);
        document.removeEventListener("input", changeHandler, true);
        if (stopValueSummaryListener) {
          stopValueSummaryListener();
          stopValueSummaryListener = null;
        }
        if (stopFilterContextListener) {
          stopFilterContextListener();
          stopFilterContextListener = null;
        }
        if (currentWrap && currentWrap.parentElement) {
          currentWrap.parentElement.removeChild(currentWrap);
        }
        currentWrap = null;
        currentSelect = null;
        currentDirectionSelect = null;
        currentValueToggle = null;
        grid = null;
        lastLoggedFilters = null;
        lastAppliedFiltersKey = null;
        lastAppliedSortKey = null;
        lastAppliedDirection = null;
        shouldEnsureInventoryValueWatcherOnNextVisible = true;
        lastSortedDomSnapshot = null;
      },
      update,
      getActiveFilters() {
        const targetGrid = resolveGrid();
        if (!targetGrid) return [];
        return getActiveFiltersFromGrid(targetGrid, cfg.checkboxSelector, cfg.checkboxLabelSelector);
      },
      getCurrentSortKey() {
        return currentSelect?.value ?? null;
      },
      getCurrentSortDirection() {
        return currentDirectionSelect?.value ?? null;
      },
      setSortKey(k) {
        if (!currentSelect) return;
        currentSelect.value = k;
        currentWrap.__prevValue = k;
        const targetGrid = resolveGrid();
        if (targetGrid) {
          const filtersForLog = getActiveFiltersFromGrid(
            targetGrid,
            cfg.checkboxSelector,
            cfg.checkboxLabelSelector
          );
          const searchQuery = getNormalizedInventorySearchQuery(targetGrid);
          const filtersKey = JSON.stringify({ filters: filtersForLog, search: searchQuery });
          console.log("[InventorySorting] Tri s\xE9lectionn\xE9 (programmatique) :", k);
          const directionToApply = currentDirectionSelect?.value ?? defaultDirectionBySortKey[k] ?? DEFAULT_DIRECTION_BY_SORT_KEY[k] ?? "asc";
          if (currentDirectionSelect) {
            currentDirectionSelect.value = directionToApply;
            currentWrap.__prevDirection = directionToApply;
          }
          void logInventoryForFilters(filtersForLog, k, directionToApply, searchQuery);
          lastAppliedFiltersKey = filtersKey;
          lastAppliedSortKey = k;
          lastAppliedDirection = directionToApply;
          persistSortKey(k);
          persistSortDirection(directionToApply);
          cfg.onSortChange?.(k, directionToApply);
          setShouldDisplayInventoryValues(showInventoryValues);
          void applySortingWithSnapshot(targetGrid, k, directionToApply);
        }
      },
      setSortDirection(direction) {
        if (!currentDirectionSelect) return;
        currentDirectionSelect.value = direction;
        currentWrap.__prevDirection = direction;
        const targetGrid = resolveGrid();
        const sortKey = currentSelect?.value ?? "none";
        if (targetGrid) {
          const filtersForLog = getActiveFiltersFromGrid(
            targetGrid,
            cfg.checkboxSelector,
            cfg.checkboxLabelSelector
          );
          const searchQuery = getNormalizedInventorySearchQuery(targetGrid);
          const filtersKey = JSON.stringify({ filters: filtersForLog, search: searchQuery });
          console.log("[InventorySorting] Ordre de tri s\xE9lectionn\xE9 (programmatique) :", direction);
          void logInventoryForFilters(filtersForLog, sortKey, direction, searchQuery);
          lastAppliedFiltersKey = filtersKey;
          lastAppliedSortKey = sortKey;
          lastAppliedDirection = direction;
          persistSortKey(sortKey);
          persistSortDirection(direction);
          cfg.onSortChange?.(sortKey, direction);
          setShouldDisplayInventoryValues(showInventoryValues);
          void applySortingWithSnapshot(targetGrid, sortKey, direction);
        }
      },
      getSortOptions() {
        const targetGrid = resolveGrid();
        const filters = targetGrid ? getActiveFiltersFromGrid(targetGrid, cfg.checkboxSelector, cfg.checkboxLabelSelector) : [];
        const search = getNormalizedInventorySearchQuery(targetGrid);
        return computeSortOptions(filters, labelByValue, mapExtraByFilter, search);
      },
      getGrid() {
        return resolveGrid();
      }
    };
  }
  function startInventorySortingObserver(options = {}) {
    if (typeof window === "undefined" || typeof document === "undefined") {
      return {
        stop() {
        },
        refresh() {
        },
        getController() {
          return null;
        }
      };
    }
    const { waitForGrid = true, log: log2, ...config } = options;
    const cfg = config;
    let controller = null;
    let observer2 = null;
    let readyListener = null;
    const logger = typeof log2 === "function" ? log2 : log2 ? (...args) => console.debug("[InventorySorting]", ...args) : () => {
    };
    const attachIfPossible = () => {
      if (controller) return controller;
      if (waitForGrid) {
        const selector = cfg.gridSelector ?? DEFAULTS5.gridSelector;
        if (!document.querySelector(selector)) {
          return null;
        }
      }
      controller = attachInventorySorting(cfg);
      logger("attached");
      return controller;
    };
    const ensureObserver = () => {
      if (controller || observer2 || !waitForGrid) return;
      const target = document.body || document.documentElement;
      if (!target) return;
      observer2 = new MutationObserver(() => {
        if (attachIfPossible()) {
          observer2?.disconnect();
          observer2 = null;
          logger("attached via mutation");
        }
      });
      observer2.observe(target, { childList: true, subtree: true });
    };
    const start = () => {
      if (!attachIfPossible()) {
        ensureObserver();
      }
    };
    if (document.readyState === "loading") {
      readyListener = () => {
        readyListener = null;
        start();
      };
      document.addEventListener("DOMContentLoaded", readyListener, { once: true });
    } else {
      start();
    }
    return {
      stop() {
        if (readyListener) {
          document.removeEventListener("DOMContentLoaded", readyListener);
          readyListener = null;
        }
        observer2?.disconnect();
        observer2 = null;
        controller?.destroy();
        controller = null;
      },
      refresh() {
        if (controller) {
          controller.update();
        } else {
          start();
        }
      },
      getController() {
        return controller;
      }
    };
  }

  // src/ui/hud.ts
  function mountHUD(opts) {
    const LS_POS = "qws:pos";
    const LS_COLL = "qws:collapsed";
    const LS_HIDDEN = "qws:hidden";
    const MARGIN = 8;
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", () => mountHUD(opts), { once: true });
      return;
    }
    const css = `
  :root{
    --qws-bg:        #0f1318;
    --qws-panel:     #111823cc;
    --qws-border:    #ffffff22;
    --qws-border-2:  #ffffff14;
    --qws-accent:    #7aa2ff;
    --qws-text:      #e7eef7;
    --qws-text-dim:  #b9c3cf;
    --qws-blur:      8px;
    --qws-shadow:    0 10px 36px rgba(0,0,0,.45);
  }

  /* ---------- HUD floating box ---------- */
  .qws2{
    position:fixed; right:16px; bottom:16px; z-index:999998;
    font:12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    color:var(--qws-text);
    background:var(--qws-panel);
    border:1px solid var(--qws-border);
    border-radius:12px;
    padding:10px 12px;
    box-shadow:var(--qws-shadow);
    backdrop-filter:blur(var(--qws-blur));
    min-width:160px;
    display:flex; flex-direction:column; gap:8px;
  }
  .qws2.hidden{ display:none }
  .qws2 .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
  .qws2 .col{ display:flex; flex-direction:column; gap:4px }
  .qws2 .title{ font-weight:700; letter-spacing:.2px }
  .qws2 .sp{ flex:1 }

  .qws2 .pill{
    display:inline-flex; align-items:center; gap:6px;
    padding:4px 8px; border-radius:999px;
    border:1px solid #ffffff26;
    background:rgba(255,255,255,.06);
    color:var(--qws-text);
    box-shadow:inset 0 1px 0 rgba(255,255,255,.08);
  }
  .qws2 .ok{   background:rgba(36, 161, 72, .20);  border-color:#48d17066 }
  .qws2 .warn{ background:rgba(241, 194, 27, .18); border-color:#ffd65c66 }
  .qws2 .bad{  background:rgba(218, 30, 40, .20);  border-color:#ff7c8666 }

  .qws2 .btn{
    cursor:pointer; border-radius:10px; border:1px solid var(--qws-border);
    padding:6px 10px;
    background:linear-gradient(180deg, #ffffff12, #ffffff06);
    color:#fff;
    transition:transform .1s ease, background .18s ease, border-color .18s ease;
  }
  .qws2 .btn:hover{ background:linear-gradient(180deg, #ffffff18, #ffffff0a); border-color:#ffffff44 }
  .qws2 .btn:active{ transform:translateY(1px) }
  .qws2 .drag{ cursor:move; opacity:.9 }

  .qws2 .mini{ display:none }
  .qws2.min .mini{ display:inline-flex }
  .qws2.min .body{ display:none }

  /* Launcher always shown */
  .qws-launch{ margin-top:4px; border-top:1px solid var(--qws-border); padding-top:6px; display:block }
  .qws-launch .launch-item{ display:flex; align-items:center; gap:8px; margin:4px 0 }
  .qws-launch .launch-item .name{ flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis }
  .qws-launch .launch-item .btn.active{
    background:linear-gradient(180deg, rgba(122,162,255,.28), rgba(122,162,255,.12));
    border-color:#9db7ff66;
  }

  /* ---------- Windows ---------- */
  .qws-win{
    position:fixed; z-index:999999; min-width:260px; max-width:900px; max-height:90vh; overflow:auto;
    background:var(--qws-panel); color:var(--qws-text);
    border:1px solid var(--qws-border); border-radius:12px;
    box-shadow:var(--qws-shadow); backdrop-filter:blur(var(--qws-blur));
  }
  .qws-win .w-head{
    display:flex; align-items:center; gap:8px; padding:10px 12px;
    border-bottom:1px solid var(--qws-border); cursor:move;
    background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    border-top-left-radius:12px; border-top-right-radius:12px;
  }
  .qws-win .w-title{ font-weight:700 }
  .qws-win .sp{ flex:1 }
  .qws-win .w-btn{
    cursor:pointer; border-radius:10px; border:1px solid var(--qws-border);
    padding:4px 8px; background:linear-gradient(180deg, #ffffff12, #ffffff06); color:#fff;
  }
  .qws-win .w-btn:hover{ background:linear-gradient(180deg, #ffffff18, #ffffff0a); border-color:#ffffff44 }
  .qws-win .w-body{ padding:12px }

  /* Inputs inside windows */
  .qws-win input[type="text"], .qws-win input[type="number"]{
    width:120px; padding:8px 10px; border-radius:10px;
    border:1px solid var(--qws-border); background:rgba(0,0,0,.42); color:#fff;
    box-shadow:inset 0 1px 0 rgba(255,255,255,.06);
  }
  .qws-win .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin:6px 0 }
  `;
    const st = document.createElement("style");
    st.textContent = css;
    (document.documentElement || document.body).appendChild(st);
    const box = document.createElement("div");
    box.className = "qws2";
    box.innerHTML = `
    <div class="row drag">
      <div class="title">\u{1F383} Arie's Mod</div>
      <div class="sp"></div>
      <span id="qws2-status-mini" class="pill warn mini">\u2026</span>
      <button id="qws2-min" class="btn" title="Minimize/Expand">\u2013</button>
      <button id="qws2-hide" class="btn" title="Hide">\u2715</button>
    </div>

    <!-- Status & store side-by-side (no mode label) -->
    <div class="row" style="margin:2px 0 2px 0;">
      <span id="qws2-status" class="pill warn">status</span>
      <span id="qws2-version" class="pill warn">\u2026</span>
    </div>

    <div class="body">
      <div id="qws-launch" class="qws-launch"></div>
    </div>
  `;
    (document.documentElement || document.body).appendChild(box);
    const setHUDHidden = (hidden) => {
      box.classList.toggle("hidden", hidden);
      try {
        localStorage.setItem(LS_HIDDEN, hidden ? "1" : "0");
      } catch {
      }
      return hidden;
    };
    const toggleHUDHidden = () => setHUDHidden(!box.classList.contains("hidden"));
    let insertDown = false;
    let insertUsedAsModifier = false;
    const KEY_TOGGLE = "gui.toggle";
    const KEY_DRAG = "gui.drag";
    const downCodes = /* @__PURE__ */ new Set();
    let toggleHotkey = getKeybind(KEY_TOGGLE);
    let dragHotkey = getKeybind(KEY_DRAG);
    let dragActive = false;
    const codeEquals = (expected, actual) => {
      if (expected === actual) return true;
      if ((expected === "AltLeft" || expected === "AltRight") && (actual === "AltLeft" || actual === "AltRight")) return true;
      if ((expected === "ControlLeft" || expected === "ControlRight") && (actual === "ControlLeft" || actual === "ControlRight")) return true;
      if ((expected === "ShiftLeft" || expected === "ShiftRight") && (actual === "ShiftLeft" || actual === "ShiftRight")) return true;
      if ((expected === "MetaLeft" || expected === "MetaRight") && (actual === "MetaLeft" || actual === "MetaRight")) return true;
      return false;
    };
    const isCodePressed = (code) => {
      for (const pressed of downCodes) {
        if (codeEquals(code, pressed)) return true;
      }
      return false;
    };
    const matchesHotkey = (e, hk) => {
      if (!hk) return false;
      if (!!hk.ctrl !== e.ctrlKey) return false;
      if (!!hk.shift !== e.shiftKey) return false;
      if (!!hk.alt !== e.altKey) return false;
      if (!!hk.meta !== e.metaKey) return false;
      return codeEquals(hk.code, e.code);
    };
    const updateDragState = () => {
      if (!dragHotkey) {
        dragActive = false;
        return;
      }
      const altDown = isCodePressed("AltLeft");
      const ctrlDown = isCodePressed("ControlLeft");
      const shiftDown = isCodePressed("ShiftLeft");
      const metaDown = isCodePressed("MetaLeft");
      if (!!dragHotkey.alt !== altDown) {
        dragActive = false;
        return;
      }
      if (!!dragHotkey.ctrl !== ctrlDown) {
        dragActive = false;
        return;
      }
      if (!!dragHotkey.shift !== shiftDown) {
        dragActive = false;
        return;
      }
      if (!!dragHotkey.meta !== metaDown) {
        dragActive = false;
        return;
      }
      dragActive = isCodePressed(dragHotkey.code);
    };
    updateDragState();
    const isInsertKey = (e) => e.code === "Insert" || e.key === "Insert";
    const isModifierActive = (e) => {
      if (dragHotkey && dragActive) return true;
      const alt = "altKey" in e && e.altKey;
      const ctrl = "ctrlKey" in e && e.ctrlKey;
      const meta = "metaKey" in e && e.metaKey;
      const shift = "shiftKey" in e && e.shiftKey;
      const insertModifier = insertDown && !alt && !ctrl && !meta;
      if (insertModifier && !shift) insertUsedAsModifier = true;
      return insertModifier && !shift;
    };
    const onInsertKey = (e) => {
      if (!isInsertKey(e)) return;
      if (e.type === "keydown") {
        if (!insertDown) insertUsedAsModifier = false;
        insertDown = true;
        return;
      }
      const target = e.target;
      const editing = !!target && (target.isContentEditable || /^(input|textarea|select)$/i.test(target.tagName));
      const usedAsModifier = insertUsedAsModifier;
      insertDown = false;
      insertUsedAsModifier = false;
      if (!usedAsModifier && !editing) {
        e.preventDefault();
        toggleHUDHidden();
      }
    };
    window.addEventListener("keydown", onInsertKey, true);
    window.addEventListener("keyup", onInsertKey, true);
    window.addEventListener("blur", () => {
      insertDown = false;
      insertUsedAsModifier = false;
      downCodes.clear();
      updateDragState();
    }, true);
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState !== "visible") {
        insertDown = false;
        insertUsedAsModifier = false;
        downCodes.clear();
        updateDragState();
      }
    });
    function clampRect(el2) {
      const rect = el2.getBoundingClientRect();
      const vw = window.innerWidth, vh = window.innerHeight;
      let r = parseFloat(getComputedStyle(el2).right) || vw - rect.right;
      let b = parseFloat(getComputedStyle(el2).bottom) || vh - rect.bottom;
      const maxRight = Math.max(MARGIN, vw - rect.width - MARGIN);
      const maxBottom = Math.max(MARGIN, vh - rect.height - MARGIN);
      r = Math.min(Math.max(r, MARGIN), maxRight);
      b = Math.min(Math.max(b, MARGIN), maxBottom);
      el2.style.right = r + "px";
      el2.style.bottom = b + "px";
    }
    function ensureOnScreen(el2) {
      clampRect(el2);
      const rect = el2.getBoundingClientRect();
      const head = el2.querySelector(".w-head");
      const hrect = head?.getBoundingClientRect() || rect;
      const vw = window.innerWidth, vh = window.innerHeight;
      const M = MARGIN;
      let r = parseFloat(getComputedStyle(el2).right);
      if (Number.isNaN(r)) r = vw - rect.right;
      let b = parseFloat(getComputedStyle(el2).bottom);
      if (Number.isNaN(b)) b = vh - rect.bottom;
      const maxRight = Math.max(M, vw - rect.width - M);
      const maxBottom = Math.max(M, vh - rect.height - M);
      if (hrect.top < M) {
        const delta = M - hrect.top;
        b = Math.max(M, Math.min(maxBottom, b - delta));
      }
      if (rect.left < M) {
        const deltaL = M - rect.left;
        r = Math.max(M, Math.min(maxRight, r - deltaL));
      }
      el2.style.right = r + "px";
      el2.style.bottom = b + "px";
    }
    function resetWinPosDefault(el2) {
      el2.style.right = "16px";
      el2.style.bottom = "16px";
      ensureOnScreen(el2);
    }
    function withTopLocked(el2, mutate) {
      const before = el2.getBoundingClientRect();
      const vh = window.innerHeight;
      let b = parseFloat(getComputedStyle(el2).bottom);
      if (Number.isNaN(b)) b = vh - before.bottom;
      mutate();
      requestAnimationFrame(() => {
        const after = el2.getBoundingClientRect();
        const deltaTop = after.top - before.top;
        let newBottom = b + deltaTop;
        const maxBottom = Math.max(MARGIN, vh - after.height - MARGIN);
        newBottom = Math.min(Math.max(MARGIN, newBottom), maxBottom);
        el2.style.bottom = newBottom + "px";
        ensureOnScreen(el2);
      });
    }
    function saveHUDPos() {
      try {
        const r = parseFloat(box.style.right) || 16;
        const b = parseFloat(box.style.bottom) || 16;
        localStorage.setItem(LS_POS, JSON.stringify({ r, b }));
      } catch {
      }
    }
    try {
      const pos = JSON.parse(localStorage.getItem(LS_POS) || "null");
      if (pos && typeof pos.r === "number" && typeof pos.b === "number") {
        box.style.right = pos.r + "px";
        box.style.bottom = pos.b + "px";
      }
      if (localStorage.getItem(LS_COLL) === "1") {
        box.classList.add("min");
        const btnMin0 = box.querySelector("#qws2-min");
        if (btnMin0) btnMin0.textContent = "+";
      }
      if (localStorage.getItem(LS_HIDDEN) === "1") box.classList.add("hidden");
      requestAnimationFrame(() => clampRect(box));
      window.addEventListener("resize", () => clampRect(box));
    } catch {
    }
    const header = box.querySelector(".drag");
    const btnMin = box.querySelector("#qws2-min");
    const btnHide = box.querySelector("#qws2-hide");
    const sMini = box.querySelector("#qws2-status-mini");
    const sFull = box.querySelector("#qws2-status");
    const sVersion = box.querySelector("#qws2-version");
    const launch = box.querySelector("#qws-launch");
    if (!header || !btnMin || !btnHide || !sMini || !sFull || !sVersion || !launch) {
      console.warn("[QuinoaWS] HUD elements missing, abort init");
      return;
    }
    const launchEl = launch;
    const updateHideButtonTitle = () => {
      const pieces = [];
      if (toggleHotkey) {
        const label2 = getKeybindLabel(KEY_TOGGLE);
        if (label2 && label2 !== "\u2014") pieces.push(label2);
      }
      pieces.push("Insert");
      btnHide.title = pieces.length ? `Hide (${pieces.join(" / ")})` : "Hide";
    };
    updateHideButtonTitle();
    onKeybindChange(KEY_TOGGLE, (hk) => {
      toggleHotkey = hk;
      updateHideButtonTitle();
    });
    onKeybindChange(KEY_DRAG, (hk) => {
      dragHotkey = hk;
      updateDragState();
    });
    (function makeDraggable2() {
      let sx = 0, sy = 0, or = 0, ob = 0, down = false;
      header.addEventListener("mousedown", (e) => {
        down = true;
        sx = e.clientX;
        sy = e.clientY;
        const rect = box.getBoundingClientRect();
        or = parseFloat(getComputedStyle(box).right) || window.innerWidth - rect.right;
        ob = parseFloat(getComputedStyle(box).bottom) || window.innerHeight - rect.bottom;
        document.body.style.userSelect = "none";
      });
      window.addEventListener("mousemove", (e) => {
        if (!down) return;
        const dx = e.clientX - sx;
        const dy = e.clientY - sy;
        let r = or - dx;
        let b = ob - dy;
        const rect = box.getBoundingClientRect();
        const vw = window.innerWidth, vh = window.innerHeight;
        const maxRight = Math.max(MARGIN, vw - rect.width - MARGIN);
        const maxBottom = Math.max(MARGIN, vh - rect.height - MARGIN);
        r = Math.min(Math.max(r, MARGIN), maxRight);
        b = Math.min(Math.max(b, MARGIN), maxBottom);
        box.style.right = r + "px";
        box.style.bottom = b + "px";
      });
      window.addEventListener("mouseup", () => {
        if (!down) return;
        down = false;
        document.body.style.userSelect = "";
        saveHUDPos();
      });
    })();
    btnMin.onclick = () => {
      withTopLocked(box, () => {
        box.classList.toggle("min");
        btnMin.textContent = box.classList.contains("min") ? "+" : "\u2013";
        try {
          localStorage.setItem(LS_COLL, box.classList.contains("min") ? "1" : "0");
        } catch {
        }
      });
    };
    btnHide.onclick = () => {
      setHUDHidden(true);
    };
    window.addEventListener(
      "keydown",
      (e) => {
        downCodes.add(e.code);
        updateDragState();
        const t = e.target;
        const editing = !!t && (t.isContentEditable || /^(input|textarea|select)$/i.test(t.tagName));
        if (editing) return;
        if (e.repeat) return;
        if (matchesHotkey(e, toggleHotkey)) {
          if (insertDown && !e.altKey && !e.ctrlKey && !e.metaKey && !e.shiftKey) {
            insertUsedAsModifier = true;
          }
          e.preventDefault();
          toggleHUDHidden();
        }
      },
      true
    );
    window.addEventListener(
      "keyup",
      (e) => {
        downCodes.delete(e.code);
        updateDragState();
      },
      true
    );
    const windows = /* @__PURE__ */ new Map();
    let cascade = 0;
    function openWindow(id, title, render) {
      if (windows.has(id)) {
        const w = windows.get(id);
        w.el.style.display = "";
        bumpZ(w.el);
        setLaunchState(id, true);
        return;
      }
      const win = document.createElement("div");
      win.className = "qws-win";
      win.innerHTML = `
      <div class="w-head">
        <div class="w-title"></div>
        <div class="sp"></div>
        <button class="w-btn" data-act="min" title="Minimize/Expand">\u2013</button>
        <button class="w-btn" data-act="close" title="Close">\u2715</button>
      </div>
      <div class="w-body"></div>
    `;
      (document.documentElement || document.body).appendChild(win);
      const head = win.querySelector(".w-head");
      const titleEl = win.querySelector(".w-title");
      const btnMin2 = win.querySelector('[data-act="min"]');
      const btnClose = win.querySelector('[data-act="close"]');
      const body = win.querySelector(".w-body");
      titleEl.textContent = title;
      const offset = cascade++ % 5 * 24;
      win.style.right = 16 + offset + "px";
      win.style.bottom = 16 + offset + "px";
      clampRect(win);
      bumpZ(win);
      (function dragWin() {
        let sx = 0, sy = 0, or = 0, ob = 0, down = false;
        head.addEventListener("mousedown", (e) => {
          const t = e.target;
          if (t.closest(".w-btn")) return;
          down = true;
          sx = e.clientX;
          sy = e.clientY;
          const rect = win.getBoundingClientRect();
          or = parseFloat(getComputedStyle(win).right) || window.innerWidth - rect.right;
          ob = parseFloat(getComputedStyle(win).bottom) || window.innerHeight - rect.bottom;
          document.body.style.userSelect = "none";
          bumpZ(win);
        });
        window.addEventListener("mousemove", (e) => {
          if (!down) return;
          const dx = e.clientX - sx;
          const dy = e.clientY - sy;
          let r = or - dx;
          let b = ob - dy;
          const rect = win.getBoundingClientRect();
          const vw = window.innerWidth, vh = window.innerHeight;
          const maxRight = Math.max(MARGIN, vw - rect.width - MARGIN);
          const maxBottom = Math.max(MARGIN, vh - rect.height - MARGIN);
          r = Math.min(Math.max(r, MARGIN), maxRight);
          b = Math.min(Math.max(b, MARGIN), maxBottom);
          win.style.right = r + "px";
          win.style.bottom = b + "px";
        });
        window.addEventListener("mouseup", () => {
          down = false;
          document.body.style.userSelect = "";
          saveWinPos(id, win);
        });
      })();
      btnMin2.onclick = () => {
        withTopLocked(win, () => {
          const hidden = body.style.display === "none";
          body.style.display = hidden ? "" : "none";
          btnMin2.textContent = hidden ? "\u2013" : "+";
        });
      };
      btnClose.onclick = () => {
        win.style.display = "none";
        setLaunchState(id, false);
      };
      patchInputsKeyTrap(win);
      try {
        render(body);
      } catch (e) {
        body.textContent = String(e);
      }
      saveWinPos(id, win);
      windows.set(id, { id, el: win, head, body });
      setLaunchState(id, true);
    }
    function isShown(el2) {
      return el2.style.display !== "none";
    }
    function toggleWindow(id, title, render) {
      const existing = windows.get(id);
      if (!existing) {
        openWindow(id, title, (root) => {
          const el2 = root.closest(".qws-win");
          if (el2) restoreWinPos(id, el2);
          render(root);
        });
        return true;
      } else {
        if (isShown(existing.el)) {
          existing.el.style.display = "none";
          setLaunchState(id, false);
          return false;
        } else {
          existing.el.style.display = "";
          bumpZ(existing.el);
          ensureOnScreen(existing.el);
          setLaunchState(id, true);
          return true;
        }
      }
    }
    function bumpZ(el2) {
      let maxZ = 999999;
      windows.forEach((w) => {
        const z = parseInt(getComputedStyle(w.el).zIndex || "999999", 10);
        if (z > maxZ) maxZ = z;
      });
      el2.style.zIndex = String(maxZ + 1);
    }
    function saveWinPos(id, el2) {
      try {
        const r = parseFloat(el2.style.right) || 16;
        const b = parseFloat(el2.style.bottom) || 16;
        localStorage.setItem(`qws:win:${id}:pos`, JSON.stringify({ r, b }));
      } catch {
      }
    }
    function restoreWinPos(id, el2) {
      try {
        const raw = localStorage.getItem(`qws:win:${id}:pos`);
        if (!raw) return;
        const pos = JSON.parse(raw);
        if (typeof pos.r === "number") el2.style.right = pos.r + "px";
        if (typeof pos.b === "number") el2.style.bottom = pos.b + "px";
        ensureOnScreen(el2);
      } catch {
      }
    }
    window.addEventListener("resize", () => {
      windows.forEach((w) => ensureOnScreen(w.el));
    });
    function enableAltDragAnywhere() {
      let st2 = null;
      const pickRoot = (node) => {
        const el2 = node;
        if (!el2) return null;
        return el2.closest?.(".qws-win, .qws2") || null;
      };
      const onDown = (e) => {
        if (!isModifierActive(e) || e.button !== 0) return;
        const root = pickRoot(e.target);
        if (!root || root.style.display === "none") return;
        const rect = root.getBoundingClientRect();
        const vw = window.innerWidth, vh = window.innerHeight;
        let or = parseFloat(getComputedStyle(root).right);
        let ob = parseFloat(getComputedStyle(root).bottom);
        if (Number.isNaN(or)) or = vw - rect.right;
        if (Number.isNaN(ob)) ob = vh - rect.bottom;
        st2 = { el: root, sx: e.clientX, sy: e.clientY, or, ob };
        document.body.style.userSelect = "none";
        bumpZ(root);
        e.preventDefault();
        e.stopPropagation();
      };
      const onMove = (e) => {
        if (!st2) return;
        const dx = e.clientX - st2.sx;
        const dy = e.clientY - st2.sy;
        let r = st2.or - dx;
        let b = st2.ob - dy;
        const rect = st2.el.getBoundingClientRect();
        const vw = window.innerWidth, vh = window.innerHeight;
        const maxRight = Math.max(MARGIN, vw - rect.width - MARGIN);
        const maxBottom = Math.max(MARGIN, vh - rect.height - MARGIN);
        r = Math.min(Math.max(r, MARGIN), maxRight);
        b = Math.min(Math.max(b, MARGIN), maxBottom);
        st2.el.style.right = `${r}px`;
        st2.el.style.bottom = `${b}px`;
      };
      const stopDrag = () => {
        if (!st2) return;
        document.body.style.userSelect = "";
        clampRect(st2.el);
        const el2 = st2.el;
        let saved = false;
        windows.forEach((w) => {
          if (w.el === el2 && !saved) {
            saveWinPos(w.id, el2);
            saved = true;
          }
        });
        if (!saved && el2 === box) saveHUDPos();
        st2 = null;
      };
      const onUp = () => stopDrag();
      const onKeyUp = (e) => {
        if (!dragHotkey) {
          stopDrag();
          return;
        }
        if (matchesHotkey(e, dragHotkey) || !dragActive) {
          stopDrag();
        }
      };
      window.addEventListener("mousedown", onDown, true);
      window.addEventListener("mousemove", onMove, true);
      window.addEventListener("mouseup", onUp, true);
      window.addEventListener("keyup", onKeyUp, true);
    }
    function patchInputsKeyTrap(scope) {
      const isEditable = (el2) => {
        if (!el2 || !(el2 instanceof HTMLElement)) return false;
        if (el2 instanceof HTMLTextAreaElement) return true;
        if (el2 instanceof HTMLInputElement) {
          const t = (el2.type || "").toLowerCase();
          return t === "text" || t === "number" || t === "search";
        }
        return el2.isContentEditable === true;
      };
      const handler = (ev) => {
        const target = ev.target;
        const active = document.activeElement;
        const inScope = (node) => !!(node && (scope.contains(node) || node.closest?.(".qws-win") || node.closest?.(".qws2")));
        if (!(inScope(target) && isEditable(target) || inScope(active) && isEditable(active))) return;
        ev.stopPropagation();
        ev.stopImmediatePropagation?.();
      };
      const types = ["keydown", "keypress", "keyup"];
      types.forEach((t) => {
        window.addEventListener(t, handler, { capture: true });
        document.addEventListener(t, handler, { capture: true });
        scope.addEventListener(t, handler, { capture: true });
      });
      return () => {
        types.forEach((t) => {
          window.removeEventListener(t, handler, { capture: true });
          document.removeEventListener(t, handler, { capture: true });
          scope.removeEventListener(t, handler, { capture: true });
        });
      };
    }
    const registry2 = [];
    const launchButtons = /* @__PURE__ */ new Map();
    function setLaunchState(id, open) {
      const btn = launchButtons.get(id);
      if (!btn) return;
      btn.textContent = open ? "Close" : "Open";
      btn.dataset.open = open ? "1" : "0";
      if (open) btn.classList.add("active");
      else btn.classList.remove("active");
    }
    function register(id, title, render) {
      registry2.push({ id, title, render });
      addLaunchItem(id, title, render);
    }
    function addLaunchItem(id, title, render) {
      const item = document.createElement("div");
      item.className = "launch-item";
      item.innerHTML = `<div class="name">${escapeHtml2(title)}</div>`;
      const openBtn = document.createElement("button");
      openBtn.className = "btn";
      openBtn.textContent = "Open";
      openBtn.dataset.open = "0";
      launchButtons.set(id, openBtn);
      openBtn.onclick = () => {
        const w = windows.get(id);
        if (w && w.el.style.display !== "none") {
          w.el.style.display = "none";
          setLaunchState(id, false);
        } else {
          openWindow(id, title, (root) => {
            const el2 = root.closest(".qws-win");
            if (el2) restoreWinPos(id, el2);
            render(root);
          });
          setLaunchState(id, true);
        }
      };
      item.appendChild(openBtn);
      launch.appendChild(item);
    }
    try {
      opts?.onRegister?.(register);
    } catch {
    }
    patchInputsKeyTrap(box);
    enableAltDragAnywhere();
    (function initVersionBadge() {
      const setBadge = (text, cls) => {
        sVersion.textContent = text;
        tag(sVersion, cls);
      };
      const setDownloadTarget = (url) => {
        if (url) {
          sVersion.dataset.download = url;
          sVersion.style.cursor = "pointer";
          sVersion.title = `Download the new version`;
        } else {
          delete sVersion.dataset.download;
          sVersion.style.removeProperty("cursor");
          sVersion.removeAttribute("title");
        }
      };
      setBadge("checking\u2026", "warn");
      setDownloadTarget(null);
      const openDownloadLink = (url) => {
        const shouldUseGM = isDiscordSurface();
        const gmObject = globalThis.GM;
        const gmOpen = typeof GM_openInTab === "function" ? GM_openInTab : typeof gmObject?.openInTab === "function" ? gmObject.openInTab.bind(gmObject) : null;
        if (shouldUseGM && gmOpen) {
          try {
            gmOpen(url, { active: true, setParent: true });
            return;
          } catch (error) {
            console.warn("[MagicGarden] GM_openInTab failed, falling back to window.open", error);
          }
        }
        window.open(url, "_blank", "noopener,noreferrer");
      };
      sVersion.addEventListener("click", () => {
        const url = sVersion.dataset.download;
        if (url) {
          openDownloadLink(url);
        }
      });
      (async () => {
        const localVersion = getLocalVersion();
        try {
          const remoteData = await fetchRemoteVersion();
          const remoteVersion = remoteData?.version?.trim();
          if (!remoteVersion) {
            if (localVersion) {
              setBadge(localVersion, "warn");
            } else {
              setBadge("version inconnue", "warn");
            }
            return;
          }
          if (!localVersion) {
            setBadge(remoteVersion, "warn");
            setDownloadTarget(remoteData?.download || null);
            return;
          }
          if (localVersion === remoteVersion) {
            setBadge(localVersion, "ok");
            setDownloadTarget(null);
            return;
          }
          setBadge(`${localVersion} \u2192 ${remoteVersion}`, "warn");
          setDownloadTarget(remoteData?.download || null);
        } catch (error) {
          console.error("[MagicGarden] Failed to check version:", error);
          if (localVersion) {
            setBadge(localVersion, "warn");
          } else {
            setBadge("Unknown", "warn");
          }
        }
      })();
    })();
    (async () => {
      try {
        await ensureStore();
      } catch {
      }
    })();
    setInterval(() => {
      const wsStatus = getWSStatus();
      const storeStatus = getStoreStatus();
      const isStoreMissing = storeStatus.message === "store none";
      const isWsMissing = wsStatus.level === "bad";
      const level = isStoreMissing && isWsMissing ? "bad" : wsStatus.level === "ok" && storeStatus.level === "ok" ? "ok" : "warn";
      const summary = `${wsStatus.message}, ${storeStatus.message}`;
      sFull.textContent = "status";
      sFull.title = summary;
      tag(sFull, level);
      const miniText = level === "ok" ? "OK" : level === "warn" ? "WARN" : "ISSUES";
      sMini.textContent = miniText;
      sMini.title = summary;
      tag(sMini, level);
    }, 800);
    function getOpenPageWS() {
      for (let i = 0; i < sockets.length; i++) {
        if (sockets[i].readyState === NativeWS.OPEN) return sockets[i];
      }
      throw new Error("no page ws");
    }
    function getWSStatus() {
      try {
        getOpenPageWS();
        return { level: "ok", message: "ws open" };
      } catch {
        const viaWorker = !!window.__QWS_workerFound || workerFound;
        if (viaWorker) {
          return { level: "ok", message: "ws via worker" };
        }
        return { level: "bad", message: "ws none" };
      }
    }
    function getStoreStatus() {
      try {
        const captured = isStoreCaptured();
        const info = getCapturedInfo();
        if (captured) {
          return { level: "ok", message: `store ${info.via || "ready"}` };
        }
        if (info.via === "polyfill" || info.polyfill) {
          return { level: "warn", message: "store polyfill" };
        }
        return { level: "bad", message: "store none" };
      } catch {
        return { level: "bad", message: "store error" };
      }
    }
    function tag(el2, cls) {
      el2.classList.remove("ok", "warn", "bad");
      if (cls) el2.classList.add(cls);
    }
    function escapeHtml2(s) {
      return s.replace(/[&<>"']/g, (m) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" })[m]);
    }
  }
  function initWatchers() {
    installShopKeybindsOnce();
    installSellKeybindsOnce();
    installGameKeybindsOnce();
    (async () => {
      try {
        setTeamsForHotkeys(PetsService.getTeams());
      } catch {
      }
      try {
        await PetsService.onTeamsChangeNow((teams) => {
          try {
            setTeamsForHotkeys(teams);
          } catch {
          }
        });
      } catch {
      }
      try {
        installPetTeamHotkeysOnce(async (teamId) => {
          try {
            await PetsService.useTeam(teamId);
          } catch (e) {
            console.warn("[Pets] hotkey useTeam failed:", e);
          }
        });
      } catch {
      }
      await PetsService.startAbilityLogsWatcher();
      await renderOverlay();
      setupBuyAll();
      startReorderObserver();
      startCropValuesObserverFromGardenAtom();
      startInjectSellAllPets();
      startPetPanelEnhancer();
      startSelectedInventoryQuantityLogger();
      startInventorySortingObserver();
      startModalObserver({ intervalMs: 6e4, log: false });
    })();
  }

  // src/data/sprites.ts
  var SOURCE_LABELS = {
    tileRefsMap: "Map tiles",
    tileRefsPlants: "Plants",
    tileRefsTallPlants: "Tall plants",
    tileRefsSeeds: "Seeds",
    tileRefsItems: "Items",
    tileRefsAnimations: "Animations",
    tileRefsPets: "Pets",
    tileRefsMutations: "Mutations",
    tileRefsDecor: "Decor"
  };
  function formatDisplayName(key2) {
    const spaced = key2.replace(/_/g, " ").replace(/([a-z0-9])([A-Z])/g, "$1 $2").replace(/\s+/g, " ").trim();
    if (!spaced) return key2;
    return spaced.charAt(0).toUpperCase() + spaced.slice(1);
  }
  function buildEntries(config) {
    const map2 = /* @__PURE__ */ new Map();
    for (const { source, refs } of config.sources) {
      const sourceLabel = SOURCE_LABELS[source] ?? source;
      for (const [key2, value] of Object.entries(refs)) {
        if (typeof value !== "number" || Number.isNaN(value)) continue;
        const index = value > 0 ? value - 1 : value;
        const entry = {
          index,
          key: key2,
          source,
          sourceLabel,
          qualifiedName: `${source}.${key2}`,
          displayName: formatDisplayName(key2)
        };
        const current = map2.get(index);
        if (current) {
          current.push(entry);
        } else {
          map2.set(index, [entry]);
        }
      }
    }
    return map2;
  }
  var rawMatchers = [
    {
      id: "plants-tall",
      label: "Tall plants",
      test: (sheet) => sheet.includes("tall"),
      sources: [{ source: "tileRefsTallPlants", refs: tileRefsTallPlants }]
    },
    {
      id: "plants",
      label: "Plants",
      test: (sheet) => sheet.includes("plants"),
      sources: [{ source: "tileRefsPlants", refs: tileRefsPlants }]
    },
    {
      id: "mutations",
      label: "Mutations",
      test: (sheet) => sheet.includes("mutation"),
      sources: [{ source: "tileRefsMutations", refs: tileRefsMutations }]
    },
    {
      id: "seeds",
      label: "Seeds",
      test: (sheet) => sheet.includes("seed"),
      sources: [{ source: "tileRefsSeeds", refs: tileRefsSeeds }]
    },
    {
      id: "items",
      label: "Items",
      test: (sheet) => sheet.includes("item"),
      sources: [{ source: "tileRefsItems", refs: tileRefsItems }]
    },
    {
      id: "pets",
      label: "Pets",
      test: (sheet) => sheet.includes("pet"),
      sources: [{ source: "tileRefsPets", refs: tileRefsPets }]
    },
    {
      id: "decor",
      label: "Decor",
      test: (sheet) => sheet.includes("decor"),
      sources: [{ source: "tileRefsDecor", refs: tileRefsDecor }]
    },
    {
      id: "animations",
      label: "Animations",
      test: (sheet) => sheet.includes("anim"),
      sources: [{ source: "tileRefsAnimations", refs: tileRefsAnimations }]
    },
    {
      id: "map",
      label: "Map",
      test: (sheet) => sheet.includes("map"),
      sources: [{ source: "tileRefsMap", refs: tileRefsMap }]
    }
  ];
  var matchers = rawMatchers.map((config) => ({
    ...config,
    entries: buildEntries(config)
  }));
  var matchersBySource = /* @__PURE__ */ new Map();
  for (const matcher of matchers) {
    for (const { source } of matcher.sources) {
      const existing = matchersBySource.get(source);
      if (existing) existing.push(matcher);
      else matchersBySource.set(source, [matcher]);
    }
  }
  var fallbackEntries = (() => {
    const map2 = /* @__PURE__ */ new Map();
    for (const matcher of matchers) {
      for (const [index, entries] of matcher.entries) {
        const existing = map2.get(index);
        if (existing) {
          existing.push(...entries);
        } else {
          map2.set(index, [...entries]);
        }
      }
    }
    return map2;
  })();
  function normalizeSheet(sheet) {
    return sheet.toLowerCase();
  }
  function findTileRefMatch(sheet, index) {
    const normalized = normalizeSheet(sheet);
    for (const matcher of matchers) {
      if (!matcher.test(normalized)) continue;
      const entries = matcher.entries.get(index);
      if (entries?.length) {
        return {
          sheetId: matcher.id,
          sheetLabel: matcher.label,
          entries: [...entries]
        };
      }
    }
    const fallback = fallbackEntries.get(index);
    if (fallback?.length === 1) {
      const entry = fallback[0];
      const sourceMatchers = matchersBySource.get(entry.source);
      if (!sourceMatchers || sourceMatchers.some((m) => m.test(normalized))) {
        return {
          sheetId: entry.source,
          sheetLabel: entry.sourceLabel,
          entries: [...fallback]
        };
      }
    }
    return null;
  }

  // src/services/debug-data.ts
  var fmtTime = (ms) => {
    const d = new Date(ms);
    const pad = (n, s = 2) => String(n).padStart(s, "0");
    return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}.${String(d.getMilliseconds()).padStart(3, "0")}`;
  };
  var escapeLite = (s) => s.replace(/[<>&]/g, (m) => ({ "<": "&lt;", ">": "&gt;", "&": "&amp;" })[m]);
  var FrameBuffer = class {
    constructor(max = 2e3) {
      this.max = max;
      __publicField(this, "arr", []);
    }
    push(f) {
      this.arr.push(f);
      if (this.arr.length > this.max) this.arr.splice(0, this.arr.length - this.max);
    }
    toArray() {
      return this.arr.slice();
    }
    clear() {
      this.arr.length = 0;
    }
  };
  var registry = /* @__PURE__ */ new Map();
  function getWSInfos() {
    return Array.from(registry.values());
  }
  function getWSStatusText() {
    const anyOpen = sockets.some((ws) => ws.readyState === WebSocket.OPEN);
    const viaW = workerFound ? "worker" : "page/auto";
    return `status: ${anyOpen ? "OPEN" : "none"} \u2022 mode: ${viaW}`;
  }
  var HOOKED_CTOR_FLAG = Symbol.for("qmm.wsCtorHooked");
  var WS_PATCHED_SEND = Symbol.for("qmm.wsPatchedSend");
  var hookedOnce = false;
  function installWSHookIfNeeded(onFrame) {
    const Ctor = window.WebSocket;
    if (!Ctor[HOOKED_CTOR_FLAG]) {
      const ProxyCtor = new Proxy(Ctor, {
        construct(target, args, newTarget) {
          const ws = Reflect.construct(target, args, newTarget);
          try {
            trackSocket(ws, "new", onFrame);
          } catch (err) {
          }
          return ws;
        }
      });
      ProxyCtor[HOOKED_CTOR_FLAG] = true;
      window.WebSocket = ProxyCtor;
    }
    sockets.forEach((ws) => {
      try {
        trackSocket(ws, "existing", onFrame);
      } catch (err) {
      }
    });
    if (!hookedOnce) {
      hookedOnce = true;
    } else {
    }
  }
  function trackSocket(ws, why, onFrame) {
    if (registry.has(ws)) {
      return;
    }
    const id = `WS#${1 + registry.size} (${label(ws.readyState)})`;
    const info = { ws, id, listeners: [] };
    if (!sockets.includes(ws)) sockets.push(ws);
    setQWS?.(ws, why);
    const onMsg = (ev) => {
      let text = "";
      try {
        text = typeof ev.data === "string" ? ev.data : JSON.stringify(ev.data);
      } catch {
        text = String(ev.data);
      }
      onFrame({ t: Date.now(), dir: "in", text, ws });
    };
    ws.addEventListener("message", onMsg);
    info.listeners.push(() => ws.removeEventListener("message", onMsg));
    const onOpen = () => {
      info.id = info.id.replace(/\(.*\)/, `(${label(ws.readyState)})`);
    };
    const onClose = () => {
      info.id = info.id.replace(/\(.*\)/, `(${label(ws.readyState)})`);
    };
    ws.addEventListener("open", onOpen);
    ws.addEventListener("close", onClose);
    info.listeners.push(() => ws.removeEventListener("open", onOpen));
    info.listeners.push(() => ws.removeEventListener("close", onClose));
    if (!ws[WS_PATCHED_SEND]) {
      const orig = ws.send.bind(ws);
      info.sendOrig = orig;
      ws[WS_PATCHED_SEND] = true;
      ws.send = (data) => {
        try {
          const text = typeof data === "string" ? data : JSON.stringify(data);
          onFrame({ t: Date.now(), dir: "out", text, ws });
        } catch {
          onFrame({ t: Date.now(), dir: "out", text: String(data), ws });
        }
        return orig(data);
      };
    } else {
    }
    registry.set(ws, info);
  }

  // src/ui/menus/debug-data.ts
  var stylesInjected = false;
  function ensureStyles() {
    if (stylesInjected) return;
    stylesInjected = true;
    const style2 = document.createElement("style");
    style2.id = "mg-debug-data-styles";
    style2.textContent = `
  .dd-debug-view{display:flex;flex-direction:column;gap:16px;}
  .dd-debug-columns{display:grid;gap:16px;grid-template-columns:repeat(2,minmax(320px,1fr));align-items:start;}
  @media (max-width:720px){.dd-debug-columns{grid-template-columns:minmax(0,1fr);}}
  .dd-debug-column{display:flex;flex-direction:column;gap:16px;min-width:0;}
  .dd-card-description{font-size:13px;opacity:.72;margin:0;}
  .dd-atom-list{display:flex;flex-direction:column;gap:4px;margin-top:8px;max-height:40vh;overflow:auto;padding-right:4px;}
  .dd-atom-list__item{display:flex;align-items:center;gap:8px;font-size:13px;padding:4px 6px;border-radius:8px;border:1px solid transparent;cursor:pointer;transition:background .12s ease,border-color .12s ease;}
  .dd-atom-list__item:hover{background:rgba(255,255,255,.06);border-color:rgba(255,255,255,.1);}
  .dd-atom-list__checkbox{accent-color:#5c7eff;}
  .dd-atom-list__label{flex:1 1 auto;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}
  .dd-status-chip{display:inline-flex;align-items:center;gap:6px;padding:4px 12px;border-radius:999px;font-size:12px;font-weight:600;letter-spacing:.01em;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.14);color:#f5f7ff;}
  .dd-status-chip.is-ok{color:#49d389;background:rgba(73,211,137,.14);border-color:rgba(73,211,137,.32);}
  .dd-status-chip.is-warn{color:#ffb760;background:rgba(255,183,96,.12);border-color:rgba(255,183,96,.32);}
  .dd-toolbar{display:flex;flex-wrap:wrap;gap:10px;align-items:center;}
  .dd-toolbar--stretch{width:100%;}
  .dd-toolbar .qmm-input{min-width:160px;}
  .dd-toolbar .dd-grow{flex:1 1 220px;min-width:180px;}
  .dd-mute-chips{display:flex;flex-wrap:wrap;gap:6px;}
  .dd-log{position:relative;border:1px solid #ffffff18;border-radius:16px;background:#0b1016;padding:10px;max-height:48vh;overflow:auto;box-shadow:inset 0 1px 0 rgba(255,255,255,.04);}
  .dd-log__empty{padding:28px 12px;text-align:center;font-size:13px;opacity:.6;}
  .dd-log .ws-row{position:relative;display:grid;grid-template-columns:96px 20px minmax(0,1fr);gap:10px;padding:8px 12px;border-radius:12px;border:1px solid transparent;transition:background .15s ease,border-color .15s ease;align-items:start;margin:2px 0;}
  .dd-log .ws-row .ts{opacity:.76;font-size:12px;}
  .dd-log .ws-row .arrow{font-weight:600;}
  .dd-log .ws-row .body{white-space:pre-wrap;word-break:break-word;}
  .dd-log .ws-row .body code{font-family:inherit;font-size:12px;color:#dbe4ff;}
  .dd-log .ws-row .acts{position:absolute;top:6px;right:8px;display:flex;gap:6px;padding:4px 6px;background:rgba(13,18,25,.94);border:1px solid rgba(255,255,255,.18);border-radius:8px;opacity:0;visibility:hidden;transition:opacity .12s ease;z-index:1;}
  .dd-log .ws-row .acts .qmm-btn{padding:2px 6px;font-size:11px;}
  .dd-log .ws-row:hover .acts{opacity:1;visibility:visible;}
  .dd-log .ws-row:hover{background:rgba(255,255,255,.05);border-color:rgba(255,255,255,.18);}
  .dd-log .ws-row.selected{background:rgba(92,126,255,.16);border-color:rgba(92,126,255,.42);}
  .dd-send-controls{display:flex;flex-wrap:wrap;gap:10px;align-items:center;}
  .dd-send-controls .qmm-radio-group{display:flex;gap:10px;}
  .dd-textarea{min-height:140px;}
  .dd-inline-note{font-size:12px;opacity:.7;}
  .dd-log-filter-group{display:flex;flex-wrap:wrap;gap:6px;align-items:center;}
  .dd-script-log{position:relative;border:1px solid #ffffff18;border-radius:16px;background:#0b1016;max-height:48vh;overflow:auto;box-shadow:inset 0 1px 0 rgba(255,255,255,.04);}
  .dd-script-log__empty{padding:28px 12px;text-align:center;font-size:13px;opacity:.6;}
  .dd-script-log__row{display:grid;grid-template-columns:minmax(92px,96px) minmax(70px,90px) minmax(120px,160px) minmax(0,1fr);gap:12px;padding:12px 16px;border-bottom:1px solid rgba(255,255,255,.06);align-items:start;}
  .dd-script-log__row:last-child{border-bottom:none;}
  .dd-script-log__ts{font-size:12px;opacity:.7;font-family:var(--qmm-font-mono,monospace);}
  .dd-script-log__level{display:inline-flex;align-items:center;justify-content:center;padding:2px 8px;border-radius:999px;font-size:11px;font-weight:600;letter-spacing:.03em;text-transform:uppercase;min-width:58px;}
  .dd-script-log__level.is-debug{background:rgba(138,180,255,.14);color:#8ab4ff;border:1px solid rgba(138,180,255,.32);}
  .dd-script-log__level.is-info{background:rgba(92,126,255,.14);color:#9fb6ff;border:1px solid rgba(92,126,255,.32);}
  .dd-script-log__level.is-warn{background:rgba(255,183,96,.12);color:#ffb760;border:1px solid rgba(255,183,96,.32);}
  .dd-script-log__level.is-error{background:rgba(255,108,132,.16);color:#ff6c84;border:1px solid rgba(255,108,132,.32);}
  .dd-script-log__source{font-size:12px;font-weight:600;opacity:.85;}
  .dd-script-log__context{display:block;font-size:11px;opacity:.6;margin-top:2px;text-transform:uppercase;letter-spacing:.05em;}
  .dd-script-log__message-wrap{display:flex;flex-direction:column;gap:6px;}
  .dd-script-log__message{font-size:13px;line-height:1.45;white-space:pre-wrap;word-break:break-word;}
  .dd-script-log__actions{display:flex;gap:6px;justify-content:flex-end;align-self:flex-end;}
  .dd-script-log__actions button{padding:2px 8px;font-size:11px;border-radius:8px;border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.04);color:inherit;cursor:pointer;transition:background .12s ease,border-color .12s ease;}
  .dd-script-log__actions button:hover{background:rgba(255,255,255,.08);border-color:rgba(255,255,255,.28);}
  .dd-script-log__details{grid-column:1/-1;margin:4px 0 0;background:#05080c;border:1px solid rgba(255,255,255,.08);border-radius:10px;padding:10px;white-space:pre-wrap;font-family:var(--qmm-font-mono,monospace);font-size:12px;line-height:1.4;display:none;word-break:break-word;max-height:180px;overflow:auto;}
  .dd-script-log__row.is-open .dd-script-log__details{display:block;}
  .dd-log-source-chips{display:flex;flex-wrap:wrap;gap:6px;}
  .dd-log-toolbar-spacer{flex:1 1 auto;}
  .dd-audio-summary{display:grid;gap:4px;font-size:13px;}
  .dd-audio-summary strong{font-size:14px;}
  .dd-audio-volume{font-family:var(--qmm-font-mono,monospace);font-size:12px;opacity:.78;}
  .dd-audio-list{display:flex;flex-direction:column;gap:8px;margin-top:4px;max-height:48vh;overflow:auto;padding-right:4px;}
  .dd-audio-row{display:flex;flex-wrap:wrap;gap:12px;align-items:flex-start;padding:10px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.08);background:rgba(9,12,18,.72);}
  .dd-audio-row__info{flex:1 1 260px;min-width:0;display:flex;flex-direction:column;gap:6px;}
  .dd-audio-row__title{font-weight:600;font-size:13px;word-break:break-word;}
  .dd-audio-meta{font-size:12px;opacity:.72;display:flex;flex-wrap:wrap;gap:8px;}
  .dd-audio-url{font-family:var(--qmm-font-mono,monospace);font-size:11px;word-break:break-all;color:#d6dcffb3;}
  .dd-audio-actions{display:flex;gap:6px;flex-wrap:wrap;margin-left:auto;}
  .dd-audio-empty{padding:24px 12px;text-align:center;font-size:13px;opacity:.6;}
  .dd-sprite-controls{display:flex;flex-direction:column;gap:12px;}
  .dd-sprite-control-grid{display:grid;gap:10px;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));}
  .dd-sprite-control{display:flex;flex-direction:column;gap:4px;}
  .dd-sprite-control__label{font-size:11px;opacity:.72;text-transform:uppercase;letter-spacing:.08em;}
  .dd-sprite-control.is-hidden{display:none;}
  .dd-sprite-control .qmm-select{width:100%;}
  .dd-sprite-toolbar{display:flex;flex-wrap:wrap;align-items:center;gap:8px;width:100%;}
  .dd-sprite-toolbar .qmm-input{flex:1 1 220px;min-width:180px;padding:6px 10px;border-radius:8px;font-size:13px;}
  .dd-sprite-btn{padding:6px 12px;font-size:12px;border-radius:8px;border:1px solid rgba(124,148,255,.38);background:linear-gradient(180deg,rgba(122,150,255,.26),rgba(82,108,214,.14));color:#f5f7ff;box-shadow:0 3px 10px rgba(78,104,214,.22);text-shadow:0 1px 0 rgba(0,0,0,.24);}
  .dd-sprite-btn:hover{border-color:rgba(148,172,255,.45);background:linear-gradient(180deg,rgba(136,162,255,.34),rgba(98,122,226,.18));}
  .dd-sprite-btn:active{transform:translateY(1px);}
  .dd-sprite-btn .qmm-btn__icon{font-size:1.05em;}
  .dd-sprite-btn--ghost{background:rgba(255,255,255,.05);border-color:rgba(255,255,255,.14);box-shadow:none;color:inherit;text-shadow:none;}
  .dd-sprite-btn--ghost:hover{background:rgba(255,255,255,.08);border-color:rgba(255,255,255,.2);}
  .dd-sprite-list{display:flex;flex-direction:column;gap:6px;max-height:48vh;overflow:auto;padding-right:4px;}
  .dd-sprite-item{display:flex;flex-direction:column;align-items:flex-start;gap:2px;padding:8px 10px;border-radius:10px;border:1px solid transparent;background:rgba(255,255,255,.02);cursor:pointer;text-align:left;transition:background .12s ease,border-color .12s ease,transform .12s ease;}
  .dd-sprite-item:hover{background:rgba(255,255,255,.05);border-color:rgba(255,255,255,.14);}
  .dd-sprite-item.is-active{border-color:rgba(92,126,255,.45);background:rgba(92,126,255,.18);}
  .dd-sprite-item__title{font-weight:600;font-size:13px;}
  .dd-sprite-item__subtitle{font-size:11px;opacity:.7;word-break:break-all;}
  .dd-sprite-empty{padding:20px 12px;text-align:center;font-size:13px;opacity:.68;}
  .dd-sprite-preview-body{display:flex;flex-direction:column;gap:12px;}
  .dd-sprite-preview-scroll{max-height:60vh;overflow:auto;padding-right:4px;}
  .dd-sprite-url{font-size:12px;opacity:.75;word-break:break-all;}
  .dd-sprite-tiles-grid{display:grid;gap:12px;grid-template-columns:repeat(auto-fill,minmax(96px,1fr));}
  .dd-sprite-tile{display:flex;flex-direction:column;gap:6px;align-items:center;padding:8px;border-radius:12px;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);}
  .dd-sprite-tile canvas{width:100%;height:auto;image-rendering:pixelated;background:#05080c;border-radius:8px;}
  .dd-sprite-tile__name{font-weight:600;font-size:12px;text-align:center;}
  .dd-sprite-tile__refs{font-size:11px;opacity:.68;text-align:center;font-family:var(--qmm-font-mono,monospace);word-break:break-word;}
  .dd-sprite-tile__meta{font-size:11px;opacity:.75;text-align:center;font-family:var(--qmm-font-mono,monospace);}
  .dd-sprite-ui-preview{display:flex;flex-direction:column;align-items:center;gap:12px;background:rgba(0,0,0,.28);padding:12px;border-radius:12px;}
  .dd-sprite-variant-grid{display:grid;gap:8px;width:100%;grid-template-columns:repeat(auto-fit,minmax(96px,1fr));}
  .dd-sprite-variant-grid.is-wide{grid-template-columns:repeat(auto-fit,minmax(160px,1fr));max-width:100%;}
  .dd-sprite-variant{display:flex;flex-direction:column;gap:4px;align-items:center;}
  .dd-sprite-variant__label{font-size:11px;opacity:.78;text-transform:uppercase;letter-spacing:.08em;text-align:center;}
  .dd-sprite-variant__label[data-variant="gold"]{color:#f8d47c;background:linear-gradient(135deg,#fff1a1,#f3c76a 58%,#f6b84f);background-clip:text;-webkit-background-clip:text;-webkit-text-fill-color:transparent;text-shadow:0 1px 4px rgba(0,0,0,.35);}
  .dd-sprite-variant__label[data-variant="rainbow"]{color:#f7f2ff;background:linear-gradient(90deg,#ff6b6b,#ffd86f,#6bff8f,#6bc7ff,#b86bff);background-clip:text;-webkit-background-clip:text;-webkit-text-fill-color:transparent;text-shadow:0 1px 4px rgba(0,0,0,.35);}
  .dd-sprite-variant__canvas{width:100%;height:auto;image-rendering:pixelated;background:#05080c;border-radius:8px;box-shadow:inset 0 1px 0 rgba(255,255,255,.08);}
  `;
    document.head.appendChild(style2);
  }
  function createTwoColumns(view) {
    const columns = document.createElement("div");
    columns.className = "dd-debug-columns";
    view.appendChild(columns);
    const leftCol = document.createElement("div");
    leftCol.className = "dd-debug-column";
    const rightCol = document.createElement("div");
    rightCol.className = "dd-debug-column";
    columns.append(leftCol, rightCol);
    return { columns, leftCol, rightCol };
  }
  async function renderDebugDataMenu(root) {
    ensureStyles();
    const ui = new Menu({ id: "debug-tools", compact: true });
    ui.mount(root);
    ui.addTab("jotai", "Jotai", (view) => renderJotaiTab(view, ui));
    ui.addTab("atoms-live", "Live atoms", (view) => renderLiveAtomsTab(view, ui));
    ui.addTab("sprites", "Sprites", (view) => renderSpritesTab(view, ui));
    ui.addTab("audio-player", "Audio player", (view) => renderAudioPlayerTab(view, ui));
    ui.addTab("websocket", "WebSocket", (view) => renderWSTab(view, ui));
  }
  function renderJotaiTab(view, ui) {
    view.innerHTML = "";
    view.classList.add("dd-debug-view");
    const { leftCol, rightCol } = createTwoColumns(view);
    {
      const card = ui.card("\u{1F5C4}\uFE0F Capture store", {
        tone: "muted",
        subtitle: "Initialize the Jotai store so atoms can be inspected."
      });
      leftCol.appendChild(card.root);
      const status = document.createElement("span");
      status.className = "dd-status-chip";
      const refreshStatus = () => {
        const captured = isStoreCaptured();
        status.textContent = captured ? "Store captured" : "Store not captured";
        status.classList.toggle("is-ok", captured);
        status.classList.toggle("is-warn", !captured);
      };
      refreshStatus();
      const actions = ui.flexRow({ gap: 10, align: "center", wrap: true });
      const btnCap = ui.btn("Capture store", {
        variant: "primary",
        icon: "\u23FA",
        onClick: async () => {
          try {
            await ensureStore();
          } catch {
          }
          refreshStatus();
        }
      });
      actions.append(btnCap, status);
      card.body.appendChild(actions);
    }
    {
      const card = ui.card("\u{1F50D} Explore atoms", {
        tone: "muted",
        subtitle: "Filter labels using a regular expression."
      });
      leftCol.appendChild(card.root);
      const queryRow = ui.flexRow({ gap: 10, wrap: true, fullWidth: true });
      const q = ui.inputText("regex label (ex: position|health)", "");
      q.classList.add("dd-grow");
      const btnList = ui.btn("List", { icon: "\u{1F4C4}", onClick: () => doList() });
      const btnCopy = ui.btn("Copy", { icon: "\u{1F4CB}", onClick: () => copy(pre.textContent || "") });
      queryRow.append(q, btnList, btnCopy);
      const pre = document.createElement("pre");
      stylePre(pre);
      pre.style.minHeight = "140px";
      async function doList() {
        const raw = q.value.trim();
        const rx = safeRegex(raw || ".*");
        const all = findAtomsByLabel(/.*/);
        const atoms = all.filter((a) => rx.test(String(a?.debugLabel || a?.label || "")));
        const labels = atoms.map((a) => String(a?.debugLabel || a?.label || "<?>"));
        pre.textContent = labels.join("\n");
      }
      card.body.append(queryRow, pre);
    }
    {
      const card = ui.card("\u{1F9ED} Inspect an atom", {
        tone: "muted",
        subtitle: "Get the current value or subscribe to updates."
      });
      rightCol.appendChild(card.root);
      const controls = ui.flexRow({ gap: 10, wrap: true, fullWidth: true });
      const q = ui.inputText("atom label (ex: positionAtom)", "");
      q.classList.add("dd-grow");
      const pre = document.createElement("pre");
      stylePre(pre);
      pre.style.minHeight = "160px";
      let unsubRef = null;
      const btnGet = ui.btn("Get", {
        icon: "\u{1F441}",
        onClick: async () => {
          const atom = getAtomByLabel(q.value.trim());
          if (!atom) {
            pre.textContent = `Atom "${q.value}" not found`;
            return;
          }
          try {
            setText(pre, await jGet(atom));
          } catch (e) {
            setText(pre, e?.message || String(e));
          }
        }
      });
      const btnSub = ui.btn("Subscribe", {
        icon: "\u{1F514}",
        onClick: async () => {
          const label2 = q.value.trim();
          if (!label2) return;
          const atom = getAtomByLabel(label2);
          if (!atom) {
            pre.textContent = `Atom "${label2}" not found`;
            return;
          }
          if (unsubRef) {
            unsubRef();
            unsubRef = null;
            btnSub.textContent = "Subscribe";
            return;
          }
          unsubRef = await jSub(atom, async () => {
            try {
              setText(pre, await jGet(atom));
            } catch {
            }
          });
          btnSub.textContent = "Unsubscribe";
        }
      });
      const btnCopy = ui.btn("Copy", { icon: "\u{1F4CB}", onClick: () => copy(pre.textContent || "") });
      controls.append(q, btnGet, btnSub, btnCopy);
      const note = document.createElement("p");
      note.className = "dd-inline-note";
      note.textContent = "Tip: subscriptions keep the value updated after each mutation.";
      card.body.append(controls, note, pre);
    }
    {
      const card = ui.card("\u270F\uFE0F Update an atom", {
        tone: "muted",
        subtitle: "Publish a new value (JSON)."
      });
      rightCol.appendChild(card.root);
      const controls = ui.flexRow({ gap: 10, wrap: true, fullWidth: true });
      const q = ui.inputText("atom label (ex: activeModalAtom)", "");
      q.classList.add("dd-grow");
      const ta = document.createElement("textarea");
      ta.className = "qmm-input dd-textarea";
      ta.placeholder = `JSON or text value, e.g. inventory or { "x": 1, "y": 2 }`;
      const btnSet = ui.btn("Set", {
        icon: "\u2705",
        variant: "primary",
        onClick: async () => {
          const label2 = q.value.trim();
          if (!label2) {
            toast("Enter an atom label");
            return;
          }
          try {
            await ensureStore();
          } catch (e) {
            toast(e?.message || "Unable to capture store");
            return;
          }
          if (!isStoreCaptured()) {
            toast('Store not captured. Use "Capture store" first.');
            return;
          }
          const atom = getAtomByLabel(label2);
          if (!atom) {
            toast(`Atom "${label2}" not found`);
            return;
          }
          const raw = ta.value;
          const trimmed = raw.trim();
          let val = raw;
          let fallback = false;
          if (trimmed) {
            try {
              val = JSON.parse(trimmed);
            } catch {
              fallback = true;
            }
          } else {
            val = "";
          }
          try {
            await jSet(atom, val);
            toast(fallback ? "Set OK (raw text)" : "Set OK");
          } catch (e) {
            toast(e?.message || "Set failed");
          }
        }
      });
      const btnCopy = ui.btn("Copy JSON", { icon: "\u{1F4CB}", onClick: () => copy(ta.value) });
      controls.append(q, btnSet, btnCopy);
      card.body.append(controls, ta);
    }
    function setText(el2, v) {
      el2.textContent = typeof v === "string" ? v : JSON.stringify(v, null, 2);
    }
    function toast(msg) {
      try {
        window.toastSimple?.(msg, "", "warn");
      } catch {
      }
    }
  }
  function renderLiveAtomsTab(view, ui) {
    if (typeof view.__atoms_live_cleanup__ === "function") {
      try {
        view.__atoms_live_cleanup__();
      } catch {
      }
    }
    view.innerHTML = "";
    view.classList.add("dd-debug-view");
    const entries = /* @__PURE__ */ new Map();
    const records = [];
    let recording = false;
    let selectedRecord = null;
    const { leftCol, rightCol } = createTwoColumns(view);
    const selectCard = ui.card("\u{1F9EA} Pick atoms", {
      tone: "muted",
      subtitle: "Filter labels with a regex then toggle atoms to monitor."
    });
    leftCol.appendChild(selectCard.root);
    const filterRow = ui.flexRow({ gap: 10, wrap: true, fullWidth: true });
    const filterInput = ui.inputText("regex label (ex: position|health)", "");
    filterInput.classList.add("dd-grow");
    const btnFilter = ui.btn("Refresh", { icon: "\u{1F50D}", onClick: () => refreshMatches() });
    filterRow.append(filterInput, btnFilter);
    const matchesWrap = document.createElement("div");
    matchesWrap.className = "dd-atom-list";
    const emptyMatches = document.createElement("p");
    emptyMatches.className = "dd-card-description";
    emptyMatches.textContent = "No atoms match the current filter.";
    emptyMatches.style.display = "none";
    const selectedInfo = document.createElement("p");
    selectedInfo.className = "dd-card-description";
    selectedInfo.style.marginTop = "8px";
    selectCard.body.append(filterRow, matchesWrap, emptyMatches, selectedInfo);
    filterInput.addEventListener("keydown", (ev) => {
      if (ev.key === "Enter") {
        ev.preventDefault();
        refreshMatches();
      }
    });
    const logCard = ui.card("\u{1F4E1} Live atom log", {
      tone: "muted",
      subtitle: "Start recording to capture updates for the selected atoms."
    });
    rightCol.appendChild(logCard.root);
    const controlsRow = ui.flexRow({ gap: 10, wrap: true, fullWidth: true });
    const btnRecord = ui.btn("Start recording", {
      variant: "primary",
      onClick: () => toggleRecording()
    });
    const btnClear = ui.btn("Clear log", {
      variant: "ghost",
      icon: "\u{1F9F9}",
      onClick: () => {
        records.length = 0;
        selectedRecord = null;
        renderRecords(false);
        updateDetails(null);
        updateControls();
      }
    });
    const btnCopyLog = ui.btn("Copy log", {
      variant: "ghost",
      icon: "\u{1F4CB}",
      onClick: () => copyLog()
    });
    controlsRow.append(btnRecord, btnClear, btnCopyLog);
    logCard.body.appendChild(controlsRow);
    const logWrap = document.createElement("div");
    logWrap.className = "dd-log";
    logWrap.style.fontFamily = "ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    const logEmpty = document.createElement("div");
    logEmpty.className = "dd-log__empty";
    logEmpty.textContent = "No updates yet.";
    logWrap.appendChild(logEmpty);
    logCard.body.appendChild(logWrap);
    const detailHeader = document.createElement("p");
    detailHeader.className = "dd-card-description";
    detailHeader.textContent = "Select a log entry to inspect previous and next values.";
    const detailWrap = ui.flexRow({ gap: 12, wrap: true, fullWidth: true });
    const prevBox = document.createElement("div");
    prevBox.style.flex = "1 1 320px";
    const prevTitle = document.createElement("strong");
    prevTitle.textContent = "Previous";
    prevTitle.style.display = "block";
    prevTitle.style.marginBottom = "6px";
    const prevPre = document.createElement("pre");
    stylePre(prevPre);
    prevPre.style.minHeight = "140px";
    prevPre.textContent = "";
    prevBox.append(prevTitle, prevPre);
    const nextBox = document.createElement("div");
    nextBox.style.flex = "1 1 320px";
    const nextTitle = document.createElement("strong");
    nextTitle.textContent = "Next";
    nextTitle.style.display = "block";
    nextTitle.style.marginBottom = "6px";
    const nextPre = document.createElement("pre");
    stylePre(nextPre);
    nextPre.style.minHeight = "140px";
    nextPre.textContent = "";
    nextBox.append(nextTitle, nextPre);
    const historyBox = document.createElement("div");
    historyBox.style.flex = "1 1 100%";
    historyBox.style.minWidth = "0";
    const historyTitle = document.createElement("strong");
    historyTitle.textContent = "History";
    historyTitle.style.display = "block";
    historyTitle.style.marginBottom = "6px";
    const historyList = document.createElement("div");
    historyList.style.display = "flex";
    historyList.style.flexDirection = "column";
    historyList.style.gap = "10px";
    historyList.style.maxHeight = "320px";
    historyList.style.overflow = "auto";
    historyBox.append(historyTitle, historyList);
    detailWrap.append(prevBox, nextBox, historyBox);
    logCard.body.append(detailHeader, detailWrap);
    function refreshMatches() {
      const raw = filterInput.value.trim();
      const rx = safeRegex(raw || ".*");
      const atoms = findAtomsByLabel(rx);
      matchesWrap.innerHTML = "";
      emptyMatches.style.display = atoms.length ? "none" : "block";
      atoms.map((atom) => ({ atom, label: String(atom?.debugLabel || atom?.label || "<unknown>") })).sort((a, b) => a.label.localeCompare(b.label)).forEach(({ atom, label: label2 }) => {
        const row = document.createElement("label");
        row.className = "dd-atom-list__item";
        row.title = label2;
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.checked = entries.has(label2);
        checkbox.className = "dd-atom-list__checkbox";
        const text = document.createElement("span");
        text.className = "dd-atom-list__label";
        text.textContent = label2;
        row.append(checkbox, text);
        checkbox.addEventListener("change", async () => {
          if (checkbox.checked) {
            const existing = entries.get(label2);
            if (existing) {
              existing.atom = atom;
            } else {
              entries.set(label2, { atom, lastValue: null, unsubscribe: null });
            }
            if (recording) {
              const ok = await attachEntry(label2);
              if (!ok) checkbox.checked = false;
            }
          } else {
            const existing = entries.get(label2);
            if (existing?.unsubscribe) {
              try {
                existing.unsubscribe();
              } catch {
              }
            }
            entries.delete(label2);
          }
          updateSelectedInfo();
          updateControls();
        });
        matchesWrap.appendChild(row);
        if (entries.has(label2)) {
          const existing = entries.get(label2);
          if (existing) existing.atom = atom;
        }
      });
      updateSelectedInfo();
    }
    function updateSelectedInfo() {
      const size = entries.size;
      selectedInfo.textContent = size ? `${size} atom${size > 1 ? "s" : ""} selected.` : "No atom selected.";
    }
    function updateControls() {
      setBtnLabel(btnRecord, recording ? "Stop recording" : "Start recording");
      btnRecord.classList.toggle("active", recording);
      btnRecord.disabled = !recording && !entries.size;
      btnClear.disabled = records.length === 0;
      btnCopyLog.disabled = records.length === 0;
    }
    function renderRecords(autoScroll = false) {
      logWrap.innerHTML = "";
      if (!records.length) {
        logWrap.appendChild(logEmpty);
        renderHistoryFor(null, null);
        return;
      }
      records.forEach((rec, idx) => {
        const row = document.createElement("div");
        row.className = "atoms-log-row";
        row.dataset.idx = String(idx);
        row.style.display = "grid";
        row.style.gridTemplateColumns = "minmax(120px, 160px) minmax(0, 1fr)";
        row.style.gap = "12px";
        row.style.padding = "10px 12px";
        row.style.margin = "4px 0";
        row.style.borderRadius = "12px";
        row.style.border = "1px solid rgba(255,255,255,.12)";
        const isSelected = selectedRecord === idx;
        row.style.background = isSelected ? "rgba(92,126,255,.16)" : "rgba(11,16,22,.85)";
        row.style.borderColor = isSelected ? "rgba(92,126,255,.42)" : "rgba(255,255,255,.12)";
        row.style.cursor = "pointer";
        row.addEventListener("mouseenter", () => {
          row.style.borderColor = "rgba(255,255,255,.28)";
        });
        row.addEventListener("mouseleave", () => {
          const sel = selectedRecord === idx;
          row.style.borderColor = sel ? "rgba(92,126,255,.42)" : "rgba(255,255,255,.12)";
        });
        const left = document.createElement("div");
        left.style.display = "flex";
        left.style.flexDirection = "column";
        left.style.gap = "2px";
        const lbl = document.createElement("strong");
        lbl.textContent = rec.label;
        const ts = document.createElement("span");
        ts.style.opacity = "0.7";
        ts.style.fontSize = "12px";
        ts.textContent = `${fmtTime(rec.timestamp)}${rec.type === "initial" ? " \u2022 initial" : ""}`;
        left.append(lbl, ts);
        const summary = document.createElement("div");
        summary.style.fontSize = "12px";
        summary.style.lineHeight = "1.45";
        summary.style.whiteSpace = "pre-wrap";
        const prefix = rec.type === "initial" ? "[initial] " : "";
        summary.textContent = prefix + summarizeValue(rec.next);
        row.append(left, summary);
        row.addEventListener("click", () => {
          selectedRecord = idx;
          renderRecords(false);
          updateDetails(rec);
        });
        logWrap.appendChild(row);
      });
      if (autoScroll) logWrap.scrollTop = logWrap.scrollHeight;
      if (selectedRecord != null && !records[selectedRecord]) {
        selectedRecord = records.length ? Math.min(selectedRecord, records.length - 1) : null;
      }
      if (selectedRecord != null) {
        renderHistoryFor(records[selectedRecord]?.label ?? null, selectedRecord);
      }
    }
    function updateDetails(rec) {
      if (!rec) {
        detailHeader.textContent = "Select a log entry to inspect previous and next values.";
        prevTitle.textContent = "Previous";
        prevPre.textContent = "";
        nextTitle.textContent = "Next";
        nextPre.textContent = "";
        renderHistoryFor(null, null);
        return;
      }
      const typeSuffix = rec.type === "initial" ? " (initial)" : "";
      detailHeader.textContent = `${rec.label} \u2014 ${fmtTime(rec.timestamp)}${typeSuffix}`;
      prevTitle.textContent = rec.type === "initial" ? "Previous (none)" : "Previous";
      prevPre.textContent = rec.type === "initial" ? "(no previous snapshot)" : stringify(rec.previous);
      nextTitle.textContent = rec.type === "initial" ? "Initial value" : "Next";
      nextPre.textContent = stringify(rec.next);
      renderHistoryFor(rec.label, selectedRecord);
    }
    function renderHistoryFor(label2, selectedIdx) {
      historyList.innerHTML = "";
      if (!label2) {
        const empty = document.createElement("p");
        empty.className = "dd-card-description";
        empty.textContent = "Select a log entry to inspect the value history.";
        historyList.appendChild(empty);
        return;
      }
      const relevant = records.map((rec, idx) => ({ rec, idx })).filter(({ rec }) => rec.label === label2);
      if (!relevant.length) {
        const empty = document.createElement("p");
        empty.className = "dd-card-description";
        empty.textContent = "No history recorded yet.";
        historyList.appendChild(empty);
        return;
      }
      relevant.forEach(({ rec, idx }, order) => {
        const item = document.createElement("div");
        item.style.display = "flex";
        item.style.flexDirection = "column";
        item.style.gap = "6px";
        item.style.padding = "10px 12px";
        item.style.borderRadius = "12px";
        item.style.border = "1px solid rgba(255,255,255,.12)";
        const isSelected = idx === selectedIdx;
        item.style.background = isSelected ? "rgba(92,126,255,.16)" : "rgba(11,16,22,.85)";
        item.style.borderColor = isSelected ? "rgba(92,126,255,.42)" : "rgba(255,255,255,.12)";
        item.style.cursor = "pointer";
        item.addEventListener("mouseenter", () => {
          if (!isSelected) item.style.borderColor = "rgba(255,255,255,.24)";
        });
        item.addEventListener("mouseleave", () => {
          item.style.borderColor = isSelected ? "rgba(92,126,255,.42)" : "rgba(255,255,255,.12)";
        });
        item.addEventListener("click", () => {
          selectedRecord = idx;
          renderRecords(false);
          updateDetails(records[selectedRecord]);
        });
        const head = document.createElement("div");
        head.style.display = "flex";
        head.style.alignItems = "center";
        head.style.justifyContent = "space-between";
        const meta = document.createElement("div");
        meta.style.display = "flex";
        meta.style.alignItems = "center";
        meta.style.gap = "8px";
        const orderBadge = document.createElement("span");
        orderBadge.textContent = `#${order + 1}`;
        orderBadge.style.fontSize = "11px";
        orderBadge.style.letterSpacing = ".04em";
        orderBadge.style.textTransform = "uppercase";
        orderBadge.style.padding = "2px 6px";
        orderBadge.style.borderRadius = "999px";
        orderBadge.style.background = "rgba(255,255,255,.08)";
        orderBadge.style.border = "1px solid rgba(255,255,255,.16)";
        const type = document.createElement("span");
        type.textContent = rec.type === "initial" ? "Initial" : "Update";
        type.style.fontSize = "11px";
        type.style.opacity = "0.75";
        type.style.textTransform = "uppercase";
        meta.append(orderBadge, type);
        const ts = document.createElement("span");
        ts.textContent = fmtTime(rec.timestamp);
        ts.style.fontSize = "12px";
        ts.style.opacity = "0.75";
        head.append(meta, ts);
        const val = document.createElement("pre");
        stylePre(val);
        val.style.margin = "0";
        val.textContent = stringify(rec.next);
        item.append(head, val);
        historyList.appendChild(item);
      });
    }
    async function toggleRecording() {
      if (recording) {
        stopRecording();
        return;
      }
      if (!entries.size) {
        toast("Select at least one atom");
        return;
      }
      try {
        await ensureStore();
      } catch (e) {
        toast(e?.message || "Unable to capture store");
        return;
      }
      recording = true;
      updateControls();
      for (const label2 of Array.from(entries.keys())) {
        const ok = await attachEntry(label2);
        if (!ok) entries.delete(label2);
      }
      if (!entries.size) {
        stopRecording();
      }
      updateSelectedInfo();
      updateControls();
    }
    function stopRecording() {
      if (!recording) return;
      recording = false;
      for (const entry of entries.values()) {
        if (entry.unsubscribe) {
          try {
            entry.unsubscribe();
          } catch {
          }
          entry.unsubscribe = null;
        }
      }
      updateControls();
    }
    async function attachEntry(label2) {
      const entry = entries.get(label2);
      if (!entry) return false;
      if (entry.unsubscribe) {
        try {
          entry.unsubscribe();
        } catch {
        }
        entry.unsubscribe = null;
      }
      try {
        const initialValue = snapshot(await jGet(entry.atom));
        entry.lastValue = initialValue;
        const unsub = await jSub(entry.atom, async () => {
          const previous = snapshot(entry.lastValue);
          let nextValue;
          try {
            nextValue = await jGet(entry.atom);
          } catch (err) {
            nextValue = err?.message || String(err);
          }
          const nextSnap = snapshot(nextValue);
          entry.lastValue = nextSnap;
          const rec = {
            label: label2,
            timestamp: Date.now(),
            previous,
            next: nextSnap,
            type: "update"
          };
          records.push(rec);
          if (selectedRecord == null) selectedRecord = records.length - 1;
          renderRecords(true);
          updateDetails(records[selectedRecord]);
          updateControls();
        });
        const initialRecord = {
          label: label2,
          timestamp: Date.now(),
          previous: null,
          next: snapshot(initialValue),
          type: "initial"
        };
        records.push(initialRecord);
        if (selectedRecord == null) selectedRecord = records.length - 1;
        renderRecords(true);
        updateDetails(records[selectedRecord]);
        entry.unsubscribe = () => {
          try {
            unsub();
          } catch {
          }
          ;
        };
        return true;
      } catch (err) {
        toast(err?.message || `Unable to subscribe to ${label2}`);
        entries.delete(label2);
        updateSelectedInfo();
        updateControls();
        return false;
      }
    }
    function copyLog() {
      if (!records.length) return;
      const text = records.map((rec) => {
        const prev = rec.previous == null ? "(no previous snapshot)" : stringify(rec.previous);
        const next = stringify(rec.next);
        const type = rec.type === "initial" ? "initial" : "update";
        return `[${fmtTime(rec.timestamp)}] ${rec.label} (${type})
previous: ${prev}
next: ${next}`;
      }).join("\n\n");
      copy(text);
    }
    function snapshot(value) {
      if (value == null) return value;
      try {
        if (typeof structuredClone === "function") return structuredClone(value);
      } catch {
      }
      try {
        return JSON.parse(JSON.stringify(value));
      } catch {
        return value;
      }
    }
    function stringify(value) {
      if (typeof value === "string") return value;
      try {
        return JSON.stringify(value, null, 2);
      } catch {
        return String(value);
      }
    }
    function summarizeValue(value) {
      const str = stringify(value).replace(/\s+/g, " ").trim();
      return str.length > 140 ? str.slice(0, 140) + "\u2026" : str;
    }
    function setBtnLabel(btn, text) {
      const label2 = btn.querySelector(".label");
      if (label2) label2.textContent = text;
      else btn.textContent = text;
    }
    function toast(msg, type = "warn") {
      try {
        window.toastSimple?.(msg, "", type);
      } catch {
      }
    }
    refreshMatches();
    updateControls();
    view.__atoms_live_cleanup__ = () => {
      stopRecording();
      for (const entry of entries.values()) {
        if (entry.unsubscribe) {
          try {
            entry.unsubscribe();
          } catch {
          }
        }
      }
      entries.clear();
      records.length = 0;
      selectedRecord = null;
    };
  }
  function renderSpritesTab(view, ui) {
    view.innerHTML = "";
    view.classList.add("dd-debug-view");
    const { leftCol, rightCol } = createTwoColumns(view);
    const tileCategoryBase = [
      { id: "all", label: "All tiles", icon: "\u{1F5C2}\uFE0F", getUrls: () => Sprites.lists().tiles },
      { id: "map", label: "Map", icon: "\u{1F5FA}\uFE0F", getUrls: () => Sprites.listMap() },
      {
        id: "plants",
        label: "Plants",
        icon: "\u{1F33F}",
        getUrls: () => {
          const urls = /* @__PURE__ */ new Set([
            ...Sprites.listPlants(),
            ...Sprites.listAllPlants()
          ]);
          return [...urls];
        }
      },
      { id: "seeds", label: "Seeds", icon: "\u{1F330}", getUrls: () => Sprites.listSeeds() },
      { id: "items", label: "Items", icon: "\u{1F381}", getUrls: () => Sprites.listItems() },
      { id: "pets", label: "Pets", icon: "\u{1F43E}", getUrls: () => Sprites.listPets() }
    ];
    const tileCategories = [
      ...tileCategoryBase,
      {
        id: "other",
        label: "Other",
        icon: "\u{1F9E9}",
        getUrls: () => {
          const rest = new Set(Sprites.lists().tiles);
          tileCategoryBase.filter((cat) => cat.id !== "all").forEach((cat) => {
            for (const url of cat.getUrls()) rest.delete(url);
          });
          return [...rest];
        }
      }
    ];
    let mode = "tiles";
    let category = "all";
    let selectedBase = null;
    let allEntries = [];
    let filteredEntries = [];
    let previewToken = 0;
    let variantFilter = "all";
    const controlsCard = ui.card("\u{1F3A8} Sprites explorer", {
      tone: "muted",
      subtitle: "Browse captured tile sheets and UI assets detected by the sprite sniffer."
    });
    controlsCard.body.classList.add("dd-sprite-controls");
    leftCol.appendChild(controlsCard.root);
    const controlsGrid = document.createElement("div");
    controlsGrid.className = "dd-sprite-control-grid";
    controlsCard.body.appendChild(controlsGrid);
    function createSelectControl(labelText, select2) {
      const wrap = document.createElement("label");
      wrap.className = "dd-sprite-control";
      const labelEl = document.createElement("span");
      labelEl.className = "dd-sprite-control__label";
      labelEl.textContent = labelText;
      wrap.append(labelEl, select2);
      return wrap;
    }
    const modeSelect = ui.select({ width: "100%" });
    const modeOptions = [
      { value: "tiles", label: "\u{1F9F1} Tiles" },
      { value: "ui", label: "\u{1F5BC}\uFE0F UI" }
    ];
    modeOptions.forEach(({ value, label: label2 }) => {
      const opt = document.createElement("option");
      opt.value = value;
      opt.textContent = label2;
      modeSelect.appendChild(opt);
    });
    modeSelect.value = mode;
    const modeControl = createSelectControl("Asset type", modeSelect);
    controlsGrid.appendChild(modeControl);
    const categorySelect = ui.select({ width: "100%" });
    tileCategories.forEach((cat) => {
      const opt = document.createElement("option");
      opt.value = cat.id;
      opt.textContent = `${cat.icon} ${cat.label}`;
      categorySelect.appendChild(opt);
    });
    categorySelect.value = category;
    const categoryControl = createSelectControl("Tiles category", categorySelect);
    controlsGrid.appendChild(categoryControl);
    const variantSelect = ui.select({ width: "100%" });
    const variantOptions = [
      { id: "all", label: "\u2728 All variants" },
      { id: "normal", label: "\u{1F3A8} Normal" },
      { id: "gold", label: "\u{1F947} Gold" },
      { id: "rainbow", label: "\u{1F308} Rainbow" }
    ];
    variantOptions.forEach((option) => {
      const opt = document.createElement("option");
      opt.value = option.id;
      opt.textContent = option.label;
      variantSelect.appendChild(opt);
    });
    variantSelect.value = variantFilter;
    const variantControl = createSelectControl("Variant preview", variantSelect);
    controlsGrid.appendChild(variantControl);
    const controlsFooter = ui.flexRow({ gap: 8, wrap: true, fullWidth: true });
    controlsFooter.classList.add("dd-sprite-toolbar");
    const btnRefresh = ui.btn("Refresh lists", {
      icon: "\u{1F504}",
      size: "sm",
      onClick: () => refreshList2({ preserveSelection: true })
    });
    btnRefresh.classList.add("dd-sprite-btn");
    controlsFooter.appendChild(btnRefresh);
    controlsCard.body.appendChild(controlsFooter);
    const listCard = ui.card("\u{1F5C2}\uFE0F Tile sheets", {
      tone: "muted",
      subtitle: "Select a sprite sheet to preview its tiles."
    });
    listCard.body.style.display = "flex";
    listCard.body.style.flexDirection = "column";
    listCard.body.style.gap = "12px";
    leftCol.appendChild(listCard.root);
    const filterRow = ui.flexRow({ gap: 8, wrap: true, fullWidth: true });
    filterRow.classList.add("dd-sprite-toolbar");
    const filterInput = ui.inputText("filter (regex)", "");
    filterInput.classList.add("dd-grow");
    const btnClearFilter = ui.btn("Clear", {
      icon: "\u{1F9F9}",
      size: "sm",
      onClick: () => {
        filterInput.value = "";
        applyFilter(true);
        filterInput.focus();
      }
    });
    btnClearFilter.classList.add("dd-sprite-btn", "dd-sprite-btn--ghost");
    filterRow.append(filterInput, btnClearFilter);
    listCard.body.appendChild(filterRow);
    const listInfo = document.createElement("div");
    listInfo.className = "dd-card-description";
    listCard.body.appendChild(listInfo);
    const listContainer = document.createElement("div");
    listContainer.className = "dd-sprite-list";
    listCard.body.appendChild(listContainer);
    const listEmpty = document.createElement("div");
    listEmpty.className = "dd-sprite-empty";
    listEmpty.style.display = "none";
    listCard.body.appendChild(listEmpty);
    const previewCard = ui.card("\u{1F441}\uFE0F Preview", {
      tone: "muted",
      subtitle: "Visualize the slices for a tile sheet or inspect a UI sprite."
    });
    previewCard.body.classList.add("dd-sprite-preview-body");
    rightCol.appendChild(previewCard.root);
    const previewBody = previewCard.body;
    const placeholder = document.createElement("div");
    placeholder.className = "dd-sprite-empty";
    placeholder.textContent = "Select a sprite sheet or UI asset from the list.";
    previewBody.appendChild(placeholder);
    function setMode(next) {
      if (mode === next) return;
      mode = next;
      modeSelect.value = mode;
      updateCategoryVisibility();
      updateListTitle();
      refreshList2({ preserveSelection: false });
    }
    function updateCategoryVisibility() {
      const showTiles = mode === "tiles";
      categoryControl.classList.toggle("is-hidden", !showTiles);
      categorySelect.disabled = !showTiles;
    }
    function refreshList2(opts = {}) {
      const preserve = !!opts.preserveSelection;
      const previous = preserve ? selectedBase : null;
      const urls = mode === "tiles" ? getCategoryUrls(category) : Array.from(new Set(Sprites.lists().ui));
      allEntries = toEntries(urls);
      if (preserve && previous && allEntries.some((entry) => entry.base === previous)) {
        selectedBase = previous;
      } else {
        selectedBase = allEntries[0]?.base ?? null;
      }
      updateListTitle();
      applyFilter(true);
    }
    function getCategoryUrls(catId) {
      const cat = tileCategories.find((c) => c.id === catId) ?? tileCategories[0];
      try {
        return Array.from(new Set(cat.getUrls()));
      } catch {
        return [];
      }
    }
    function toEntries(urls) {
      return urls.map((url) => ({ url, base: baseName(url) })).sort((a, b) => a.base.localeCompare(b.base));
    }
    function applyFilter(preserveSelection) {
      const query = filterInput.value.trim();
      const rx = query ? safeRegex(query) : /.*/i;
      filteredEntries = allEntries.filter((entry) => rx.test(entry.base) || rx.test(entry.url));
      if (preserveSelection) {
        if (selectedBase && !filteredEntries.some((entry) => entry.base === selectedBase)) {
          selectedBase = filteredEntries[0]?.base ?? null;
        }
      } else {
        selectedBase = filteredEntries[0]?.base ?? null;
      }
      renderListItems();
      updateInfoLine();
      updateEmptyState();
      updateSelectionStyles();
      void renderCurrentPreview();
    }
    function renderListItems() {
      listContainer.innerHTML = "";
      for (const entry of filteredEntries) {
        const item = document.createElement("button");
        item.type = "button";
        item.className = "dd-sprite-item";
        item.dataset.base = entry.base;
        if (entry.base === selectedBase) item.classList.add("is-active");
        const title = document.createElement("span");
        title.className = "dd-sprite-item__title";
        title.textContent = entry.base;
        const subtitle = document.createElement("span");
        subtitle.className = "dd-sprite-item__subtitle";
        subtitle.textContent = shortenUrl(entry.url);
        item.append(title, subtitle);
        item.addEventListener("click", () => setSelected(entry.base));
        listContainer.appendChild(item);
      }
    }
    function updateSelectionStyles() {
      listContainer.querySelectorAll(".dd-sprite-item").forEach((btn) => {
        btn.classList.toggle("is-active", btn.dataset.base === selectedBase);
      });
    }
    function updateInfoLine() {
      const total = allEntries.length;
      const visible = filteredEntries.length;
      const label2 = mode === "tiles" ? "tile sheet" : "UI asset";
      if (!total) {
        listInfo.textContent = mode === "tiles" ? "No tile sheets captured yet. Trigger in-game actions then refresh." : "No UI sprites captured yet. Interact with the UI then refresh.";
        return;
      }
      let text = `${visible} ${label2}${visible === 1 ? "" : "s"} visible`;
      if (visible !== total) text += ` (total ${total})`;
      if (mode === "tiles" && category !== "all") {
        const cat = tileCategories.find((c) => c.id === category);
        if (cat) text += ` \xB7 ${cat.label}`;
      }
      listInfo.textContent = text;
    }
    function updateEmptyState() {
      if (filteredEntries.length) {
        listEmpty.style.display = "none";
      } else {
        listEmpty.style.display = "";
        if (!allEntries.length) {
          listEmpty.textContent = mode === "tiles" ? "No tile sheets captured yet. Trigger in-game actions then refresh." : "No UI sprites captured yet. Interact with the UI then refresh.";
        } else {
          listEmpty.textContent = mode === "tiles" ? "No tile sheets match the current filters." : "No UI assets match the current filters.";
        }
      }
    }
    function setSelected(base) {
      if (selectedBase === base) return;
      selectedBase = base;
      updateSelectionStyles();
      void renderCurrentPreview();
    }
    async function renderCurrentPreview() {
      const entry = filteredEntries.find((item) => item.base === selectedBase) ?? allEntries.find((item) => item.base === selectedBase) ?? null;
      const token = ++previewToken;
      await renderPreview(entry, token);
    }
    async function renderPreview(entry, token) {
      if (!entry) {
        previewCard.setTitle("\u{1F441}\uFE0F Preview");
        previewBody.replaceChildren(
          createEmptyMessage(
            mode === "tiles" ? "Select a tile sheet to preview its tiles." : "Select a UI asset to inspect it."
          )
        );
        return;
      }
      previewCard.setTitle(`\u{1F441}\uFE0F Preview \xB7 ${entry.base}`);
      const loading = createEmptyMessage("Loading\u2026");
      previewBody.replaceChildren(loading);
      try {
        if (mode === "tiles") {
          await renderTilesPreview(entry, token);
        } else {
          await renderUiPreview(entry, token);
        }
      } catch (error) {
        if (token !== previewToken) return;
        const message = error instanceof Error ? error.message : typeof error === "string" ? error : "Unknown error";
        previewBody.replaceChildren(createEmptyMessage(`Failed to load sprite: ${message}`));
      }
    }
    function createVariantGrid(variants, opts) {
      const grid = document.createElement("div");
      grid.className = "dd-sprite-variant-grid";
      if (opts?.wide) grid.classList.add("is-wide");
      variants.forEach((variant) => {
        const { type, icon, label: label2, canvas } = variant;
        canvas.classList.add("dd-sprite-variant__canvas");
        const item = document.createElement("div");
        item.className = "dd-sprite-variant";
        const caption = document.createElement("div");
        caption.className = "dd-sprite-variant__label";
        caption.dataset.variant = type;
        caption.textContent = `${icon} ${label2}`;
        item.append(canvas, caption);
        grid.appendChild(item);
      });
      return grid;
    }
    function tileToCanvasCopy(tile) {
      const src = tile.data;
      if (typeof src === "string" || !src) return null;
      const fallbackSize = tile.size ?? 0;
      const width = Math.max(typeof src.width === "number" ? src.width : fallbackSize, 1);
      const height = Math.max(typeof src.height === "number" ? src.height : fallbackSize, 1);
      const canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext("2d");
      if (!ctx) return null;
      ctx.imageSmoothingEnabled = false;
      try {
        ctx.drawImage(src, 0, 0, width, height);
      } catch {
        return null;
      }
      return canvas;
    }
    function filterVariantsForDisplay(variants) {
      if (variantFilter === "all") return variants;
      return variants.filter((variant) => variant.type === variantFilter);
    }
    function buildVariants(tile) {
      const variants = [];
      const base = tileToCanvasCopy(tile);
      if (base) {
        variants.push({ type: "normal", icon: "\u{1F3A8}", label: "Normal", canvas: base });
      }
      const addVariant = (type, label2, icon, factory) => {
        try {
          const canvas = factory();
          variants.push({ type, icon, label: label2, canvas });
        } catch {
        }
      };
      if (base) {
        addVariant("gold", "Gold", "\u{1F947}", () => Sprites.effectGold(tile));
        addVariant("rainbow", "Rainbow", "\u{1F308}", () => Sprites.effectRainbow(tile));
      }
      return variants;
    }
    async function renderTilesPreview(entry, token) {
      const escaped = entry.base.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      const rx = new RegExp(`${escaped}.(png|webp)$`, "i");
      const map2 = await Sprites.loadTiles({ mode: "canvas", includeBlanks: false, onlySheets: rx });
      if (token !== previewToken) return;
      const tiles = map2.get(entry.base) || [];
      previewBody.innerHTML = "";
      if (!tiles.length) {
        previewBody.append(createEmptyMessage("No tiles available for this sheet."));
        return;
      }
      const summary = document.createElement("div");
      summary.className = "dd-card-description";
      const size = tiles[0]?.size ?? 0;
      summary.textContent = `${tiles.length} tile${tiles.length === 1 ? "" : "s"} \xB7 ${size ? `${size}\xD7${size}px` : "unknown size"}`;
      const urlLine = createUrlLine(entry.url);
      const scroll = document.createElement("div");
      scroll.className = "dd-sprite-preview-scroll";
      const grid = document.createElement("div");
      grid.className = "dd-sprite-tiles-grid";
      scroll.appendChild(grid);
      tiles.forEach((tile) => {
        const cell = document.createElement("div");
        cell.className = "dd-sprite-tile";
        const variants = filterVariantsForDisplay(buildVariants(tile));
        if (variants.length) {
          cell.appendChild(createVariantGrid(variants));
        }
        const match = findTileRefMatch(tile.sheet, tile.index);
        if (match) {
          const displayNames = Array.from(
            new Set(match.entries.map((entry2) => entry2.displayName || entry2.key))
          );
          const titleLine = document.createElement("div");
          titleLine.className = "dd-sprite-tile__name";
          titleLine.textContent = displayNames.length ? `${match.sheetLabel}: ${displayNames.join(", ")}` : match.sheetLabel;
          cell.appendChild(titleLine);
          const refsLine = document.createElement("div");
          refsLine.className = "dd-sprite-tile__refs";
          const refsText = match.entries.map((entry2) => `${entry2.qualifiedName} (#${entry2.index})`).join(" \xB7 ");
          refsLine.textContent = refsText;
          refsLine.title = refsText;
          cell.appendChild(refsLine);
        }
        const meta = document.createElement("div");
        meta.className = "dd-sprite-tile__meta";
        meta.textContent = `#${tile.index} \xB7 col ${tile.col} \xB7 row ${tile.row}`;
        cell.appendChild(meta);
        grid.appendChild(cell);
      });
      previewBody.append(summary, urlLine, scroll);
    }
    async function renderUiPreview(entry, token) {
      const map2 = await Sprites.loadUI();
      if (token !== previewToken) return;
      const img = map2.get(entry.base);
      previewBody.innerHTML = "";
      if (!img) {
        previewBody.append(createEmptyMessage("This UI asset was not found in the cache yet."));
        return;
      }
      const dimensions = document.createElement("div");
      dimensions.className = "dd-card-description";
      dimensions.textContent = "Dimensions: \u2026";
      const urlLine = createUrlLine(entry.url);
      const wrap = document.createElement("div");
      wrap.className = "dd-sprite-ui-preview";
      const naturalWidth = img.naturalWidth || img.width;
      const naturalHeight = img.naturalHeight || img.height;
      if (naturalWidth && naturalHeight) {
        dimensions.textContent = `Dimensions: ${naturalWidth}\xD7${naturalHeight}px`;
      } else {
        dimensions.textContent = "Dimensions: unknown";
      }
      const baseCanvas = document.createElement("canvas");
      baseCanvas.width = naturalWidth || img.width || 1;
      baseCanvas.height = naturalHeight || img.height || 1;
      const ctx = baseCanvas.getContext("2d");
      if (ctx) {
        ctx.imageSmoothingEnabled = false;
        try {
          ctx.drawImage(img, 0, 0, baseCanvas.width, baseCanvas.height);
        } catch {
        }
      }
      const baseTile = {
        sheet: entry.base,
        url: entry.url,
        index: 0,
        col: 0,
        row: 0,
        size: Math.max(baseCanvas.width, baseCanvas.height, 1),
        data: baseCanvas
      };
      const variants = filterVariantsForDisplay(buildVariants(baseTile));
      if (variants.length) {
        wrap.appendChild(createVariantGrid(variants, { wide: true }));
      }
      previewBody.append(dimensions, urlLine, wrap);
    }
    function updateListTitle() {
      if (mode === "tiles") {
        const cat = tileCategories.find((c) => c.id === category);
        listCard.setTitle(`${cat?.icon ?? "\u{1F5C2}\uFE0F"} ${cat?.label ?? "Tiles"}`);
      } else {
        listCard.setTitle("\u{1F5BC}\uFE0F UI assets");
      }
    }
    function createUrlLine(url) {
      const line = document.createElement("div");
      line.className = "dd-sprite-url";
      const link = document.createElement("a");
      link.href = url;
      link.target = "_blank";
      link.rel = "noopener noreferrer";
      link.textContent = url;
      line.appendChild(link);
      return line;
    }
    function createEmptyMessage(text) {
      const div = document.createElement("div");
      div.className = "dd-sprite-empty";
      div.textContent = text;
      return div;
    }
    function baseName(url) {
      try {
        const clean = decodeURIComponent(url.split(/[#?]/)[0]);
        const parts = clean.split("/");
        const file = parts.pop() || "";
        return file.replace(/\.[a-z0-9]+$/i, "") || file || clean;
      } catch {
        return url;
      }
    }
    function shortenUrl(url) {
      try {
        const parsed = new URL(url, location.href);
        const path = parsed.pathname.replace(/^\//, "");
        return path || parsed.hostname;
      } catch {
        return url;
      }
    }
    function onSpriteDetected() {
      refreshList2({ preserveSelection: true });
    }
    filterInput.addEventListener("input", () => applyFilter(true));
    filterInput.addEventListener("keydown", (ev) => {
      if (ev.key === "Enter") {
        ev.preventDefault();
        applyFilter(true);
      }
    });
    modeSelect.addEventListener("change", () => {
      const next = modeSelect.value === "ui" ? "ui" : "tiles";
      setMode(next);
    });
    categorySelect.addEventListener("change", () => {
      const next = categorySelect.value || tileCategories[0]?.id || "all";
      if (category === next) return;
      category = next;
      updateListTitle();
      refreshList2({ preserveSelection: false });
    });
    variantSelect.addEventListener("change", () => {
      const next = variantSelect.value || "all";
      if (variantFilter === next) return;
      variantFilter = next;
      void renderCurrentPreview();
    });
    updateCategoryVisibility();
    updateListTitle();
    refreshList2({ preserveSelection: false });
    const existingListener = view.__spriteListener;
    if (existingListener) window.removeEventListener("mg:sprite-detected", existingListener);
    view.__spriteListener = onSpriteDetected;
    window.addEventListener("mg:sprite-detected", onSpriteDetected);
    const offUnmount = ui.on("unmounted", () => {
      window.removeEventListener("mg:sprite-detected", onSpriteDetected);
      view.__spriteListener = void 0;
      offUnmount();
    });
  }
  function renderAudioPlayerTab(view, ui) {
    view.innerHTML = "";
    view.classList.add("dd-debug-view");
    const { leftCol, rightCol } = createTwoColumns(view);
    let infoList = [];
    let groupEntries = [];
    let visibleSounds = [];
    const overviewCard = ui.card("\u{1F3A7} Audio player", {
      tone: "muted",
      subtitle: "Inspect detected sounds, auto groups and Howler status."
    });
    leftCol.appendChild(overviewCard.root);
    const summary = document.createElement("div");
    summary.className = "dd-audio-summary";
    const summarySounds = document.createElement("div");
    const summaryGroups = document.createElement("div");
    const summarySources = document.createElement("div");
    summary.append(summarySounds, summaryGroups, summarySources);
    const volumeLine = document.createElement("div");
    volumeLine.className = "dd-audio-volume";
    const finalLine = document.createElement("div");
    finalLine.className = "dd-audio-volume";
    const overviewError = ui.errorBar();
    const actionsRow = ui.flexRow({ gap: 10, wrap: true, fullWidth: true });
    const btnScan = ui.btn("Rescan sounds", {
      icon: "\u{1F504}",
      variant: "primary",
      onClick: () => {
        void refreshAll({ rescan: true });
      }
    });
    const btnRefresh = ui.btn("Refresh snapshot", {
      icon: "\u{1F501}",
      onClick: () => {
        void refreshAll();
      }
    });
    const btnCopyJson = ui.btn("Copy JSON", {
      icon: "\u{1F4CB}",
      onClick: () => copy(audioPlayer.exportJSON())
    });
    actionsRow.append(btnScan, btnRefresh, btnCopyJson);
    overviewCard.body.append(summary, volumeLine, finalLine, overviewError.el, actionsRow);
    const groupsCard = ui.card("\u{1F39B}\uFE0F Groups", {
      tone: "muted",
      subtitle: "Browse auto-generated groups and play random variations."
    });
    leftCol.appendChild(groupsCard.root);
    const groupToolbar = ui.flexRow({ gap: 10, wrap: true, fullWidth: true });
    const groupFilter = ui.inputText("filter groups (regex)", "");
    groupFilter.classList.add("dd-grow");
    const btnGroupClear = ui.btn("Clear", {
      icon: "\u{1F9F9}",
      onClick: () => {
        groupFilter.value = "";
        renderGroups();
        groupFilter.focus();
      }
    });
    groupToolbar.append(groupFilter, btnGroupClear);
    const groupInfo = document.createElement("p");
    groupInfo.className = "dd-card-description";
    groupInfo.style.margin = "0";
    const groupList = document.createElement("div");
    groupList.className = "dd-audio-list";
    const groupEmpty = document.createElement("div");
    groupEmpty.className = "dd-audio-empty";
    groupEmpty.textContent = "No groups match the current filter.";
    groupsCard.body.append(groupToolbar, groupInfo, groupList, groupEmpty);
    const soundsCard = ui.card("\u{1F509} Sounds", {
      tone: "muted",
      subtitle: "Inspect detected files and trigger playback."
    });
    rightCol.appendChild(soundsCard.root);
    const soundToolbar = ui.flexRow({ gap: 10, wrap: true, fullWidth: true });
    const soundFilter = ui.inputText("filter sounds (regex)", "");
    soundFilter.classList.add("dd-grow");
    const btnSoundClear = ui.btn("Clear", {
      icon: "\u{1F9F9}",
      onClick: () => {
        soundFilter.value = "";
        renderSounds();
        soundFilter.focus();
      }
    });
    const btnCopyVisible = ui.btn("Copy visible URLs", {
      icon: "\u{1F4CB}",
      onClick: () => {
        if (!visibleSounds.length) return;
        copy(visibleSounds.map((s) => s.url).join("\n"));
      }
    });
    soundToolbar.append(soundFilter, btnSoundClear, btnCopyVisible);
    const soundInfo = document.createElement("p");
    soundInfo.className = "dd-card-description";
    soundInfo.style.margin = "0";
    const soundList = document.createElement("div");
    soundList.className = "dd-audio-list";
    const soundEmpty = document.createElement("div");
    soundEmpty.className = "dd-audio-empty";
    soundEmpty.textContent = "No sounds match the current filter.";
    soundsCard.body.append(soundToolbar, soundInfo, soundList, soundEmpty);
    groupFilter.addEventListener("input", () => renderGroups());
    groupFilter.addEventListener("keydown", (ev) => {
      if (ev.key === "Enter") {
        ev.preventDefault();
        renderGroups();
      }
    });
    soundFilter.addEventListener("input", () => renderSounds());
    soundFilter.addEventListener("keydown", (ev) => {
      if (ev.key === "Enter") {
        ev.preventDefault();
        renderSounds();
      }
    });
    let busy = false;
    function labelForSound(info) {
      return info.logicalName || info.name || fileNameFromUrl(info.url);
    }
    function fileNameFromUrl(url) {
      try {
        return new URL(url, location.href).pathname.split("/").pop() || url;
      } catch {
        return url;
      }
    }
    function formatNumber(value, digits = 3) {
      return value == null || Number.isNaN(value) || !Number.isFinite(value) ? "\u2014" : value.toFixed(digits);
    }
    function setButtonEnabled(btn, enabled) {
      const setter = btn.setEnabled;
      if (typeof setter === "function") setter(enabled);
      else btn.disabled = !enabled;
    }
    const scanLabel = btnScan.querySelector(".label");
    const defaultScanText = scanLabel?.textContent ?? "Rescan sounds";
    function setScanButtonLoading(loading) {
      setButtonEnabled(btnScan, !loading);
      if (scanLabel) scanLabel.textContent = loading ? "Scanning\u2026" : defaultScanText;
    }
    function refreshData() {
      infoList = audioPlayer.info().slice().sort((a, b) => labelForSound(a).localeCompare(labelForSound(b)));
      groupEntries = Object.entries(audioPlayer.groups()).sort((a, b) => a[0].localeCompare(b[0]));
    }
    function updateOverview() {
      const sources = /* @__PURE__ */ new Set();
      infoList.forEach((info) => {
        (info.sources || "").split(",").map((s) => s.trim()).filter(Boolean).forEach((src) => sources.add(src));
      });
      const vol = audioPlayer.getGameSfxVolume();
      const howlerGlobal = window?.Howler;
      let howlerMaster = null;
      try {
        if (howlerGlobal && typeof howlerGlobal.volume === "function") {
          const val = howlerGlobal.volume();
          if (typeof val === "number" && Number.isFinite(val)) howlerMaster = val;
        }
      } catch {
      }
      const howlerCount = Array.isArray(howlerGlobal?._howls) ? howlerGlobal._howls.length : 0;
      summarySounds.innerHTML = `<strong>${infoList.length}</strong> sounds detected`;
      summaryGroups.innerHTML = `<strong>${groupEntries.length}</strong> auto groups`;
      summarySources.innerHTML = `<strong>${sources.size}</strong> unique source tags`;
      volumeLine.textContent = `Atom raw: ${formatNumber(vol.raw)} (clamped ${formatNumber(vol.clamped)})`;
      let suffix = "";
      if (howlerMaster != null) {
        suffix = ` \xB7 Howler master ${formatNumber(howlerMaster)}`;
        if (howlerCount) suffix += ` (${howlerCount} howl${howlerCount === 1 ? "" : "s"})`;
      } else if (howlerCount) {
        suffix = ` \xB7 ${howlerCount} howl${howlerCount === 1 ? "" : "s"} registered`;
      }
      finalLine.textContent = `Final output volume: ${formatNumber(vol.vol)}${suffix}`;
    }
    function renderGroups() {
      const rx = safeRegex(groupFilter.value.trim() || ".*");
      const infoByUrl = new Map(infoList.map((info) => [info.url, info]));
      groupList.innerHTML = "";
      let visible = 0;
      const matches = (value) => !!value && rx.test(value);
      for (const [name, urls] of groupEntries) {
        const include = matches(name) || urls.some((url) => {
          const info = infoByUrl.get(url);
          return matches(url) || matches(info?.logicalName) || matches(info?.name);
        });
        if (!include) continue;
        visible++;
        const sampleUrl = urls[0] || "";
        const sampleInfo = infoByUrl.get(sampleUrl);
        const row = document.createElement("div");
        row.className = "dd-audio-row";
        const infoWrap = document.createElement("div");
        infoWrap.className = "dd-audio-row__info";
        const title = document.createElement("div");
        title.className = "dd-audio-row__title";
        title.textContent = name;
        const meta = document.createElement("div");
        meta.className = "dd-audio-meta";
        const parts = [];
        parts.push(`${urls.length} variation${urls.length === 1 ? "" : "s"}`);
        if (sampleInfo?.name) parts.push(`Sample: ${sampleInfo.name}`);
        if (sampleInfo?.sources) parts.push(`Sources: ${sampleInfo.sources}`);
        meta.textContent = parts.join(" \u2022 ");
        const urlEl = document.createElement("div");
        urlEl.className = "dd-audio-url";
        urlEl.textContent = sampleUrl || "(no sample)";
        infoWrap.append(title, meta, urlEl);
        row.appendChild(infoWrap);
        const actions = ui.flexRow({ gap: 6, wrap: false, align: "center" });
        actions.className = "dd-audio-actions";
        const playBtn = ui.btn("Play", {
          icon: "\u25B6\uFE0F",
          size: "sm",
          onClick: () => {
            audioPlayer.playGroup(name, { random: true });
          }
        });
        const copyBtn = ui.btn("Copy URLs", {
          icon: "\u{1F4CB}",
          size: "sm",
          onClick: () => copy(urls.join("\n"))
        });
        const openBtn = sampleUrl ? ui.btn("Open", {
          icon: "\u{1F517}",
          size: "sm",
          onClick: () => {
            try {
              window.open(sampleUrl, "_blank", "noopener,noreferrer");
            } catch {
            }
          }
        }) : null;
        actions.append(playBtn, copyBtn);
        if (openBtn) actions.append(openBtn);
        row.appendChild(actions);
        groupList.appendChild(row);
      }
      groupInfo.textContent = groupEntries.length ? `${visible} / ${groupEntries.length} groups shown.` : "No groups have been detected yet. Run a rescan to populate the cache.";
      groupList.style.display = visible ? "" : "none";
      groupEmpty.textContent = groupEntries.length ? "No groups match the current filter." : "No groups detected yet. Run a rescan to populate the cache.";
      groupEmpty.style.display = visible ? "none" : "block";
      setButtonEnabled(btnGroupClear, groupFilter.value.trim().length > 0);
    }
    function renderSounds() {
      const rx = safeRegex(soundFilter.value.trim() || ".*");
      visibleSounds = [];
      soundList.innerHTML = "";
      const matches = (value) => !!value && rx.test(value);
      for (const info of infoList) {
        if (!(matches(info.logicalName) || matches(info.name) || matches(info.sources) || matches(info.url))) continue;
        visibleSounds.push(info);
        const row = document.createElement("div");
        row.className = "dd-audio-row";
        const infoWrap = document.createElement("div");
        infoWrap.className = "dd-audio-row__info";
        const title = document.createElement("div");
        title.className = "dd-audio-row__title";
        title.textContent = labelForSound(info);
        const meta = document.createElement("div");
        meta.className = "dd-audio-meta";
        const parts = [];
        if (info.name && info.name !== info.logicalName) parts.push(`File: ${info.name}`);
        if (info.logicalName) parts.push(`Logical: ${info.logicalName}`);
        if (info.sources) parts.push(`Sources: ${info.sources}`);
        meta.textContent = parts.join(" \u2022 ");
        const urlEl = document.createElement("div");
        urlEl.className = "dd-audio-url";
        urlEl.textContent = info.url;
        infoWrap.append(title, meta, urlEl);
        row.appendChild(infoWrap);
        const actions = ui.flexRow({ gap: 6, wrap: false, align: "center" });
        actions.className = "dd-audio-actions";
        const playBtn = ui.btn("Play", {
          icon: "\u25B6\uFE0F",
          size: "sm",
          onClick: () => {
            audioPlayer.playUrl(info.url);
          }
        });
        const copyBtn = ui.btn("Copy", {
          icon: "\u{1F4CB}",
          size: "sm",
          onClick: () => copy(info.url)
        });
        const openBtn = ui.btn("Open", {
          icon: "\u{1F517}",
          size: "sm",
          onClick: () => {
            try {
              window.open(info.url, "_blank", "noopener,noreferrer");
            } catch {
            }
          }
        });
        actions.append(playBtn, copyBtn, openBtn);
        row.appendChild(actions);
        soundList.appendChild(row);
      }
      soundInfo.textContent = infoList.length ? `${visibleSounds.length} / ${infoList.length} sounds shown.` : "No sounds have been detected yet. Run a rescan to populate the cache.";
      soundList.style.display = visibleSounds.length ? "" : "none";
      soundEmpty.textContent = infoList.length ? "No sounds match the current filter." : "No sounds detected yet. Run a rescan to populate the cache.";
      soundEmpty.style.display = visibleSounds.length ? "none" : "block";
      setButtonEnabled(btnCopyVisible, visibleSounds.length > 0);
      setButtonEnabled(btnSoundClear, soundFilter.value.trim().length > 0);
    }
    async function refreshAll(opts = {}) {
      if (busy) return;
      busy = true;
      const { rescan = false } = opts;
      overviewError.clear();
      if (rescan) setScanButtonLoading(true);
      else setButtonEnabled(btnScan, false);
      setButtonEnabled(btnRefresh, false);
      let scanError = null;
      try {
        if (rescan) {
          try {
            await audioPlayer.scan();
          } catch (err) {
            scanError = err;
          }
        }
        refreshData();
        updateOverview();
        renderGroups();
        renderSounds();
        if (scanError) {
          const message = scanError instanceof Error ? scanError.message : String(scanError);
          overviewError.show(`Scan failed: ${message}`);
          console.error("[debug] audio scan failed", scanError);
        }
      } finally {
        if (rescan) setScanButtonLoading(false);
        else setButtonEnabled(btnScan, true);
        setButtonEnabled(btnRefresh, true);
        busy = false;
      }
    }
    void refreshAll();
  }
  function renderWSTab(view, ui) {
    if (typeof view.__ws_cleanup__ === "function") {
      try {
        view.__ws_cleanup__();
      } catch {
      }
    }
    view.innerHTML = "";
    view.classList.add("dd-debug-view");
    const frames = new FrameBuffer(2e3);
    const framesMap = /* @__PURE__ */ new Map();
    let seq = 0;
    let paused = false;
    let autoScroll = true;
    let showIn = true;
    let showOut = true;
    let filterText = "";
    let onlyCurrentSocket = false;
    let replayToSource = false;
    let selectedId = null;
    let mutePatterns = [];
    const setSelectedRow = (fid) => {
      selectedId = fid;
      [...logWrap.querySelectorAll("[data-fid]")].forEach((row) => {
        row.classList.toggle("selected", String(fid || "") === row.dataset.fid);
      });
      if (fid != null) {
        const f = framesMap.get(fid);
        if (f) ta.value = f.text;
      }
    };
    const matchesMutes = (text) => mutePatterns.some((rx) => rx.test(text));
    const statusCard = ui.card("\u{1F4E1} Live traffic", {
      tone: "muted",
      subtitle: "Monitor, filter, and replay WebSocket frames."
    });
    view.appendChild(statusCard.root);
    const muteCard = ui.card("\u{1F649} Mutes (regex)", {
      tone: "muted",
      subtitle: "Hide unwanted messages."
    });
    view.appendChild(muteCard.root);
    const logCard = ui.card("\u{1F9FE} Frame log", { tone: "muted" });
    view.appendChild(logCard.root);
    const sendCard = ui.card("\u{1F4E4} Send a frame", {
      tone: "muted",
      subtitle: "Pick or compose a payload and send it."
    });
    view.appendChild(sendCard.root);
    const statusToolbar = document.createElement("div");
    statusToolbar.className = "dd-toolbar dd-toolbar--stretch";
    statusCard.body.appendChild(statusToolbar);
    const lblConn = document.createElement("span");
    lblConn.className = "dd-status-chip";
    const sel = ui.select({ width: "220px" });
    const btnPause = ui.btn("Pause", {
      variant: "secondary",
      onClick: () => {
        paused = !paused;
        setPauseLabel(paused ? "Resume" : "Pause");
        btnPause.classList.toggle("active", paused);
        btnPause.title = paused ? "Resume live updates" : "Pause live updates";
      }
    });
    const setPauseLabel = (text) => {
      const label2 = btnPause.querySelector(".label");
      if (label2) label2.textContent = text;
      else btnPause.textContent = text;
    };
    setPauseLabel("Pause");
    btnPause.title = "Suspend live updates";
    const btnClear = ui.btn("Clear", {
      variant: "ghost",
      icon: "\u{1F9F9}",
      onClick: () => {
        frames.clear();
        framesMap.clear();
        setSelectedRow(null);
        repaint(true);
      }
    });
    const btnCopy = ui.btn("Copy visible", {
      variant: "ghost",
      icon: "\u{1F4CB}",
      onClick: () => copyVisible()
    });
    statusToolbar.append(lblConn, sel, btnPause, btnClear, btnCopy);
    const filterToolbar = document.createElement("div");
    filterToolbar.className = "dd-toolbar dd-toolbar--stretch";
    statusCard.body.appendChild(filterToolbar);
    const inputFilter = ui.inputText("filter text (case-insensitive)", "");
    inputFilter.classList.add("dd-grow");
    inputFilter.addEventListener("input", () => {
      filterText = inputFilter.value.trim().toLowerCase();
      repaint(true);
    });
    const inToggle = ui.toggleChip("IN", { checked: true, icon: "\u2190", tooltip: "Show incoming messages" });
    inToggle.input.addEventListener("change", () => {
      showIn = inToggle.input.checked;
      repaint(true);
    });
    const outToggle = ui.toggleChip("OUT", { checked: true, icon: "\u2192", tooltip: "Show outgoing messages" });
    outToggle.input.addEventListener("change", () => {
      showOut = outToggle.input.checked;
      repaint(true);
    });
    const currentToggle = ui.toggleChip("Active socket", { checked: false, icon: "\u{1F3AF}", tooltip: "Limit to the selected socket" });
    currentToggle.input.addEventListener("change", () => {
      onlyCurrentSocket = currentToggle.input.checked;
      repaint(true);
    });
    const autoScrollToggle = ui.toggleChip("Auto-scroll", { checked: true, icon: "\u{1F4DC}", tooltip: "Keep the log aligned with the latest frames" });
    autoScrollToggle.input.addEventListener("change", () => {
      autoScroll = autoScrollToggle.input.checked;
    });
    filterToolbar.append(inputFilter, inToggle.root, outToggle.root, currentToggle.root, autoScrollToggle.root);
    const muteRow = ui.flexRow({ gap: 10, wrap: true, fullWidth: true });
    const muteInput = ui.inputText("add regex (e.g. ping|keepalive)", "");
    muteInput.classList.add("dd-grow");
    const btnAddMute = ui.btn("Add", {
      icon: "\u2795",
      onClick: () => {
        const raw = muteInput.value.trim();
        if (!raw) return;
        try {
          mutePatterns.push(new RegExp(raw, "i"));
          muteInput.value = "";
          repaintMutes();
          repaint(true);
        } catch {
        }
      }
    });
    muteRow.append(muteInput, btnAddMute);
    muteCard.body.appendChild(muteRow);
    const mutesWrap = document.createElement("div");
    mutesWrap.className = "dd-mute-chips";
    muteCard.body.appendChild(mutesWrap);
    function repaintMutes() {
      mutesWrap.innerHTML = "";
      mutePatterns.forEach((rx, i) => {
        const chip = ui.btn(`/${rx.source}/i \xD7`, {
          variant: "ghost",
          size: "sm",
          onClick: () => {
            mutePatterns.splice(i, 1);
            repaintMutes();
            repaint(true);
          }
        });
        mutesWrap.appendChild(chip);
      });
    }
    const logWrap = document.createElement("div");
    logWrap.className = "dd-log";
    logWrap.style.fontFamily = "ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    logWrap.style.fontSize = "12px";
    logWrap.style.lineHeight = "1.4";
    logWrap.style.userSelect = "text";
    const emptyState = document.createElement("div");
    emptyState.className = "dd-log__empty";
    emptyState.textContent = "No frames visible yet.";
    logWrap.appendChild(emptyState);
    logCard.body.appendChild(logWrap);
    const ta = document.createElement("textarea");
    ta.className = "qmm-input dd-textarea";
    ta.placeholder = `Select a frame or paste a payload here. Choose Text or JSON below.`;
    const sendControls = document.createElement("div");
    sendControls.className = "dd-send-controls";
    const asJson = ui.radioGroup(
      "ws-send-mode",
      [{ value: "text", label: "Text" }, { value: "json", label: "JSON" }],
      "text",
      () => {
      }
    );
    const replayToggle = ui.toggleChip("Use source WS", { checked: false, icon: "\u21A9" });
    replayToggle.input.addEventListener("change", () => {
      replayToSource = replayToggle.input.checked;
    });
    const btnSend = ui.btn("Send", { variant: "primary", icon: "\u{1F4E8}", onClick: () => doSend() });
    const btnCopyPayload = ui.btn("Copy payload", { variant: "ghost", icon: "\u{1F4CB}", onClick: () => copy(ta.value) });
    sendControls.append(asJson, replayToggle.root, btnSend, btnCopyPayload);
    sendCard.body.append(ta, sendControls);
    function refreshSocketPicker() {
      const wsArr = getWSInfos();
      sel.innerHTML = "";
      wsArr.forEach((info, idx) => {
        const op = document.createElement("option");
        op.value = String(idx);
        op.textContent = info.id + (info.ws === quinoaWS ? " \u2022 page" : "");
        sel.appendChild(op);
      });
      if (!sel.value && sel.options.length) sel.value = "0";
      updateStatus();
    }
    function currentWS() {
      const idx = Number(sel.value);
      const vals = getWSInfos();
      return Number.isFinite(idx) ? vals[idx]?.ws ?? null : null;
    }
    function updateStatus() {
      const text = getWSStatusText();
      lblConn.textContent = text;
      const low = text.toLowerCase();
      lblConn.classList.toggle("is-ok", /open|connected|ready/.test(low));
      lblConn.classList.toggle("is-warn", /closing|connecting|pending/.test(low));
    }
    function updateEmptyState() {
      const hasRows = logWrap.querySelector(".ws-row") != null;
      emptyState.style.display = hasRows ? "none" : "";
    }
    function passesFilters(f) {
      if (f.dir === "in" && !showIn || f.dir === "out" && !showOut) return false;
      if (filterText && !f.text.toLowerCase().includes(filterText)) return false;
      if (onlyCurrentSocket && f.ws && currentWS() && f.ws !== currentWS()) return false;
      if (matchesMutes(f.text)) return false;
      return true;
    }
    function rowActions(fid, f) {
      const acts = document.createElement("div");
      acts.className = "acts";
      const bCopy = document.createElement("button");
      bCopy.className = "qmm-btn";
      bCopy.textContent = "Copy";
      bCopy.onclick = (e) => {
        e.stopPropagation();
        copy(f.text);
      };
      const bToEd = document.createElement("button");
      bToEd.className = "qmm-btn";
      bToEd.textContent = "\u2192 Editor";
      bToEd.onclick = (e) => {
        e.stopPropagation();
        ta.value = f.text;
        setSelectedRow(fid);
      };
      const bReplay = document.createElement("button");
      bReplay.className = "qmm-btn";
      bReplay.textContent = "Replay";
      bReplay.title = "Send right away (to current WS or source WS if enabled)";
      bReplay.onclick = (e) => {
        e.stopPropagation();
        replayFrame(f);
      };
      acts.append(bCopy, bToEd, bReplay);
      return acts;
    }
    function buildRow(f) {
      const row = document.createElement("div");
      row.className = "ws-row";
      row.dataset.fid = String(f.id);
      const ts = document.createElement("div");
      ts.className = "ts";
      ts.textContent = fmtTime(f.t);
      const arrow = document.createElement("div");
      arrow.className = "arrow";
      arrow.textContent = f.dir === "in" ? "\u2190" : "\u2192";
      arrow.style.color = f.dir === "in" ? "#4bd17a" : "#8ab4ff";
      const body = document.createElement("div");
      body.className = "body";
      body.innerHTML = `<code>${escapeLite(f.text)}</code>`;
      const acts = rowActions(f.id, f);
      row.append(ts, arrow, body, acts);
      row.onclick = () => setSelectedRow(f.id);
      row.ondblclick = () => {
        ta.value = f.text;
        setSelectedRow(f.id);
      };
      return row;
    }
    function appendOne(f) {
      if (!passesFilters(f)) return;
      const row = buildRow(f);
      logWrap.appendChild(row);
      updateEmptyState();
      if (autoScroll) logWrap.scrollTop = logWrap.scrollHeight;
    }
    function repaint(_full = false) {
      logWrap.querySelectorAll(".ws-row").forEach((n) => n.remove());
      frames.toArray().forEach((f) => {
        if (passesFilters(f)) logWrap.appendChild(buildRow(f));
      });
      updateEmptyState();
      if (selectedId != null) setSelectedRow(selectedId);
      if (autoScroll) logWrap.scrollTop = logWrap.scrollHeight;
    }
    function copyVisible() {
      const lines = frames.toArray().filter((f) => passesFilters(f)).map((f) => `[${fmtTime(f.t)}] ${f.dir === "in" ? "<-" : "->"} ${f.text}`).join("\n");
      copy(lines);
    }
    function replayFrame(f) {
      const target = replayToSource && f.ws ? f.ws : currentWS();
      if (!target || target.readyState !== WebSocket.OPEN) return;
      const mode = asJson.querySelector('input[type="radio"]:checked')?.value || "text";
      if (mode === "json") {
        try {
          target.send(JSON.parse(f.text));
        } catch {
          target.send(f.text);
        }
      } else {
        target.send(f.text);
      }
    }
    function doSend() {
      const ws = currentWS();
      const wsAlt = selectedId != null && replayToSource ? framesMap.get(selectedId)?.ws ?? null : null;
      const target = (replayToSource ? wsAlt : ws) || ws;
      if (!target || target.readyState !== WebSocket.OPEN) return;
      const mode = asJson.querySelector('input[type="radio"]:checked')?.value || "text";
      if (mode === "json") {
        try {
          target.send(JSON.parse(ta.value));
        } catch {
          target.send(ta.value);
        }
      } else {
        target.send(ta.value);
      }
    }
    installWSHookIfNeeded((f) => {
      if (paused) return;
      const ex = { ...f, id: ++seq };
      frames.push(ex);
      framesMap.set(ex.id, ex);
      updateStatus();
      appendOne(ex);
    });
    refreshSocketPicker();
    repaint(true);
    const pollId = window.setInterval(() => {
      refreshSocketPicker();
    }, 1e3);
    view.__ws_cleanup__ = () => {
      window.clearInterval(pollId);
    };
  }
  function copy(text) {
    const str = String(text ?? "");
    if (!str.length) return;
    const fallback = () => {
      const ta = document.createElement("textarea");
      ta.value = str;
      ta.setAttribute("readonly", "true");
      ta.style.position = "fixed";
      ta.style.left = "-9999px";
      ta.style.opacity = "0";
      document.body.appendChild(ta);
      ta.focus();
      ta.select();
      let ok = false;
      try {
        ok = document.execCommand("copy");
      } catch {
      }
      document.body.removeChild(ta);
      try {
        window.toastSimple?.(ok ? "Copied" : "Copy failed", "", ok ? "success" : "error");
      } catch {
      }
    };
    if (window.isSecureContext && navigator.clipboard?.writeText) {
      navigator.clipboard.writeText(str).then(() => {
        try {
          window.toastSimple?.("Copied", "", "success");
        } catch {
        }
      }).catch(fallback);
    } else {
      fallback();
    }
  }
  function safeRegex(q) {
    try {
      return new RegExp(q, "i");
    } catch {
      return /.*/i;
    }
  }
  function stylePre(pre) {
    pre.style.maxHeight = "260px";
    pre.style.overflow = "auto";
    pre.style.background = "#0b1016";
    pre.style.border = "1px solid #ffffff18";
    pre.style.borderRadius = "12px";
    pre.style.padding = "12px";
    pre.style.margin = "6px 0 0";
    pre.style.fontSize = "12px";
    pre.style.lineHeight = "1.5";
    pre.style.color = "#dbe4ff";
    pre.style.boxShadow = "inset 0 1px 0 rgba(255,255,255,.04)";
  }

  // src/ui/menus/locker.ts
  var NO_WEATHER_TAG = "NoWeatherEffect";
  var SEED_EMOJIS = [
    "\u{1F955}",
    "\u{1F353}",
    "\u{1F343}",
    "\u{1F535}",
    "\u{1F34E}",
    "\u{1F337}",
    "\u{1F345}",
    "\u{1F33C}",
    "\u{1F33D}",
    "\u{1F349}",
    "\u{1F383}",
    "\u{1F33F}",
    "\u{1F965}",
    "\u{1F34C}",
    "\u{1F338}",
    "\u{1F7E2}",
    "\u{1F344}",
    "\u{1F335}",
    "\u{1F38D}",
    "\u{1F347}",
    "\u{1F336}\uFE0F",
    "\u{1F34B}",
    "\u{1F96D}",
    "\u{1F409}",
    "\u{1F352}",
    "\u{1F33B}",
    "\u2728",
    "\u{1F506}",
    "\u{1F52E}"
  ];
  var lockerSeedOptions = Object.entries(
    plantCatalog
  ).map(([key2, def]) => ({
    key: key2,
    seedName: def?.seed?.name ?? "",
    cropName: def?.crop?.name ?? ""
  }));
  var lockerSeedEmojiByKey = /* @__PURE__ */ new Map();
  var lockerSeedEmojiBySeedName = /* @__PURE__ */ new Map();
  lockerSeedOptions.forEach((opt, index) => {
    const emoji = SEED_EMOJIS[index % SEED_EMOJIS.length];
    lockerSeedEmojiByKey.set(opt.key, emoji);
    if (opt.seedName) {
      lockerSeedEmojiBySeedName.set(opt.seedName, emoji);
    }
  });
  var getLockerSeedOptions = () => lockerSeedOptions;
  var getLockerSeedEmojiForKey = (key2) => {
    if (!key2) return void 0;
    return lockerSeedEmojiByKey.get(key2) ?? "\u2022";
  };
  var getLockerSeedEmojiForSeedName = (name) => {
    if (!name) return void 0;
    return lockerSeedEmojiBySeedName.get(name) ?? "\u2022";
  };
  function formatMutationLabel(key2) {
    const spaced = key2.replace(/_/g, " ").replace(/([a-z0-9])([A-Z])/g, "$1 $2").replace(/\s+/g, " ").trim();
    if (!spaced) return key2;
    return spaced.charAt(0).toUpperCase() + spaced.slice(1);
  }
  var WEATHER_MUTATION_LABELS = tileRefsMutationLabels ?? {};
  var WEATHER_MUTATIONS = Object.entries(
    tileRefsMutations
  ).filter((entry) => {
    const [key2, value] = entry;
    if (key2 === "Puddle") {
      return false;
    }
    return typeof value === "number" && Number.isFinite(value);
  }).map(([key2, value]) => ({
    key: key2,
    label: WEATHER_MUTATION_LABELS[key2] ?? formatMutationLabel(key2),
    tileRef: value
  }));
  var createNoWeatherIcon = (options) => {
    const size = Math.max(24, options?.size ?? 48);
    const wrap = applyStyles(document.createElement("div"), {
      width: `${size}px`,
      height: `${size}px`,
      display: "grid",
      placeItems: "center"
    });
    const glyph = applyStyles(document.createElement("span"), {
      color: "#ff5c5c",
      fontSize: `${Math.round(size * 0.65)}px`,
      fontWeight: "700",
      textShadow: "0 1px 2px rgba(0, 0, 0, 0.6)",
      lineHeight: "1"
    });
    glyph.textContent = "\u2716";
    wrap.appendChild(glyph);
    return wrap;
  };
  WEATHER_MUTATIONS.unshift({
    key: NO_WEATHER_TAG,
    label: "No weather effect",
    tileRef: null,
    iconFactory: createNoWeatherIcon
  });
  var isWeatherMutationAvailable = (tag) => WEATHER_MUTATIONS.some((info) => info.key === tag);
  var WEATHER_RECIPE_GROUPS = {
    Wet: "condition",
    Chilled: "condition",
    Frozen: "condition",
    Dawnlit: "lighting",
    Ambershine: "lighting",
    Dawncharged: "lighting",
    Ambercharged: "lighting"
  };
  var WEATHER_RECIPE_GROUP_MEMBERS = {
    condition: ["Wet", "Chilled", "Frozen"],
    lighting: ["Dawnlit", "Ambershine", "Dawncharged", "Ambercharged"]
  };
  function normalizeWeatherSelection(selection) {
    selection.forEach((tag) => {
      if (!isWeatherMutationAvailable(tag)) {
        selection.delete(tag);
      }
    });
  }
  function normalizeRecipeSelection(selection) {
    normalizeWeatherSelection(selection);
    const seen = /* @__PURE__ */ new Set();
    WEATHER_MUTATIONS.forEach((info) => {
      if (!selection.has(info.key)) return;
      const group = WEATHER_RECIPE_GROUPS[info.key];
      if (!group) return;
      if (seen.has(group)) {
        selection.delete(info.key);
      } else {
        seen.add(group);
      }
    });
  }
  var applyStyles = (el2, styles) => {
    Object.entries(styles).forEach(([prop, value]) => {
      el2.style[prop] = value;
    });
    return el2;
  };
  var plantSpriteCache = /* @__PURE__ */ new Map();
  var plantSpritePromises = /* @__PURE__ */ new Map();
  var plantSpriteSubscribers = /* @__PURE__ */ new Map();
  var spriteConfig3 = /* @__PURE__ */ new WeakMap();
  var plantSpriteListenerAttached = false;
  var lockerSpritesPreloaded = false;
  var lockerSpritePreloadTimer = null;
  var weatherModeNameSeq = 0;
  function hasLockerSpriteSources() {
    try {
      if (Sprites.listPlants().length || Sprites.listAllPlants().length) {
        return true;
      }
    } catch {
    }
    try {
      if (Sprites.listTilesByCategory(/mutations/i).length) {
        return true;
      }
    } catch {
    }
    return false;
  }
  function scheduleLockerSpritePreload(delay4 = 0) {
    if (lockerSpritesPreloaded || typeof window === "undefined") {
      return;
    }
    if (lockerSpritePreloadTimer != null) {
      window.clearTimeout(lockerSpritePreloadTimer);
    }
    lockerSpritePreloadTimer = window.setTimeout(() => {
      lockerSpritePreloadTimer = null;
      preloadLockerSprites();
    }, Math.max(0, delay4));
  }
  function ensurePlantSpriteListener() {
    if (plantSpriteListenerAttached) return;
    plantSpriteListenerAttached = true;
    window.addEventListener("mg:sprite-detected", () => {
      plantSpriteCache.clear();
      plantSpritePromises.clear();
      const keys = Array.from(plantSpriteSubscribers.keys());
      keys.forEach((key2) => {
        loadPlantSprite(key2);
      });
    });
  }
  function subscribePlantSprite(seedKey, el2, config) {
    let subs = plantSpriteSubscribers.get(seedKey);
    if (!subs) {
      subs = /* @__PURE__ */ new Set();
      plantSpriteSubscribers.set(seedKey, subs);
    }
    subs.add(el2);
    spriteConfig3.set(el2, config);
  }
  function notifyPlantSpriteSubscribers(seedKey, src) {
    const subs = plantSpriteSubscribers.get(seedKey);
    if (!subs) return;
    subs.forEach((el2) => {
      if (!el2.isConnected) {
        subs.delete(el2);
        spriteConfig3.delete(el2);
        return;
      }
      applySprite3(el2, src);
    });
    if (subs.size === 0) {
      plantSpriteSubscribers.delete(seedKey);
    }
  }
  var TALL_PLANT_SEEDS = /* @__PURE__ */ new Set(["Bamboo", "Cactus"]);
  function plantSheetBases(seedKey) {
    const urls = /* @__PURE__ */ new Set();
    try {
      Sprites.listPlants().forEach((url) => urls.add(url));
    } catch {
    }
    try {
      Sprites.listAllPlants().forEach((url) => urls.add(url));
    } catch {
    }
    const bases = Array.from(urls, (url) => {
      const clean = url.split(/[?#]/)[0] ?? url;
      const file = clean.split("/").pop() ?? clean;
      return file.replace(/\.[^.]+$/, "");
    });
    if (!seedKey) return bases;
    const normalizedBases = bases.map((base) => base.toLowerCase());
    const findPreferred = (predicate) => bases.filter((base, index) => predicate(base, normalizedBases[index] ?? base.toLowerCase()));
    if (TALL_PLANT_SEEDS.has(seedKey)) {
      const tallExact = findPreferred((_, norm3) => norm3 === "tallplants");
      if (tallExact.length) return tallExact;
      const tallAny = findPreferred((base, norm3) => /tall/.test(base) || /tall/.test(norm3));
      if (tallAny.length) return tallAny;
    } else {
      const plantsExact = findPreferred((_, norm3) => norm3 === "plants");
      if (plantsExact.length) return plantsExact;
      const nonTall = findPreferred((base, norm3) => !/tall/.test(base) && !/tall/.test(norm3));
      if (nonTall.length) return nonTall;
    }
    return bases;
  }
  function toTileIndex3(tileRef, bases = []) {
    const value = typeof tileRef === "number" && Number.isFinite(tileRef) ? tileRef : Number(tileRef);
    if (!Number.isFinite(value)) return null;
    if (value <= 0) return value;
    const normalizedBases = bases.map((base) => base.toLowerCase());
    if (normalizedBases.some((base) => base.includes("tall"))) {
      return value - 1;
    }
    if (normalizedBases.some((base) => base.includes("plants"))) {
      return value - 1;
    }
    return value - 1;
  }
  async function fetchPlantSprite(seedKey) {
    const entry = plantCatalog[seedKey];
    if (!entry) return null;
    const tileRef = entry?.crop?.tileRef ?? entry?.plant?.tileRef ?? entry?.seed?.tileRef;
    const bases = plantSheetBases(seedKey);
    const index = toTileIndex3(tileRef, bases);
    if (index == null) return null;
    for (const base of bases) {
      try {
        const tile = await Sprites.getTile(base, index, "canvas");
        const canvas = tile?.data;
        if (canvas && canvas.width > 0 && canvas.height > 0) {
          const copy2 = document.createElement("canvas");
          copy2.width = canvas.width;
          copy2.height = canvas.height;
          const ctx = copy2.getContext("2d");
          if (!ctx) continue;
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(canvas, 0, 0);
          return copy2.toDataURL();
        }
      } catch {
      }
    }
    return null;
  }
  function applySprite3(el2, src) {
    const cfg = spriteConfig3.get(el2);
    if (!cfg) return;
    const { size, fallback } = cfg;
    el2.innerHTML = "";
    el2.style.display = "inline-flex";
    el2.style.alignItems = "center";
    el2.style.justifyContent = "center";
    el2.style.width = `${size}px`;
    el2.style.height = `${size}px`;
    el2.style.flexShrink = "0";
    el2.style.position = "relative";
    if (src) {
      const img = document.createElement("img");
      img.src = src;
      img.alt = "";
      img.decoding = "async";
      img.loading = "lazy";
      img.draggable = false;
      img.style.width = "100%";
      img.style.height = "100%";
      img.style.objectFit = "contain";
      img.style.imageRendering = "pixelated";
      el2.appendChild(img);
    } else {
      el2.textContent = fallback;
      el2.style.fontSize = `${Math.max(10, Math.round(size * 0.8))}px`;
    }
  }
  function loadPlantSprite(seedKey) {
    const cached = plantSpriteCache.get(seedKey);
    if (cached !== void 0) {
      notifyPlantSpriteSubscribers(seedKey, cached);
      return Promise.resolve(cached);
    }
    const inflight = plantSpritePromises.get(seedKey);
    if (inflight) return inflight;
    const promise = fetchPlantSprite(seedKey).then((src) => {
      plantSpriteCache.set(seedKey, src);
      plantSpritePromises.delete(seedKey);
      notifyPlantSpriteSubscribers(seedKey, src);
      return src;
    }).catch(() => {
      plantSpritePromises.delete(seedKey);
      return null;
    });
    plantSpritePromises.set(seedKey, promise);
    return promise;
  }
  function createPlantSprite(seedKey, options = {}) {
    ensurePlantSpriteListener();
    const size = Math.max(12, options.size ?? 24);
    const fallback = options.fallback ?? "\u{1F331}";
    const el2 = document.createElement("span");
    subscribePlantSprite(seedKey, el2, { size, fallback });
    const cached = plantSpriteCache.get(seedKey);
    applySprite3(el2, cached ?? null);
    loadPlantSprite(seedKey);
    return el2;
  }
  var mutationSpriteCache = /* @__PURE__ */ new Map();
  var mutationSpritePromises = /* @__PURE__ */ new Map();
  var mutationSpriteSubscribers = /* @__PURE__ */ new Map();
  var mutationSpriteListenerAttached = false;
  var mutationSpriteBases = null;
  function ensureMutationSpriteListener() {
    if (mutationSpriteListenerAttached) return;
    mutationSpriteListenerAttached = true;
    window.addEventListener("mg:sprite-detected", () => {
      mutationSpriteCache.clear();
      mutationSpritePromises.clear();
      mutationSpriteBases = null;
      const keys = Array.from(mutationSpriteSubscribers.keys());
      keys.forEach((key2) => {
        loadMutationSprite(key2);
      });
    });
  }
  function mutationSheetBases() {
    if (mutationSpriteBases) return mutationSpriteBases;
    const urls = /* @__PURE__ */ new Set();
    try {
      Sprites.listTilesByCategory(/mutations/i).forEach((url) => urls.add(url));
    } catch {
    }
    const bases = Array.from(urls, (url) => {
      const clean = url.split(/[?#]/)[0] ?? url;
      const file = clean.split("/").pop() ?? clean;
      return file.replace(/\.[^.]+$/, "");
    });
    if (!bases.length) {
      bases.push("mutations");
    }
    mutationSpriteBases = bases;
    return mutationSpriteBases;
  }
  function subscribeMutationSprite(tag, el2, config) {
    let subs = mutationSpriteSubscribers.get(tag);
    if (!subs) {
      subs = /* @__PURE__ */ new Set();
      mutationSpriteSubscribers.set(tag, subs);
    }
    subs.add(el2);
    spriteConfig3.set(el2, config);
  }
  function notifyMutationSpriteSubscribers(tag, src) {
    const subs = mutationSpriteSubscribers.get(tag);
    if (!subs) return;
    subs.forEach((el2) => {
      if (!el2.isConnected) {
        subs.delete(el2);
        spriteConfig3.delete(el2);
        return;
      }
      applySprite3(el2, src);
    });
    if (subs.size === 0) {
      mutationSpriteSubscribers.delete(tag);
    }
  }
  async function fetchMutationSprite(tag) {
    const entry = WEATHER_MUTATIONS.find((info) => info.key === tag);
    if (!entry || entry.tileRef == null) return null;
    const [base] = mutationSheetBases();
    const index = toTileIndex3(entry.tileRef, base ? [base] : []);
    if (index == null || !base) return null;
    try {
      const tile = await Sprites.getTile(base, index, "canvas");
      const canvas = tile?.data;
      if (canvas && canvas.width > 0 && canvas.height > 0) {
        const copy2 = document.createElement("canvas");
        copy2.width = canvas.width;
        copy2.height = canvas.height;
        const ctx = copy2.getContext("2d");
        if (!ctx) return null;
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(canvas, 0, 0);
        return copy2.toDataURL();
      }
    } catch {
    }
    return null;
  }
  function loadMutationSprite(tag) {
    const cached = mutationSpriteCache.get(tag);
    if (cached !== void 0) {
      notifyMutationSpriteSubscribers(tag, cached);
      return Promise.resolve(cached);
    }
    const inflight = mutationSpritePromises.get(tag);
    if (inflight) return inflight;
    const promise = fetchMutationSprite(tag).then((src) => {
      mutationSpriteCache.set(tag, src);
      mutationSpritePromises.delete(tag);
      notifyMutationSpriteSubscribers(tag, src);
      return src;
    }).catch(() => {
      mutationSpritePromises.delete(tag);
      return null;
    });
    mutationSpritePromises.set(tag, promise);
    return promise;
  }
  function createMutationSprite(tag, options = {}) {
    ensureMutationSpriteListener();
    const size = Math.max(12, options.size ?? 36);
    const fallback = options.fallback ?? "?";
    const el2 = document.createElement("span");
    subscribeMutationSprite(tag, el2, { size, fallback });
    const cached = mutationSpriteCache.get(tag);
    applySprite3(el2, cached ?? null);
    loadMutationSprite(tag);
    return el2;
  }
  function preloadLockerSprites() {
    if (lockerSpritesPreloaded || typeof window === "undefined") {
      return;
    }
    if (!hasLockerSpriteSources()) {
      scheduleLockerSpritePreload(200);
      return;
    }
    lockerSpritesPreloaded = true;
    ensurePlantSpriteListener();
    ensureMutationSpriteListener();
    try {
      const catalog = plantCatalog;
      Object.keys(catalog).forEach((seedKey) => {
        if (seedKey) {
          loadPlantSprite(seedKey);
        }
      });
    } catch {
    }
    WEATHER_MUTATIONS.forEach((info) => {
      if (info.tileRef != null) {
        loadMutationSprite(info.key);
      }
    });
  }
  if (typeof window !== "undefined") {
    scheduleLockerSpritePreload();
    window.addEventListener("mg:sprite-detected", () => {
      if (!lockerSpritesPreloaded) {
        scheduleLockerSpritePreload(100);
      }
    });
  }
  function createDefaultSettings() {
    return {
      minScalePct: 50,
      maxScalePct: 100,
      scaleLockMode: "RANGE",
      minInventory: 91,
      avoidNormal: false,
      visualMutations: /* @__PURE__ */ new Set(),
      weatherMode: "ANY",
      weatherSelected: /* @__PURE__ */ new Set(),
      weatherRecipes: []
    };
  }
  function copySettings(target, source) {
    target.minScalePct = source.minScalePct;
    target.maxScalePct = source.maxScalePct;
    target.scaleLockMode = source.scaleLockMode;
    target.minInventory = source.minInventory;
    target.avoidNormal = source.avoidNormal;
    target.visualMutations.clear();
    source.visualMutations.forEach((v) => target.visualMutations.add(v));
    target.weatherMode = source.weatherMode;
    target.weatherSelected.clear();
    source.weatherSelected.forEach((v) => target.weatherSelected.add(v));
    target.weatherRecipes.length = 0;
    source.weatherRecipes.forEach((set2) => target.weatherRecipes.push(new Set(set2)));
  }
  function hydrateSettingsFromPersisted(target, persisted) {
    const src = persisted ?? {};
    const mode = src.scaleLockMode === "MINIMUM" ? "MINIMUM" : src.scaleLockMode === "NONE" ? "NONE" : "RANGE";
    const minClampHigh = mode === "MINIMUM" ? 100 : 99;
    let minScale = Math.max(50, Math.min(minClampHigh, Math.round(src.minScalePct ?? 50)));
    let maxScale = Math.max(50, Math.min(100, Math.round(src.maxScalePct ?? 100)));
    if (mode === "RANGE" || mode === "NONE") {
      maxScale = Math.max(51, Math.min(100, maxScale));
      if (maxScale <= minScale) {
        if (minScale >= 99) {
          minScale = 99;
          maxScale = 100;
        } else {
          maxScale = Math.min(100, Math.max(51, minScale + 1));
        }
      }
    }
    target.minScalePct = minScale;
    target.maxScalePct = maxScale;
    target.scaleLockMode = mode;
    target.minInventory = Math.max(0, Math.min(999, Math.round(src.minInventory ?? 91)));
    target.avoidNormal = src.avoidNormal === true || src.includeNormal === false;
    target.visualMutations.clear();
    (src.visualMutations ?? []).forEach((mut) => {
      if (mut === "Gold" || mut === "Rainbow") target.visualMutations.add(mut);
    });
    target.weatherMode = src.weatherMode === "ALL" || src.weatherMode === "RECIPES" ? src.weatherMode : "ANY";
    target.weatherSelected.clear();
    (src.weatherSelected ?? []).forEach((tag) => {
      const weatherTag = tag;
      if (isWeatherMutationAvailable(weatherTag)) {
        target.weatherSelected.add(weatherTag);
      }
    });
    target.weatherRecipes.length = 0;
    (src.weatherRecipes ?? []).forEach((recipe) => {
      const set2 = /* @__PURE__ */ new Set();
      if (Array.isArray(recipe)) {
        recipe.forEach((tag) => {
          const weatherTag = tag;
          if (isWeatherMutationAvailable(weatherTag)) {
            set2.add(weatherTag);
          }
        });
      }
      target.weatherRecipes.push(set2);
    });
  }
  function serializeSettingsState(state2) {
    normalizeWeatherSelection(state2.weatherSelected);
    state2.weatherRecipes.forEach((set2) => normalizeRecipeSelection(set2));
    const mode = state2.scaleLockMode === "MINIMUM" ? "MINIMUM" : state2.scaleLockMode === "NONE" ? "NONE" : "RANGE";
    const minClampHigh = mode === "MINIMUM" ? 100 : 99;
    let minScale = Math.max(50, Math.min(minClampHigh, Math.round(state2.minScalePct || 50)));
    let maxScale = Math.max(50, Math.min(100, Math.round(state2.maxScalePct || 100)));
    if (mode === "RANGE" || mode === "NONE") {
      maxScale = Math.max(51, Math.min(100, maxScale));
      if (maxScale <= minScale) {
        if (minScale >= 99) {
          minScale = 99;
          maxScale = 100;
        } else {
          maxScale = Math.min(100, Math.max(51, minScale + 1));
        }
      }
    }
    return {
      minScalePct: minScale,
      maxScalePct: maxScale,
      scaleLockMode: mode,
      minInventory: Math.max(0, Math.min(999, Math.round(state2.minInventory || 91))),
      avoidNormal: !!state2.avoidNormal,
      includeNormal: !state2.avoidNormal,
      visualMutations: Array.from(state2.visualMutations),
      weatherMode: state2.weatherMode,
      weatherSelected: Array.from(state2.weatherSelected),
      weatherRecipes: state2.weatherRecipes.map((set2) => Array.from(set2))
    };
  }
  var LockerMenuStore = class {
    constructor(initial) {
      __publicField(this, "global");
      __publicField(this, "overrides", /* @__PURE__ */ new Map());
      __publicField(this, "listeners", /* @__PURE__ */ new Set());
      __publicField(this, "syncing", false);
      this.global = { enabled: false, settings: createDefaultSettings(), hasPersistedSettings: true };
      this.syncFromService(initial);
    }
    applyPersisted(state2) {
      this.global.enabled = !!state2.enabled;
      hydrateSettingsFromPersisted(this.global.settings, state2.settings);
      this.global.hasPersistedSettings = true;
      const seen = /* @__PURE__ */ new Set();
      Object.entries(state2.overrides ?? {}).forEach(([key2, value]) => {
        const entry = this.ensureOverride(key2, { silent: true });
        entry.enabled = !!value?.enabled;
        hydrateSettingsFromPersisted(entry.settings, value?.settings);
        entry.hasPersistedSettings = true;
        seen.add(key2);
      });
      for (const key2 of Array.from(this.overrides.keys())) {
        if (!seen.has(key2)) {
          this.overrides.delete(key2);
        }
      }
    }
    subscribe(listener) {
      this.listeners.add(listener);
      return () => this.listeners.delete(listener);
    }
    emit() {
      for (const listener of this.listeners) {
        try {
          listener();
        } catch {
        }
      }
    }
    syncFromService(state2) {
      this.syncing = true;
      this.applyPersisted(state2);
      this.emit();
      this.syncing = false;
    }
    setGlobalEnabled(enabled) {
      this.global.enabled = !!enabled;
      this.persistGlobal();
      this.emit();
    }
    notifyGlobalSettingsChanged() {
      this.persistGlobal();
      this.emit();
    }
    ensureOverride(key2, opts = {}) {
      let entry = this.overrides.get(key2);
      if (!entry) {
        entry = { enabled: false, settings: createDefaultSettings(), hasPersistedSettings: false };
        this.overrides.set(key2, entry);
        if (!opts.silent) {
          this.emit();
        }
      }
      return entry;
    }
    getOverride(key2) {
      return this.overrides.get(key2);
    }
    setOverrideEnabled(key2, enabled) {
      const entry = this.ensureOverride(key2, { silent: true });
      entry.enabled = !!enabled;
      this.persistOverride(key2);
      this.emit();
    }
    notifyOverrideSettingsChanged(key2) {
      const entry = this.overrides.get(key2);
      if (!entry) return;
      entry.hasPersistedSettings = true;
      this.persistOverride(key2);
      this.emit();
    }
    removeOverride(key2) {
      if (!this.overrides.has(key2)) return;
      this.overrides.delete(key2);
      if (!this.syncing) {
        lockerService.removeOverride(key2);
        lockerService.recomputeCurrentSlot();
      }
      this.emit();
    }
    persistGlobal() {
      if (this.syncing) return;
      lockerService.setGlobalState({
        enabled: this.global.enabled,
        settings: serializeSettingsState(this.global.settings)
      });
      lockerService.recomputeCurrentSlot();
    }
    persistOverride(key2) {
      if (this.syncing) return;
      const entry = this.overrides.get(key2);
      if (!entry) {
        lockerService.removeOverride(key2);
      } else {
        lockerService.setOverride(key2, {
          enabled: entry.enabled,
          settings: serializeSettingsState(entry.settings)
        });
        entry.hasPersistedSettings = true;
      }
      lockerService.recomputeCurrentSlot();
    }
  };
  function setCheck(input, value) {
    input.checked = !!value;
  }
  function createWeatherMutationToggle({
    key: key2,
    label: label2,
    spriteSize,
    dense,
    kind = "main",
    iconFactory
  }) {
    const isMain = kind === "main" && !dense;
    const gap = dense ? "3px" : isMain ? "3px" : "6px";
    const padding = dense ? "4px 6px" : isMain ? "6px 8px" : "10px 12px";
    const minWidth = dense ? "80px" : isMain ? "88px" : "120px";
    const wrapStyles = {
      position: "relative",
      display: "grid",
      justifyItems: "center",
      alignItems: "center",
      gap,
      padding,
      border: "1px solid #4445",
      borderRadius: "10px",
      background: "#0f1318",
      cursor: "pointer",
      minWidth,
      transition: "border-color 120ms ease, box-shadow 120ms ease, background 120ms ease",
      boxShadow: "0 0 0 1px #0002 inset"
    };
    if (isMain) {
      wrapStyles.width = "100%";
    }
    const wrap = applyStyles(document.createElement("label"), wrapStyles);
    wrap.title = "Active filters influence harvest conditions";
    const input = document.createElement("input");
    input.type = "checkbox";
    applyStyles(input, {
      position: "absolute",
      inset: "0",
      opacity: "0",
      pointerEvents: "none",
      margin: "0"
    });
    input.dataset.weatherToggle = kind;
    wrap.appendChild(input);
    wrap.dataset.weatherToggle = kind;
    const iconSize = Math.max(24, spriteSize ?? (dense ? 36 : isMain ? 52 : 72));
    const icon = iconFactory ? iconFactory({ size: iconSize, fallback: label2.charAt(0) || "?" }) : createMutationSprite(key2, {
      size: iconSize,
      fallback: label2.charAt(0) || "?"
    });
    applyStyles(icon, {
      filter: "drop-shadow(0 1px 1px rgba(0, 0, 0, 0.45))"
    });
    wrap.appendChild(icon);
    const caption = applyStyles(document.createElement("div"), {
      fontSize: dense ? "11px" : "11.5px",
      fontWeight: dense ? "500" : "600",
      opacity: "0.85",
      textAlign: "center"
    });
    caption.textContent = label2;
    wrap.appendChild(caption);
    const applyDisabledState = () => {
      if (input.disabled) {
        wrap.style.cursor = "default";
        wrap.style.opacity = "0.55";
        wrap.style.pointerEvents = "none";
      } else {
        wrap.style.cursor = "pointer";
        wrap.style.opacity = "";
        wrap.style.pointerEvents = "";
      }
    };
    const updateState = () => {
      if (input.checked) {
        applyStyles(wrap, {
          borderColor: "#6aa6",
          boxShadow: "0 0 0 1px #6aa4 inset, 0 2px 6px rgba(0, 0, 0, 0.45)",
          background: "#182029"
        });
      } else {
        applyStyles(wrap, {
          borderColor: "#4445",
          boxShadow: "0 0 0 1px #0002 inset",
          background: "#0f1318"
        });
      }
      applyDisabledState();
    };
    const setChecked = (value) => {
      setCheck(input, value);
      updateState();
    };
    const setDisabled = (value) => {
      input.disabled = !!value;
      updateState();
    };
    input.addEventListener("change", updateState);
    input.addEventListener("mg-weather-toggle-refresh", updateState);
    updateState();
    return { key: key2, wrap, input, setChecked, setDisabled };
  }
  function styleBtnFullWidth(button, text) {
    button.textContent = text;
    button.style.flex = "1";
    button.style.margin = "0";
    button.style.padding = "6px 10px";
    button.style.borderRadius = "8px";
    button.style.border = "1px solid #4445";
    button.style.background = "#1f2328";
    button.style.color = "#e7eef7";
    button.style.justifyContent = "center";
    button.onmouseenter = () => button.style.borderColor = "#6aa1";
    button.onmouseleave = () => button.style.borderColor = "#4445";
  }
  function styleBtnCompact(button, text) {
    button.textContent = text;
    button.style.margin = "0";
    button.style.padding = "4px 8px";
    button.style.borderRadius = "8px";
    button.style.border = "1px solid #4445";
    button.style.background = "#1f2328";
    button.style.color = "#e7eef7";
    button.style.display = "inline-flex";
    button.style.alignItems = "center";
    button.style.justifyContent = "center";
    button.style.minWidth = "36px";
    button.onmouseenter = () => button.style.borderColor = "#6aa1";
    button.onmouseleave = () => button.style.borderColor = "#4445";
  }
  function createLockerSettingsCard(ui, state2, opts = {}) {
    const card = document.createElement("div");
    card.dataset.lockerSettingsCard = "1";
    card.style.border = "1px solid #4445";
    card.style.borderRadius = "10px";
    card.style.padding = "12px";
    card.style.display = "flex";
    card.style.flexDirection = "column";
    card.style.gap = "12px";
    card.style.alignItems = "center";
    card.style.overflow = "auto";
    card.style.minHeight = "0";
    card.style.width = "min(760px, 100%)";
    const makeSection = (titleText, content) => {
      const section = document.createElement("div");
      section.style.display = "grid";
      section.style.justifyItems = "center";
      section.style.gap = "8px";
      section.style.textAlign = "center";
      section.style.border = "1px solid #4446";
      section.style.borderRadius = "10px";
      section.style.padding = "10px";
      section.style.background = "#1f2328";
      section.style.boxShadow = "0 0 0 1px #0002 inset";
      section.style.width = "min(720px, 100%)";
      const heading = document.createElement("div");
      heading.textContent = titleText;
      heading.style.fontWeight = "600";
      heading.style.opacity = "0.95";
      section.append(heading, content);
      return section;
    };
    const centerRow = () => {
      const row = document.createElement("div");
      row.style.display = "flex";
      row.style.flexWrap = "wrap";
      row.style.justifyContent = "center";
      row.style.alignItems = "center";
      row.style.gap = "8px";
      return row;
    };
    const scaleRow = centerRow();
    scaleRow.style.flexDirection = "column";
    scaleRow.style.alignItems = "center";
    scaleRow.style.width = "100%";
    scaleRow.style.gap = "12px";
    const scaleModeRow = centerRow();
    scaleModeRow.style.flexWrap = "wrap";
    scaleModeRow.style.justifyContent = "center";
    scaleModeRow.style.gap = "12px";
    const toMode = (value) => {
      switch (value) {
        case "minimum":
          return "MINIMUM";
        case "ranged":
          return "RANGE";
        default:
          return "NONE";
      }
    };
    const fromMode = (mode) => {
      switch (mode) {
        case "MINIMUM":
          return "minimum";
        case "RANGE":
          return "ranged";
        default:
          return "none";
      }
    };
    let isProgrammaticScaleMode = false;
    const initialScaleMode = fromMode(state2.scaleLockMode);
    const scaleModeSegmented = ui.segmented(
      [
        { value: "none", label: "None" },
        { value: "minimum", label: "Minimum size" },
        { value: "ranged", label: "Range size" }
      ],
      initialScaleMode,
      (value) => {
        if (isProgrammaticScaleMode) return;
        applyScaleMode(toMode(value), true);
      },
      { ariaLabel: "Scale lock mode" }
    );
    scaleModeRow.append(scaleModeSegmented);
    const minSlider = ui.slider(50, 100, 1, state2.minScalePct);
    applyStyles(minSlider, {
      width: "min(420px, 100%)"
    });
    const scaleSlider = ui.rangeDual(50, 100, 1, state2.minScalePct, state2.maxScalePct);
    applyStyles(scaleSlider.root, {
      width: "min(420px, 100%)",
      marginLeft: "auto",
      marginRight: "auto"
    });
    const scaleMinSlider = scaleSlider.min;
    const scaleMaxSlider = scaleSlider.max;
    const scaleMinimumValue = ui.label("50%");
    const scaleMinValue = ui.label("50%");
    const scaleMaxValue = ui.label("100%");
    [scaleMinimumValue, scaleMinValue, scaleMaxValue].forEach((label2) => {
      label2.style.margin = "0";
      label2.style.fontWeight = "600";
    });
    const makeScaleValue = (labelText, valueLabel) => {
      const wrap = applyStyles(document.createElement("div"), {
        display: "flex",
        alignItems: "center",
        gap: "6px"
      });
      const label2 = ui.label(labelText);
      label2.style.margin = "0";
      label2.style.opacity = "0.9";
      wrap.append(label2, valueLabel);
      return wrap;
    };
    const scaleValues = applyStyles(document.createElement("div"), {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      width: "min(420px, 100%)",
      gap: "16px"
    });
    scaleValues.append(makeScaleValue("Min", scaleMinValue), makeScaleValue("Max", scaleMaxValue));
    const minimumValues = applyStyles(document.createElement("div"), {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      width: "min(420px, 100%)",
      gap: "16px"
    });
    minimumValues.append(makeScaleValue("Minimum", scaleMinimumValue));
    const minimumControls = applyStyles(document.createElement("div"), {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap: "12px",
      width: "100%"
    });
    minimumControls.append(minSlider, minimumValues);
    const rangeControls = applyStyles(document.createElement("div"), {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap: "12px",
      width: "100%"
    });
    rangeControls.append(scaleSlider.root, scaleValues);
    scaleRow.append(scaleModeRow, minimumControls, rangeControls);
    const applyScaleRange = (commit, notify = commit) => {
      let minValue = parseInt(scaleMinSlider.value, 10);
      let maxValue = parseInt(scaleMaxSlider.value, 10);
      if (!Number.isFinite(minValue)) minValue = state2.minScalePct;
      if (!Number.isFinite(maxValue)) maxValue = state2.maxScalePct;
      minValue = Math.max(50, Math.min(99, minValue));
      maxValue = Math.max(51, Math.min(100, maxValue));
      if (maxValue <= minValue) {
        if (minValue >= 99) {
          minValue = 99;
          maxValue = 100;
        } else {
          maxValue = Math.min(100, Math.max(51, minValue + 1));
        }
      }
      scaleSlider.setValues(minValue, maxValue);
      scaleMinValue.textContent = `${minValue}%`;
      scaleMaxValue.textContent = `${maxValue}%`;
      if (commit) {
        state2.minScalePct = minValue;
        state2.maxScalePct = maxValue;
        if (notify) opts.onChange?.();
      }
    };
    const applyScaleMinimum = (commit, notify = commit) => {
      let minValue = parseInt(minSlider.value, 10);
      if (!Number.isFinite(minValue)) minValue = state2.minScalePct;
      minValue = Math.max(50, Math.min(100, minValue));
      minSlider.value = String(minValue);
      scaleMinimumValue.textContent = `${minValue}%`;
      if (commit) {
        state2.minScalePct = minValue;
        if (notify) opts.onChange?.();
      }
    };
    const updateScaleModeUI = () => {
      const isMinimum = state2.scaleLockMode === "MINIMUM";
      const isRange = state2.scaleLockMode === "RANGE";
      minimumControls.style.display = isMinimum ? "" : "none";
      rangeControls.style.display = isRange ? "" : "none";
      const segValue = fromMode(state2.scaleLockMode);
      if (scaleModeSegmented.get?.() !== segValue) {
        isProgrammaticScaleMode = true;
        try {
          scaleModeSegmented.set?.(segValue);
        } finally {
          isProgrammaticScaleMode = false;
        }
      }
    };
    const applyScaleMode = (mode, notify) => {
      const prevMode = state2.scaleLockMode;
      state2.scaleLockMode = mode;
      if (mode === "MINIMUM") {
        minSlider.value = String(state2.minScalePct);
        applyScaleMinimum(prevMode !== mode, false);
      } else if (mode === "RANGE") {
        scaleSlider.setValues(state2.minScalePct, state2.maxScalePct);
        applyScaleRange(prevMode !== mode, false);
      } else {
        minSlider.value = String(state2.minScalePct);
        scaleSlider.setValues(state2.minScalePct, state2.maxScalePct);
      }
      updateScaleModeUI();
      if (notify && prevMode !== mode) {
        opts.onChange?.();
      }
    };
    minSlider.addEventListener("input", () => applyScaleMinimum(false));
    minSlider.addEventListener("change", () => applyScaleMinimum(true));
    scaleMinSlider.addEventListener("input", () => applyScaleRange(false));
    scaleMaxSlider.addEventListener("input", () => applyScaleRange(false));
    scaleMinSlider.addEventListener("change", () => applyScaleRange(true));
    scaleMaxSlider.addEventListener("change", () => applyScaleRange(true));
    applyScaleRange(false);
    applyScaleMinimum(false);
    applyScaleMode(state2.scaleLockMode, false);
    const colorsRow = centerRow();
    colorsRow.style.flexWrap = "wrap";
    colorsRow.style.gap = "8px";
    const createColorButton = (label2, gradient) => {
      const button = document.createElement("button");
      button.type = "button";
      button.title = "Active filters influence harvest conditions";
      applyStyles(button, {
        padding: "6px 12px",
        borderRadius: "8px",
        border: "1px solid #4445",
        background: "#1f2328",
        color: "#e7eef7",
        fontWeight: "600",
        letterSpacing: "0.3px",
        transition: "border-color 120ms ease, box-shadow 120ms ease, background 120ms ease, opacity 120ms ease",
        boxShadow: "0 0 0 1px #0002 inset",
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        gap: "6px",
        minWidth: "92px",
        cursor: "pointer"
      });
      const text = document.createElement("span");
      text.textContent = label2;
      if (gradient) {
        applyStyles(text, {
          backgroundImage: gradient,
          backgroundClip: "text",
          WebkitBackgroundClip: "text",
          color: "transparent",
          fontWeight: "700",
          textShadow: "0 0 6px rgba(0, 0, 0, 0.35)"
        });
      }
      button.appendChild(text);
      button.addEventListener("mouseenter", () => {
        if (button.disabled || button.dataset.active === "1") return;
        button.style.borderColor = "#6aa1";
      });
      button.addEventListener("mouseleave", () => {
        if (button.dataset.active === "1") return;
        button.style.borderColor = "#4445";
      });
      return button;
    };
    const btnNormal = createColorButton("Normal");
    const btnGold = createColorButton(
      "Gold",
      "linear-gradient(120deg, #f5d76e, #c9932b, #f9e9b6)"
    );
    const btnRainbow = createColorButton(
      "Rainbow",
      "linear-gradient(90deg, #ff6b6b, #f7d35c, #3fd3ff, #9b6bff, #ff6b6b)"
    );
    const updateColorButtonVisual = (button, active) => {
      button.dataset.active = active ? "1" : "0";
      button.style.borderColor = active ? "#6aa6" : "#4445";
      button.style.boxShadow = active ? "0 0 0 1px #6aa4 inset, 0 2px 6px rgba(0, 0, 0, 0.45)" : "0 0 0 1px #0002 inset";
      button.style.background = active ? "#182029" : "#1f2328";
      button.style.opacity = button.disabled ? "0.55" : "";
      button.style.cursor = button.disabled ? "default" : "pointer";
    };
    const updateColorButtons = () => {
      updateColorButtonVisual(btnNormal, state2.avoidNormal);
      updateColorButtonVisual(btnGold, state2.visualMutations.has("Gold"));
      updateColorButtonVisual(btnRainbow, state2.visualMutations.has("Rainbow"));
    };
    btnNormal.addEventListener("click", () => {
      state2.avoidNormal = !state2.avoidNormal;
      updateColorButtons();
      opts.onChange?.();
    });
    btnGold.addEventListener("click", () => {
      if (state2.visualMutations.has("Gold")) state2.visualMutations.delete("Gold");
      else state2.visualMutations.add("Gold");
      updateColorButtons();
      opts.onChange?.();
    });
    btnRainbow.addEventListener("click", () => {
      if (state2.visualMutations.has("Rainbow")) state2.visualMutations.delete("Rainbow");
      else state2.visualMutations.add("Rainbow");
      updateColorButtons();
      opts.onChange?.();
    });
    colorsRow.append(btnNormal, btnGold, btnRainbow);
    const weatherGrid = applyStyles(document.createElement("div"), {
      display: "grid",
      gridTemplateColumns: "repeat(4, minmax(0, 1fr))",
      columnGap: "6px",
      rowGap: "6px",
      justifyItems: "stretch",
      width: "min(640px, 100%)",
      marginInline: "auto"
    });
    const applyWeatherSelection = (selection) => (tag, checked) => {
      if (checked) {
        selection.add(tag);
      } else {
        selection.delete(tag);
      }
      opts.onChange?.();
    };
    const updateMainWeatherSelection = applyWeatherSelection(state2.weatherSelected);
    const weatherToggles = WEATHER_MUTATIONS.map((info) => {
      const toggle = createWeatherMutationToggle({
        key: info.key,
        label: info.label,
        kind: "main",
        iconFactory: info.iconFactory
      });
      toggle.input.addEventListener(
        "change",
        () => updateMainWeatherSelection(info.key, toggle.input.checked)
      );
      weatherGrid.appendChild(toggle.wrap);
      return toggle;
    });
    const updateWeatherMutationsDisabled = () => {
      const disabled = card.dataset.disabled === "1" || state2.weatherMode === "RECIPES";
      weatherGrid.style.opacity = disabled ? "0.55" : "";
      weatherGrid.style.pointerEvents = disabled ? "none" : "";
      weatherToggles.forEach((toggle) => toggle.setDisabled(disabled));
    };
    const weatherModeName = `locker-weather-mode-${++weatherModeNameSeq}`;
    const weatherModeRow = centerRow();
    const buildRadio = (value, label2) => {
      const wrap = document.createElement("label");
      wrap.style.display = "inline-flex";
      wrap.style.alignItems = "center";
      wrap.style.gap = "6px";
      const input = ui.radio(weatherModeName, value);
      const span = document.createElement("span");
      span.textContent = label2;
      wrap.append(input, span);
      input.addEventListener("change", () => {
        if (!input.checked) return;
        state2.weatherMode = value;
        recipesWrap.style.display = value === "RECIPES" ? "" : "none";
        updateWeatherMutationsDisabled();
        opts.onChange?.();
      });
      return { wrap, input };
    };
    const radioAny = buildRadio("ANY", "Any match (OR)");
    const radioAll = buildRadio("ALL", "All match (AND)");
    const radioRecipes = buildRadio("RECIPES", "Recipes (match rows)");
    weatherModeRow.append(radioAny.wrap, radioAll.wrap, radioRecipes.wrap);
    const recipesWrap = document.createElement("div");
    recipesWrap.style.display = "grid";
    recipesWrap.style.gap = "8px";
    recipesWrap.style.justifyItems = "center";
    recipesWrap.style.width = "min(720px, 100%)";
    const recipesHeader = centerRow();
    recipesHeader.style.width = "100%";
    recipesHeader.style.justifyContent = "space-between";
    const recipesTitle = document.createElement("div");
    recipesTitle.textContent = "Lock when any recipe row matches (OR between rows)";
    recipesTitle.style.fontWeight = "600";
    recipesTitle.style.opacity = "0.9";
    const btnAddRecipe = document.createElement("button");
    btnAddRecipe.style.maxWidth = "140px";
    styleBtnFullWidth(btnAddRecipe, "+ Recipe");
    recipesHeader.append(recipesTitle, btnAddRecipe);
    const recipesList = document.createElement("div");
    recipesList.style.display = "grid";
    recipesList.style.gap = "8px";
    recipesList.style.gridTemplateColumns = "repeat(auto-fit, minmax(320px, 1fr))";
    recipesList.style.justifyItems = "stretch";
    let editingRecipeIndex = null;
    let editingRecipeDraft = /* @__PURE__ */ new Set();
    const emptyRecipes = document.createElement("div");
    emptyRecipes.textContent = "No recipe rows yet.";
    emptyRecipes.style.fontSize = "12px";
    emptyRecipes.style.opacity = "0.7";
    emptyRecipes.style.textAlign = "center";
    const updateAddRecipeDisabled = () => {
      const editing = editingRecipeIndex !== null;
      const cardDisabled = card.dataset.disabled === "1";
      btnAddRecipe.disabled = editing || cardDisabled;
      btnAddRecipe.style.opacity = editing ? "0.7" : "";
      btnAddRecipe.style.pointerEvents = editing ? "none" : "";
    };
    const startEditingRecipe = (index, base) => {
      editingRecipeIndex = index;
      editingRecipeDraft = new Set(base ?? []);
      normalizeRecipeSelection(editingRecipeDraft);
      repaintRecipes();
    };
    const cancelEditingRecipe = () => {
      editingRecipeIndex = null;
      editingRecipeDraft = /* @__PURE__ */ new Set();
      repaintRecipes();
    };
    const commitEditingRecipe = () => {
      if (editingRecipeIndex === null) return;
      const draft = new Set(editingRecipeDraft);
      normalizeRecipeSelection(draft);
      if (editingRecipeIndex === state2.weatherRecipes.length) {
        state2.weatherRecipes.push(draft);
      } else if (editingRecipeIndex >= 0 && editingRecipeIndex < state2.weatherRecipes.length) {
        state2.weatherRecipes[editingRecipeIndex] = draft;
      }
      editingRecipeIndex = null;
      editingRecipeDraft = /* @__PURE__ */ new Set();
      repaintRecipes();
      opts.onChange?.();
    };
    const deleteRecipeAt = (index) => {
      if (index < 0) return;
      if (index < state2.weatherRecipes.length) {
        state2.weatherRecipes.splice(index, 1);
      }
      if (editingRecipeIndex !== null) {
        if (index === editingRecipeIndex) {
          editingRecipeIndex = null;
          editingRecipeDraft = /* @__PURE__ */ new Set();
        } else if (index < editingRecipeIndex) {
          editingRecipeIndex -= 1;
        }
      }
      repaintRecipes();
      opts.onChange?.();
    };
    const buildRecipeBadge = (info) => {
      const { key: tag, label: label2 } = info;
      const badge = document.createElement("div");
      applyStyles(badge, {
        display: "inline-flex",
        alignItems: "center",
        gap: "6px",
        padding: "4px 10px",
        borderRadius: "999px",
        border: "1px solid #4445",
        background: "#11161c",
        color: "#e7eef7",
        fontSize: "12px",
        fontWeight: "600",
        letterSpacing: "0.2px"
      });
      const sprite = info.iconFactory ? info.iconFactory({ size: 20, fallback: label2.charAt(0) || "?" }) : createMutationSprite(tag, {
        size: 20,
        fallback: label2.charAt(0) || "?"
      });
      applyStyles(sprite, {
        filter: "drop-shadow(0 1px 1px rgba(0, 0, 0, 0.45))"
      });
      const text = document.createElement("span");
      text.textContent = label2;
      badge.append(sprite, text);
      return badge;
    };
    const renderRecipeSummary = (container, selection) => {
      container.innerHTML = "";
      const badges = document.createElement("div");
      applyStyles(badges, {
        display: "flex",
        flexWrap: "wrap",
        gap: "6px",
        justifyContent: "flex-start"
      });
      let count = 0;
      WEATHER_MUTATIONS.forEach((info) => {
        if (!selection.has(info.key)) return;
        count += 1;
        badges.appendChild(buildRecipeBadge(info));
      });
      if (count === 0) {
        const empty = document.createElement("div");
        empty.textContent = "No weather mutation selected.";
        empty.style.fontSize = "12px";
        empty.style.opacity = "0.7";
        empty.style.textAlign = "left";
        badges.appendChild(empty);
      }
      container.appendChild(badges);
    };
    const applyDisabled = () => {
      const cardDisabled = card.dataset.disabled === "1";
      const inputs = card.querySelectorAll("input,button,select,textarea");
      inputs.forEach((el2) => {
        if (el2.dataset.weatherToggle === "main") {
          return;
        }
        el2.disabled = cardDisabled;
        el2.dispatchEvent(new Event("mg-weather-toggle-refresh"));
      });
      updateWeatherMutationsDisabled();
      updateColorButtons();
      card.style.opacity = cardDisabled ? "0.55" : "";
      updateAddRecipeDisabled();
    };
    function buildRecipeToggleGrid(selection, onSelectionChange) {
      const toggleGrid = applyStyles(document.createElement("div"), {
        display: "grid",
        gridTemplateColumns: "repeat(4, minmax(80px, 1fr))",
        columnGap: "6px",
        rowGap: "6px",
        justifyItems: "center"
      });
      const toggles = /* @__PURE__ */ new Map();
      WEATHER_MUTATIONS.forEach((info) => {
        const toggle = createWeatherMutationToggle({
          key: info.key,
          label: info.label,
          spriteSize: 40,
          dense: true,
          kind: "recipe",
          iconFactory: info.iconFactory
        });
        toggles.set(info.key, toggle);
        toggle.setChecked(selection.has(toggle.key));
        toggle.input.addEventListener("change", () => {
          const checked = toggle.input.checked;
          const group = WEATHER_RECIPE_GROUPS[toggle.key];
          if (checked && group) {
            WEATHER_RECIPE_GROUP_MEMBERS[group].forEach((other) => {
              if (other === toggle.key) return;
              if (!selection.has(other)) return;
              selection.delete(other);
              toggles.get(other)?.setChecked(false);
            });
          }
          if (checked) {
            selection.add(toggle.key);
          } else {
            selection.delete(toggle.key);
          }
          onSelectionChange();
        });
        toggleGrid.appendChild(toggle.wrap);
      });
      return toggleGrid;
    }
    function repaintRecipes() {
      recipesList.innerHTML = "";
      const hasDraftNew = editingRecipeIndex !== null && editingRecipeIndex === state2.weatherRecipes.length;
      const totalRows = state2.weatherRecipes.length + (hasDraftNew ? 1 : 0);
      if (totalRows === 0) {
        recipesList.appendChild(emptyRecipes);
        applyDisabled();
        return;
      }
      state2.weatherRecipes.forEach((set2, index) => {
        normalizeRecipeSelection(set2);
        const isEditing = editingRecipeIndex === index;
        const selection = isEditing ? editingRecipeDraft : set2;
        const row = applyStyles(document.createElement("div"), {
          display: "flex",
          gap: isEditing ? "10px" : "12px",
          border: "1px solid #4446",
          borderRadius: "10px",
          padding: isEditing ? "12px" : "10px 12px",
          background: "#0f1318",
          boxShadow: "0 0 0 1px #0002 inset",
          width: "100%"
        });
        if (isEditing) {
          row.style.flexDirection = "column";
        } else {
          row.style.flexDirection = "row";
          row.style.alignItems = "center";
          row.style.justifyContent = "space-between";
          row.style.flexWrap = "wrap";
        }
        const summary = document.createElement("div");
        renderRecipeSummary(summary, selection);
        if (!isEditing) {
          summary.style.flex = "1 1 auto";
          summary.style.minWidth = "220px";
        }
        row.appendChild(summary);
        if (isEditing) {
          const toggleGrid = buildRecipeToggleGrid(selection, () => renderRecipeSummary(summary, selection));
          row.appendChild(toggleGrid);
          const actions = applyStyles(document.createElement("div"), {
            display: "flex",
            gap: "8px",
            width: "100%"
          });
          const btnCancel = document.createElement("button");
          styleBtnFullWidth(btnCancel, "\u274C");
          btnCancel.onclick = cancelEditingRecipe;
          const btnValidate = document.createElement("button");
          styleBtnFullWidth(btnValidate, "\u2714\uFE0F");
          btnValidate.onclick = commitEditingRecipe;
          actions.append(btnCancel, btnValidate);
          if (editingRecipeIndex !== null && editingRecipeIndex < state2.weatherRecipes.length) {
            const btnDelete = document.createElement("button");
            styleBtnFullWidth(btnDelete, "\u{1F5D1}\uFE0F");
            btnDelete.title = "Delete";
            btnDelete.setAttribute("aria-label", "Delete");
            btnDelete.onclick = () => deleteRecipeAt(index);
            actions.append(btnDelete);
          }
          row.appendChild(actions);
        } else {
          const actions = applyStyles(document.createElement("div"), {
            display: "flex",
            gap: "6px",
            alignItems: "center",
            justifyContent: "flex-end",
            flex: "0 0 auto"
          });
          actions.style.flexWrap = "nowrap";
          const btnEdit = document.createElement("button");
          styleBtnCompact(btnEdit, "\u270F\uFE0F");
          btnEdit.title = "Edit";
          btnEdit.setAttribute("aria-label", "Edit");
          btnEdit.onclick = () => startEditingRecipe(index, set2);
          const btnDelete = document.createElement("button");
          styleBtnCompact(btnDelete, "\u{1F5D1}\uFE0F");
          btnDelete.title = "Delete";
          btnDelete.setAttribute("aria-label", "Delete");
          btnDelete.onclick = () => deleteRecipeAt(index);
          actions.append(btnEdit, btnDelete);
          row.appendChild(actions);
        }
        recipesList.appendChild(row);
      });
      if (hasDraftNew && editingRecipeIndex !== null) {
        const selection = editingRecipeDraft;
        const row = applyStyles(document.createElement("div"), {
          display: "flex",
          flexDirection: "column",
          gap: "10px",
          border: "1px solid #4446",
          borderRadius: "10px",
          padding: "12px",
          background: "#0f1318",
          boxShadow: "0 0 0 1px #0002 inset",
          width: "100%"
        });
        const summary = document.createElement("div");
        renderRecipeSummary(summary, selection);
        row.appendChild(summary);
        const toggleGrid = buildRecipeToggleGrid(selection, () => renderRecipeSummary(summary, selection));
        row.appendChild(toggleGrid);
        const actions = applyStyles(document.createElement("div"), {
          display: "flex",
          gap: "8px",
          width: "100%"
        });
        const btnCancel = document.createElement("button");
        styleBtnFullWidth(btnCancel, "\u274C");
        btnCancel.onclick = cancelEditingRecipe;
        const btnValidate = document.createElement("button");
        styleBtnFullWidth(btnValidate, "\u2714\uFE0F");
        btnValidate.onclick = commitEditingRecipe;
        actions.append(btnCancel, btnValidate);
        row.appendChild(actions);
        recipesList.appendChild(row);
      }
      applyDisabled();
    }
    btnAddRecipe.onclick = () => {
      startEditingRecipe(state2.weatherRecipes.length);
    };
    recipesWrap.append(recipesHeader, recipesList);
    card.append(
      makeSection("Lock by size", scaleRow),
      makeSection("Lock by color", colorsRow),
      makeSection("Lock by weather", weatherGrid),
      makeSection("Weather lock mode", weatherModeRow),
      makeSection("Recipe lockers", recipesWrap)
    );
    const refresh = () => {
      scaleSlider.setValues(state2.minScalePct, state2.maxScalePct);
      minSlider.value = String(state2.minScalePct);
      applyScaleRange(false);
      applyScaleMinimum(false);
      applyScaleMode(state2.scaleLockMode, false);
      updateColorButtons();
      weatherToggles.forEach((toggle) => toggle.setChecked(state2.weatherSelected.has(toggle.key)));
      radioAny.input.checked = state2.weatherMode === "ANY";
      radioAll.input.checked = state2.weatherMode === "ALL";
      radioRecipes.input.checked = state2.weatherMode === "RECIPES";
      recipesWrap.style.display = state2.weatherMode === "RECIPES" ? "" : "none";
      updateWeatherMutationsDisabled();
      repaintRecipes();
    };
    const setDisabled = (value) => {
      card.dataset.disabled = value ? "1" : "0";
      applyDisabled();
    };
    refresh();
    return { root: card, refresh, setDisabled };
  }
  function createGeneralTabRenderer(ui, store) {
    const viewRoot = applyStyles(document.createElement("div"), {
      display: "flex",
      flexDirection: "column",
      gap: "12px",
      alignItems: "center",
      width: "100%"
    });
    const layout = applyStyles(document.createElement("div"), {
      display: "flex",
      flexDirection: "column",
      gap: "12px",
      alignItems: "center",
      width: "100%"
    });
    const header = applyStyles(document.createElement("div"), {
      display: "flex",
      alignItems: "center",
      gap: "10px",
      justifyContent: "space-between",
      border: "1px solid #4445",
      borderRadius: "10px",
      padding: "12px 16px",
      background: "#1f2328",
      boxShadow: "0 0 0 1px #0002 inset",
      width: "min(760px, 100%)"
    });
    const textWrap = applyStyles(document.createElement("div"), {
      display: "flex",
      flexDirection: "column",
      gap: "4px"
    });
    const title = document.createElement("div");
    title.textContent = "Global locker";
    title.style.fontWeight = "600";
    title.style.fontSize = "15px";
    const subtitle = document.createElement("div");
    subtitle.textContent = "Set the rules for locking harvests using the filters below.";
    subtitle.style.opacity = "0.8";
    subtitle.style.fontSize = "12px";
    textWrap.append(title, subtitle);
    const toggleWrap = applyStyles(document.createElement("label"), {
      display: "flex",
      alignItems: "center",
      gap: "8px"
    });
    const toggleLabel = ui.label("Enabled");
    toggleLabel.style.margin = "0";
    const toggle = ui.switch(store.global.enabled);
    toggleWrap.append(toggleLabel, toggle);
    header.append(textWrap, toggleWrap);
    const form = createLockerSettingsCard(ui, store.global.settings, {
      onChange: () => store.notifyGlobalSettingsChanged()
    });
    layout.append(header, form.root);
    viewRoot.append(layout);
    const update = () => {
      setCheck(toggle, store.global.enabled);
      form.setDisabled(!store.global.enabled);
      form.refresh();
    };
    toggle.addEventListener("change", () => {
      store.setGlobalEnabled(!!toggle.checked);
    });
    const unsubscribe2 = store.subscribe(() => {
      update();
    });
    update();
    const render = (view) => {
      view.innerHTML = "";
      view.style.maxHeight = "54vh";
      view.style.overflow = "auto";
      view.append(viewRoot);
      update();
    };
    return {
      render,
      destroy: () => unsubscribe2()
    };
  }
  function createOverridesTabRenderer(ui, store) {
    const layout = applyStyles(document.createElement("div"), {
      display: "grid",
      gridTemplateColumns: "minmax(220px, 280px) minmax(0, 1fr)",
      gap: "10px",
      alignItems: "stretch",
      height: "54vh",
      overflow: "hidden"
    });
    const left = applyStyles(document.createElement("div"), {
      display: "grid",
      gridTemplateRows: "1fr",
      gap: "8px",
      minHeight: "0"
    });
    layout.appendChild(left);
    const list = applyStyles(document.createElement("div"), {
      display: "grid",
      gridTemplateColumns: "1fr",
      rowGap: "6px",
      overflow: "auto",
      paddingRight: "2px",
      border: "1px solid #4445",
      borderRadius: "10px",
      padding: "6px"
    });
    left.appendChild(list);
    const right = applyStyles(document.createElement("div"), {
      display: "flex",
      flexDirection: "column",
      gap: "12px",
      minHeight: "0"
    });
    layout.appendChild(right);
    const detail = applyStyles(document.createElement("div"), {
      display: "grid",
      gap: "12px",
      justifyItems: "center",
      alignContent: "start",
      height: "100%",
      overflow: "auto"
    });
    right.appendChild(detail);
    let selectedKey = null;
    let renderedDetailKey = null;
    const detailScrollMemory = /* @__PURE__ */ new Map();
    const getClampedScrollTop = (element) => {
      const max = Math.max(0, element.scrollHeight - element.clientHeight);
      return Math.max(0, Math.min(element.scrollTop, max));
    };
    const restoreScrollTop = (element, value) => {
      const max = Math.max(0, element.scrollHeight - element.clientHeight);
      const target = Math.max(0, Math.min(value, max));
      element.scrollTop = target;
      return target;
    };
    const updateDetailScrollMemory = (key2) => {
      const current = detailScrollMemory.get(key2) ?? { detail: 0, card: 0 };
      current.detail = getClampedScrollTop(detail);
      const currentCard = detail.querySelector('[data-locker-settings-card="1"]');
      if (currentCard) {
        current.card = getClampedScrollTop(currentCard);
      }
      detailScrollMemory.set(key2, current);
    };
    detail.addEventListener("scroll", () => {
      if (!renderedDetailKey) return;
      const memory = detailScrollMemory.get(renderedDetailKey) ?? { detail: 0, card: 0 };
      memory.detail = getClampedScrollTop(detail);
      detailScrollMemory.set(renderedDetailKey, memory);
    });
    const renderList = () => {
      const previousScrollTop = getClampedScrollTop(list);
      list.innerHTML = "";
      const seeds = getLockerSeedOptions();
      if (!seeds.length) {
        const empty = document.createElement("div");
        empty.textContent = "No crops available.";
        empty.style.opacity = "0.7";
        empty.style.fontSize = "12px";
        empty.style.textAlign = "center";
        empty.style.padding = "16px";
        list.appendChild(empty);
        restoreScrollTop(list, previousScrollTop);
        selectedKey = null;
        return;
      }
      scheduleLockerSpritePreload();
      if (selectedKey && !seeds.some((opt) => opt.key === selectedKey)) {
        selectedKey = null;
      }
      const fragment = document.createDocumentFragment();
      seeds.forEach((opt) => {
        const button = document.createElement("button");
        button.className = "qmm-vtab";
        button.style.display = "grid";
        button.style.gridTemplateColumns = "16px 1fr auto";
        button.style.alignItems = "center";
        button.style.gap = "8px";
        button.style.textAlign = "left";
        button.style.padding = "6px 8px";
        button.style.borderRadius = "8px";
        button.style.border = "1px solid #4445";
        button.style.background = selectedKey === opt.key ? "#2b8a3e" : "#1f2328";
        button.style.color = "#e7eef7";
        const dot = document.createElement("span");
        dot.className = "qmm-dot";
        dot.style.background = store.getOverride(opt.key)?.enabled ? "#2ecc71" : "#e74c3c";
        const label2 = document.createElement("span");
        label2.className = "label";
        label2.textContent = opt.cropName || opt.key;
        const fallbackEmoji = getLockerSeedEmojiForKey(opt.key) || getLockerSeedEmojiForSeedName(opt.seedName) || "\u{1F331}";
        const sprite = createPlantSprite(opt.key, {
          size: 24,
          fallback: fallbackEmoji
        });
        button.append(dot, label2, sprite);
        button.onmouseenter = () => button.style.borderColor = "#6aa1";
        button.onmouseleave = () => button.style.borderColor = "#4445";
        button.onclick = () => {
          if (selectedKey === opt.key) return;
          selectedKey = opt.key;
          renderList();
          renderDetail();
        };
        fragment.appendChild(button);
      });
      list.appendChild(fragment);
      restoreScrollTop(list, previousScrollTop);
    };
    const renderDetail = () => {
      if (renderedDetailKey) {
        updateDetailScrollMemory(renderedDetailKey);
      }
      detail.innerHTML = "";
      if (!selectedKey) {
        const empty = document.createElement("div");
        empty.textContent = "Select a crop on the left to customise its locker settings.";
        empty.style.opacity = "0.7";
        empty.style.fontSize = "13px";
        empty.style.textAlign = "center";
        empty.style.padding = "32px 24px";
        empty.style.border = "1px dashed #4445";
        empty.style.borderRadius = "10px";
        empty.style.width = "min(760px, 100%)";
        detail.appendChild(empty);
        renderedDetailKey = null;
        return;
      }
      const seeds = getLockerSeedOptions();
      const seed = seeds.find((opt) => opt.key === selectedKey);
      if (!seed) {
        selectedKey = null;
        renderedDetailKey = null;
        renderDetail();
        return;
      }
      const override = store.ensureOverride(selectedKey, { silent: true });
      const header = ui.flexRow({ justify: "between", align: "center", fullWidth: true });
      header.style.border = "1px solid #4445";
      header.style.borderRadius = "10px";
      header.style.padding = "12px 16px";
      header.style.background = "#1f2328";
      header.style.boxShadow = "0 0 0 1px #0002 inset";
      header.style.width = "min(760px, 100%)";
      const titleWrap = ui.flexRow({ gap: 10, align: "center" });
      titleWrap.style.flexWrap = "nowrap";
      const fallbackEmoji = getLockerSeedEmojiForKey(seed.key) || getLockerSeedEmojiForSeedName(seed.seedName) || "\u{1F331}";
      const sprite = createPlantSprite(seed.key, { size: 32, fallback: fallbackEmoji });
      const title = document.createElement("div");
      title.textContent = seed.cropName || seed.key;
      title.style.fontWeight = "600";
      title.style.fontSize = "15px";
      titleWrap.append(sprite, title);
      const toggleWrap = ui.flexRow({ gap: 8, align: "center" });
      toggleWrap.style.flexWrap = "nowrap";
      const toggleLabel = ui.label("Override");
      toggleLabel.style.margin = "0";
      const toggle = ui.switch(override.enabled);
      toggleWrap.append(toggleLabel, toggle);
      header.append(titleWrap, toggleWrap);
      const status = document.createElement("div");
      status.style.fontSize = "12px";
      status.style.opacity = "0.75";
      status.style.textAlign = "center";
      status.style.width = "min(760px, 100%)";
      const updateStatus = () => {
        status.textContent = override.enabled ? "This crop uses its own locker filters." : "Uses the global locker settings.";
      };
      const form = createLockerSettingsCard(ui, override.settings, {
        onChange: () => {
          if (selectedKey) {
            store.notifyOverrideSettingsChanged(selectedKey);
          }
        }
      });
      const applyEnabledState = () => {
        form.setDisabled(!override.enabled);
        form.refresh();
        updateStatus();
      };
      toggle.addEventListener("change", () => {
        if (!selectedKey) return;
        const wasEnabled = override.enabled;
        const nextEnabled = !!toggle.checked;
        if (nextEnabled && !wasEnabled && !override.hasPersistedSettings) {
          copySettings(override.settings, store.global.settings);
        }
        if (nextEnabled) {
          override.hasPersistedSettings = true;
        }
        store.setOverrideEnabled(selectedKey, nextEnabled);
      });
      applyEnabledState();
      detail.append(header, status, form.root);
      if (selectedKey) {
        const memory = detailScrollMemory.get(selectedKey) ?? { detail: 0, card: 0 };
        memory.detail = restoreScrollTop(detail, memory.detail);
        memory.card = restoreScrollTop(form.root, memory.card);
        detailScrollMemory.set(selectedKey, memory);
        const activeKey = selectedKey;
        form.root.addEventListener("scroll", () => {
          if (renderedDetailKey !== activeKey) return;
          const current = detailScrollMemory.get(activeKey) ?? { detail: getClampedScrollTop(detail), card: 0 };
          current.card = getClampedScrollTop(form.root);
          detailScrollMemory.set(activeKey, current);
        });
        renderedDetailKey = activeKey;
      }
    };
    const refresh = () => {
      renderList();
      renderDetail();
    };
    const unsubscribe2 = store.subscribe(refresh);
    const render = (view) => {
      view.innerHTML = "";
      view.append(layout);
      refresh();
    };
    return {
      render,
      destroy: () => unsubscribe2()
    };
  }
  async function renderLockerMenu(container) {
    const ui = new Menu({ id: "locker", compact: true });
    ui.mount(container);
    const store = new LockerMenuStore(lockerService.getState());
    const generalTab = createGeneralTabRenderer(ui, store);
    const overridesTab = createOverridesTabRenderer(ui, store);
    ui.addTabs([
      { id: "locker-general", title: "General", render: (view) => generalTab.render(view) },
      { id: "locker-overrides", title: "Overrides by species", render: (view) => overridesTab.render(view) }
    ]);
    ui.switchTo("locker-general");
    const disposables = [];
    disposables.push(lockerService.subscribe((event) => store.syncFromService(event.state)));
    disposables.push(() => generalTab.destroy());
    disposables.push(() => overridesTab.destroy());
    const cleanup2 = () => {
      while (disposables.length) {
        const dispose = disposables.pop();
        try {
          dispose?.();
        } catch {
        }
      }
    };
    ui.on("unmounted", cleanup2);
  }

  // src/services/players.ts
  function findPlayersDeep(state2) {
    if (!state2 || typeof state2 !== "object") return [];
    const out = [];
    const seen = /* @__PURE__ */ new Set();
    const stack = [state2];
    while (stack.length) {
      const cur = stack.pop();
      if (!cur || typeof cur !== "object" || seen.has(cur)) continue;
      seen.add(cur);
      for (const k of Object.keys(cur)) {
        const v = cur[k];
        if (Array.isArray(v) && v.length && v.every((x) => x && typeof x === "object")) {
          const looks = v.some((p) => "id" in p && "name" in p);
          if (looks && /player/i.test(k)) out.push(...v);
        }
        if (v && typeof v === "object") stack.push(v);
      }
    }
    const byId = /* @__PURE__ */ new Map();
    for (const p of out) if (p?.id) byId.set(String(p.id), p);
    return [...byId.values()];
  }
  function getPlayersArray(st) {
    const direct = st?.fullState?.data?.players ?? st?.data?.players ?? st?.players;
    return Array.isArray(direct) ? direct : findPlayersDeep(st);
  }
  function getSlotsArray(st) {
    const raw = st?.child?.data?.userSlots ?? st?.fullState?.child?.data?.userSlots ?? st?.data?.userSlots;
    if (Array.isArray(raw)) return raw;
    if (raw && typeof raw === "object") {
      const entries = Object.entries(raw);
      entries.sort((a, b) => {
        const ai = Number(a[0]);
        const bi = Number(b[0]);
        if (Number.isFinite(ai) && Number.isFinite(bi)) return ai - bi;
        return a[0].localeCompare(b[0]);
      });
      return entries.map(([, v]) => v);
    }
    return [];
  }
  function extractPosFromSlot(slot) {
    const pos = slot?.data?.position ?? slot?.position ?? slot?.data?.coords ?? slot?.coords;
    const x = Number(pos?.x);
    const y = Number(pos?.y);
    return Number.isFinite(x) && Number.isFinite(y) ? { x, y } : null;
  }
  function extractInventoryFromSlot(slot) {
    const inv = slot?.data?.inventory;
    if (!inv || typeof inv !== "object") return null;
    const items = Array.isArray(inv.items) ? inv.items : [];
    const favoritedItemIds = Array.isArray(inv.favoritedItemIds) ? inv.favoritedItemIds : [];
    return { items, favoritedItemIds };
  }
  function extractJournalFromSlot(slot) {
    const j = slot?.data?.journal ?? slot?.journal;
    if (!j || typeof j !== "object") return null;
    const produce = j.produce && typeof j.produce === "object" ? j.produce : void 0;
    const pets = j.pets && typeof j.pets === "object" ? j.pets : void 0;
    const normProduce = produce ? Object.fromEntries(Object.entries(produce).map(([k, v]) => [
      String(k),
      { variantsLogged: Array.isArray(v?.variantsLogged) ? v.variantsLogged : [] }
    ])) : void 0;
    const normPets = pets ? Object.fromEntries(Object.entries(pets).map(([k, v]) => [
      String(k),
      {
        variantsLogged: Array.isArray(v?.variantsLogged) ? v.variantsLogged : [],
        abilitiesLogged: Array.isArray(v?.abilitiesLogged) ? v.abilitiesLogged : []
      }
    ])) : void 0;
    return { produce: normProduce, pets: normPets };
  }
  function extractGardenFromSlot(slot) {
    const g = slot?.data?.garden ?? slot?.garden;
    if (!g || typeof g !== "object") return null;
    const to = g.tileObjects;
    const bto = g.boardwalkTileObjects;
    const tileObjects = to && typeof to === "object" ? to : {};
    const boardwalkTileObjects = bto && typeof bto === "object" ? bto : {};
    return { tileObjects, boardwalkTileObjects };
  }
  function getSlotByPlayerId(st, playerId2) {
    for (const s of getSlotsArray(st)) if (String(s?.playerId ?? "") === String(playerId2)) return s;
    return null;
  }
  function enrichPlayersWithSlots(players, st) {
    const byPid = /* @__PURE__ */ new Map();
    for (const slot of getSlotsArray(st)) {
      if (!slot || typeof slot !== "object") continue;
      const pid = slot.playerId != null ? String(slot.playerId) : "";
      if (!pid) continue;
      const pos = extractPosFromSlot(slot);
      const inv = extractInventoryFromSlot(slot);
      byPid.set(pid, { x: pos?.x, y: pos?.y, inventory: inv ?? null });
    }
    return players.map((p) => {
      const extra = byPid.get(String(p.id));
      return extra ? { ...p, ...extra } : { ...p, inventory: null };
    });
  }
  function orderPlayersBySlots(players, st) {
    const slots = getSlotsArray(st);
    const mapById = /* @__PURE__ */ new Map();
    for (const p of players) mapById.set(String(p.id), p);
    const out = [];
    const seen = /* @__PURE__ */ new Set();
    for (const s of slots) {
      const pid = s?.playerId != null ? String(s.playerId) : "";
      if (!pid || seen.has(pid)) continue;
      const p = mapById.get(pid);
      if (p) {
        out.push(p);
        seen.add(pid);
      }
    }
    for (const p of players) {
      const pid = String(p.id);
      if (!seen.has(pid)) {
        out.push(p);
        seen.add(pid);
      }
    }
    return out;
  }
  function clampPlayers(n) {
    const v = Math.floor(Number(n));
    if (!Number.isFinite(v)) return 1;
    return Math.max(1, Math.min(6, v));
  }
  async function getPlayersInRoom() {
    try {
      const raw = await Atoms.server.numPlayers.get();
      return clampPlayers(raw);
    } catch {
      return 1;
    }
  }
  var __cachedSpawnTiles = null;
  var __spawnLoadPromise = null;
  async function getSpawnTilesSorted() {
    if (Array.isArray(__cachedSpawnTiles)) return __cachedSpawnTiles;
    if (__spawnLoadPromise) return __spawnLoadPromise;
    __spawnLoadPromise = (async () => {
      try {
        const map2 = await Atoms.root.map.get();
        const arr = map2?.spawnTiles;
        if (Array.isArray(arr) && arr.every((n) => Number.isFinite(n))) {
          __cachedSpawnTiles = [...arr].sort((a, b) => a - b);
          return __cachedSpawnTiles;
        }
      } catch {
      }
      try {
        const st = await Atoms.root.state.get();
        const seen = /* @__PURE__ */ new Set();
        const stack = [st];
        while (stack.length) {
          const cur = stack.pop();
          if (!cur || typeof cur !== "object" || seen.has(cur)) continue;
          seen.add(cur);
          const arr = cur?.spawnTiles;
          if (Array.isArray(arr) && arr.every((n) => Number.isFinite(n))) {
            __cachedSpawnTiles = [...arr].sort((a, b) => a - b);
            return __cachedSpawnTiles;
          }
          for (const k of Object.keys(cur)) {
            const v = cur[k];
            if (v && typeof v === "object") stack.push(v);
          }
        }
      } catch {
      }
      __cachedSpawnTiles = [];
      return __cachedSpawnTiles;
    })();
    const res = await __spawnLoadPromise;
    __spawnLoadPromise = null;
    return res;
  }
  async function getMapCols() {
    try {
      const map2 = await Atoms.root.map.get();
      const cols = Number(map2?.cols);
      if (Number.isFinite(cols) && cols > 0) return cols;
    } catch {
    }
    try {
      const st = await Atoms.root.state.get();
      const maybeCols = Number(
        st?.map?.cols ?? st?.child?.data?.map?.cols ?? st?.fullState?.map?.cols
      );
      if (Number.isFinite(maybeCols) && maybeCols > 0) return maybeCols;
    } catch {
    }
    return 81;
  }
  function assignGardenPositions(players, spawnTilesSorted) {
    if (!players.length || !spawnTilesSorted.length) {
      return players.map((p) => ({ ...p, gardenPosition: null }));
    }
    const out = [];
    for (let i = 0; i < players.length; i++) {
      out.push({ ...players[i], gardenPosition: spawnTilesSorted[i] ?? null });
    }
    return out;
  }
  function nowTs() {
    return Date.now();
  }
  function normJournal(j) {
    if (!j || typeof j !== "object") return {};
    const out = {};
    if (j.produce && typeof j.produce === "object") out.produce = j.produce;
    if (j.pets && typeof j.pets === "object") out.pets = j.pets;
    return out;
  }
  function hasJournalData(j) {
    if (!j) return false;
    const hasProduce = !!j.produce && Object.values(j.produce).some((s) => (s.variantsLogged?.length ?? 0) > 0);
    const hasPets = !!j.pets && Object.values(j.pets).some((s) => (s.variantsLogged?.length ?? 0) > 0 || (s.abilitiesLogged?.length ?? 0) > 0);
    return hasProduce || hasPets;
  }
  var followingState = {
    currentTargetId: null,
    unsub: null,
    lastPos: null,
    prevPos: null,
    steps: 0
  };
  var PET_FOLLOW_INTERVAL_MS = 20;
  var PET_HISTORY_FACTOR = 3;
  var PET_SPACING_STEPS = 1;
  var petFollowState = {
    targetId: null,
    unsub: null,
    timer: null,
    pets: [],
    history: [],
    historyCap: 0
  };
  function clearPetFollowTimer() {
    if (petFollowState.timer) {
      clearInterval(petFollowState.timer);
      petFollowState.timer = null;
    }
  }
  async function resetPetFollowState() {
    if (petFollowState.unsub) {
      const fn = petFollowState.unsub;
      petFollowState.unsub = null;
      try {
        await fn();
      } catch {
      }
    } else {
      petFollowState.unsub = null;
    }
    clearPetFollowTimer();
    petFollowState.targetId = null;
    petFollowState.pets = [];
    petFollowState.history = [];
    petFollowState.historyCap = 0;
  }
  function recordPetHistory(pos, force = false) {
    const top = petFollowState.history[0];
    if (!force && top && top.x === pos.x && top.y === pos.y) return;
    petFollowState.history.unshift({ x: pos.x, y: pos.y });
    const cap = petFollowState.historyCap || petFollowState.history.length;
    if (petFollowState.history.length > cap) {
      petFollowState.history.length = cap;
    }
  }
  var PlayersService = {
    async list() {
      const st = await Atoms.root.state.get();
      if (!st) return [];
      const base = enrichPlayersWithSlots(getPlayersArray(st), st);
      const ordered = orderPlayersBySlots(base, st);
      const spawns = await getSpawnTilesSorted();
      const players = assignGardenPositions(ordered, spawns);
      return players;
    },
    async onChange(cb) {
      return Atoms.root.state.onChange(async () => {
        try {
          cb(await this.list());
        } catch {
        }
      });
    },
    async getPosition(playerId2) {
      const st = await Atoms.root.state.get();
      if (!st) return null;
      const slot = getSlotByPlayerId(st, playerId2);
      const pos = extractPosFromSlot(slot);
      return pos;
    },
    async getInventory(playerId2) {
      const st = await Atoms.root.state.get();
      if (!st) return null;
      const slot = getSlotByPlayerId(st, playerId2);
      const inv = extractInventoryFromSlot(slot);
      return inv;
    },
    async getJournal(playerId2) {
      const st = await Atoms.root.state.get();
      if (!st) return null;
      const slot = getSlotByPlayerId(st, playerId2);
      const j = extractJournalFromSlot(slot);
      const journal = j ? normJournal(j) : null;
      return journal;
    },
    async getGarden(playerId2) {
      const st = await Atoms.root.state.get();
      if (!st) return null;
      const slot = getSlotByPlayerId(st, playerId2);
      return extractGardenFromSlot(slot);
    },
    async getGardenPosition(playerId2) {
      const list = await this.list();
      const p = list.find((x) => String(x.id) === String(playerId2));
      return p?.gardenPosition ?? null;
    },
    async getPlayerNameById(playerId2) {
      try {
        const st = await Atoms.root.state.get();
        if (st) {
          const arr = getPlayersArray(st);
          const p = arr.find((x) => String(x?.id) === String(playerId2));
          if (p && typeof p.name === "string" && p.name) return p.name;
        }
      } catch {
      }
      try {
        const list = await this.list();
        const p = list.find((x) => String(x.id) === String(playerId2));
        return p?.name ?? null;
      } catch {
        return null;
      }
    },
    async teleportToPlayer(playerId2) {
      const pos = await this.getPosition(playerId2);
      if (!pos) throw new Error("Unknown position for this player");
      PlayerService.teleport(pos.x, pos.y);
      toastSimple("Teleport", `Teleported to ${await this.getPlayerNameById(playerId2)}`, "success");
    },
    async teleportToGarden(playerId2) {
      const tileId = await this.getGardenPosition(playerId2);
      if (tileId == null) {
        await toastSimple("Teleport", "No garden position for this player.", "error");
        return;
      }
      const cols = await getMapCols();
      const x = tileId % cols, y = Math.floor(tileId / cols);
      await PlayerService.teleport(x, y);
      await toastSimple("Teleport", `Teleported to ${await this.getPlayerNameById(playerId2)}'s garden`, "success");
    },
    async getInventoryValue(playerId2, opts) {
      try {
        const playersInRoom = await getPlayersInRoom();
        const inv = await this.getInventory(playerId2);
        const items = Array.isArray(inv?.items) ? inv.items : [];
        if (!items.length) return 0;
        const value = sumInventoryValue(items, opts, playersInRoom);
        return value;
      } catch {
        return 0;
      }
    },
    async getGardenValue(playerId2, opts) {
      try {
        const playersInRoom = await getPlayersInRoom();
        const garden2 = await this.getGarden(playerId2);
        if (!garden2) return 0;
        const value = sumGardenValue(garden2.tileObjects ?? {}, opts, playersInRoom);
        return value;
      } catch {
        return 0;
      }
    },
    /** Ouvre l’aperçu d’inventaire (fake modal) avec garde + toasts. */
    async openInventoryPreview(playerId2, playerName) {
      try {
        const inv = await this.getInventory(playerId2);
        if (!inv) {
          await toastSimple("Inventory", "No inventory object found for this player.", "error");
          return;
        }
        const items = Array.isArray(inv.items) ? inv.items : [];
        if (items.length === 0) {
          await toastSimple("Inventory", "Inventory is empty for this player.", "info");
          return;
        }
        try {
          await fakeInventoryShow({ ...inv, items }, { open: true });
        } catch (err) {
          await toastSimple("Inventory", err?.message || "Failed to open inventory", "error");
          return;
        }
        if (playerName) await toastSimple("Inventory", `${playerName}'s inventory displayed.`, "info");
      } catch (e) {
        await toastSimple("Inventory", e?.message || "Failed to open inventory.", "error");
      }
    },
    /** Ouvre le Journal (produce + pets) avec garde + toasts. */
    async openJournalLog(playerId2, playerName) {
      try {
        const journal = await this.getJournal(playerId2);
        if (!hasJournalData(journal)) {
          await toastSimple("Journal", "No journal data for this player.", "error");
          return;
        }
        const safe = journal ?? {};
        try {
          await fakeJournalShow(safe, { open: true });
        } catch (err) {
          await toastSimple("Journal", err?.message || "Failed to open journal.", "error");
          return;
        }
        if (playerName) await toastSimple("Journal", `${playerName}'s journal displayed.`, "info");
      } catch (e) {
        await toastSimple("Journal", e?.message || "Failed to open journal.", "error");
      }
    },
    /* ---------------- Ajouts "fake" au journal (UI only, avec gardes) ---------------- */
    async addProduceVariant(playerId2, species, variant, createdAt = nowTs()) {
      if (!species || !variant) {
        await toastSimple("Journal", "Missing species or variant.", "error");
        return;
      }
      try {
        await fakeJournalShow({
          produce: {
            [String(species)]: {
              variantsLogged: [{ variant: String(variant), createdAt }]
            }
          }
        }, { open: true });
        const name = await this.getPlayerNameById(playerId2);
        await toastSimple("Journal", `Added produce variant "${variant}" for ${name ?? playerId2}.`, "success");
      } catch (e) {
        await toastSimple("Journal", e?.message || "Failed to add produce variant.", "error");
      }
    },
    async addPetVariant(playerId2, petSpecies, variant, createdAt = nowTs()) {
      if (!petSpecies || !variant) {
        await toastSimple("Journal", "Missing pet species or variant.", "error");
        return;
      }
      try {
        await fakeJournalShow({
          pets: {
            [String(petSpecies)]: {
              variantsLogged: [{ variant: String(variant), createdAt }]
            }
          }
        }, { open: true });
        const name = await this.getPlayerNameById(playerId2);
        await toastSimple("Journal", `Added pet variant "${variant}" for ${name ?? playerId2}.`, "success");
      } catch (e) {
        await toastSimple("Journal", e?.message || "Failed to add pet variant.", "error");
      }
    },
    async addPetAbility(playerId2, petSpecies, ability, createdAt = nowTs()) {
      if (!petSpecies || !ability) {
        await toastSimple("Journal", "Missing pet species or ability.", "error");
        return;
      }
      try {
        await fakeJournalShow({
          pets: {
            [String(petSpecies)]: {
              abilitiesLogged: [{ ability: String(ability), createdAt }]
            }
          }
        }, { open: true });
        const name = await this.getPlayerNameById(playerId2);
        await toastSimple("Journal", `Added pet ability "${ability}" for ${name ?? playerId2}.`, "success");
      } catch (e) {
        await toastSimple("Journal", e?.message || "Failed to add pet ability.", "error");
      }
    },
    /* ---------------- Follow ---------------- */
    async stopFollowing() {
      if (followingState.unsub) {
        try {
          await followingState.unsub();
        } catch {
        }
      }
      followingState.unsub = null;
      followingState.currentTargetId = null;
      followingState.lastPos = null;
      followingState.prevPos = null;
      followingState.steps = 0;
    },
    isFollowing(playerId2) {
      return followingState.currentTargetId === playerId2;
    },
    async startFollowing(playerId2) {
      if (followingState.unsub) {
        try {
          await followingState.unsub();
        } catch {
        }
        followingState.unsub = null;
      }
      followingState.currentTargetId = playerId2;
      followingState.lastPos = null;
      followingState.prevPos = null;
      followingState.steps = 0;
      const pos = await this.getPosition(playerId2);
      if (!pos) {
        await toastSimple("Follow", "Unable to retrieve player position.", "error");
        followingState.currentTargetId = null;
        return;
      }
      await PlayerService.teleport(pos.x, pos.y);
      followingState.lastPos = { x: pos.x, y: pos.y };
      followingState.prevPos = null;
      followingState.steps = 0;
      followingState.unsub = await this.onChange(async (players) => {
        if (followingState.currentTargetId !== playerId2) return;
        const target = players.find((p) => p.id === playerId2);
        if (!target || typeof target.x !== "number" || typeof target.y !== "number") {
          await this.stopFollowing();
          await toastSimple("Follow", "The target is no longer trackable (disconnected?).", "error");
          return;
        }
        const cur = { x: target.x, y: target.y };
        const last = followingState.lastPos;
        if (!last) {
          followingState.lastPos = cur;
          return;
        }
        if (cur.x !== last.x || cur.y !== last.y) {
          followingState.steps += 1;
          if (followingState.steps >= 2) {
            if (last) {
              PlayerService.move(last.x, last.y);
            }
          }
          followingState.prevPos = followingState.lastPos;
          followingState.lastPos = cur;
        }
      });
      await toastSimple("Follow", "Follow enabled", "success");
    },
    /* ---------------- Pet Follow ---------------- */
    async stopPetFollowing(opts) {
      await resetPetFollowState();
      if (!opts?.silent) {
        await toastSimple("Pet follow", opts?.message ?? "Disabled.", opts?.tone ?? "info");
      }
    },
    isPetFollowing(playerId2) {
      return petFollowState.targetId === playerId2;
    },
    async startPetFollowing(playerId2) {
      await this.stopPetFollowing({ silent: true });
      const petsRaw = await Atoms.pets.myPetInfos.get();
      const petIds = Array.isArray(petsRaw) ? petsRaw.map((entry) => entry?.slot?.id).filter((id) => typeof id === "string" && !!id) : [];
      if (!petIds.length) {
        await toastSimple("Pet follow", "You don't have any active pets.", "error");
        return;
      }
      const pos = await this.getPosition(playerId2);
      if (!pos) {
        await toastSimple("Pet follow", "Unable to retrieve player position.", "error");
        return;
      }
      petFollowState.targetId = playerId2;
      petFollowState.pets = petIds;
      petFollowState.historyCap = Math.max(petIds.length * PET_HISTORY_FACTOR, petIds.length + PET_SPACING_STEPS + 1);
      petFollowState.history = [];
      for (let i = 0; i < petFollowState.historyCap; i += 1) {
        recordPetHistory(pos, true);
      }
      const sendPositions = async () => {
        if (petFollowState.targetId !== playerId2) return;
        if (!petFollowState.pets.length || !petFollowState.history.length) return;
        const payload = {};
        for (let i = 0; i < petFollowState.pets.length; i += 1) {
          const petId = petFollowState.pets[i];
          const historyIndex = Math.min(
            petFollowState.history.length - 1,
            (i + 1) * PET_SPACING_STEPS
          );
          const targetPos = petFollowState.history[historyIndex] ?? petFollowState.history[petFollowState.history.length - 1];
          if (targetPos) {
            payload[petId] = { x: targetPos.x, y: targetPos.y };
          }
        }
        if (Object.keys(payload).length === 0) return;
        try {
          await PlayerService.petPositions(payload);
        } catch (err) {
        }
      };
      petFollowState.timer = setInterval(() => {
        sendPositions().catch(() => {
        });
      }, PET_FOLLOW_INTERVAL_MS);
      const initialSend = sendPositions();
      petFollowState.unsub = await this.onChange(async (players) => {
        if (petFollowState.targetId !== playerId2) return;
        const target = players.find((p) => p.id === playerId2);
        if (!target || typeof target.x !== "number" || typeof target.y !== "number") {
          await this.stopPetFollowing({ silent: false, message: "Target is no longer trackable.", tone: "error" });
          return;
        }
        recordPetHistory({ x: target.x, y: target.y });
      });
      await initialSend;
      await toastSimple("Pet follow", "Pets are now following the target.", "success");
    }
  };

  // src/ui/menus/players.ts
  async function readPlayers() {
    return PlayersService.list();
  }
  var NF_US_INT = new Intl.NumberFormat("en-US", { maximumFractionDigits: 0 });
  function truncateLabel(s, max = 22) {
    if (!s) return "";
    return s.length <= max ? s : s.slice(0, max - 1) + "\u2026";
  }
  var vItem = (p) => ({
    id: p.id,
    title: truncateLabel(p.name || p.id, 9),
    subtitle: p.isConnected ? "Online" : "Offline",
    avatarUrl: p.discordAvatarUrl || "",
    statusColor: p.isConnected ? "#48d170" : "#999a"
  });
  async function renderPlayersMenu(root) {
    const ui = new Menu({ id: "players", compact: true, windowSelector: ".qws-win" });
    ui.mount(root);
    const panel = ui.root.querySelector(".qmm-views");
    const { root: split, left, right } = ui.split2("260px");
    panel.appendChild(split);
    split.style.height = "100%";
    split.style.minHeight = "0";
    left.style.display = "flex";
    left.style.flexDirection = "column";
    left.style.minHeight = "0";
    right.style.minHeight = "0";
    right.style.overflow = "auto";
    const vt = ui.vtabs({
      filterPlaceholder: "Find player\u2026",
      onSelect: (_id, item) => renderRight(item?.id || null),
      fillAvailableHeight: true
    });
    vt.root.style.display = "flex";
    vt.root.style.flexDirection = "column";
    vt.root.style.flex = "1 1 auto";
    vt.root.style.minHeight = "0";
    left.appendChild(vt.root);
    const filter = vt.root.querySelector(".filter");
    if (filter) {
      filter.style.display = "flex";
      filter.style.alignItems = "center";
      filter.style.gap = "8px";
      const input = filter.querySelector("input");
      if (input) {
        input.style.flex = "1 1 auto";
        input.style.minWidth = "0";
      }
    }
    async function renderRight(playerId2) {
      right.innerHTML = "";
      const p = playerId2 ? players.find((x) => x.id === playerId2) || null : null;
      if (!p) {
        const empty = document.createElement("div");
        empty.style.opacity = "0.75";
        empty.textContent = "Select a player on the left.";
        right.appendChild(empty);
        return;
      }
      const col = document.createElement("div");
      col.style.display = "grid";
      col.style.gridAutoRows = "min-content";
      col.style.justifyItems = "center";
      col.style.gap = "10px";
      col.style.overflow = "auto";
      right.appendChild(col);
      const prof = document.createElement("div");
      prof.style.display = "grid";
      prof.style.gap = "8px";
      prof.style.justifyItems = "center";
      const head = document.createElement("div");
      head.style.display = "flex";
      head.style.alignItems = "center";
      head.style.gap = "12px";
      const avatar = document.createElement("img");
      avatar.src = p.discordAvatarUrl || "";
      avatar.alt = p.name;
      avatar.width = 48;
      avatar.height = 48;
      avatar.style.borderRadius = "50%";
      avatar.style.objectFit = "cover";
      avatar.style.border = "1px solid #4446";
      const title = document.createElement("div");
      const nameEl = document.createElement("div");
      nameEl.textContent = p.name || p.id;
      nameEl.style.fontWeight = "600";
      nameEl.style.fontSize = "16px";
      const sub = document.createElement("div");
      sub.style.opacity = "0.8";
      sub.style.fontSize = "12px";
      sub.textContent = p.isConnected ? "Online" : "Offline";
      title.append(nameEl, sub);
      head.append(avatar, title);
      const info = document.createElement("div");
      info.style.opacity = "0.9";
      prof.append(head, info);
      col.appendChild(prof);
      const infoWrap = document.createElement("div");
      infoWrap.style.display = "grid";
      infoWrap.style.gap = "6px";
      infoWrap.style.justifySelf = "stretch";
      infoWrap.style.width = "100%";
      const invValueRow = ui.flexRow({ justify: "start", fullWidth: true, gap: 6 });
      const invLabel = document.createElement("div");
      invLabel.textContent = "Inventory: ";
      invLabel.style.fontSize = "14px";
      invLabel.style.opacity = "0.85";
      const invValue = document.createElement("div");
      invValue.textContent = "\u2026";
      invValue.style.fontSize = "15px";
      invValue.style.fontWeight = "700";
      invValue.style.color = "#FFD84D";
      invValueRow.append(invLabel, invValue);
      const gardenValueRow = ui.flexRow({ justify: "start", fullWidth: true, gap: 6 });
      const gardenLabel = document.createElement("div");
      gardenLabel.textContent = "Garden: ";
      gardenLabel.style.fontSize = "14px";
      gardenLabel.style.opacity = "0.85";
      const gardenValue = document.createElement("div");
      gardenValue.textContent = "\u2026";
      gardenValue.style.fontWeight = "700";
      gardenValue.style.fontSize = "15px";
      gardenValue.style.color = "#FFD84D";
      gardenValueRow.append(gardenLabel, gardenValue);
      infoWrap.append(invValueRow, gardenValueRow);
      const infoCard = ui.card("\u{1F331} Crops values", { tone: "muted", align: "center" });
      infoCard.body.append(infoWrap);
      col.appendChild(infoCard.root);
      const teleRow = ui.flexRow({ justify: "center" });
      const btnToPlayer = ui.btn("To player", { size: "sm" });
      btnToPlayer.style.minWidth = "120px";
      const btnToGarden = ui.btn("To garden", { size: "sm" });
      btnToGarden.style.minWidth = "120px";
      btnToPlayer.onclick = async () => {
        try {
          const fn = PlayersService.teleportToPlayer ?? PlayersService.teleportTo;
          await fn.call(PlayersService, p.id);
        } catch (e) {
          await toastSimple("Teleport", e?.message || "Error during teleport.", "error");
        }
      };
      btnToGarden.onclick = async () => {
        try {
          const fn = PlayersService.teleportToGarden ?? PlayersService.tptogarden;
          await fn.call(PlayersService, p.id);
        } catch (e) {
          await toastSimple("Teleport", e?.message || "Error during teleport.", "error");
        }
      };
      teleRow.append(btnToPlayer, btnToGarden);
      const teleportCard = ui.card("\u{1F300} Teleport", { tone: "muted", align: "center" });
      teleportCard.body.append(teleRow);
      col.appendChild(teleportCard.root);
      const invRow = ui.flexRow({ justify: "center" });
      const btnInv = ui.btn("Inventory", { size: "sm" });
      btnInv.style.minWidth = "120px";
      const btnJournal = ui.btn("Journal", { size: "sm" });
      btnJournal.style.minWidth = "120px";
      btnInv.onclick = async () => {
        try {
          ui.setWindowVisible(false);
          await PlayersService.openInventoryPreview(p.id, p.name);
          if (await isInventoryPanelOpen()) {
            await waitInventoryPanelClosed();
          }
        } finally {
          ui.setWindowVisible(true);
        }
      };
      btnJournal.onclick = async () => {
        try {
          ui.setWindowVisible(false);
          await PlayersService.openJournalLog(p.id, p.name);
          if (await isJournalModalOpen()) {
            await waitJournalModalClosed();
          }
        } finally {
          ui.setWindowVisible(true);
        }
      };
      invRow.append(btnInv, btnJournal);
      const inspectCard = ui.card("\u{1F50D} Inspect", { tone: "muted", align: "center" });
      inspectCard.body.append(invRow);
      col.appendChild(inspectCard.root);
      const funWrap = document.createElement("div");
      funWrap.style.display = "grid";
      funWrap.style.gap = "10px";
      const followRow = ui.flexRow({ justify: "center" });
      followRow.style.gap = "16px";
      const playerFollowGroup = document.createElement("div");
      playerFollowGroup.style.display = "flex";
      playerFollowGroup.style.alignItems = "center";
      playerFollowGroup.style.gap = "8px";
      const label2 = document.createElement("div");
      label2.textContent = "Follow player";
      label2.style.fontSize = "14px";
      label2.style.opacity = "0.85";
      const sw = ui.switch(PlayersService.isFollowing(p.id));
      sw.addEventListener("change", async () => {
        try {
          if (sw.checked) {
            await PlayersService.startFollowing(p.id);
            await toastSimple("Follow", "Enabled.", "success");
          } else {
            PlayersService.stopFollowing();
            await toastSimple("Follow", "Disable.", "info");
          }
        } catch (e) {
          await toastSimple("Follow", e?.message || "Error", "error");
          sw.checked = !sw.checked;
        }
      });
      playerFollowGroup.append(label2, sw);
      const petFollowGroup = document.createElement("div");
      petFollowGroup.style.display = "flex";
      petFollowGroup.style.alignItems = "center";
      petFollowGroup.style.gap = "4px";
      const petsLabel = document.createElement("div");
      petsLabel.textContent = "Pet follow";
      petsLabel.style.fontSize = "14px";
      petsLabel.style.opacity = "0.85";
      const petsSwitch = ui.switch(PlayersService.isPetFollowing(p.id));
      petsSwitch.addEventListener("change", async () => {
        try {
          if (petsSwitch.checked) {
            await PlayersService.startPetFollowing(p.id);
          } else {
            await PlayersService.stopPetFollowing();
          }
        } catch (e) {
          await toastSimple("Pet follow", e?.message || "Error", "error");
          petsSwitch.checked = !petsSwitch.checked;
        }
      });
      petFollowGroup.append(petsLabel, petsSwitch);
      followRow.append(playerFollowGroup, petFollowGroup);
      funWrap.append(followRow);
      const funCard = ui.card("\u{1F389} Fun", { tone: "muted", align: "center" });
      funCard.body.append(funWrap);
      col.appendChild(funCard.root);
      (async () => {
        try {
          const total = await PlayersService.getInventoryValue(p.id);
          invValue.textContent = `${NF_US_INT.format(Math.round(total))}`;
          invValue.title = "Total inventory value";
        } catch {
          invValue.textContent = "\u2014";
        }
        try {
          const total = await PlayersService.getGardenValue(p.id);
          gardenValue.textContent = `${NF_US_INT.format(Math.round(total))}`;
          gardenValue.title = "Total garden value";
        } catch {
          gardenValue.textContent = "\u2014";
        }
      })();
    }
    let players = [];
    let lastSig = "";
    function signature(ps) {
      return ps.map(
        (p) => `${p.id}|${p.name ?? ""}|${p.isConnected ? 1 : 0}|${p.inventory?.items?.length ?? 0}`
      ).join(";");
    }
    async function refreshAll(keepSelection = true) {
      const prevSel = vt.getSelected()?.id ?? null;
      const next = await readPlayers();
      const sig = signature(next);
      if (sig === lastSig) {
        return;
      }
      lastSig = sig;
      players = next;
      vt.setItems(players.map(vItem));
      const sel = keepSelection && prevSel && players.some((p) => p.id === prevSel) ? prevSel : players[0]?.id ?? null;
      if (sel !== null) vt.select(sel);
      else renderRight(null);
    }
    await PlayersService.onChange(() => {
      refreshAll(true).catch(() => {
      });
    });
    await refreshAll(true);
  }

  // src/ui/menus/calculator.ts
  var ROOT_CLASS = "mg-crop-simulation";
  var SIZE_MIN = 50;
  var SIZE_MAX = 100;
  var SCALE_MIN = 1;
  var SCALE_MAX = 3;
  var COLOR_MUTATION_LABELS = ["None", "Gold", "Rainbow"];
  var WEATHER_CONDITION_LABELS = ["None", "Wet", "Chilled", "Frozen"];
  var WEATHER_LIGHTING_LABELS = ["None", "Dawnlit", "Dawnbound", "Amberlit", "Amberbound"];
  var FRIEND_BONUS_LABELS = ["+0%", "+10%", "+20%", "+30%", "+40%", "+50%"];
  var FRIEND_BONUS_MIN_PLAYERS = 1;
  var FRIEND_BONUS_MAX_PLAYERS = FRIEND_BONUS_LABELS.length;
  var COLOR_SEGMENT_METADATA = {
    None: { mgColor: "none" },
    Gold: { mgColor: "gold" },
    Rainbow: { mgColor: "rainbow" }
  };
  var WEATHER_CONDITION_SEGMENT_METADATA = {
    None: { mgWeather: "none" },
    Wet: { mgWeather: "wet" },
    Chilled: { mgWeather: "chilled" },
    Frozen: { mgWeather: "frozen" }
  };
  var WEATHER_LIGHTING_SEGMENT_METADATA = {
    None: { mgLighting: "none" },
    Dawnlit: { mgLighting: "dawnlit" },
    Dawnbound: { mgLighting: "dawnbound" },
    Amberlit: { mgLighting: "amberlit" },
    Amberbound: { mgLighting: "amberbound" }
  };
  var segmentedUi = new Menu({ compact: true });
  var ensureMenuStyles = segmentedUi.ensureStyles;
  ensureMenuStyles?.call(segmentedUi);
  var priceFormatter = new Intl.NumberFormat("en-US");
  var weightFormatter = new Intl.NumberFormat("en-US", {
    minimumFractionDigits: 3,
    maximumFractionDigits: 3
  });
  var DEFAULT_STATE = {
    sizePercent: SIZE_MIN,
    color: "None",
    weatherCondition: "None",
    weatherLighting: "None",
    friendPlayers: FRIEND_BONUS_MIN_PLAYERS
  };
  var BASE_SPRITE_SIZE_PX = 96;
  var WEATHER_EFFECT_PRIORITY = ["wet", "chilled", "frozen"];
  var LIGHTING_EFFECT_PRIORITY_GROUPS = [
    ["dawnlit"],
    ["dawnbound", "dawncharged", "dawn radiant", "dawnradiant", "dawn-radiant"],
    ["ambershine", "amberlit"],
    ["amberbound", "ambercharged", "amber radiant", "amberradiant", "amber-radiant"]
  ];
  var EFFECTS_CONFIG = {
    Wet: {
      blendMode: "source-atop",
      colors: ["rgb(128, 128, 255)"],
      alpha: 0.2
    },
    Chilled: {
      blendMode: "source-atop",
      colors: ["rgb(183, 183, 236)"],
      alpha: 0.5
    },
    Frozen: {
      blendMode: "source-atop",
      colors: ["rgb(128, 128, 255)"],
      alpha: 0.6
    },
    Dawnlit: {
      blendMode: "source-atop",
      colors: ["rgb(120, 100, 180)"],
      alpha: 0.4
    },
    Ambershine: {
      blendMode: "source-atop",
      colors: ["rgb(255, 140, 26)", "rgb(230, 92, 26)", "rgb(178, 58, 26)"],
      alpha: 0.5
    },
    Dawncharged: {
      blendMode: "source-atop",
      colors: ["rgb(100, 80, 160)", "rgb(110, 90, 170)", "rgb(120, 100, 180)"],
      alpha: 0.5
    },
    Ambercharged: {
      blendMode: "source-atop",
      colors: ["rgb(167, 50, 30)", "rgb(177, 60, 40)", "rgb(187, 70, 50)"],
      alpha: 0.5
    }
  };
  var EFFECT_PRIORITY_BY_LOWER_NAME = (() => {
    const map2 = /* @__PURE__ */ new Map();
    WEATHER_EFFECT_PRIORITY.forEach((name, index) => {
      map2.set(name.toLowerCase(), index);
    });
    let offset = WEATHER_EFFECT_PRIORITY.length;
    LIGHTING_EFFECT_PRIORITY_GROUPS.forEach((group) => {
      group.forEach((name) => {
        map2.set(name.toLowerCase(), offset);
      });
      offset += 1;
    });
    return map2;
  })();
  var LIGHTING_EFFECT_NAMES_LOWER = /* @__PURE__ */ new Set([
    "dawnlit",
    "dawncharged",
    "ambershine",
    "ambercharged"
  ]);
  var EFFECT_TOKEN_ALIASES = /* @__PURE__ */ new Map([
    ["wet", "Wet"],
    ["damp", "Wet"],
    ["moist", "Wet"],
    ["chilled", "Chilled"],
    ["cold", "Chilled"],
    ["frozen", "Frozen"],
    ["ice", "Frozen"],
    ["icy", "Frozen"],
    ["dawnlit", "Dawnlit"],
    ["dawn-lit", "Dawnlit"],
    ["dawnbound", "Dawnlit"],
    ["dawn-bound", "Dawnlit"],
    ["dawncharged", "Dawncharged"],
    ["dawn-charged", "Dawncharged"],
    ["dawn radiant", "Dawncharged"],
    ["dawnradiant", "Dawncharged"],
    ["dawn-radiant", "Dawncharged"],
    ["ambershine", "Ambershine"],
    ["amber-shine", "Ambershine"],
    ["amberlit", "Ambershine"],
    ["amber-lit", "Ambershine"],
    ["amberbound", "Ambercharged"],
    ["amber-bound", "Ambercharged"],
    ["ambercharged", "Ambercharged"],
    ["amber-charged", "Ambercharged"],
    ["amber radiant", "Ambercharged"],
    ["amberradiant", "Ambercharged"],
    ["amber-radiant", "Ambercharged"]
  ]);
  var EFFECT_NAME_BY_TOKEN = (() => {
    const map2 = /* @__PURE__ */ new Map();
    Object.keys(EFFECTS_CONFIG).forEach((key2) => {
      map2.set(key2.toLowerCase(), key2);
    });
    EFFECT_TOKEN_ALIASES.forEach((value, key2) => {
      map2.set(key2, value);
    });
    return map2;
  })();
  var WEATHER_LABEL_NORMALIZATION = (() => {
    const map2 = /* @__PURE__ */ new Map();
    const entries = tileRefsMutationLabels;
    for (const [key2, value] of Object.entries(entries)) {
      if (typeof key2 !== "string" || typeof value !== "string") continue;
      map2.set(key2.toLowerCase(), value);
      map2.set(value.toLowerCase(), value);
    }
    return map2;
  })();
  var TALL_PLANT_SEEDS2 = /* @__PURE__ */ new Set(["Bamboo", "Cactus"]);
  var mutationMetadataByNormalizedName = (() => {
    const map2 = /* @__PURE__ */ new Map();
    const catalog = mutationCatalog;
    for (const [key2, value] of Object.entries(catalog)) {
      if (typeof key2 !== "string" || !key2.trim()) continue;
      const label2 = typeof value?.name === "string" && value.name.trim().length > 0 ? value.name : key2;
      const tileRef = typeof value?.tileRef === "number" ? value.tileRef : null;
      const category = tileRef != null ? "weather" : "color";
      const info = {
        id: key2,
        label: label2,
        tileRef,
        category
      };
      map2.set(key2.toLowerCase(), info);
      map2.set(label2.toLowerCase(), info);
    }
    const tileRefLabels = tileRefsMutationLabels;
    for (const [key2, value] of Object.entries(tileRefLabels)) {
      if (typeof key2 !== "string" || typeof value !== "string") continue;
      const info = map2.get(key2.toLowerCase());
      if (!info) continue;
      const normalizedLabel = value.toLowerCase();
      if (!map2.has(normalizedLabel)) {
        map2.set(normalizedLabel, info);
      }
    }
    const goldInfo = map2.get("gold");
    if (goldInfo) {
      map2.set("golden", goldInfo);
    }
    const normalInfo = {
      id: "Normal",
      label: "Normal",
      tileRef: null,
      category: "color"
    };
    map2.set("normal", normalInfo);
    return map2;
  })();
  var plantSpriteCache2 = /* @__PURE__ */ new Map();
  var plantSpritePromises2 = /* @__PURE__ */ new Map();
  var plantSpriteCanvasCache = /* @__PURE__ */ new Map();
  var plantSpriteCanvasPromises = /* @__PURE__ */ new Map();
  var plantSpriteVariantCache = /* @__PURE__ */ new Map();
  var plantSpriteVariantPromises = /* @__PURE__ */ new Map();
  var plantSpriteEffectVariantCache = /* @__PURE__ */ new Map();
  var plantSpriteEffectVariantPromises = /* @__PURE__ */ new Map();
  var mutationSpriteCache2 = /* @__PURE__ */ new Map();
  var mutationSpritePromises2 = /* @__PURE__ */ new Map();
  var spriteUpdateSeq = 0;
  var CROP_SIMULATION_CSS = `
.${ROOT_CLASS} {
  display: none;
  width: min(100%, 500px);
  padding: 12px 14px;
  color: #e2e8f0;
  display: flex;
  flex-direction: column;
  gap: 10px;
  font-family: "Inter", system-ui, -apple-system, "Segoe UI", sans-serif;
  position: relative;
  z-index: 2000;
  pointer-events: auto;
}
.${ROOT_CLASS} .mg-crop-simulation__header {
  display: flex;
  align-items: baseline;
  justify-content: space-between;
  gap: 8px;
}
.${ROOT_CLASS} .mg-crop-simulation__title {
  font-size: 13px;
  font-weight: 600;
  letter-spacing: 0.03em;
  text-transform: uppercase;
  color: #f8fafc;
}
.${ROOT_CLASS} .mg-crop-simulation__crop-name {
  font-size: 13px;
  font-weight: 600;
  color: #38bdf8;
  text-transform: capitalize;
}
.${ROOT_CLASS} .mg-crop-simulation__sprite-section {
  display: flex;
  flex-direction: column;
}
.${ROOT_CLASS} .mg-crop-simulation__sprite-box {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 12px;
}
.${ROOT_CLASS} .mg-crop-simulation__sprite {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: ${BASE_SPRITE_SIZE_PX}px;
  height: ${BASE_SPRITE_SIZE_PX}px;
  position: relative;
  flex-shrink: 0;
  --mg-crop-simulation-scale: 1;
  transform-origin: center;
  transform: scale(var(--mg-crop-simulation-scale));
}
.${ROOT_CLASS} .mg-crop-simulation__sprite-layer,
.${ROOT_CLASS} .mg-crop-simulation__sprite-fallback {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
}
.${ROOT_CLASS} .mg-crop-simulation__sprite-layer img {
  width: 100%;
  height: 100%;
  object-fit: contain;
  image-rendering: pixelated;
}
.${ROOT_CLASS} .mg-crop-simulation__sprite-layer--base {
  z-index: 1;
}
.${ROOT_CLASS} .mg-crop-simulation__sprite-layer--overlay {
  z-index: 2;
  transform: translateY(-4px);
}
.${ROOT_CLASS} .mg-crop-simulation__sprite-layer--overlay-lighting {
  transform: translateY(-30px);
}
.${ROOT_CLASS} .mg-crop-simulation__sprite-fallback {
  z-index: 0;
  font-size: 42px;
}
.${ROOT_CLASS} .mg-crop-simulation__slider-container {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  gap: 6px;
}
.${ROOT_CLASS} .mg-crop-simulation__slider-row {
  display: flex;
  align-items: center;
  gap: 8px;
}
.${ROOT_CLASS} .mg-crop-simulation__slider-label {
  font-size: 12px;
  color: rgba(226, 232, 240, 0.82);
  flex: 0 0 auto;
}
.${ROOT_CLASS} .mg-crop-simulation__slider-value {
  margin-left: auto;
  font-size: 12px;
  font-variant-numeric: tabular-nums;
  color: #f8fafc;
  text-align: right;
  width: 4ch;
  min-width: 4ch;
  flex: 0 0 4ch;
  white-space: nowrap;
}
.${ROOT_CLASS} .mg-crop-simulation__slider-weight {
  font-size: 11px;
  color: rgba(148, 163, 184, 0.82);
  font-variant-numeric: tabular-nums;
  text-align: center;
  white-space: nowrap;
}
.${ROOT_CLASS} .mg-crop-simulation__slider {
  flex: 1 1 auto;
  min-width: 0;
  accent-color: #38bdf8;
}
.${ROOT_CLASS} .mg-crop-simulation__price {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  font-weight: 700;
  font-size: 14px;
  color: #ffd84d;
  align-self: flex-start;
  margin-top: auto;
}
.${ROOT_CLASS} .mg-crop-simulation__price-icon {
  width: 20px;
  height: 20px;
  flex: 0 0 auto;
  display: inline-block;
  user-select: none;
  pointer-events: none;
}
.${ROOT_CLASS} .mg-crop-simulation__price-value {
  line-height: 1;
}
.${ROOT_CLASS} .mg-crop-simulation__section-title {
  font-size: 11px;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  color: rgba(148, 163, 184, 0.9);
}
.${ROOT_CLASS}.mg-crop-simulation--calculator {
  align-items: center;
}
.${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-calculator__layout {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  gap: 12px;
  width: min(440px, 100%);
  margin: 0 auto;
}
.${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-calculator__section {
  display: grid;
  gap: 10px;
  padding: 12px;
  border-radius: 12px;
  border: 1px solid #4446;
  background: #1f2328;
  box-shadow: 0 0 0 1px #0002 inset;
  justify-items: stretch;
}
.${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-calculator__section-heading {
  font-size: 11px;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  color: rgba(226, 232, 240, 0.82);
  font-weight: 600;
  text-align: center;
}
.${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-calculator__section--preview {
  justify-items: center;
  text-align: center;
}
.${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-calculator__section--preview .mg-crop-simulation__slider-row {
  width: 100%;
}
.${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-calculator__mutations-weather {
  display: grid;
  gap: 8px;
}
.${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-calculator__mutations-heading {
  font-size: 10px;
  letter-spacing: 0.05em;
  text-transform: uppercase;
  color: rgba(148, 163, 184, 0.82);
  text-align: center;
}
.${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-simulation__price {
  margin-top: 0;
}
.${ROOT_CLASS} .mg-crop-simulation__segmented {
  display: flex;
  width: 100%;
}
.${ROOT_CLASS} .mg-crop-simulation__segmented-control {
  --qmm-bg-soft: rgba(11, 15, 19, 0.8);
  --qmm-border-2: rgba(148, 163, 184, 0.28);
  --qmm-text: #e2e8f0;
  --qmm-text-dim: rgba(148, 163, 184, 0.82);
  --seg-pad: 6px;
  --seg-fill: rgba(56, 191, 248, 0.02);
  --seg-stroke-color: rgba(255, 255, 255, 0.49);
  flex: 1 1 auto;
  min-width: 0;
  width: 100%;
}
.${ROOT_CLASS} .mg-crop-simulation__segmented-control .qmm-seg__btn {
  font-size: 11px;
  letter-spacing: 0.02em;
  font-weight: 600;
  flex: 1 1 0;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  min-width: 0;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="none"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="none"].active {
  color: rgba(148, 163, 184, 0.92);
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="gold"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="gold"].active {
  color: #facc15;
  font-weight: 700;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="gold"] .qmm-seg__btn-label,
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="gold"].active .qmm-seg__btn-label {
  color: transparent;
  background-image: linear-gradient(90deg, #fef08a, #facc15, #fef08a);
  background-clip: text;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-size: 100% 100%;
  background-repeat: no-repeat;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="rainbow"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="rainbow"].active {
  color: #fbbf24;
  font-weight: 700;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="rainbow"] .qmm-seg__btn-label,
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="rainbow"].active .qmm-seg__btn-label {
  color: transparent;
  background-image: linear-gradient(90deg, #f87171, #fbbf24, #34d399, #38bdf8, #c084fc);
  background-clip: text;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-size: 100% 100%;
  background-repeat: no-repeat;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-weather="none"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-weather="none"].active,
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="none"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="none"].active {
  color: rgba(148, 163, 184, 0.92);
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-weather="wet"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-weather="wet"].active {
  color: #5AF6F5;
  font-weight: 700;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-weather="chilled"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-weather="chilled"].active {
  color: #AFE0F6;
  font-weight: 700;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-weather="frozen"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-weather="frozen"].active {
  color: #AABEFF;
  font-weight: 700;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="dawnlit"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="dawnlit"].active {
  color: #7864B4;
  font-weight: 700;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="dawnbound"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="dawnbound"].active {
  color: #9785CB;
  font-weight: 700;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="amberlit"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="amberlit"].active {
  color: #A04632;
  font-weight: 700;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="amberbound"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="amberbound"].active {
  color: #F06E50;
  font-weight: 700;
}
.${ROOT_CLASS} .mg-crop-simulation__mutations-section {
  display: flex;
  flex-direction: column;
  gap: 6px;
}
`;
  var cropSimulationStyleEl = null;
  function ensureCropSimulationStyles() {
    if (cropSimulationStyleEl) return;
    cropSimulationStyleEl = addStyle(CROP_SIMULATION_CSS);
  }
  function resolveEffectNameToken(value) {
    if (typeof value !== "string") return null;
    const normalized = value.trim().toLowerCase();
    if (!normalized) return null;
    return EFFECT_NAME_BY_TOKEN.get(normalized) ?? null;
  }
  function getMutationEffectName(mutation) {
    return resolveEffectNameToken(mutation.id) ?? resolveEffectNameToken(mutation.label);
  }
  function getEffectPriority(effectName) {
    const lower = effectName.toLowerCase();
    return EFFECT_PRIORITY_BY_LOWER_NAME.get(lower) ?? Number.MAX_SAFE_INTEGER;
  }
  function isLightingEffect(effectName) {
    return LIGHTING_EFFECT_NAMES_LOWER.has(effectName.toLowerCase());
  }
  function normalizeEffectNames(effectNames) {
    const seen = /* @__PURE__ */ new Set();
    const order = /* @__PURE__ */ new Map();
    const normalized = [];
    effectNames.forEach((name, index) => {
      if (seen.has(name)) return;
      seen.add(name);
      normalized.push(name);
      order.set(name, index);
    });
    normalized.sort((a, b) => {
      const priorityDiff = getEffectPriority(a) - getEffectPriority(b);
      if (priorityDiff !== 0) return priorityDiff;
      return (order.get(a) ?? 0) - (order.get(b) ?? 0);
    });
    return normalized;
  }
  function getApplicableEffectNames(weatherMutations) {
    const effectNames = weatherMutations.map((mutation) => getMutationEffectName(mutation)).filter((value) => value != null);
    return normalizeEffectNames(effectNames);
  }
  function makeEffectCacheKey(seedKey, variant, effectNames) {
    return `${seedKey}::variant::${variant}::effects::${effectNames.join("+")}`;
  }
  function getMutationSheetBases() {
    const urls = /* @__PURE__ */ new Set();
    try {
      Sprites.listTilesByCategory(/mutations/i).forEach((url) => urls.add(url));
    } catch {
    }
    const bases = Array.from(urls, (url) => {
      const clean = url.split(/[?#]/)[0] ?? url;
      const file = clean.split("/").pop() ?? clean;
      return file.replace(/\.[^.]+$/, "");
    });
    return bases.length ? bases : ["mutations"];
  }
  async function fetchPlantSpriteCanvas(seedKey) {
    if (typeof window === "undefined") return null;
    const entry = plantCatalog[seedKey];
    if (!entry) return null;
    const tileRef = entry?.crop?.tileRef ?? entry?.plant?.tileRef ?? entry?.seed?.tileRef;
    const bases = plantSheetBases2(seedKey);
    const index = toTileIndex4(tileRef, bases);
    if (index == null) return null;
    for (const base of bases) {
      try {
        const tile = await Sprites.getTile(base, index, "canvas");
        const canvas = tile?.data;
        if (canvas && canvas.width > 0 && canvas.height > 0) {
          const copy2 = document.createElement("canvas");
          copy2.width = canvas.width;
          copy2.height = canvas.height;
          const ctx = copy2.getContext("2d");
          if (!ctx) continue;
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(canvas, 0, 0);
          return copy2;
        }
      } catch {
      }
    }
    return null;
  }
  function loadPlantSpriteCanvas(seedKey) {
    const cached = plantSpriteCanvasCache.get(seedKey);
    if (cached !== void 0) return Promise.resolve(cached);
    const inFlight = plantSpriteCanvasPromises.get(seedKey);
    if (inFlight) return inFlight;
    const promise = fetchPlantSpriteCanvas(seedKey).then((canvas) => {
      plantSpriteCanvasCache.set(seedKey, canvas);
      plantSpriteCanvasPromises.delete(seedKey);
      return canvas;
    }).catch(() => {
      plantSpriteCanvasCache.set(seedKey, null);
      plantSpriteCanvasPromises.delete(seedKey);
      return null;
    });
    plantSpriteCanvasPromises.set(seedKey, promise);
    return promise;
  }
  async function loadPlantSpriteCanvasForVariant(seedKey, variant) {
    const canvas = await loadPlantSpriteCanvas(seedKey);
    if (!canvas) return null;
    if (variant === "normal") return canvas;
    const tileInfo = {
      sheet: "",
      url: "",
      index: 0,
      col: 0,
      row: 0,
      size: canvas.width,
      data: canvas
    };
    return variant === "gold" ? Sprites.effectGold(tileInfo) : Sprites.effectRainbow(tileInfo);
  }
  function loadPlantSpriteVariant(seedKey, variant) {
    if (variant === "normal") {
      return loadPlantSprite2(seedKey);
    }
    const cacheKey = `${seedKey}::${variant}`;
    const cached = plantSpriteVariantCache.get(cacheKey);
    if (cached !== void 0) return Promise.resolve(cached);
    const inFlight = plantSpriteVariantPromises.get(cacheKey);
    if (inFlight) return inFlight;
    const promise = loadPlantSpriteCanvasForVariant(seedKey, variant).then((canvas) => {
      if (!canvas) return null;
      return canvas.toDataURL();
    }).then((src) => {
      plantSpriteVariantCache.set(cacheKey, src ?? null);
      plantSpriteVariantPromises.delete(cacheKey);
      return src ?? null;
    }).catch(() => {
      plantSpriteVariantCache.set(cacheKey, null);
      plantSpriteVariantPromises.delete(cacheKey);
      return null;
    });
    plantSpriteVariantPromises.set(cacheKey, promise);
    return promise;
  }
  function loadMutationSprite2(mutation) {
    const tileRef = mutation.tileRef;
    if (tileRef == null) return Promise.resolve(null);
    const cacheKey = mutation.id.toLowerCase();
    const cached = mutationSpriteCache2.get(cacheKey);
    if (cached !== void 0) return Promise.resolve(cached);
    const inFlight = mutationSpritePromises2.get(cacheKey);
    if (inFlight) return inFlight;
    const promise = (async () => {
      const bases = getMutationSheetBases();
      const index = tileRef > 0 ? tileRef - 1 : tileRef;
      for (const base of bases) {
        try {
          const tile = await Sprites.getTile(base, index, "canvas");
          const canvas = tile?.data;
          if (canvas && canvas.width > 0 && canvas.height > 0) {
            const copy2 = document.createElement("canvas");
            copy2.width = canvas.width;
            copy2.height = canvas.height;
            const ctx = copy2.getContext("2d");
            if (!ctx) continue;
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(canvas, 0, 0);
            return copy2.toDataURL();
          }
        } catch {
        }
      }
      return null;
    })().then((src) => {
      mutationSpriteCache2.set(cacheKey, src);
      mutationSpritePromises2.delete(cacheKey);
      return src;
    }).catch(() => {
      mutationSpriteCache2.set(cacheKey, null);
      mutationSpritePromises2.delete(cacheKey);
      return null;
    });
    mutationSpritePromises2.set(cacheKey, promise);
    return promise;
  }
  function plantSheetBases2(seedKey) {
    const urls = /* @__PURE__ */ new Set();
    try {
      Sprites.listPlants().forEach((url) => urls.add(url));
    } catch {
    }
    try {
      Sprites.listAllPlants().forEach((url) => urls.add(url));
    } catch {
    }
    const bases = Array.from(urls, (url) => {
      const clean = url.split(/[?#]/)[0] ?? url;
      const file = clean.split("/").pop() ?? clean;
      return file.replace(/\.[^.]+$/, "");
    });
    if (!seedKey) return bases.length ? bases : ["plants"];
    const normalizedBases = bases.map((base) => base.toLowerCase());
    const findPreferred = (predicate) => bases.filter((base, index) => predicate(base, normalizedBases[index] ?? base.toLowerCase()));
    if (TALL_PLANT_SEEDS2.has(seedKey)) {
      const tallExact = findPreferred((_, norm3) => norm3 === "tallplants");
      if (tallExact.length) return tallExact;
      const tallAny = findPreferred((base, norm3) => /tall/.test(base) || /tall/.test(norm3));
      if (tallAny.length) return tallAny;
    } else {
      const plantsExact = findPreferred((_, norm3) => norm3 === "plants");
      if (plantsExact.length) return plantsExact;
      const nonTall = findPreferred((base, norm3) => !/tall/.test(base) && !/tall/.test(norm3));
      if (nonTall.length) return nonTall;
    }
    return bases.length ? bases : ["plants"];
  }
  function toTileIndex4(tileRef, bases = []) {
    const value = typeof tileRef === "number" && Number.isFinite(tileRef) ? tileRef : Number(tileRef);
    if (!Number.isFinite(value)) return null;
    if (value <= 0) return value;
    const normalizedBases = bases.map((base) => base.toLowerCase());
    if (normalizedBases.some((base) => base.includes("tall"))) {
      return value - 1;
    }
    if (normalizedBases.some((base) => base.includes("plants"))) {
      return value - 1;
    }
    return value - 1;
  }
  function loadPlantSprite2(seedKey) {
    const cached = plantSpriteCache2.get(seedKey);
    if (cached !== void 0) return Promise.resolve(cached);
    const inFlight = plantSpritePromises2.get(seedKey);
    if (inFlight) return inFlight;
    const promise = loadPlantSpriteCanvas(seedKey).then((canvas) => {
      const src = canvas ? canvas.toDataURL() : null;
      plantSpriteCache2.set(seedKey, src);
      plantSpritePromises2.delete(seedKey);
      return src;
    }).catch(() => {
      plantSpriteCache2.set(seedKey, null);
      plantSpritePromises2.delete(seedKey);
      return null;
    });
    plantSpritePromises2.set(seedKey, promise);
    return promise;
  }
  function sortMutationsForRendering(mutations) {
    const entries = mutations.map((mutation, index) => ({ mutation, index }));
    entries.sort((a, b) => {
      const effectA = getMutationEffectName(a.mutation);
      const effectB = getMutationEffectName(b.mutation);
      const priorityA = effectA ? getEffectPriority(effectA) : Number.MAX_SAFE_INTEGER;
      const priorityB = effectB ? getEffectPriority(effectB) : Number.MAX_SAFE_INTEGER;
      if (priorityA !== priorityB) {
        return priorityA - priorityB;
      }
      return a.index - b.index;
    });
    return entries.map((entry) => entry.mutation);
  }
  function applyEffectToCanvas(canvas, effect) {
    if (!effect.colors.length) return;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    ctx.save();
    ctx.imageSmoothingEnabled = false;
    ctx.globalCompositeOperation = effect.blendMode;
    ctx.globalAlpha = effect.alpha;
    if (effect.colors.length === 1) {
      ctx.fillStyle = effect.colors[0] ?? "transparent";
    } else {
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      const stops = effect.colors.length - 1;
      effect.colors.forEach((color, index) => {
        const stop = stops === 0 ? 0 : index / stops;
        gradient.addColorStop(stop, color);
      });
      ctx.fillStyle = gradient;
    }
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
  }
  function loadPlantSpriteWithEffects(seedKey, variant, effectNames) {
    const normalizedEffects = normalizeEffectNames(effectNames);
    if (!normalizedEffects.length) {
      return loadPlantSpriteVariant(seedKey, variant);
    }
    const cacheKey = makeEffectCacheKey(seedKey, variant, normalizedEffects);
    const cached = plantSpriteEffectVariantCache.get(cacheKey);
    if (cached !== void 0) return Promise.resolve(cached);
    const inFlight = plantSpriteEffectVariantPromises.get(cacheKey);
    if (inFlight) return inFlight;
    const promise = loadPlantSpriteCanvasForVariant(seedKey, variant).then((canvas) => {
      if (!canvas) return null;
      const copy2 = document.createElement("canvas");
      copy2.width = canvas.width;
      copy2.height = canvas.height;
      const ctx = copy2.getContext("2d");
      if (!ctx) return null;
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(canvas, 0, 0);
      normalizedEffects.forEach((effectName) => {
        const effect = EFFECTS_CONFIG[effectName];
        if (effect) {
          applyEffectToCanvas(copy2, effect);
        }
      });
      return copy2.toDataURL();
    }).then((src) => {
      plantSpriteEffectVariantCache.set(cacheKey, src ?? null);
      plantSpriteEffectVariantPromises.delete(cacheKey);
      return src ?? null;
    }).catch(() => {
      plantSpriteEffectVariantCache.set(cacheKey, null);
      plantSpriteEffectVariantPromises.delete(cacheKey);
      return null;
    });
    plantSpriteEffectVariantPromises.set(cacheKey, promise);
    return promise;
  }
  function getCachedPlantSpriteSource(seedKey, variant, effectNames) {
    const normalizedEffects = normalizeEffectNames(effectNames);
    if (normalizedEffects.length === 0) {
      if (variant === "normal") {
        return plantSpriteCache2.get(seedKey);
      }
      const variantCacheKey = `${seedKey}::${variant}`;
      return plantSpriteVariantCache.get(variantCacheKey);
    }
    const cacheKey = makeEffectCacheKey(seedKey, variant, normalizedEffects);
    return plantSpriteEffectVariantCache.get(cacheKey);
  }
  function isLightingOverlay(mutation) {
    const effectName = getMutationEffectName(mutation);
    if (!effectName) return false;
    return isLightingEffect(effectName);
  }
  function applySpriteElement(el2, baseSrc, overlayLayers, fallbackText) {
    el2.innerHTML = "";
    if (baseSrc) {
      const baseLayer = document.createElement("span");
      baseLayer.className = "mg-crop-simulation__sprite-layer mg-crop-simulation__sprite-layer--base";
      const img = document.createElement("img");
      img.src = baseSrc;
      img.alt = "";
      img.decoding = "async";
      img.loading = "lazy";
      img.draggable = false;
      baseLayer.appendChild(img);
      el2.appendChild(baseLayer);
    }
    overlayLayers.forEach(({ src, mutation }, index) => {
      const layer = document.createElement("span");
      layer.className = "mg-crop-simulation__sprite-layer mg-crop-simulation__sprite-layer--overlay";
      layer.style.setProperty("--mg-crop-simulation-layer", String(index + 1));
      if (isLightingOverlay(mutation)) {
        layer.classList.add("mg-crop-simulation__sprite-layer--overlay-lighting");
      }
      const img = document.createElement("img");
      img.src = src;
      img.alt = "";
      img.decoding = "async";
      img.loading = "lazy";
      img.draggable = false;
      layer.appendChild(img);
      el2.appendChild(layer);
    });
    if (!baseSrc && overlayLayers.length === 0) {
      const fallback = document.createElement("span");
      fallback.className = "mg-crop-simulation__sprite-fallback";
      const content = typeof fallbackText === "string" && fallbackText.trim().length > 0 ? fallbackText : "\u{1F331}";
      fallback.textContent = content;
      el2.appendChild(fallback);
    }
  }
  function setSpriteElement(el2, speciesKey, options) {
    spriteUpdateSeq += 1;
    const seq = spriteUpdateSeq;
    el2.dataset.spriteSeq = String(seq);
    if (!speciesKey) {
      applySpriteElement(el2, null, [], options.fallback ?? null);
      return;
    }
    const { colorVariant, weatherMutations } = options;
    const sortedMutations = sortMutationsForRendering(weatherMutations);
    const effectNames = colorVariant === "normal" ? getApplicableEffectNames(sortedMutations) : [];
    const cachedBase = getCachedPlantSpriteSource(speciesKey, colorVariant, effectNames);
    const cachedOverlays = sortedMutations.map((mutation) => {
      const src = mutationSpriteCache2.get(mutation.id.toLowerCase());
      return typeof src === "string" && src.length > 0 ? { mutation, src } : null;
    }).filter((value) => value != null);
    const baseSrcCached = typeof cachedBase === "string" ? cachedBase : null;
    applySpriteElement(el2, baseSrcCached, cachedOverlays, options.fallback ?? null);
    const basePromise = loadPlantSpriteWithEffects(speciesKey, colorVariant, effectNames);
    const overlayPromises = sortedMutations.map(async (mutation) => ({
      mutation,
      src: await loadMutationSprite2(mutation)
    }));
    Promise.all([basePromise, Promise.all(overlayPromises)]).then(([baseSrc, overlays]) => {
      if (el2.dataset.spriteSeq !== String(seq)) return;
      const overlaySources = overlays.filter(
        (entry) => typeof entry.src === "string" && entry.src.length > 0
      );
      applySpriteElement(el2, baseSrc ?? null, overlaySources, options.fallback ?? null);
    }).catch(() => {
      if (el2.dataset.spriteSeq !== String(seq)) return;
      applySpriteElement(el2, null, [], options.fallback ?? null);
    });
  }
  function labelToVariant(label2) {
    const normalized = typeof label2 === "string" ? label2.trim().toLowerCase() : "";
    if (normalized === "gold") return "gold";
    if (normalized === "rainbow") return "rainbow";
    return "normal";
  }
  function normalizeMutationName2(name) {
    if (typeof name !== "string") return null;
    const trimmed = name.trim();
    if (!trimmed) return null;
    const normalized = trimmed.toLowerCase();
    const info = mutationMetadataByNormalizedName.get(normalized);
    if (info) {
      return info;
    }
    const normalizedLabel = WEATHER_LABEL_NORMALIZATION.get(normalized);
    if (normalizedLabel) {
      const fallback = mutationMetadataByNormalizedName.get(normalizedLabel.toLowerCase());
      if (fallback) {
        return fallback;
      }
    }
    return {
      id: trimmed,
      label: trimmed,
      tileRef: null,
      category: "weather"
    };
  }
  function applyCropSimulationSprite(el2, speciesKey, options = {}) {
    const colorLabel = options.colorLabel ?? "None";
    const colorVariant = labelToVariant(colorLabel);
    const weatherLabels = Array.isArray(options.weatherLabels) ? options.weatherLabels : [];
    const seen = /* @__PURE__ */ new Set();
    const weatherMutations = [];
    for (const label2 of weatherLabels) {
      if (!label2 || typeof label2 !== "string") continue;
      const info = normalizeMutationName2(label2);
      if (!info || info.category !== "weather") continue;
      const key2 = info.id.toLowerCase();
      if (seen.has(key2)) continue;
      seen.add(key2);
      weatherMutations.push(info);
    }
    setSpriteElement(el2, speciesKey, {
      colorVariant,
      weatherMutations,
      fallback: options.fallback ?? null
    });
  }
  var applyStyles2 = (el2, styles) => {
    const toKebab = (s) => s.startsWith("--") ? s : s.replace(/[A-Z]/g, (m) => "-" + m.toLowerCase());
    for (const [key2, value] of Object.entries(styles)) {
      el2.style.setProperty(toKebab(key2), value);
    }
    return el2;
  };
  var calculatorStyleEl = null;
  function ensureCalculatorStyles() {
    ensureCropSimulationStyles();
    if (calculatorStyleEl) return;
    calculatorStyleEl = addStyle(`
    .${ROOT_CLASS}.mg-crop-simulation--calculator {
      width: 100%;
      max-width: none;
      min-width: 0;
      position: relative;
    }
    .${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-simulation__price {
      justify-content: center;
      margin: 0 0 12px;
      font-size: 20px;
      gap: 10px;
    }
    .${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-simulation__price-value {
      font-size: 20px;
    }
    .mg-crop-calculator__placeholder {
      font-size: 13px;
      text-align: center;
      opacity: 0.7;
      padding: 24px 12px;
    }
  `);
  }
  function clamp3(value, min, max) {
    return Math.min(max, Math.max(min, value));
  }
  function coerceLabel(label2, allowed) {
    const normalized = typeof label2 === "string" ? label2.trim().toLowerCase() : "";
    for (const candidate of allowed) {
      if (candidate.toLowerCase() === normalized) {
        return candidate;
      }
    }
    return allowed[0];
  }
  function clampFriendPlayers(players) {
    if (typeof players !== "number" || !Number.isFinite(players)) {
      return FRIEND_BONUS_MIN_PLAYERS;
    }
    const rounded = Math.round(players);
    return clamp3(rounded, FRIEND_BONUS_MIN_PLAYERS, FRIEND_BONUS_MAX_PLAYERS);
  }
  function friendPlayersToLabel(players) {
    const clamped = clampFriendPlayers(players);
    return FRIEND_BONUS_LABELS[clamped - 1] ?? FRIEND_BONUS_LABELS[0];
  }
  function labelToFriendPlayers(label2) {
    const coerced = coerceLabel(label2, FRIEND_BONUS_LABELS);
    const index = FRIEND_BONUS_LABELS.indexOf(coerced);
    const players = index >= 0 ? index + 1 : FRIEND_BONUS_MIN_PLAYERS;
    return clamp3(players, FRIEND_BONUS_MIN_PLAYERS, FRIEND_BONUS_MAX_PLAYERS);
  }
  function setSpriteScale(el2, sizePercent) {
    const clamped = clamp3(Math.round(sizePercent), SIZE_MIN, SIZE_MAX);
    const scale = clamped / 100;
    el2.style.setProperty("--mg-crop-simulation-scale", scale.toString());
  }
  function applySizePercent(refs, sizePercent, maxScale, baseWeight) {
    const clamped = clamp3(Math.round(sizePercent), SIZE_MIN, SIZE_MAX);
    refs.sizeSlider.value = String(clamped);
    refs.sizeValue.textContent = `${clamped}%`;
    setSpriteScale(refs.sprite, clamped);
    if (typeof maxScale === "number" && Number.isFinite(maxScale) && maxScale > SCALE_MIN) {
      refs.sizeSlider.dataset.maxScale = String(maxScale);
    } else {
      delete refs.sizeSlider.dataset.maxScale;
    }
    const [minWeight, maxWeight] = computeWeightRange(baseWeight, clamped, maxScale);
    refs.sizeWeight.textContent = formatWeightRange(minWeight, maxWeight);
  }
  function formatCoinValue(value) {
    if (typeof value !== "number" || !Number.isFinite(value)) return "\u2014";
    const safe = Math.max(0, Math.round(value));
    return priceFormatter.format(safe);
  }
  function formatCoinRange(min, max) {
    const minValue = typeof min === "number" && Number.isFinite(min) ? Math.max(0, min) : null;
    const maxValue = typeof max === "number" && Number.isFinite(max) ? Math.max(0, max) : null;
    if (minValue == null && maxValue == null) return "\u2014";
    if (minValue == null) return formatCoinValue(maxValue);
    if (maxValue == null) return formatCoinValue(minValue);
    if (Math.round(minValue) === Math.round(maxValue)) {
      return formatCoinValue(minValue);
    }
    return `${formatCoinValue(minValue)} \u2013 ${formatCoinValue(maxValue)}`;
  }
  function computeWeightRange(baseWeight, sizePercent, maxScale) {
    const numericWeight = typeof baseWeight === "number" ? baseWeight : Number(baseWeight);
    if (!Number.isFinite(numericWeight) || numericWeight == null || numericWeight <= 0) {
      return [null, null];
    }
    const scale = sizePercentToScale(sizePercent, maxScale);
    if (!Number.isFinite(scale) || scale <= 0) {
      return [null, null];
    }
    const minWeight = numericWeight * scale;
    const safeMax = typeof maxScale === "number" && Number.isFinite(maxScale) && maxScale > SCALE_MIN ? maxScale : SCALE_MIN;
    const variation = 1 + Math.max(0, (safeMax - scale) * 0.02);
    const maxWeight = minWeight * variation;
    return [minWeight, maxWeight];
  }
  function formatWeight(value) {
    if (typeof value !== "number" || !Number.isFinite(value) || value <= 0) return null;
    const formatted = weightFormatter.format(value);
    return formatted.replace(/(\.\d*?[1-9])0+$/u, "$1").replace(/\.0+$/u, "");
  }
  function formatWeightRange(min, max) {
    const minFormatted = formatWeight(min);
    const maxFormatted = formatWeight(max);
    if (!minFormatted && !maxFormatted) return "\u2014";
    if (!maxFormatted || minFormatted === maxFormatted) {
      return `${minFormatted ?? maxFormatted} kg`;
    }
    return `${minFormatted ?? "\u2014"} \u2013 ${maxFormatted} kg`;
  }
  function sizePercentToScale(sizePercent, maxScale) {
    const numeric = Number(sizePercent);
    if (!Number.isFinite(numeric)) return SCALE_MIN;
    const clampedPercent = clamp3(numeric, SIZE_MIN, SIZE_MAX);
    const safeMax = typeof maxScale === "number" && Number.isFinite(maxScale) && maxScale > SCALE_MIN ? maxScale : SCALE_MAX;
    if (safeMax <= SCALE_MIN) return SCALE_MIN;
    const normalized = (clampedPercent - SIZE_MIN) / (SIZE_MAX - SIZE_MIN);
    const scale = SCALE_MIN + normalized * (safeMax - SCALE_MIN);
    return Number.isFinite(scale) ? scale : SCALE_MIN;
  }
  function createSegmentedControl(labels, selectedLabel, interactive, onSelect, ariaLabel) {
    const coerced = coerceLabel(selectedLabel, labels);
    const items = labels.map((label2) => ({ value: label2, label: label2, disabled: !interactive }));
    const segmented = segmentedUi.segmented(
      items,
      coerced,
      interactive && onSelect ? (value) => onSelect(value) : void 0,
      { ariaLabel, fullWidth: true }
    );
    segmented.classList.add("mg-crop-simulation__segmented-control");
    return segmented;
  }
  function applySegmentedButtonMetadata(segmented, metadata) {
    const buttons = segmented.querySelectorAll(".qmm-seg__btn");
    buttons.forEach((button) => {
      const label2 = button.textContent?.trim();
      if (!label2) return;
      const meta = metadata[label2];
      if (!meta) return;
      Object.entries(meta).forEach(([key2, value]) => {
        if (!value) return;
        button.dataset[key2] = value;
      });
    });
  }
  function getMutationsForState(state2) {
    const mutations = [];
    if (state2.color !== "None") mutations.push(state2.color);
    if (state2.weatherCondition !== "None") mutations.push(state2.weatherCondition);
    if (state2.weatherLighting !== "None") mutations.push(state2.weatherLighting);
    return mutations;
  }
  function getWeatherLabelsForState(state2) {
    const labels = [];
    if (state2.weatherCondition !== "None") labels.push(state2.weatherCondition);
    if (state2.weatherLighting !== "None") labels.push(state2.weatherLighting);
    return labels;
  }
  function computePrice(speciesKey, state2, percent, maxScale) {
    const scale = sizePercentToScale(percent, maxScale);
    if (!Number.isFinite(scale) || scale <= 0) return null;
    const mutations = getMutationsForState(state2);
    const friendPlayers = clampFriendPlayers(state2.friendPlayers);
    const pricingOptions = { ...DefaultPricing, friendPlayers };
    const value = estimateProduceValue(speciesKey, scale, mutations, pricingOptions);
    return Number.isFinite(value) && value > 0 ? value : null;
  }
  function getMaxScaleForSpecies(key2) {
    const entry = plantCatalog[key2];
    const candidates = [entry?.crop?.maxScale, entry?.plant?.maxScale, entry?.seed?.maxScale];
    for (const candidate of candidates) {
      const numeric = typeof candidate === "number" ? candidate : Number(candidate);
      if (Number.isFinite(numeric) && numeric > 0) {
        return numeric;
      }
    }
    return null;
  }
  function getBaseWeightForSpecies(key2) {
    const entry = plantCatalog[key2];
    const candidates = [
      entry?.produce?.baseWeight,
      entry?.crop?.baseWeight,
      entry?.item?.baseWeight,
      entry?.seed?.baseWeight
    ];
    for (const candidate of candidates) {
      const numeric = typeof candidate === "number" ? candidate : Number(candidate);
      if (Number.isFinite(numeric) && numeric > 0) {
        return numeric;
      }
    }
    return null;
  }
  async function renderCalculatorMenu(container) {
    ensureCalculatorStyles();
    scheduleLockerSpritePreload();
    const ui = new Menu({ id: "calculator", compact: true });
    ui.addTab("crops", "Crops", (root) => {
      root.innerHTML = "";
      root.style.padding = "8px";
      root.style.boxSizing = "border-box";
      root.style.height = "61vh";
      root.style.overflow = "auto";
      root.style.display = "grid";
      const layout = applyStyles2(document.createElement("div"), {
        display: "grid",
        gridTemplateColumns: "minmax(220px, 280px) minmax(0, 1fr)",
        gap: "10px",
        alignItems: "stretch",
        height: "100%",
        overflow: "hidden"
      });
      root.appendChild(layout);
      const left = applyStyles2(document.createElement("div"), {
        display: "grid",
        gridTemplateRows: "minmax(0, 1fr)",
        minHeight: "0",
        flex: "0 0 260px",
        minWidth: "220px",
        maxWidth: "280px"
      });
      layout.appendChild(left);
      const list = applyStyles2(document.createElement("div"), {
        display: "grid",
        gridTemplateColumns: "1fr",
        overflow: "auto",
        paddingRight: "2px",
        border: "1px solid #4445",
        borderRadius: "10px",
        minHeight: "0",
        // important
        height: "100%"
        // pour que overflow: auto prenne effet
      });
      left.appendChild(list);
      const right = applyStyles2(document.createElement("div"), {
        display: "flex",
        flexDirection: "column",
        minHeight: "0",
        flex: "1 1 auto"
      });
      layout.appendChild(right);
      const detailScroll = applyStyles2(document.createElement("div"), {
        flex: "1 1 auto",
        overflow: "auto",
        display: "flex",
        justifyContent: "center"
      });
      right.appendChild(detailScroll);
      const simulationRoot = document.createElement("div");
      simulationRoot.className = `${ROOT_CLASS} mg-crop-simulation--visible mg-crop-simulation--calculator`;
      const detailLayout = document.createElement("div");
      detailLayout.className = "mg-crop-calculator__layout";
      const createSection = (title, extraClass) => {
        const section = document.createElement("div");
        section.className = "mg-crop-calculator__section";
        if (extraClass) {
          section.classList.add(extraClass);
        }
        if (title) {
          const heading = document.createElement("div");
          heading.className = "mg-crop-calculator__section-heading";
          heading.textContent = title;
          section.appendChild(heading);
        }
        return section;
      };
      const previewSection = createSection(null, "mg-crop-calculator__section--preview");
      const priceRow = document.createElement("div");
      priceRow.className = "mg-crop-simulation__price";
      const priceIcon = document.createElement("img");
      priceIcon.className = "mg-crop-simulation__price-icon";
      priceIcon.src = coin.img64;
      priceIcon.alt = "";
      priceIcon.decoding = "async";
      priceIcon.loading = "lazy";
      priceIcon.setAttribute("aria-hidden", "true");
      priceIcon.draggable = false;
      const priceValue = document.createElement("span");
      priceValue.className = "mg-crop-simulation__price-value";
      priceValue.textContent = "\u2014";
      priceRow.append(priceIcon, priceValue);
      const spriteSection = document.createElement("div");
      spriteSection.className = "mg-crop-simulation__sprite-section";
      const spriteBox = document.createElement("div");
      spriteBox.className = "mg-crop-simulation__sprite-box";
      const sprite = document.createElement("span");
      sprite.className = "mg-crop-simulation__sprite";
      spriteBox.appendChild(sprite);
      const sliderContainer = document.createElement("div");
      sliderContainer.className = "mg-crop-simulation__slider-container";
      const sliderRow = document.createElement("div");
      sliderRow.className = "mg-crop-simulation__slider-row";
      const sliderLabel = document.createElement("span");
      sliderLabel.className = "mg-crop-simulation__slider-label";
      sliderLabel.textContent = "Size";
      const slider = ui.slider(SIZE_MIN, SIZE_MAX, 1, SIZE_MIN);
      slider.classList.add("mg-crop-simulation__slider");
      slider.disabled = true;
      const sliderValue = document.createElement("span");
      sliderValue.className = "mg-crop-simulation__slider-value";
      sliderValue.textContent = `${SIZE_MIN}%`;
      const sliderWeight = document.createElement("span");
      sliderWeight.className = "mg-crop-simulation__slider-weight";
      sliderWeight.textContent = "\u2014";
      sliderRow.append(sliderLabel, slider, sliderValue);
      sliderContainer.append(sliderRow, sliderWeight);
      spriteSection.append(spriteBox, sliderContainer);
      previewSection.appendChild(spriteSection);
      const mutationsSection = createSection("Mutations");
      const colorList = document.createElement("div");
      colorList.className = "mg-crop-simulation__segmented";
      mutationsSection.appendChild(colorList);
      const weatherContainer = document.createElement("div");
      weatherContainer.className = "mg-crop-calculator__mutations-weather";
      const weatherConditions = document.createElement("div");
      weatherConditions.className = "mg-crop-simulation__segmented";
      const weatherLighting = document.createElement("div");
      weatherLighting.className = "mg-crop-simulation__segmented";
      weatherContainer.append(weatherConditions, weatherLighting);
      mutationsSection.appendChild(weatherContainer);
      const friendBonusSection = createSection("Friend bonus", "mg-crop-calculator__section--friend-bonus");
      const friendBonus = document.createElement("div");
      friendBonus.className = "mg-crop-simulation__segmented";
      friendBonusSection.appendChild(friendBonus);
      detailLayout.append(
        priceRow,
        previewSection,
        mutationsSection,
        friendBonusSection
      );
      simulationRoot.appendChild(detailLayout);
      detailScroll.appendChild(simulationRoot);
      const refs = {
        root: simulationRoot,
        sprite,
        sizeSlider: slider,
        sizeValue: sliderValue,
        sizeWeight: sliderWeight,
        colorMutations: colorList,
        weatherConditions,
        weatherLighting,
        friendBonus,
        priceValue
      };
      const states = /* @__PURE__ */ new Map();
      const optionByKey = /* @__PURE__ */ new Map();
      const options = getLockerSeedOptions();
      options.forEach((opt) => optionByKey.set(opt.key, opt));
      const getStateForKey = (key2) => {
        const existing = states.get(key2);
        if (existing) return existing;
        const state2 = { ...DEFAULT_STATE };
        states.set(key2, state2);
        return state2;
      };
      let selectedKey = null;
      let currentMaxScale = null;
      let currentBaseWeight = null;
      function renderColorSegment(state2, interactive) {
        const active = state2?.color ?? COLOR_MUTATION_LABELS[0];
        const segmented = createSegmentedControl(
          COLOR_MUTATION_LABELS,
          active,
          interactive,
          interactive ? (label2) => {
            if (!selectedKey) return;
            const target = getStateForKey(selectedKey);
            target.color = coerceLabel(label2, COLOR_MUTATION_LABELS);
            renderColorSegment(target, true);
            renderWeatherConditions(target, true);
            renderWeatherLighting(target, true);
            updateSprite();
            updateOutputs();
          } : void 0,
          "Mutations"
        );
        applySegmentedButtonMetadata(segmented, COLOR_SEGMENT_METADATA);
        refs.colorMutations.innerHTML = "";
        refs.colorMutations.appendChild(segmented);
      }
      function renderWeatherConditions(state2, interactive) {
        const active = state2?.weatherCondition ?? WEATHER_CONDITION_LABELS[0];
        const segmented = createSegmentedControl(
          WEATHER_CONDITION_LABELS,
          active,
          interactive,
          interactive ? (label2) => {
            if (!selectedKey) return;
            const target = getStateForKey(selectedKey);
            target.weatherCondition = coerceLabel(label2, WEATHER_CONDITION_LABELS);
            renderWeatherConditions(target, true);
            updateSprite();
            updateOutputs();
          } : void 0,
          "Weather condition"
        );
        applySegmentedButtonMetadata(segmented, WEATHER_CONDITION_SEGMENT_METADATA);
        refs.weatherConditions.innerHTML = "";
        refs.weatherConditions.appendChild(segmented);
      }
      function renderWeatherLighting(state2, interactive) {
        const active = state2?.weatherLighting ?? WEATHER_LIGHTING_LABELS[0];
        const segmented = createSegmentedControl(
          WEATHER_LIGHTING_LABELS,
          active,
          interactive,
          interactive ? (label2) => {
            if (!selectedKey) return;
            const target = getStateForKey(selectedKey);
            target.weatherLighting = coerceLabel(label2, WEATHER_LIGHTING_LABELS);
            renderWeatherLighting(target, true);
            updateSprite();
            updateOutputs();
          } : void 0,
          "Weather lighting"
        );
        applySegmentedButtonMetadata(segmented, WEATHER_LIGHTING_SEGMENT_METADATA);
        refs.weatherLighting.innerHTML = "";
        refs.weatherLighting.appendChild(segmented);
      }
      function renderFriendBonus(state2, interactive) {
        const active = friendPlayersToLabel(state2?.friendPlayers ?? FRIEND_BONUS_MIN_PLAYERS);
        const segmented = createSegmentedControl(
          FRIEND_BONUS_LABELS,
          active,
          interactive,
          interactive ? (label2) => {
            if (!selectedKey) return;
            const target = getStateForKey(selectedKey);
            target.friendPlayers = labelToFriendPlayers(label2);
            renderFriendBonus(target, true);
            updateOutputs();
          } : void 0,
          "Friend bonus"
        );
        refs.friendBonus.innerHTML = "";
        refs.friendBonus.appendChild(segmented);
      }
      function updateOutputs() {
        const key2 = selectedKey;
        if (!key2) {
          refs.priceValue.textContent = "\u2014";
          return;
        }
        const state2 = getStateForKey(key2);
        const min = computePrice(key2, state2, state2.sizePercent, currentMaxScale);
        const maxPercent = Math.min(SIZE_MAX, state2.sizePercent + 1);
        const max = computePrice(key2, state2, maxPercent, currentMaxScale);
        refs.priceValue.textContent = formatCoinRange(min, max);
      }
      function updateSprite() {
        const key2 = selectedKey;
        if (!key2) {
          refs.sprite.innerHTML = "";
          return;
        }
        const state2 = getStateForKey(key2);
        const option = optionByKey.get(key2);
        const fallbackEmoji = getLockerSeedEmojiForKey(key2) || (option?.seedName ? getLockerSeedEmojiForSeedName(option.seedName) : void 0) || "\u{1F331}";
        applyCropSimulationSprite(refs.sprite, key2, {
          colorLabel: state2.color,
          weatherLabels: getWeatherLabelsForState(state2),
          fallback: fallbackEmoji
        });
      }
      function renderDetail() {
        const key2 = selectedKey;
        if (!key2) {
          refs.sprite.innerHTML = "";
          refs.sizeSlider.disabled = true;
          currentBaseWeight = null;
          applySizePercent(refs, SIZE_MIN, null, currentBaseWeight);
          renderColorSegment(null, false);
          renderWeatherConditions(null, false);
          renderWeatherLighting(null, false);
          renderFriendBonus(null, false);
          refs.priceValue.textContent = "\u2014";
          return;
        }
        currentMaxScale = getMaxScaleForSpecies(key2);
        currentBaseWeight = getBaseWeightForSpecies(key2);
        const state2 = getStateForKey(key2);
        refs.sizeSlider.disabled = false;
        applySizePercent(refs, state2.sizePercent, currentMaxScale, currentBaseWeight);
        renderColorSegment(state2, true);
        renderWeatherConditions(state2, true);
        renderWeatherLighting(state2, true);
        renderFriendBonus(state2, true);
        updateSprite();
        updateOutputs();
      }
      slider.addEventListener("input", () => {
        if (!selectedKey) return;
        const state2 = getStateForKey(selectedKey);
        const raw = Number(slider.value);
        const value = clamp3(Math.round(raw), SIZE_MIN, SIZE_MAX);
        state2.sizePercent = value;
        applySizePercent(refs, value, currentMaxScale, currentBaseWeight);
        updateOutputs();
      });
      function renderList() {
        const previous = list.scrollTop;
        list.innerHTML = "";
        if (!options.length) {
          const empty = document.createElement("div");
          empty.className = "mg-crop-calculator__placeholder";
          empty.textContent = "No crops available.";
          list.appendChild(empty);
          selectedKey = null;
          currentMaxScale = null;
          renderDetail();
          return;
        }
        if (selectedKey && !options.some((opt) => opt.key === selectedKey)) {
          selectedKey = options[0].key;
          currentMaxScale = getMaxScaleForSpecies(selectedKey);
        }
        if (!selectedKey) {
          selectedKey = options[0].key;
          currentMaxScale = getMaxScaleForSpecies(selectedKey);
        }
        const fragment = document.createDocumentFragment();
        scheduleLockerSpritePreload();
        options.forEach((opt) => {
          const button = document.createElement("button");
          button.className = "qmm-vtab";
          button.style.display = "grid";
          button.style.gridTemplateColumns = "16px 1fr auto";
          button.style.alignItems = "center";
          button.style.gap = "8px";
          button.style.textAlign = "left";
          button.style.padding = "6px 8px";
          button.style.marginBottom = "6px";
          button.style.borderRadius = "8px";
          button.style.border = "1px solid #4445";
          button.style.background = selectedKey === opt.key ? "#2b8a3e" : "#1f2328";
          button.style.color = "#e7eef7";
          const dot = document.createElement("span");
          dot.className = "qmm-dot";
          dot.style.background = selectedKey === opt.key ? "#2ecc71" : "#4c566a";
          const label2 = document.createElement("span");
          label2.className = "label";
          label2.textContent = opt.cropName || opt.key;
          const fallbackEmoji = getLockerSeedEmojiForKey(opt.key) || getLockerSeedEmojiForSeedName(opt.seedName) || "\u{1F331}";
          const sprite2 = createPlantSprite(opt.key, {
            size: 24,
            fallback: fallbackEmoji
          });
          button.append(dot, label2, sprite2);
          button.onmouseenter = () => button.style.borderColor = "#6aa1";
          button.onmouseleave = () => button.style.borderColor = "#4445";
          button.onclick = () => {
            if (selectedKey === opt.key) return;
            selectedKey = opt.key;
            currentMaxScale = getMaxScaleForSpecies(opt.key);
            renderList();
          };
          fragment.appendChild(button);
        });
        list.appendChild(fragment);
        list.scrollTop = previous;
        renderDetail();
      }
      renderList();
    });
    ui.mount(container);
  }

  // src/ui/menus/notifier.ts
  var rulePopover = null;
  var detachRuleDocHandler = null;
  var detachRuleKeyBlocker = null;
  var detachRuleWheelBlocker = null;
  var detachRuleDragHandler = null;
  var closeRuleEditor = () => {
    if (rulePopover) {
      try {
        rulePopover.remove();
      } catch {
      }
      rulePopover = null;
    }
    if (detachRuleDocHandler) {
      detachRuleDocHandler();
      detachRuleDocHandler = null;
    }
    if (detachRuleKeyBlocker) {
      detachRuleKeyBlocker();
      detachRuleKeyBlocker = null;
    }
    if (detachRuleWheelBlocker) {
      detachRuleWheelBlocker();
      detachRuleWheelBlocker = null;
    }
    if (detachRuleDragHandler) {
      detachRuleDragHandler();
      detachRuleDragHandler = null;
    }
  };
  var setSwitchCapState = (wrap, capped) => {
    if (capped) {
      wrap.setAttribute("aria-disabled", "true");
      wrap.style.opacity = "0.5";
      wrap.style.pointerEvents = "none";
      wrap.style.cursor = "not-allowed";
      wrap.title = "Max owned \u2014 notifications disabled";
    } else {
      wrap.removeAttribute("aria-disabled");
      wrap.style.opacity = "";
      wrap.style.pointerEvents = "";
      wrap.style.cursor = "";
      wrap.removeAttribute("title");
    }
  };
  var createSwitch = (onToggle) => {
    const wrap = document.createElement("label");
    wrap.style.display = "inline-flex";
    wrap.style.alignItems = "center";
    wrap.style.justifyContent = "center";
    wrap.style.width = "100%";
    wrap.style.padding = "4px 6px";
    wrap.style.userSelect = "none";
    wrap.setAttribute("role", "switch");
    wrap.setAttribute("aria-checked", "false");
    const box = document.createElement("span");
    box.style.position = "relative";
    box.style.width = "42px";
    box.style.height = "24px";
    box.style.borderRadius = "999px";
    box.style.background = "#1f2328";
    box.style.border = "1px solid #4446";
    box.style.display = "inline-block";
    box.style.boxShadow = "inset 0 0 0 1px #0005";
    const knob = document.createElement("span");
    knob.style.position = "absolute";
    knob.style.top = "50%";
    knob.style.left = "3px";
    knob.style.transform = "translateY(-50%)";
    knob.style.width = "18px";
    knob.style.height = "18px";
    knob.style.borderRadius = "50%";
    knob.style.background = "#e7eef7";
    knob.style.boxShadow = "0 1px 2px rgba(0,0,0,.7)";
    knob.style.transition = "left 160ms ease, transform 160ms ease";
    const input = document.createElement("input");
    input.type = "checkbox";
    input.style.position = "absolute";
    input.style.opacity = "0";
    input.style.pointerEvents = "none";
    input.tabIndex = -1;
    const apply = (on) => {
      input.checked = on;
      wrap.setAttribute("aria-checked", on ? "true" : "false");
      knob.style.left = on ? "21px" : "3px";
      knob.style.transform = on ? "translateY(-50%) scale(1.02)" : "translateY(-50%) scale(1)";
      if (on) {
        box.style.background = "linear-gradient(180deg, #2b5cff, #1e40ff)";
        box.style.borderColor = "#7aa2ff";
        box.style.boxShadow = "0 0 0 2px #7aa2ff55, inset 0 0 0 1px #0005";
      } else {
        box.style.background = "#1f2328";
        box.style.borderColor = "#4446";
        box.style.boxShadow = "inset 0 0 0 1px #0005";
      }
    };
    input.disabled = true;
    wrap.addEventListener("mousedown", (e) => e.preventDefault());
    wrap.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      apply(!input.checked);
      onToggle?.(input.checked);
    });
    box.appendChild(knob);
    wrap.appendChild(input);
    wrap.appendChild(box);
    apply(false);
    return wrap;
  };
  var setSwitchVisual = (wrap, checked) => {
    const input = wrap.querySelector("input");
    const box = wrap.querySelector("span");
    const knob = box?.querySelector("span");
    if (!input || !box || !knob) return;
    input.checked = !!checked;
    knob.style.left = checked ? "21px" : "3px";
    knob.style.transform = checked ? "translateY(-50%) scale(1.02)" : "translateY(-50%) scale(1)";
    if (checked) {
      box.style.background = "linear-gradient(180deg, #2b5cff, #1e40ff)";
      box.style.borderColor = "#7aa2ff";
      box.style.boxShadow = "0 0 0 2px #7aa2ff55, inset 0 0 0 1px #0005";
      wrap.setAttribute("aria-checked", "true");
    } else {
      box.style.background = "#1f2328";
      box.style.borderColor = "#4446";
      box.style.boxShadow = "inset 0 0 0 1px #0005";
      wrap.setAttribute("aria-checked", "false");
    }
  };
  var wrapCell = (child) => {
    const d = document.createElement("div");
    d.style.display = "flex";
    d.style.alignItems = "center";
    d.style.justifyContent = "center";
    d.style.borderBottom = "1px solid #ffffff12";
    d.style.padding = "4px 6px";
    d.style.boxSizing = "border-box";
    d.appendChild(child);
    return d;
  };
  var mkHeadCell = (txt, align = "center") => {
    const el2 = document.createElement("div");
    el2.textContent = txt;
    el2.style.fontWeight = "600";
    el2.style.opacity = "0.9";
    el2.style.padding = "4px 6px";
    el2.style.display = "flex";
    el2.style.alignItems = "center";
    el2.style.justifyContent = align === "left" ? "flex-start" : "center";
    return el2;
  };
  function rarityBadge(raw) {
    const rarity2 = String(raw || "").trim();
    const key2 = (() => {
      const k = rarity2.toLowerCase();
      if (k === "mythical") return "Mythical";
      if (k === "celestial") return "Celestial";
      if (k === "divine") return "Divine";
      if (k === "legendary") return "Legendary";
      if (k === "rare") return "Rare";
      if (k === "uncommon") return "Uncommon";
      if (k === "common") return "Common";
      return rarity2 || "\u2014";
    })();
    const COLORS = {
      Common: "#E7E7E7",
      Uncommon: "#67BD4D",
      Rare: "#0071C6",
      Legendary: "#FFC734",
      Mythical: "#9944A7",
      Divine: "#FF7835",
      Celestial: null
    };
    const darkText = /* @__PURE__ */ new Set(["Common", "Uncommon", "Legendary", "Divine"]);
    const el2 = document.createElement("div");
    el2.textContent = key2;
    Object.assign(el2.style, {
      display: "inline-flex",
      justifyContent: "center",
      alignItems: "center",
      padding: "4px 8px",
      borderRadius: "5px",
      fontSize: "12px",
      fontWeight: "700",
      margin: "2px auto",
      color: darkText.has(key2) ? "#0b0b0b" : "#ffffff",
      boxShadow: "0 0 0 1px #0006 inset",
      lineHeight: "1.1",
      whiteSpace: "nowrap"
    });
    if (key2 === "Celestial") {
      if (!document.getElementById("qws-celestial-kf")) {
        const style2 = document.createElement("style");
        style2.id = "qws-celestial-kf";
        style2.textContent = `
@keyframes qwsCelestialShift {
  0%   { background-position: 0% 50%; }
  50%  { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}`;
        document.head.appendChild(style2);
      }
      el2.style.background = `linear-gradient(130deg,
      rgb(0,180,216) 0%,
      rgb(124,42,232) 40%,
      rgb(160,0,126) 60%,
      rgb(255,215,0) 100%)`;
      el2.style.backgroundSize = "200% 200%";
      el2.style.animation = "qwsCelestialShift 4s linear infinite";
    } else {
      el2.style.background = COLORS[key2] || "#444";
    }
    return el2;
  }
  var applyRuleState = (itemCell, ruleCell, rule) => {
    const gearBtn = ruleCell?.querySelector("button[data-role='rule']") ?? null;
    const hint = itemCell.querySelector('[data-role="rule-hint"]');
    const hasRule = !!(rule && (rule.sound || rule.playbackMode || rule.stopMode || rule.loopIntervalMs != null));
    const summary = hasRule ? formatRuleSummary(rule) : "";
    if (gearBtn) {
      gearBtn.dataset.active = hasRule ? "1" : "0";
      gearBtn.title = hasRule && summary ? `Custom rule \u2014 ${summary}` : "Custom rule";
    }
    if (hint) {
      if (hasRule && summary) {
        hint.textContent = summary;
        hint.style.visibility = "visible";
      } else {
        hint.textContent = "";
        hint.style.visibility = "hidden";
      }
    }
  };
  var openRuleEditor = (ui, row, anchor) => {
    closeRuleEditor();
    const pop = document.createElement("div");
    pop.className = "qws-rule-popover";
    Object.assign(pop.style, {
      position: "fixed",
      zIndex: "var(--qws-z-popover)",
      minWidth: "260px",
      maxWidth: "320px",
      padding: "14px 16px",
      borderRadius: "14px",
      border: "1px solid #32404e",
      background: "linear-gradient(180deg, #111923, #0b131c)",
      boxShadow: "0 16px 40px rgba(0,0,0,0.45)"
    });
    const margin = 12;
    const clampPosition = (value, min, max) => {
      if (!Number.isFinite(min) || !Number.isFinite(max)) return value;
      if (max >= min) {
        return Math.min(Math.max(value, min), max);
      }
      return Math.min(Math.max(value, max), min);
    };
    const applyPosition = (left2, top2) => {
      const width2 = pop.offsetWidth;
      const height2 = pop.offsetHeight;
      const boundedLeft = clampPosition(left2, margin, window.innerWidth - width2 - margin);
      const boundedTop = clampPosition(top2, margin, window.innerHeight - height2 - margin);
      pop.style.left = `${Math.round(boundedLeft)}px`;
      pop.style.top = `${Math.round(boundedTop)}px`;
      return { left: boundedLeft, top: boundedTop };
    };
    const header = document.createElement("div");
    header.style.display = "flex";
    header.style.justifyContent = "space-between";
    header.style.alignItems = "flex-start";
    header.style.gap = "12px";
    header.style.cursor = "move";
    header.style.userSelect = "none";
    header.style.touchAction = "none";
    const titleWrap = document.createElement("div");
    const title = document.createElement("div");
    title.textContent = row.name;
    title.style.fontWeight = "700";
    title.style.fontSize = "14px";
    title.style.lineHeight = "1.2";
    const subtitle = document.createElement("div");
    subtitle.textContent = row.type;
    subtitle.style.opacity = "0.7";
    subtitle.style.fontSize = "12px";
    titleWrap.append(title, subtitle);
    const closeBtn = document.createElement("button");
    closeBtn.type = "button";
    closeBtn.textContent = "\u2715";
    Object.assign(closeBtn.style, {
      background: "transparent",
      border: "none",
      color: "#c8d7e8",
      fontSize: "16px",
      lineHeight: "1",
      cursor: "pointer"
    });
    closeBtn.addEventListener("click", (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      closeRuleEditor();
    });
    header.append(titleWrap, closeBtn);
    let dragState = null;
    const onDragMove = (ev) => {
      if (!dragState) return;
      if (ev.pointerId !== dragState.pointerId) return;
      const dx = ev.clientX - dragState.startX;
      const dy = ev.clientY - dragState.startY;
      applyPosition(dragState.baseLeft + dx, dragState.baseTop + dy);
    };
    const stopDrag = (ev) => {
      if (!dragState) return;
      if (ev && ev.pointerId !== dragState.pointerId) return;
      document.removeEventListener("pointermove", onDragMove);
      document.removeEventListener("pointerup", stopDrag);
      document.removeEventListener("pointercancel", stopDrag);
      try {
        header.releasePointerCapture(dragState.pointerId);
      } catch {
      }
      dragState = null;
    };
    const onPointerDown = (ev) => {
      if (ev.button !== 0) return;
      const target = ev.target;
      if (target && closeBtn.contains(target)) return;
      if (dragState) stopDrag();
      const rect = pop.getBoundingClientRect();
      dragState = {
        pointerId: ev.pointerId,
        startX: ev.clientX,
        startY: ev.clientY,
        baseLeft: rect.left,
        baseTop: rect.top
      };
      try {
        header.setPointerCapture(ev.pointerId);
      } catch {
      }
      document.addEventListener("pointermove", onDragMove);
      document.addEventListener("pointerup", stopDrag);
      document.addEventListener("pointercancel", stopDrag);
      ev.preventDefault();
    };
    header.addEventListener("pointerdown", onPointerDown);
    detachRuleDragHandler = () => {
      header.removeEventListener("pointerdown", onPointerDown);
      stopDrag();
    };
    pop.appendChild(header);
    const current = NotifierService.getRule(row.id);
    const defaults = audio.getPlaybackSettings(row.context);
    const contextDefaults = NotifierService.getContextStopDefaults(row.context);
    const allowPurchase = row.context === "shops";
    const defaultSoundName = (() => {
      const label2 = (defaults.defaultSoundName || "").trim();
      return label2 || "Default";
    })();
    const formatModeLabel = (mode) => mode === "loop" ? "Loop" : "One-shot";
    const defaultModeLabel = formatModeLabel(defaults.mode);
    const defaultIntervalMs = Math.max(
      150,
      Math.floor(contextDefaults.loopIntervalMs ?? defaults.loopIntervalMs ?? 150)
    );
    const soundField = document.createElement("div");
    soundField.className = "qws-rule-field";
    const soundLabel = document.createElement("label");
    soundLabel.textContent = "Sound";
    const soundSelect = document.createElement("select");
    soundSelect.className = "qmm-input";
    soundSelect.style.width = "100%";
    const populateSoundOptions = () => {
      const selected = current?.sound ?? "";
      soundSelect.innerHTML = "";
      const optDefault = document.createElement("option");
      optDefault.value = "";
      optDefault.textContent = defaultSoundName;
      soundSelect.appendChild(optDefault);
      const names = audio.listSounds();
      for (const name of names) {
        if (name === defaultSoundName && selected !== name) continue;
        const opt = document.createElement("option");
        opt.value = name;
        opt.textContent = name;
        soundSelect.appendChild(opt);
      }
      if (selected && !names.includes(selected)) {
        const extra = document.createElement("option");
        extra.value = selected;
        extra.textContent = selected.length > 32 ? `${selected.slice(0, 29)}\u2026` : selected;
        extra.dataset.extra = "1";
        soundSelect.appendChild(extra);
      }
      soundSelect.value = selected;
    };
    populateSoundOptions();
    soundField.append(soundLabel, soundSelect);
    pop.appendChild(soundField);
    const modeField = document.createElement("div");
    modeField.className = "qws-rule-field";
    const modeLabel = document.createElement("label");
    modeLabel.textContent = "Playback mode";
    const modeSelect = document.createElement("select");
    modeSelect.className = "qmm-input";
    const modeOptions = allowPurchase ? defaults.mode === "loop" ? ["loop", "oneshot"] : ["oneshot", "loop"] : ["oneshot"];
    modeOptions.forEach((value) => {
      const opt = document.createElement("option");
      opt.value = value;
      opt.textContent = formatModeLabel(value);
      modeSelect.appendChild(opt);
    });
    const initialMode = allowPurchase ? current?.playbackMode ?? defaults.mode : "oneshot";
    modeSelect.value = initialMode === "loop" && !allowPurchase ? "oneshot" : initialMode;
    if (!allowPurchase) modeSelect.disabled = true;
    modeField.append(modeLabel, modeSelect);
    pop.appendChild(modeField);
    let stopSelect = null;
    const stopField = document.createElement("div");
    stopField.className = "qws-rule-field";
    if (allowPurchase) {
      const stopLabel = document.createElement("label");
      stopLabel.textContent = "Stop condition";
      stopSelect = document.createElement("select");
      stopSelect.className = "qmm-input";
      const stopOption = document.createElement("option");
      stopOption.value = "purchase";
      stopOption.textContent = "Until purchase";
      stopSelect.appendChild(stopOption);
      const initialStopMode = current?.stopMode ?? contextDefaults.stopMode;
      stopSelect.value = initialStopMode === "purchase" ? "purchase" : "purchase";
      stopField.append(stopLabel, stopSelect);
      pop.appendChild(stopField);
    }
    const intervalField = document.createElement("div");
    intervalField.className = "qws-rule-field";
    const intervalLabel = document.createElement("label");
    intervalLabel.textContent = "Loop interval (ms)";
    const intervalInput = document.createElement("input");
    intervalInput.type = "number";
    intervalInput.className = "qmm-input";
    intervalInput.min = "150";
    intervalInput.step = "50";
    intervalInput.placeholder = String(defaultIntervalMs);
    intervalInput.value = current?.loopIntervalMs != null ? String(current.loopIntervalMs) : "";
    intervalInput.inputMode = "numeric";
    intervalField.append(intervalLabel, intervalInput);
    if (allowPurchase) pop.appendChild(intervalField);
    const enforceIntegerOnly = (input) => {
      input.addEventListener("keydown", (ev) => {
        ev.stopPropagation();
        ev.stopImmediatePropagation();
        if (ev.ctrlKey || ev.metaKey || ev.altKey) return;
        const key2 = ev.key;
        if (/^[0-9]$/.test(key2)) return;
        if (key2 === "Backspace" || key2 === "Delete" || key2 === "Tab" || key2 === "Enter" || key2 === "ArrowLeft" || key2 === "ArrowRight" || key2 === "ArrowUp" || key2 === "ArrowDown" || key2 === "Home" || key2 === "End") {
          return;
        }
        ev.preventDefault();
      });
      input.addEventListener("input", () => {
        const sanitized = input.value.replace(/\D+/g, "");
        if (sanitized !== input.value) input.value = sanitized;
      });
    };
    enforceIntegerOnly(intervalInput);
    const resolveMode = () => {
      const raw = modeSelect.value;
      if (raw === "oneshot" || raw === "loop") return raw;
      return allowPurchase ? defaults.mode : "oneshot";
    };
    const resolveStop = () => {
      if (!allowPurchase) return "purchase";
      const raw = stopSelect?.value;
      if (raw === "purchase") return "purchase";
      return "purchase";
    };
    const updateLoopVisibility = () => {
      if (!allowPurchase) {
        stopField.style.display = "none";
        intervalField.style.display = "none";
        return;
      }
      const mode = resolveMode();
      const showLoop = mode === "loop";
      stopField.style.display = showLoop ? "grid" : "none";
      intervalField.style.display = showLoop ? "grid" : "none";
    };
    const forceLoopMode = () => {
      if (!allowPurchase) return;
      if (modeSelect.value === "loop") return;
      modeSelect.value = "loop";
      updateLoopVisibility();
    };
    modeSelect.addEventListener("change", () => {
      updateLoopVisibility();
    });
    if (allowPurchase && stopSelect) {
      stopSelect.addEventListener("change", () => {
        forceLoopMode();
      });
    }
    if (allowPurchase) intervalInput.addEventListener("input", forceLoopMode);
    updateLoopVisibility();
    const hint = document.createElement("div");
    hint.textContent = "Leave fields empty to inherit global defaults.";
    hint.style.opacity = "0.7";
    hint.style.fontSize = "12px";
    pop.appendChild(hint);
    const actions = document.createElement("div");
    actions.className = "qws-rule-actions";
    const clearBtn = ui.btn("Clear", { variant: "ghost", size: "sm" });
    clearBtn.addEventListener("click", (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      NotifierService.clearRule(row.id);
      closeRuleEditor();
    });
    if (!current) ui.setButtonEnabled(clearBtn, false);
    const saveBtn = ui.btn("Save", { variant: "primary", size: "sm" });
    saveBtn.addEventListener("click", (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      const sound = soundSelect.value?.trim() || null;
      const modeRaw = modeSelect.value || "";
      const stopRaw = stopSelect?.value || "";
      const intervalRaw = intervalInput.value?.trim();
      let playbackMode = modeRaw === "oneshot" || modeRaw === "loop" ? modeRaw : null;
      if (playbackMode === defaults.mode) playbackMode = null;
      let stopMode = allowPurchase ? stopRaw === "purchase" ? "purchase" : null : null;
      if (stopMode != null && stopMode === contextDefaults.stopMode) {
        stopMode = null;
      }
      let loopIntervalMs = null;
      if (allowPurchase && intervalRaw) {
        const parsed = Number(intervalRaw);
        if (Number.isFinite(parsed)) {
          const normalized = Math.max(150, Math.min(1e4, Math.floor(parsed)));
          if (normalized !== defaultIntervalMs) loopIntervalMs = normalized;
        }
      }
      if (allowPurchase && !playbackMode && defaults.mode !== "loop" && (stopMode != null || loopIntervalMs != null)) {
        playbackMode = "loop";
      }
      NotifierService.setRule(row.id, {
        sound,
        playbackMode,
        stopMode,
        loopIntervalMs
      });
      closeRuleEditor();
    });
    actions.append(clearBtn, saveBtn);
    pop.appendChild(actions);
    document.body.appendChild(pop);
    const anchorRect = anchor.getBoundingClientRect();
    const width = pop.offsetWidth;
    const height = pop.offsetHeight;
    let left = anchorRect.right - width;
    let top = anchorRect.bottom + 8;
    if (left < margin) left = margin;
    if (left + width > window.innerWidth - margin) left = window.innerWidth - width - margin;
    if (top + height > window.innerHeight - margin) top = anchorRect.top - height - 8;
    if (top < margin) top = margin;
    applyPosition(left, top);
    const onDocPointer = (ev) => {
      const target = ev.target;
      if (!target) return;
      if (pop.contains(target)) return;
      if (anchor.contains(target)) return;
      closeRuleEditor();
    };
    setTimeout(() => document.addEventListener("pointerdown", onDocPointer, true));
    detachRuleDocHandler = () => document.removeEventListener("pointerdown", onDocPointer, true);
    const keyBlocker = (ev) => {
      if (!rulePopover) return;
      if (rulePopover.contains(ev.target)) return;
      ev.stopImmediatePropagation();
    };
    document.addEventListener("keydown", keyBlocker, true);
    detachRuleKeyBlocker = () => document.removeEventListener("keydown", keyBlocker, true);
    const wheelBlocker = (ev) => {
      const t = ev.target;
      if (rulePopover && t && rulePopover.contains(t)) {
        ev.stopImmediatePropagation();
      }
    };
    document.addEventListener("wheel", wheelBlocker, { capture: true, passive: true });
    detachRuleWheelBlocker = () => {
      document.removeEventListener("wheel", wheelBlocker, { capture: true });
    };
    rulePopover = pop;
  };
  function renderSettingsTab(view, ui) {
    view.innerHTML = "";
    const section = (title) => {
      const card = ui.card(title, { tone: "muted" });
      card.body.style.display = "grid";
      card.body.style.gap = "10px";
      return card;
    };
    const row = (labelTxt, control, opts) => {
      const { root: r, label: label2 } = ui.formRow(labelTxt, control, { alignTop: opts?.alignTop, labelWidth: "160px" });
      label2.style.opacity = "0.9";
      label2.style.fontWeight = "600";
      return r;
    };
    const radio = (name, value, text) => {
      const chip = ui.toggleChip(text, { type: "radio", name, value });
      chip.root.classList.add("qmm-radio-chip");
      return { label: chip.root, input: chip.input };
    };
    const makeSelect = (id) => {
      const sel = ui.select({ id, width: "180px" });
      return sel;
    };
    const playIconBtn = (title = "Play") => {
      return ui.btn("", { icon: "\u25B6", size: "sm", tooltip: title, ariaLabel: title });
    };
    const smallBtn = (txt) => ui.btn(txt, { size: "sm" });
    const errorBar = () => ui.errorBar();
    const root = document.createElement("div");
    Object.assign(root.style, {
      display: "grid",
      gridTemplateRows: "1fr",
      gap: "12px",
      height: "54vh",
      minHeight: "0",
      overflow: "hidden"
    });
    view.appendChild(root);
    const s1 = section("Audio & Playback");
    root.appendChild(s1.root);
    const contextControls = {};
    const contextOrder = [
      { key: "shops", label: "Shops", allowPurchase: true },
      { key: "weather", label: "Weather", allowPurchase: false }
    ];
    for (const cfg of contextOrder) {
      const card = document.createElement("div");
      Object.assign(card.style, {
        display: "grid",
        gap: "12px",
        padding: "16px",
        borderRadius: "12px",
        border: "1px solid #1f2429",
        background: "#111821"
      });
      const heading = document.createElement("div");
      heading.textContent = cfg.label;
      heading.style.fontWeight = "700";
      heading.style.fontSize = "14px";
      heading.style.letterSpacing = "0.02em";
      card.appendChild(heading);
      const defaultWrap = document.createElement("div");
      defaultWrap.style.display = "flex";
      defaultWrap.style.alignItems = "center";
      defaultWrap.style.gap = "8px";
      const select2 = makeSelect(`ap.defaultSound.${cfg.key}`);
      select2.dataset.soundSelect = cfg.key;
      const playBtn = playIconBtn(`Play ${cfg.label.toLowerCase()} sound`);
      defaultWrap.append(select2, playBtn);
      card.appendChild(row("Default sound", defaultWrap));
      const volumeWrap = document.createElement("div");
      volumeWrap.style.display = "flex";
      volumeWrap.style.alignItems = "center";
      volumeWrap.style.gap = "10px";
      const volumeRange = document.createElement("input");
      volumeRange.type = "range";
      volumeRange.min = "0";
      volumeRange.max = "100";
      volumeRange.step = "1";
      volumeRange.style.width = "220px";
      const volumeValue = document.createElement("span");
      volumeValue.style.minWidth = "32px";
      volumeValue.style.textAlign = "right";
      volumeWrap.append(volumeRange, volumeValue);
      card.appendChild(row("Volume", volumeWrap));
      const modeWrap = document.createElement("div");
      modeWrap.style.display = "flex";
      modeWrap.style.gap = "12px";
      const modeOne = radio(`ap.mode.${cfg.key}`, "oneshot", "One-shot");
      modeWrap.append(modeOne.label);
      let modeLoop = null;
      if (cfg.allowPurchase) {
        modeLoop = radio(`ap.mode.${cfg.key}`, "loop", "Loop");
        modeWrap.append(modeLoop.label);
      }
      card.appendChild(row("Playback mode", modeWrap));
      let stopRow;
      let loopInput;
      let loopWrap;
      if (cfg.allowPurchase) {
        const stopWrap = document.createElement("div");
        stopWrap.style.display = "flex";
        stopWrap.style.flexDirection = "column";
        stopWrap.style.gap = "10px";
        loopWrap = document.createElement("div");
        loopWrap.style.display = "flex";
        loopWrap.style.flexDirection = "column";
        loopWrap.style.gap = "4px";
        const loopTitle = document.createElement("div");
        loopTitle.textContent = "Loop interval";
        loopTitle.style.opacity = "0.8";
        loopTitle.style.fontSize = "12px";
        loopTitle.style.fontWeight = "600";
        const loopBox = document.createElement("div");
        loopBox.style.display = "inline-flex";
        loopBox.style.alignItems = "center";
        loopBox.style.gap = "8px";
        loopInput = document.createElement("input");
        loopInput.type = "number";
        loopInput.min = "150";
        loopInput.max = "10000";
        loopInput.step = "50";
        loopInput.style.width = "100px";
        loopInput.style.textAlign = "center";
        const loopLabel = document.createElement("span");
        loopLabel.textContent = "ms between plays";
        loopLabel.style.opacity = "0.85";
        loopBox.append(loopInput, loopLabel);
        loopWrap.append(loopTitle, loopBox);
        const stopInfo = document.createElement("div");
        stopInfo.textContent = "Loops stop automatically when the item is purchased.";
        stopInfo.style.opacity = "0.75";
        stopInfo.style.fontSize = "12px";
        stopInfo.style.lineHeight = "1.4";
        stopWrap.append(stopInfo, loopWrap);
        stopRow = row("Stop condition", stopWrap);
        card.appendChild(stopRow);
      } else {
        const info = document.createElement("div");
        info.textContent = "Weather alerts play once per trigger.";
        info.style.opacity = "0.75";
        info.style.fontSize = "12px";
        info.style.lineHeight = "1.4";
        card.appendChild(row("Details", info));
      }
      contextControls[cfg.key] = {
        container: card,
        select: select2,
        playBtn,
        volumeRange,
        volumeValue,
        modeOneshot: modeOne.input,
        modeLoop: modeLoop?.input,
        stopRow,
        loopInput,
        loopWrap
      };
      s1.body.appendChild(card);
    }
    const s1Err = errorBar();
    s1.body.appendChild(s1Err.el);
    const s2 = section("Sound library");
    root.appendChild(s2.root);
    const importRow = document.createElement("div");
    Object.assign(importRow.style, {
      display: "flex",
      flexDirection: "column",
      gap: "12px",
      width: "100%"
    });
    const fileInput = document.createElement("input");
    fileInput.type = "file";
    fileInput.accept = "audio/*";
    fileInput.multiple = true;
    fileInput.style.display = "none";
    const fileCard = document.createElement("div");
    Object.assign(fileCard.style, {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center",
      gap: "6px",
      padding: "18px 22px",
      width: "100%",
      minHeight: "110px",
      borderRadius: "14px",
      border: "1px dashed #5d6a7d",
      background: "linear-gradient(180deg, #0b141c, #091018)",
      transition: "border-color 0.2s ease, background 0.2s ease, box-shadow 0.2s ease",
      cursor: "pointer",
      textAlign: "center"
    });
    fileCard.tabIndex = 0;
    fileCard.setAttribute("role", "button");
    fileCard.setAttribute("aria-label", "Select audio files");
    const fileCardTitle = document.createElement("div");
    fileCardTitle.textContent = "Select audio files";
    Object.assign(fileCardTitle.style, {
      fontWeight: "600",
      fontSize: "14px",
      letterSpacing: "0.02em"
    });
    const fileStatus = document.createElement("div");
    const defaultStatusText = "Click to browse or drop files";
    fileStatus.textContent = defaultStatusText;
    Object.assign(fileStatus.style, {
      fontSize: "12px",
      opacity: "0.75"
    });
    fileCard.append(fileCardTitle, fileStatus);
    const setFileCardActive = (active) => {
      if (active) {
        fileCard.style.borderColor = "#6fc3ff";
        fileCard.style.boxShadow = "0 0 0 3px #6fc3ff22";
        fileCard.style.background = "linear-gradient(180deg, #102030, #0b1826)";
      } else {
        fileCard.style.borderColor = "#5d6a7d";
        fileCard.style.boxShadow = "none";
        fileCard.style.background = "linear-gradient(180deg, #0b141c, #091018)";
      }
    };
    fileCard.addEventListener("mouseenter", () => setFileCardActive(true));
    fileCard.addEventListener("mouseleave", () => setFileCardActive(document.activeElement === fileCard));
    fileCard.addEventListener("focus", () => setFileCardActive(true));
    fileCard.addEventListener("blur", () => setFileCardActive(false));
    fileCard.addEventListener("dragover", (ev) => {
      ev.preventDefault();
      setFileCardActive(true);
      if (ev.dataTransfer) ev.dataTransfer.dropEffect = "copy";
    });
    fileCard.addEventListener("dragleave", () => setFileCardActive(document.activeElement === fileCard));
    const triggerFileSelect = () => fileInput.click();
    fileCard.addEventListener("click", triggerFileSelect);
    fileCard.addEventListener("keydown", (ev) => {
      if (ev.key === "Enter" || ev.key === " ") {
        ev.preventDefault();
        triggerFileSelect();
      }
    });
    const displaySelection = (files) => {
      if (!files || !files.length) {
        fileStatus.textContent = defaultStatusText;
        return;
      }
      fileStatus.textContent = files.length === 1 ? files[0].name : `${files.length} files selected`;
    };
    fileCard.addEventListener("drop", async (ev) => {
      ev.preventDefault();
      const files = ev.dataTransfer?.files || null;
      displaySelection(files);
      await handleFiles(files);
      displaySelection(null);
      setFileCardActive(document.activeElement === fileCard);
    });
    importRow.append(fileInput, fileCard);
    s2.body.appendChild(importRow);
    const tip = document.createElement("div");
    tip.textContent = "MP3, WAV, OGG \u2014 limited to \u2264 10 s and \u2264 200 KB.";
    tip.style.opacity = "0.75";
    tip.style.fontSize = "12px";
    s2.body.appendChild(tip);
    const listWrap = document.createElement("div");
    Object.assign(listWrap.style, {
      display: "grid",
      gridTemplateRows: "auto 1fr",
      gap: "6px",
      border: "1px solid #4445",
      borderRadius: "10px",
      background: "#10161c",
      padding: "10px"
    });
    const listHeader = document.createElement("div");
    Object.assign(listHeader.style, {
      display: "grid",
      gridTemplateColumns: "minmax(0, 1fr) auto",
      gap: "12px",
      fontSize: "12px",
      letterSpacing: "0.05em",
      textTransform: "uppercase",
      opacity: "0.65",
      paddingBottom: "4px",
      borderBottom: "1px solid #ffffff14"
    });
    const headName = document.createElement("span");
    headName.textContent = "Sound";
    const headActions = document.createElement("span");
    headActions.textContent = "Actions";
    headActions.style.justifySelf = "end";
    listHeader.append(headName, headActions);
    const listBody = document.createElement("div");
    Object.assign(listBody.style, {
      display: "flex",
      flexDirection: "column",
      gap: "6px",
      maxHeight: "240px",
      overflowY: "auto",
      paddingRight: "4px",
      minHeight: "0",
      padding: "4px 0"
    });
    listWrap.append(listHeader, listBody);
    s2.body.appendChild(listWrap);
    const s2Err = errorBar();
    s2.body.appendChild(s2Err.el);
    const sanitizeLoopInput = (input, fallback) => {
      const trimmed = (input.value || "").trim();
      const raw = trimmed ? Number(trimmed) : NaN;
      const normalized = Number.isFinite(raw) ? raw : fallback;
      const clamped = Math.max(150, Math.min(1e4, Math.floor(normalized)));
      input.value = String(clamped);
      return clamped;
    };
    const updateStopVisibility = (context) => {
      const controls = contextControls[context];
      const loopChecked = controls.modeLoop?.checked ?? false;
      if (controls.stopRow) controls.stopRow.style.display = loopChecked ? "" : "none";
      if (controls.loopWrap) controls.loopWrap.style.display = loopChecked ? "flex" : "none";
    };
    const applyMode = (context, mode) => {
      if (context === "weather" && mode === "loop") {
        audio.setPlaybackMode("oneshot", context);
        contextControls[context].modeOneshot.checked = true;
        contextControls[context].modeLoop && (contextControls[context].modeLoop.checked = false);
        updateStopVisibility(context);
        return;
      }
      audio.setPlaybackMode(mode, context);
      updateStopVisibility(context);
    };
    const applyShopsStop = () => {
      const controls = contextControls.shops;
      if (!controls.loopInput) return;
      const loopMs = sanitizeLoopInput(controls.loopInput, audio.getLoopInterval("shops"));
      audio.setLoopInterval(loopMs, "shops");
      if (!controls.modeLoop?.checked) {
        if (controls.modeLoop) controls.modeLoop.checked = true;
        controls.modeOneshot.checked = false;
        applyMode("shops", "loop");
      }
      audio.setStopPurchase("shops");
      NotifierService.setContextStopDefaults("shops", { stopMode: "purchase", stopRepeats: null, loopIntervalMs: loopMs });
      return loopMs;
    };
    for (const cfg of contextOrder) {
      const controls = contextControls[cfg.key];
      controls.select.addEventListener("change", () => {
        audio.setDefaultSoundByName(controls.select.value, cfg.key);
        renderLibList();
      });
      controls.playBtn.addEventListener("click", () => {
        audio.trigger("preview", { sound: controls.select.value }, cfg.key).catch(() => {
        });
      });
      controls.volumeRange.addEventListener("input", () => {
        const value = Math.max(0, Math.min(100, parseInt(controls.volumeRange.value || "0", 10) || 0));
        controls.volumeValue.textContent = `${value}%`;
        audio.setVolume(value / 100, cfg.key);
      });
      controls.modeOneshot.addEventListener("change", () => {
        if (!controls.modeOneshot.checked) return;
        applyMode(cfg.key, "oneshot");
        if (cfg.key === "shops") {
          const loopMs = controls.loopInput ? sanitizeLoopInput(controls.loopInput, audio.getLoopInterval("shops")) : audio.getLoopInterval("shops");
          audio.setLoopInterval(loopMs, "shops");
          audio.setStopManual("shops");
          NotifierService.setContextStopDefaults("shops", { stopMode: "manual", stopRepeats: null, loopIntervalMs: loopMs });
        }
      });
      controls.modeLoop?.addEventListener("change", () => {
        if (!controls.modeLoop?.checked) return;
        applyMode(cfg.key, "loop");
        if (cfg.key === "shops") applyShopsStop();
      });
      if (cfg.allowPurchase) {
        controls.loopInput?.addEventListener("change", applyShopsStop);
        controls.loopInput?.addEventListener("blur", applyShopsStop);
      }
    }
    const refreshAllSoundSelects = () => {
      const names = audio.listSounds();
      const applyOptions = (sel, context) => {
        const current = sel.value;
        sel.innerHTML = "";
        for (const n of names) {
          const option = document.createElement("option");
          option.value = n;
          option.textContent = n;
          sel.appendChild(option);
        }
        const preferred = audio.getDefaultSoundName(context);
        if (names.includes(current)) sel.value = current;
        else if (preferred && names.includes(preferred)) sel.value = preferred;
        else if (names.length) sel.value = names[0];
      };
      for (const cfg of contextOrder) {
        applyOptions(contextControls[cfg.key].select, cfg.key);
      }
      const all = Array.from(document.querySelectorAll("select[data-sound-select]"));
      for (const sel of all) {
        const ctx = sel.dataset.soundSelect || "shops";
        if (contextControls[ctx]?.select === sel) continue;
        applyOptions(sel, ctx);
      }
    };
    const renderLibList = () => {
      listBody.replaceChildren();
      const names = audio.listSounds();
      if (!names.length) {
        const empty = document.createElement("div");
        empty.textContent = "No sounds in the library.";
        empty.style.opacity = "0.75";
        empty.style.textAlign = "center";
        empty.style.padding = "12px 6px";
        listBody.appendChild(empty);
        return;
      }
      const defaultShops = audio.getDefaultSoundName("shops");
      const defaultWeather = audio.getDefaultSoundName("weather");
      for (const name of names) {
        const row2 = document.createElement("div");
        Object.assign(row2.style, {
          display: "grid",
          gridTemplateColumns: "minmax(0, 1fr) auto",
          gap: "12px",
          alignItems: "center",
          padding: "8px 10px",
          borderRadius: "8px",
          border: "1px solid #1f2429",
          background: "#151b22"
        });
        const info = document.createElement("div");
        Object.assign(info.style, {
          display: "flex",
          alignItems: "center",
          gap: "8px",
          minWidth: "0"
        });
        const title = document.createElement("span");
        title.textContent = name;
        title.style.fontWeight = "600";
        title.style.overflow = "hidden";
        title.style.textOverflow = "ellipsis";
        title.style.whiteSpace = "nowrap";
        info.appendChild(title);
        const badges = document.createElement("div");
        badges.style.display = "flex";
        badges.style.gap = "6px";
        const makeBadge = (label2) => {
          const badge = document.createElement("span");
          badge.textContent = label2;
          Object.assign(badge.style, {
            fontSize: "11px",
            padding: "2px 6px",
            borderRadius: "999px",
            background: "#2b5cff33",
            border: "1px solid #2b5cff66",
            color: "#9cbcff",
            fontWeight: "600",
            textTransform: "uppercase",
            letterSpacing: "0.04em"
          });
          return badge;
        };
        const isShopsDefault = defaultShops === name;
        const isWeatherDefault = defaultWeather === name;
        if (isShopsDefault) badges.appendChild(makeBadge("Shops"));
        if (isWeatherDefault) badges.appendChild(makeBadge("Weather"));
        if (badges.childElementCount) info.appendChild(badges);
        if (isShopsDefault || isWeatherDefault) {
          row2.style.borderColor = "#2b5cff99";
          row2.style.boxShadow = "0 0 0 1px #2b5cff33";
        }
        const actions = document.createElement("div");
        Object.assign(actions.style, {
          display: "flex",
          gap: "6px",
          justifyContent: "flex-end",
          flexWrap: "wrap"
        });
        const btnPlay = smallBtn("\u25B6");
        const btnSetShops = smallBtn("Set shops");
        const btnSetWeather = smallBtn("Set weather");
        const btnDel = smallBtn("Remove");
        btnPlay.title = "Preview";
        btnSetShops.title = "Set as shops default";
        btnSetWeather.title = "Set as weather default";
        btnDel.title = "Remove from library";
        const isProtected = typeof audio.isProtectedSound === "function" && audio.isProtectedSound(name);
        if (isProtected || isShopsDefault || isWeatherDefault) {
          btnDel.disabled = true;
          btnDel.style.opacity = "0.6";
          if (isProtected) btnDel.title = "Built-in sound cannot be removed";
          else btnDel.title = "Currently used as default";
        }
        btnPlay.onclick = () => audio.trigger("preview", { sound: name }, "shops").catch(() => {
        });
        btnSetShops.onclick = () => {
          audio.setDefaultSoundByName(name, "shops");
          refreshAllSoundSelects();
          renderLibList();
        };
        btnSetWeather.onclick = () => {
          audio.setDefaultSoundByName(name, "weather");
          refreshAllSoundSelects();
          renderLibList();
        };
        btnDel.onclick = () => {
          audio.unregisterSound(name);
          refreshAllSoundSelects();
          renderLibList();
        };
        actions.append(btnPlay, btnSetShops, btnSetWeather, btnDel);
        row2.append(info, actions);
        listBody.appendChild(row2);
      }
    };
    const syncContext = (context) => {
      const controls = contextControls[context];
      const settings = audio.getPlaybackSettings(context);
      const names = audio.listSounds();
      if (settings.defaultSoundName && names.includes(settings.defaultSoundName)) {
        controls.select.value = settings.defaultSoundName;
      }
      const volPercent = Math.round(settings.volume * 100);
      controls.volumeRange.value = String(volPercent);
      controls.volumeValue.textContent = `${volPercent}%`;
      if (controls.modeLoop && settings.mode === "loop") controls.modeLoop.checked = true;
      else controls.modeOneshot.checked = true;
      const defaults = NotifierService.getContextStopDefaults(context);
      const fallbackLoop = Math.max(150, Math.min(1e4, Math.floor(defaults.loopIntervalMs || settings.loopIntervalMs || 150)));
      const loopMs = controls.loopInput ? sanitizeLoopInput(controls.loopInput, fallbackLoop) : fallbackLoop;
      audio.setLoopInterval(loopMs, context);
      if (context === "shops") {
        if (controls.modeLoop?.checked) {
          audio.setStopPurchase("shops");
          NotifierService.setContextStopDefaults("shops", { stopMode: "purchase", stopRepeats: null, loopIntervalMs: loopMs });
        } else {
          audio.setStopManual("shops");
          NotifierService.setContextStopDefaults("shops", { stopMode: "manual", stopRepeats: null, loopIntervalMs: loopMs });
        }
      } else {
        applyMode("weather", "oneshot");
        audio.setStopManual("weather");
        NotifierService.setContextStopDefaults("weather", { stopMode: "manual", stopRepeats: null, loopIntervalMs: loopMs });
      }
      updateStopVisibility(context);
    };
    const syncFromAudio = () => {
      refreshAllSoundSelects();
      syncContext("shops");
      syncContext("weather");
      renderLibList();
    };
    const handleFiles = async (files) => {
      s2Err.clear();
      if (!files || !files.length) return;
      const added = [];
      for (const f of Array.from(files)) {
        try {
          const res = await audio.importFileAsSound(f, {
            maxBytes: 200 * 1024,
            maxSeconds: 10,
            bitrates: [48e3, 32e3, 2e4, 12e3, 8e3],
            maxInputBytes: 8 * 1024 * 1024
          });
          added.push(res.name);
        } catch (e) {
          s2Err.show(`Failed for "${f.name}": ${e?.message || e}`);
        }
      }
      if (added.length) {
        refreshAllSoundSelects();
        renderLibList();
        for (const cfg of contextOrder) {
          if (!audio.getDefaultSoundName(cfg.key)) {
            audio.setDefaultSoundByName(added[0], cfg.key);
          }
        }
        refreshAllSoundSelects();
        renderLibList();
      }
      fileInput.value = "";
    };
    fileInput.onchange = async () => {
      const files = fileInput.files;
      displaySelection(files);
      await handleFiles(files);
      displaySelection(null);
      setFileCardActive(document.activeElement === fileCard);
    };
    syncFromAudio();
    const scroller = document.createElement("div");
    Object.assign(scroller.style, {
      overflow: "auto",
      minHeight: "0",
      height: "100%",
      display: "grid",
      gap: "12px"
    });
    scroller.append(s1.root, s2.root);
    root.appendChild(scroller);
    view.__cleanup__ = (() => {
      const prev = view.__cleanup__;
      return () => {
        try {
          prev?.();
        } catch {
        }
      };
    })();
  }
  function renderShopTab(view, ui) {
    view.innerHTML = "";
    view.style.cssText = "";
    if (!document.getElementById("qws-rule-style")) {
      const style2 = document.createElement("style");
      style2.id = "qws-rule-style";
      style2.textContent = `
:root {
  /* PATCH: z-index centralis\xE9 */
  --qws-z-popover: 99999999999999;
}

/* PATCH: bouton engrenage carr\xE9, centr\xE9, plus gros */
.qws-rule-btn {
  display: inline-grid;
  place-items: center;
  width: 32px;
  height: 32px;
  padding: 0;
  border-radius: 8px;
  line-height: 1;
  font-size: 18px; /* taille de l'ic\xF4ne */
  min-width: 32px; /* \xE9vite les r\xE9tr\xE9cissements */
  box-sizing: border-box;
}
.qws-rule-btn[data-active="1"] {
  background: linear-gradient(180deg, #1b2735, #101821);
  box-shadow: 0 0 0 1px #658dff88 inset;
  color: #c7daff;
}

/* PATCH: popover toujours devant */
.qws-rule-popover {
  position: fixed !important;
  z-index: var(--qws-z-popover) !important;
  display: flex;
  flex-direction: column;
  gap: 10px;
  color: #f1f6ff;
}
.qws-rule-popover .qws-rule-field {
  display: grid;
  gap: 6px;
}
.qws-rule-popover .qws-rule-field label {
  font-weight: 600;
  font-size: 13px;
}
.qws-rule-popover .qws-rule-actions {
  display: flex;
  justify-content: space-between;
  gap: 8px;
}

/* PATCH: r\xE9serve un espace pour le r\xE9sum\xE9 afin d'\xE9viter tout shift */
[data-role="rule-hint"] {
  min-height: 1.2em;  /* ~1 ligne r\xE9serv\xE9e */
}
`;
      document.head.appendChild(style2);
    }
    const wrap = document.createElement("div");
    Object.assign(wrap.style, {
      display: "grid",
      gridTemplateRows: "auto 1fr",
      gap: "10px",
      height: "54vh",
      overflow: "hidden",
      minHeight: "0",
      position: "relative"
    });
    view.appendChild(wrap);
    const header = document.createElement("div");
    header.style.display = "flex";
    header.style.flexWrap = "wrap";
    header.style.alignItems = "center";
    header.style.gap = "10px";
    header.style.rowGap = "8px";
    wrap.appendChild(header);
    const lblType = ui.label("Type");
    const selType = document.createElement("select");
    selType.className = "qmm-input";
    selType.style.minWidth = "140px";
    selType.id = "shop.filter.type";
    [
      ["all", "All"],
      ["seed", "Seeds"],
      ["egg", "Eggs"],
      ["tool", "Tools"],
      ["decor", "Decor"]
    ].forEach(([v, t]) => {
      const o = document.createElement("option");
      o.value = v;
      o.textContent = t;
      selType.appendChild(o);
    });
    selType.value = "all";
    const lblRarity = ui.label("Rarity");
    const selRarity = document.createElement("select");
    selRarity.className = "qmm-input";
    selRarity.style.minWidth = "160px";
    selRarity.id = "shop.filter.rarity";
    [
      ["all", "All"],
      ["common", "Common"],
      ["uncommon", "Uncommon"],
      ["rare", "Rare"],
      ["legendary", "Legendary"],
      ["mythical", "Mythical"],
      ["divine", "Divine"],
      ["celestial", "Celestial"]
    ].forEach(([v, t]) => {
      const o = document.createElement("option");
      o.value = v;
      o.textContent = t;
      selRarity.appendChild(o);
    });
    selRarity.value = "all";
    const followedBadge = document.createElement("div");
    followedBadge.id = "shop.followedCount";
    followedBadge.textContent = "Followed: 0";
    followedBadge.title = "Items with Overlay enabled";
    followedBadge.style.padding = "6px 10px";
    followedBadge.style.borderRadius = "999px";
    followedBadge.style.border = "1px solid #4445";
    followedBadge.style.background = "#1f2328";
    followedBadge.style.color = "#e7eef7";
    followedBadge.style.fontWeight = "600";
    followedBadge.style.marginLeft = "auto";
    followedBadge.style.width = "115px";
    header.append(lblType, selType, lblRarity, selRarity, followedBadge);
    const card = document.createElement("div");
    card.style.border = "1px solid #4445";
    card.style.borderRadius = "10px";
    card.style.padding = "10px";
    card.style.background = "#0f1318";
    card.style.overflow = "hidden";
    card.style.display = "grid";
    card.style.gridTemplateRows = "auto 1fr";
    card.style.minHeight = "0";
    wrap.appendChild(card);
    const headerGrid = document.createElement("div");
    const COLS = "minmax(200px, 1fr) 9rem 7rem 8rem";
    headerGrid.style.display = "grid";
    headerGrid.style.gridTemplateColumns = COLS;
    headerGrid.style.justifyContent = "start";
    headerGrid.style.columnGap = "0";
    headerGrid.style.borderBottom = "1px solid #ffffff1a";
    headerGrid.style.padding = "0 0 4px 0";
    headerGrid.style.position = "sticky";
    headerGrid.style.top = "0";
    headerGrid.append(
      mkHeadCell("Item", "left"),
      mkHeadCell("Rarity"),
      mkHeadCell("Notify"),
      mkHeadCell("Custom rules")
    );
    card.appendChild(headerGrid);
    const bodyGrid = document.createElement("div");
    bodyGrid.style.display = "grid";
    bodyGrid.style.gridTemplateColumns = COLS;
    bodyGrid.style.justifyContent = "start";
    bodyGrid.style.gridAutoRows = "auto";
    bodyGrid.style.alignContent = "start";
    bodyGrid.style.minHeight = "0";
    bodyGrid.style.height = "100%";
    bodyGrid.style.overflow = "auto";
    bodyGrid.style.overscrollBehavior = "contain";
    bodyGrid.style.width = "100%";
    bodyGrid.style.scrollbarGutter = "stable";
    card.appendChild(bodyGrid);
    const refreshRulesUI = () => {
      const kids = Array.from(bodyGrid.children);
      for (let i = 0; i + 3 < kids.length; i += 4) {
        const itemCell = kids[i];
        const ruleCell = kids[i + 3];
        const id = itemCell?.dataset?.id;
        if (!id) continue;
        applyRuleState(itemCell, ruleCell ?? null, NotifierService.getRule(id));
      }
    };
    const softUpdateRenderedRows = (next) => {
      const byId = new Map(next.rows.map((r) => [r.id, r]));
      const kids = Array.from(bodyGrid.children);
      for (let i = 0; i + 3 < kids.length; i += 4) {
        const itemCell = kids[i];
        const popupCell = kids[i + 2];
        const ruleCell = kids[i + 3];
        const id = itemCell.dataset.id;
        const row = byId.get(id);
        if (!row) continue;
        const popupSwitch = popupCell.querySelector("label");
        if (popupSwitch) setSwitchVisual(popupSwitch, !!row.popup);
        itemCell.dataset.follow = row.followed ? "1" : "0";
        applyRuleState(itemCell, ruleCell ?? null, NotifierService.getRule(id));
        const capped = NotifierService.isIdCapped?.(id) ?? false;
        if (popupSwitch) setSwitchCapState(popupSwitch, capped);
      }
    };
    const syncHeaderToScrollbar = () => {
      const sbw = bodyGrid.offsetWidth - bodyGrid.clientWidth;
      headerGrid.style.boxSizing = "border-box";
      headerGrid.style.paddingRight = `${sbw}px`;
    };
    syncHeaderToScrollbar();
    const resizeObserver = new ResizeObserver(syncHeaderToScrollbar);
    resizeObserver.observe(bodyGrid);
    const onResize = () => syncHeaderToScrollbar();
    window.addEventListener("resize", onResize);
    const lastSeenRefs = /* @__PURE__ */ new Map();
    let state2 = null;
    let renderedIds = /* @__PURE__ */ new Set();
    const getFilters = () => ({
      type: selType.value || "all",
      rarity: selRarity.value || "all"
    });
    const passesFilters = (rows) => NotifierService.filterRows(rows, getFilters());
    const mkItemCell = (row) => {
      const wrap2 = document.createElement("div");
      Object.assign(wrap2.style, {
        display: "flex",
        alignItems: "center",
        gap: "6px",
        padding: "4px 6px",
        borderBottom: "1px solid #ffffff12"
      });
      const ICON = 40;
      const iconWrap = document.createElement("div");
      Object.assign(iconWrap.style, {
        width: `${ICON}px`,
        height: `${ICON}px`,
        flex: `0 0 ${ICON}px`,
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        borderRadius: "8px",
        background: "#101820",
        marginRight: "6px",
        aspectRatio: "1 / 1"
      });
      const afterColon = (s) => {
        const i = s.indexOf(":");
        return i >= 0 ? s.slice(i + 1) : s;
      };
      const spriteFallback = row.type === "Seed" ? "\u{1F331}" : row.type === "Egg" ? "\u{1F95A}" : row.type === "Tool" ? "\u{1F9F0}" : "\u{1F3E0}";
      const spriteKey2 = afterColon(row.id);
      const sprite = createShopSprite(row.type, spriteKey2, {
        size: ICON - 6,
        fallback: spriteFallback,
        alt: row.name
      });
      iconWrap.appendChild(sprite);
      const col = document.createElement("div");
      Object.assign(col.style, {
        display: "flex",
        flexDirection: "column",
        gap: "2px",
        lineHeight: "1.15",
        minWidth: "0",
        // autorise l'ellipsis
        flex: "1 1 auto"
      });
      const title = document.createElement("div");
      title.textContent = row.name;
      Object.assign(title.style, {
        fontWeight: "700",
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
      });
      const sub = document.createElement("div");
      sub.textContent = row.type;
      sub.style.opacity = "0.7";
      sub.style.fontSize = "12px";
      const ruleHint = document.createElement("div");
      ruleHint.dataset.role = "rule-hint";
      ruleHint.style.display = "none";
      ruleHint.style.opacity = "0.75";
      ruleHint.style.fontSize = "11px";
      ruleHint.style.whiteSpace = "nowrap";
      ruleHint.style.overflow = "hidden";
      ruleHint.style.textOverflow = "ellipsis";
      ruleHint.style.minHeight = "1.2em";
      ruleHint.style.visibility = "hidden";
      col.append(title, sub, ruleHint);
      wrap2.append(iconWrap, col);
      return wrap2;
    };
    const addRow = (row) => {
      const itemCell = mkItemCell(row);
      itemCell.dataset.id = row.id;
      itemCell.dataset.type = row.type;
      itemCell.dataset.follow = row.followed ? "1" : "0";
      itemCell.dataset.context = "shops";
      const rarityCell = document.createElement("div");
      rarityCell.style.display = "flex";
      rarityCell.style.alignItems = "center";
      rarityCell.style.justifyContent = "center";
      rarityCell.style.borderBottom = "1px solid #ffffff12";
      rarityCell.appendChild(rarityBadge(String(row.rarity ?? "\u2014")));
      const popupSwitch = createSwitch((on) => {
        try {
          NotifierService.setPopup(row.id, !!on);
        } catch {
        }
        const cur = NotifierService.getPref(row.id);
        itemCell.dataset.follow = cur.followed ? "1" : "0";
      });
      setSwitchVisual(popupSwitch, !!row.popup);
      popupSwitch.style.padding = "0";
      const popupCell = wrapCell(popupSwitch);
      const capped = NotifierService.isIdCapped?.(row.id) ?? false;
      setSwitchCapState(popupSwitch, capped);
      const gearBtn = ui.btn("", {
        icon: "\u2699",
        size: "sm",
        tooltip: "Custom rule",
        ariaLabel: `Custom rule for ${row.name}`
      });
      gearBtn.dataset.role = "rule";
      gearBtn.classList.add("qws-rule-btn");
      gearBtn.addEventListener("click", (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        openRuleEditor(ui, {
          id: row.id,
          name: row.name,
          type: row.type,
          context: "shops"
        }, gearBtn);
      });
      const ruleCell = wrapCell(gearBtn);
      ruleCell.dataset.role = "rule-cell";
      bodyGrid.append(itemCell, rarityCell, popupCell, ruleCell);
      applyRuleState(itemCell, ruleCell, NotifierService.getRule(row.id));
    };
    function clearBody() {
      closeRuleEditor();
      bodyGrid.innerHTML = "";
      renderedIds = /* @__PURE__ */ new Set();
    }
    function renderEmpty() {
      const empty = document.createElement("div");
      empty.textContent = "No items.";
      empty.style.opacity = "0.75";
      empty.style.gridColumn = "1 / -1";
      empty.style.padding = "8px";
      bodyGrid.appendChild(empty);
    }
    function rebuildGrid() {
      clearBody();
      if (!state2) {
        renderEmpty();
        return;
      }
      const rows = passesFilters(state2.rows);
      if (!rows.length) {
        renderEmpty();
      } else {
        rows.forEach((r) => {
          addRow(r);
          renderedIds.add(r.id);
        });
      }
      refreshRulesUI();
      followedBadge.textContent = `Followed: ${state2.counts.followed}`;
      syncHeaderToScrollbar();
    }
    function softUpdateBadge(next) {
      followedBadge.textContent = `Followed: ${next.counts.followed}`;
    }
    function filteredIdSet(s) {
      const set2 = /* @__PURE__ */ new Set();
      for (const r of passesFilters(s.rows)) set2.add(r.id);
      return set2;
    }
    let unsub = null;
    let unsubRules = null;
    (async () => {
      try {
        await NotifierService.start();
      } catch {
      }
      unsub = await NotifierService.onChangeNow((s) => {
        const prev = state2;
        state2 = s;
        if (!prev) {
          rebuildGrid();
          softUpdateRenderedRows(state2);
          return;
        }
        const prevIds = renderedIds;
        const nextIds = filteredIdSet(s);
        let needRebuild = false;
        if (prevIds.size !== nextIds.size) needRebuild = true;
        else {
          for (const id of nextIds) if (!prevIds.has(id)) {
            needRebuild = true;
            break;
          }
        }
        if (needRebuild) {
          rebuildGrid();
        } else {
          softUpdateBadge(s);
          softUpdateRenderedRows(s);
        }
      });
      try {
        unsubRules = await NotifierService.onRulesChangeNow(() => refreshRulesUI());
      } catch {
      }
    })();
    const onFilterChange = () => {
      if (state2) rebuildGrid();
    };
    selType.onchange = onFilterChange;
    selRarity.onchange = onFilterChange;
    view.__cleanup__ = (() => {
      const prev = view.__cleanup__;
      return () => {
        try {
          unsub?.();
        } catch {
        }
        try {
          unsubRules?.();
        } catch {
        }
        try {
          resizeObserver.disconnect();
        } catch {
        }
        try {
          window.removeEventListener("resize", onResize);
        } catch {
        }
        try {
          closeRuleEditor();
        } catch {
        }
        try {
          prev?.();
        } catch {
        }
      };
    })();
  }
  function renderWeatherTab(view, ui) {
    view.innerHTML = "";
    view.style.cssText = "";
    const wrap = document.createElement("div");
    Object.assign(wrap.style, {
      display: "grid",
      gridTemplateRows: "1fr",
      height: "54vh",
      overflow: "hidden",
      minHeight: "0"
    });
    view.appendChild(wrap);
    const card = document.createElement("div");
    card.style.border = "1px solid #4445";
    card.style.borderRadius = "10px";
    card.style.padding = "10px";
    card.style.background = "#0f1318";
    card.style.overflow = "hidden";
    card.style.display = "grid";
    card.style.gridTemplateRows = "auto 1fr";
    card.style.minHeight = "0";
    wrap.appendChild(card);
    const headerGrid = document.createElement("div");
    const COLS = "minmax(240px, 1fr) 9rem 7rem 8rem";
    headerGrid.style.display = "grid";
    headerGrid.style.gridTemplateColumns = COLS;
    headerGrid.style.justifyContent = "start";
    headerGrid.style.columnGap = "0";
    headerGrid.style.borderBottom = "1px solid #ffffff1a";
    headerGrid.style.padding = "0 0 4px 0";
    headerGrid.style.position = "sticky";
    headerGrid.style.top = "0";
    headerGrid.append(
      mkHeadCell("Weather", "left"),
      mkHeadCell("Last seen"),
      mkHeadCell("Notify"),
      mkHeadCell("Custom rules")
    );
    card.appendChild(headerGrid);
    const bodyGrid = document.createElement("div");
    bodyGrid.style.display = "grid";
    bodyGrid.style.gridTemplateColumns = COLS;
    bodyGrid.style.justifyContent = "start";
    bodyGrid.style.gridAutoRows = "auto";
    bodyGrid.style.alignContent = "start";
    bodyGrid.style.minHeight = "0";
    bodyGrid.style.height = "100%";
    bodyGrid.style.overflow = "auto";
    bodyGrid.style.overscrollBehavior = "contain";
    bodyGrid.style.width = "100%";
    bodyGrid.style.scrollbarGutter = "stable";
    card.appendChild(bodyGrid);
    const weatherLastSeenRefs = /* @__PURE__ */ new Map();
    const refreshRulesUI = () => {
      const kids = Array.from(bodyGrid.children);
      for (let i = 0; i + 3 < kids.length; i += 4) {
        const itemCell = kids[i];
        const ruleCell = kids[i + 3];
        const id = itemCell?.dataset?.id;
        if (!id) continue;
        applyRuleState(itemCell, ruleCell ?? null, NotifierService.getRule(id));
      }
    };
    const syncHeaderToScrollbar = () => {
      const sbw = bodyGrid.offsetWidth - bodyGrid.clientWidth;
      headerGrid.style.boxSizing = "border-box";
      headerGrid.style.paddingRight = `${sbw}px`;
    };
    syncHeaderToScrollbar();
    const resizeObserver = new ResizeObserver(syncHeaderToScrollbar);
    resizeObserver.observe(bodyGrid);
    const onResize = () => syncHeaderToScrollbar();
    window.addEventListener("resize", onResize);
    const makeItemCell = (row) => {
      const wrapCellDiv = document.createElement("div");
      Object.assign(wrapCellDiv.style, {
        display: "flex",
        alignItems: "center",
        gap: "8px",
        padding: "6px",
        borderBottom: "1px solid #ffffff12"
      });
      const ICON = 40;
      const iconWrap = document.createElement("div");
      Object.assign(iconWrap.style, {
        width: `${ICON}px`,
        height: `${ICON}px`,
        flex: `0 0 ${ICON}px`,
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        borderRadius: "8px",
        background: "#101820"
      });
      const weatherSprite = createWeatherSprite(row.spriteKey ?? row.id, {
        size: ICON - 4,
        fallback: "\u{1F326}",
        alt: row.name
      });
      iconWrap.appendChild(weatherSprite);
      const col = document.createElement("div");
      Object.assign(col.style, {
        display: "flex",
        flexDirection: "column",
        gap: "4px",
        lineHeight: "1.2",
        minWidth: "0",
        flex: "1 1 auto"
      });
      const headerRow = document.createElement("div");
      Object.assign(headerRow.style, {
        display: "flex",
        alignItems: "center",
        gap: "6px",
        minWidth: "0"
      });
      const title = document.createElement("div");
      title.textContent = row.name;
      Object.assign(title.style, {
        fontWeight: "700",
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap",
        flex: "1 1 auto"
      });
      headerRow.appendChild(title);
      if (row.isCurrent) {
        const badge = document.createElement("span");
        badge.textContent = "Current";
        Object.assign(badge.style, {
          fontSize: "11px",
          padding: "2px 6px",
          borderRadius: "999px",
          background: "#2b5cff33",
          border: "1px solid #2b5cff66",
          color: "#9cbcff",
          fontWeight: "600",
          whiteSpace: "nowrap"
        });
        headerRow.appendChild(badge);
      }
      const mutationsLabel = document.createElement("div");
      mutationsLabel.textContent = "Mutations";
      Object.assign(mutationsLabel.style, {
        fontSize: "11px",
        opacity: "0.7",
        fontWeight: "600"
      });
      const mutationsList = document.createElement("div");
      Object.assign(mutationsList.style, {
        display: "flex",
        flexWrap: "wrap",
        gap: "6px",
        alignItems: "flex-start",
        fontSize: "12px",
        lineHeight: "1.3",
        opacity: row.mutations.length ? "0.85" : "0.6"
      });
      if (row.mutations.length) {
        for (const mutation of row.mutations) {
          const chip = document.createElement("span");
          chip.textContent = formatWeatherMutation(mutation);
          Object.assign(chip.style, {
            display: "inline-flex",
            alignItems: "center",
            padding: "2px 8px",
            borderRadius: "999px",
            background: "#ffffff12",
            whiteSpace: "nowrap"
          });
          mutationsList.appendChild(chip);
        }
      } else {
        const chip = document.createElement("span");
        chip.textContent = "No mutation effects.";
        chip.style.whiteSpace = "nowrap";
        mutationsList.appendChild(chip);
      }
      const ruleHint = document.createElement("div");
      ruleHint.dataset.role = "rule-hint";
      ruleHint.style.opacity = "0.75";
      ruleHint.style.fontSize = "11px";
      ruleHint.style.whiteSpace = "nowrap";
      ruleHint.style.overflow = "hidden";
      ruleHint.style.textOverflow = "ellipsis";
      ruleHint.style.minHeight = "1.2em";
      ruleHint.style.visibility = "hidden";
      col.append(headerRow, mutationsLabel, mutationsList, ruleHint);
      wrapCellDiv.append(iconWrap, col);
      if (row.isCurrent) {
        wrapCellDiv.style.background = "linear-gradient(180deg, #1b2735, #141d25)";
        wrapCellDiv.style.borderRadius = "8px";
      }
      return wrapCellDiv;
    };
    const addRow = (row) => {
      const itemCell = makeItemCell(row);
      itemCell.dataset.id = row.id;
      itemCell.dataset.context = "weather";
      itemCell.dataset.current = row.isCurrent ? "1" : "0";
      const lastSeenInfo = document.createElement("div");
      const { label: label2, title } = formatLastSeen(row.lastSeen, row.isCurrent);
      lastSeenInfo.textContent = label2;
      lastSeenInfo.title = title;
      lastSeenInfo.style.fontWeight = "600";
      lastSeenInfo.style.opacity = label2 === "Never" ? "0.7" : "1";
      lastSeenInfo.style.whiteSpace = "nowrap";
      const lastSeenCell = wrapCell(lastSeenInfo);
      weatherLastSeenRefs.set(row.id, lastSeenInfo);
      const notifySwitch = createSwitch((on) => {
        try {
          NotifierService.setWeatherNotify(row.id, !!on);
        } catch {
        }
      });
      setSwitchVisual(notifySwitch, !!row.notify);
      notifySwitch.style.padding = "0";
      const notifyCell = wrapCell(notifySwitch);
      const gearBtn = ui.btn("", {
        icon: "\u2699",
        size: "sm",
        tooltip: "Custom rule",
        ariaLabel: `Custom rule for ${row.name}`
      });
      gearBtn.dataset.role = "rule";
      gearBtn.classList.add("qws-rule-btn");
      gearBtn.addEventListener("click", (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        openRuleEditor(ui, {
          id: row.id,
          name: row.name,
          type: row.type,
          context: "weather"
        }, gearBtn);
      });
      const ruleCell = wrapCell(gearBtn);
      ruleCell.dataset.role = "rule-cell";
      bodyGrid.append(itemCell, lastSeenCell, notifyCell, ruleCell);
      applyRuleState(itemCell, ruleCell, NotifierService.getRule(row.id));
    };
    const clearGrid = () => {
      closeRuleEditor();
      bodyGrid.innerHTML = "";
      weatherLastSeenRefs.clear();
    };
    const renderEmpty = () => {
      const empty = document.createElement("div");
      empty.textContent = "No weather entries.";
      empty.style.opacity = "0.75";
      empty.style.gridColumn = "1 / -1";
      empty.style.padding = "8px";
      bodyGrid.appendChild(empty);
    };
    let state2 = null;
    let stateSig = "";
    const updateDynamicWeatherStats = () => {
      if (!state2) return;
      for (const row of state2.rows) {
        const target = weatherLastSeenRefs.get(row.id);
        if (target) {
          const { label: label2, title } = formatLastSeen(row.lastSeen, row.isCurrent);
          target.textContent = label2;
          target.title = title;
          target.style.opacity = label2 === "Never" ? "0.7" : "1";
        }
      }
    };
    const rebuildGrid = () => {
      clearGrid();
      if (!state2 || !state2.rows.length) {
        renderEmpty();
      } else {
        state2.rows.forEach(addRow);
        refreshRulesUI();
      }
      syncHeaderToScrollbar();
      updateDynamicWeatherStats();
    };
    let unsubWeather = null;
    let unsubRules = null;
    (async () => {
      try {
        await NotifierService.start();
      } catch {
      }
      try {
        unsubWeather = await NotifierService.onWeatherChangeNow((next) => {
          state2 = next;
          stateSig = weatherStateSignature(next.rows);
          rebuildGrid();
        });
      } catch {
      }
      try {
        unsubRules = await NotifierService.onRulesChangeNow(() => refreshRulesUI());
      } catch {
      }
    })();
    const refreshWeatherState = async () => {
      try {
        const next = await NotifierService.getWeatherState();
        const nextSig = weatherStateSignature(next.rows);
        const changed = nextSig !== stateSig;
        state2 = next;
        stateSig = nextSig;
        if (changed) rebuildGrid();
        else updateDynamicWeatherStats();
      } catch {
      }
    };
    const dynamicTimer = window.setInterval(updateDynamicWeatherStats, 3e4);
    const weatherRefreshTimer = window.setInterval(() => {
      void refreshWeatherState();
    }, 6e4);
    view.__cleanup__ = (() => {
      const prev = view.__cleanup__;
      return () => {
        try {
          unsubWeather?.();
        } catch {
        }
        try {
          unsubRules?.();
        } catch {
        }
        try {
          resizeObserver.disconnect();
        } catch {
        }
        try {
          window.removeEventListener("resize", onResize);
        } catch {
        }
        try {
          window.clearInterval(dynamicTimer);
        } catch {
        }
        try {
          window.clearInterval(weatherRefreshTimer);
        } catch {
        }
        try {
          closeRuleEditor();
        } catch {
        }
        try {
          prev?.();
        } catch {
        }
      };
    })();
  }
  function renderNotifierMenu(root) {
    const ui = new Menu({ id: "alerts", compact: true, windowSelector: ".qws-win" });
    ui.addTab("shops", "\u{1F6D2} Shops", (view) => renderShopTab(view, ui));
    ui.addTab("weather", "\u{1F326} Weather", (view) => renderWeatherTab(view, ui));
    ui.addTab("settings", "\u2699\uFE0F General settings", (view) => renderSettingsTab(view, ui));
    ui.mount(root);
  }

  // src/utils/format.ts
  function formatPrice(val) {
    const n = typeof val === "number" ? val : Number(val);
    if (!Number.isFinite(n)) return n === Infinity ? "\u221E" : null;
    const abs = Math.abs(n);
    const fmt = (x) => Number.isInteger(x) ? String(x) : x.toFixed(1);
    if (abs >= 1e12) return `${fmt(n / 1e12)}T`;
    if (abs >= 1e9) return `${fmt(n / 1e9)}B`;
    if (abs >= 1e6) return `${fmt(n / 1e6)}M`;
    if (abs >= 1e3) return `${fmt(n / 1e3)}k`;
    return String(n);
  }

  // src/ui/menus/stats.ts
  var NF_INT = new Intl.NumberFormat("en-US");
  var formatInt = (value) => NF_INT.format(Math.max(0, Math.floor(value || 0)));
  var DURATION_ABILITIES = /* @__PURE__ */ new Set([
    "egggrowthboost",
    "egggrowthboostii",
    "egggrowthboostiii",
    "plantgrowthboost",
    "plantgrowthboostii"
  ]);
  var XP_ABILITIES = /* @__PURE__ */ new Set(["petxpboost", "petxpboostii"]);
  var STRENGTH_ABILITIES = /* @__PURE__ */ new Set(["pethatchsizeboost", "pethatchsizeboostii"]);
  var HUNGER_ABILITIES = /* @__PURE__ */ new Set(["hungerrestore", "hungerrestoreii"]);
  function isPlainRecord(value) {
    return typeof value === "object" && value !== null;
  }
  function isGardenStatsSectionEmpty(garden2) {
    return (garden2.totalPlanted ?? 0) <= 0 && (garden2.totalHarvested ?? 0) <= 0 && (garden2.totalDestroyed ?? 0) <= 0 && (garden2.watercanUsed ?? 0) <= 0 && (garden2.waterTimeSavedMs ?? 0) <= 0;
  }
  function isShopStatsSectionEmpty(shops2) {
    return (shops2.seedsBought ?? 0) <= 0 && (shops2.decorBought ?? 0) <= 0 && (shops2.eggsBought ?? 0) <= 0 && (shops2.toolsBought ?? 0) <= 0 && (shops2.cropsSoldCount ?? 0) <= 0 && (shops2.cropsSoldValue ?? 0) <= 0 && (shops2.petsSoldCount ?? 0) <= 0 && (shops2.petsSoldValue ?? 0) <= 0;
  }
  function isPetStatsSectionEmpty(stats) {
    const entries = Object.values(stats.pets?.hatchedByType ?? {});
    if (entries.length === 0) return true;
    return entries.every((counts) => {
      if (!counts) return true;
      const normal = Number(counts.normal) || 0;
      const gold = Number(counts.gold) || 0;
      const rainbow = Number(counts.rainbow) || 0;
      return normal <= 0 && gold <= 0 && rainbow <= 0;
    });
  }
  async function readInventoryQuantity(atom, label2) {
    try {
      const raw = await atom.get();
      if (!Array.isArray(raw)) return 0;
      let total = 0;
      for (const entry of raw) {
        if (!entry || typeof entry !== "object") continue;
        const quantity = Number(entry.quantity);
        if (Number.isFinite(quantity) && quantity > 0) {
          total += Math.max(0, Math.floor(quantity));
        }
      }
      return total;
    } catch (error) {
      console.warn(`[StatsMenu] Failed to read ${label2} inventory`, error);
      return 0;
    }
  }
  async function initGarden(stats) {
    if (!isGardenStatsSectionEmpty(stats.garden)) return;
    let state2;
    try {
      state2 = await garden.get();
    } catch (error) {
      console.warn("[StatsMenu] Failed to read garden data", error);
      return;
    }
    if (!state2 || !isPlainRecord(state2.tileObjects)) return;
    let totalPlanted = 0;
    for (const value of Object.values(state2.tileObjects)) {
      if (!isPlainRecord(value)) continue;
      const objectType = typeof value.objectType === "string" ? value.objectType.toLowerCase() : "";
      if (objectType === "plant") {
        totalPlanted += 1;
      }
    }
    if (totalPlanted <= 0) return;
    StatsService.update((draft) => {
      if (!isGardenStatsSectionEmpty(draft.garden)) return;
      draft.garden.totalPlanted = totalPlanted;
    });
  }
  async function initShops(stats) {
    if (!isShopStatsSectionEmpty(stats.shops)) return;
    let state2 = null;
    try {
      state2 = await garden.get();
    } catch (error) {
      console.warn("[StatsMenu] Failed to read garden data", error);
    }
    let seedsBought = 0;
    let eggsBought = 0;
    let decorBought = 0;
    let toolsBought = 0;
    if (state2 && isPlainRecord(state2.tileObjects)) {
      for (const value of Object.values(state2.tileObjects)) {
        if (!isPlainRecord(value)) continue;
        const objectType = typeof value.objectType === "string" ? value.objectType.toLowerCase() : "";
        if (objectType === "plant") {
          seedsBought += 1;
        } else if (objectType === "egg") {
          eggsBought += 1;
        }
      }
    }
    if (state2 && isPlainRecord(state2.boardwalkTileObjects)) {
      for (const value of Object.values(state2.boardwalkTileObjects)) {
        if (value != null) {
          decorBought += 1;
        }
      }
    }
    const [seedInventoryQty, toolInventoryQty, eggInventoryQty, decorInventoryQty] = await Promise.all([
      readInventoryQuantity(mySeedInventory, "seed"),
      readInventoryQuantity(myToolInventory, "tool"),
      readInventoryQuantity(myEggInventory, "egg"),
      readInventoryQuantity(myDecorInventory, "decor")
    ]);
    seedsBought += seedInventoryQty;
    eggsBought += eggInventoryQty;
    decorBought += decorInventoryQty;
    toolsBought += toolInventoryQty;
    if (seedsBought <= 0 && eggsBought <= 0 && decorBought <= 0 && toolsBought <= 0) return;
    StatsService.update((draft) => {
      if (!isShopStatsSectionEmpty(draft.shops)) return;
      if (seedsBought > 0 && (draft.shops.seedsBought ?? 0) <= 0) {
        draft.shops.seedsBought = seedsBought;
      }
      if (eggsBought > 0 && (draft.shops.eggsBought ?? 0) <= 0) {
        draft.shops.eggsBought = eggsBought;
      }
      if (decorBought > 0 && (draft.shops.decorBought ?? 0) <= 0) {
        draft.shops.decorBought = decorBought;
      }
      if (toolsBought > 0 && (draft.shops.toolsBought ?? 0) <= 0) {
        draft.shops.toolsBought = toolsBought;
      }
    });
  }
  function getInventoryItems(raw) {
    if (Array.isArray(raw)) return raw;
    if (isPlainRecord(raw) && Array.isArray(raw.items)) {
      return raw.items;
    }
    return [];
  }
  function determinePetMutationType(mutations) {
    if (!Array.isArray(mutations)) return "normal";
    let hasGold = false;
    for (const mutation of mutations) {
      if (typeof mutation !== "string") continue;
      const normalized = mutation.trim().toLowerCase();
      if (normalized === "rainbow") {
        return "rainbow";
      }
      if (normalized === "gold") {
        hasGold = true;
      }
    }
    return hasGold ? "gold" : "normal";
  }
  async function initPets(stats) {
    if (!isPetStatsSectionEmpty(stats)) return;
    let inventory;
    try {
      inventory = await myInventory.get();
    } catch (error) {
      console.warn("[StatsMenu] Failed to read inventory data", error);
      inventory = null;
    }
    let activePetsRaw;
    try {
      activePetsRaw = await myPetInfos.get();
    } catch (error) {
      console.warn("[StatsMenu] Failed to read active pet data", error);
      activePetsRaw = null;
    }
    const items = getInventoryItems(inventory);
    const activePets = Array.isArray(activePetsRaw) ? activePetsRaw : [];
    if (items.length === 0 && activePets.length === 0) return;
    const countsBySpecies = /* @__PURE__ */ new Map();
    for (const item of items) {
      if (!isPlainRecord(item)) continue;
      const itemType = typeof item.itemType === "string" ? item.itemType.toLowerCase() : "";
      if (itemType !== "pet") continue;
      const speciesRaw = typeof item.petSpecies === "string" ? item.petSpecies : null;
      const species = speciesRaw?.trim();
      if (!species) continue;
      const key2 = species.toLowerCase();
      const counts = countsBySpecies.get(key2) ?? { normal: 0, gold: 0, rainbow: 0 };
      const rarityKey = determinePetMutationType(item.mutations);
      counts[rarityKey] = (counts[rarityKey] ?? 0) + 1;
      countsBySpecies.set(key2, counts);
    }
    for (const entry of activePets) {
      if (!isPlainRecord(entry)) continue;
      const slot = isPlainRecord(entry.slot) ? entry.slot : null;
      if (!slot) continue;
      const speciesRaw = typeof slot.petSpecies === "string" ? slot.petSpecies : null;
      const species = speciesRaw?.trim();
      if (!species) continue;
      const key2 = species.toLowerCase();
      const counts = countsBySpecies.get(key2) ?? { normal: 0, gold: 0, rainbow: 0 };
      const rarityKey = determinePetMutationType(slot.mutations);
      counts[rarityKey] = (counts[rarityKey] ?? 0) + 1;
      countsBySpecies.set(key2, counts);
    }
    let hasCounts = false;
    for (const counts of countsBySpecies.values()) {
      if ((counts.normal ?? 0) > 0 || (counts.gold ?? 0) > 0 || (counts.rainbow ?? 0) > 0) {
        hasCounts = true;
        break;
      }
    }
    if (!hasCounts) return;
    StatsService.update((draft) => {
      if (!isPetStatsSectionEmpty(draft)) return;
      for (const [speciesKey, counts] of countsBySpecies) {
        if ((counts.normal ?? 0) <= 0 && (counts.gold ?? 0) <= 0 && (counts.rainbow ?? 0) <= 0) {
          continue;
        }
        const entry = draft.pets.hatchedByType[speciesKey] ?? { normal: 0, gold: 0, rainbow: 0 };
        entry.normal = (entry.normal ?? 0) + (counts.normal ?? 0);
        entry.gold = (entry.gold ?? 0) + (counts.gold ?? 0);
        entry.rainbow = (entry.rainbow ?? 0) + (counts.rainbow ?? 0);
        draft.pets.hatchedByType[speciesKey] = entry;
      }
    });
  }
  function formatAbilityTotalValue(abilityId, totalValue) {
    const normalized = abilityId.toLowerCase();
    const safeValue = Number.isFinite(totalValue) ? Math.max(0, totalValue) : 0;
    if (DURATION_ABILITIES.has(normalized)) {
      return formatDuration(safeValue);
    }
    if (XP_ABILITIES.has(normalized)) {
      return `${formatInt(safeValue)} XP`;
    }
    if (STRENGTH_ABILITIES.has(normalized)) {
      return `${formatInt(safeValue)} strength`;
    }
    if (HUNGER_ABILITIES.has(normalized)) {
      const rounded = Math.round(safeValue);
      const isWholeNumber = Math.abs(safeValue - rounded) < 1e-6;
      const formatted = isWholeNumber ? formatInt(rounded) : safeValue.toFixed(1);
      return `${formatted}% hunger`;
    }
    return formatPrice(safeValue) ?? formatInt(safeValue);
  }
  var STATS_WINDOW_MIN_WIDTH = 560;
  var LS_STATS_COLLAPSE_KEY = "menu:stats:collapsed";
  var collapseStateCache = null;
  function getStatsStorage() {
    try {
      if (typeof window !== "undefined" && window.localStorage) {
        return window.localStorage;
      }
    } catch {
    }
    try {
      if (typeof localStorage !== "undefined") {
        return localStorage;
      }
    } catch {
    }
    return null;
  }
  function readCollapseState() {
    const storage = getStatsStorage();
    if (!storage) return {};
    try {
      const raw = storage.getItem(LS_STATS_COLLAPSE_KEY);
      if (!raw) return {};
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== "object") return {};
      const entries = Object.entries(parsed).filter((entry) => {
        return typeof entry[1] === "boolean";
      });
      return Object.fromEntries(entries);
    } catch (error) {
      console.warn("[StatsMenu] Failed to read collapse state", error);
      return {};
    }
  }
  function writeCollapseState(state2) {
    const storage = getStatsStorage();
    if (!storage) return;
    try {
      storage.setItem(LS_STATS_COLLAPSE_KEY, JSON.stringify(state2));
    } catch (error) {
      console.warn("[StatsMenu] Failed to save collapse state", error);
    }
  }
  function getCollapseState() {
    if (!collapseStateCache) {
      collapseStateCache = readCollapseState();
    }
    return collapseStateCache;
  }
  function getSectionCollapsed(id, fallback) {
    const state2 = getCollapseState();
    const value = state2[id];
    return typeof value === "boolean" ? value : fallback;
  }
  function setSectionCollapsed(id, collapsed) {
    const current = getCollapseState();
    if (current[id] === collapsed) return;
    const next = { ...current, [id]: collapsed };
    collapseStateCache = next;
    writeCollapseState(next);
  }
  var DATE_TIME_FORMATTER = new Intl.DateTimeFormat(void 0, {
    dateStyle: "medium",
    timeStyle: "short"
  });
  var RELATIVE_TIME_FORMATTER = new Intl.RelativeTimeFormat(void 0, {
    numeric: "auto"
  });
  var RARITY_ORDER2 = [
    rarity.Common,
    rarity.Uncommon,
    rarity.Rare,
    rarity.Legendary,
    rarity.Mythic,
    rarity.Divine,
    rarity.Celestial
  ];
  var RARITY_BORDER_COLORS = {
    [rarity.Common]: "#E7E7E7",
    [rarity.Uncommon]: "#67BD4D",
    [rarity.Rare]: "#0071C6",
    [rarity.Legendary]: "#FFC734",
    [rarity.Mythic]: "#9944A7",
    [rarity.Divine]: "#FF7835",
    [rarity.Celestial]: "#7C2AE8"
  };
  function createCollapsibleCard(ui, title, opts = {}) {
    const card = ui.card(title, { tone: "muted", align: "stretch", subtitle: opts.subtitle, icon: opts.icon });
    card.root.classList.add("qmm-card--collapsible");
    const toggle = document.createElement("button");
    toggle.type = "button";
    toggle.className = "qmm-btn qmm-btn--ghost qmm-btn--sm stats-collapse-toggle";
    toggle.style.marginLeft = "auto";
    const toggleIcon = document.createElement("span");
    toggleIcon.className = "stats-collapse-toggle__icon";
    toggleIcon.setAttribute("aria-hidden", "true");
    const toggleLabel = document.createElement("span");
    toggleLabel.className = "stats-collapse-toggle__label";
    toggle.append(toggleIcon, toggleLabel);
    const titleElement = card.header.querySelector(".qmm-card__title");
    if (titleElement) titleElement.insertAdjacentElement("afterend", toggle);
    else card.header.appendChild(toggle);
    const storageId = opts.storageId?.trim() || null;
    let currentAnimation = null;
    const stopAnimation = () => {
      if (!currentAnimation) return;
      currentAnimation.cancel();
      currentAnimation = null;
    };
    const animateBody = (collapsed) => {
      const body = card.body;
      stopAnimation();
      const prefersReducedMotion = typeof window.matchMedia === "function" && window.matchMedia("(prefers-reduced-motion: reduce)").matches;
      if (prefersReducedMotion) {
        body.style.display = collapsed ? "none" : "grid";
        body.style.height = "";
        body.style.opacity = "";
        body.style.overflow = "";
        return;
      }
      const easing = "cubic-bezier(0.33, 1, 0.68, 1)";
      const duration = 220;
      body.style.overflow = "hidden";
      if (!collapsed) {
        body.style.display = "grid";
        body.style.height = "0px";
        body.style.opacity = "0";
        const targetHeight = body.scrollHeight;
        currentAnimation = body.animate(
          [
            { height: "0px", opacity: 0 },
            { height: `${targetHeight}px`, opacity: 1 }
          ],
          { duration, easing, fill: "forwards" }
        );
      } else {
        const startHeight = body.offsetHeight;
        body.style.height = `${startHeight}px`;
        body.style.opacity = "1";
        currentAnimation = body.animate(
          [
            { height: `${startHeight}px`, opacity: 1 },
            { height: "0px", opacity: 0 }
          ],
          { duration, easing, fill: "forwards" }
        );
      }
      if (!currentAnimation) {
        body.style.display = collapsed ? "none" : "grid";
        body.style.height = "";
        body.style.opacity = "";
        body.style.overflow = "";
        return;
      }
      currentAnimation.onfinish = () => {
        if (collapsed) {
          body.style.display = "none";
          body.style.opacity = "";
        } else {
          body.style.display = "grid";
          body.style.opacity = "";
        }
        body.style.height = "";
        body.style.overflow = "";
        currentAnimation = null;
      };
      currentAnimation.oncancel = () => {
        body.style.height = "";
        body.style.opacity = "";
        body.style.overflow = "";
        if (collapsed) {
          body.style.display = "none";
        }
        currentAnimation = null;
      };
    };
    const setCollapsed = (collapsed, persist = true, animate = true) => {
      if (!animate) {
        stopAnimation();
        card.body.style.display = collapsed ? "none" : "grid";
        card.body.style.height = "";
        card.body.style.opacity = "";
        card.body.style.overflow = "";
      } else {
        animateBody(collapsed);
      }
      card.root.dataset.collapsed = collapsed ? "true" : "false";
      toggle.setAttribute("aria-expanded", String(!collapsed));
      const verb = collapsed ? "Show" : "Hide";
      const label2 = `${verb} ${title}`;
      toggleLabel.textContent = verb;
      toggle.setAttribute("aria-label", label2);
      toggle.title = label2;
      card.root.classList.toggle("is-collapsed", collapsed);
      if (persist && storageId) {
        setSectionCollapsed(storageId, collapsed);
      }
    };
    const defaultCollapsed = !!opts.startCollapsed;
    const initialCollapsed = storageId ? getSectionCollapsed(storageId, defaultCollapsed) : defaultCollapsed;
    setCollapsed(initialCollapsed, false, false);
    toggle.addEventListener("click", () => {
      const collapsed = card.root.dataset.collapsed === "true";
      setCollapsed(!collapsed);
    });
    return { root: card.root, body: card.body, header: card.header, setCollapsed };
  }
  function createMetricGrid(rows) {
    const grid = document.createElement("div");
    grid.className = "stats-metric-grid";
    for (const row of rows) {
      const card = document.createElement("div");
      card.className = "stats-metric";
      if (row.hint) card.title = row.hint;
      const label2 = document.createElement("span");
      label2.className = "stats-metric__label";
      label2.textContent = row.label;
      const value = document.createElement("span");
      value.className = "stats-metric__value qmm-num";
      value.textContent = row.value;
      card.append(label2, value);
      grid.appendChild(card);
    }
    return grid;
  }
  function createWeatherNameCell(entry) {
    const wrapper = document.createElement("span");
    wrapper.className = "stats-weather__name";
    const iconWrap = document.createElement("span");
    iconWrap.className = "stats-weather__icon";
    const sprite = createWeatherSprite(entry.spriteKey ?? entry.label, {
      size: 32,
      fallback: "\u{1F326}",
      alt: entry.label
    });
    iconWrap.appendChild(sprite);
    const label2 = document.createElement("span");
    label2.className = "stats-weather__label";
    label2.textContent = entry.label;
    wrapper.append(iconWrap, label2);
    return { content: wrapper };
  }
  function createStatList(columns, rows) {
    const container = document.createElement("div");
    container.className = "stats-list";
    const toTemplate = (column) => {
      if (column.width) return column.width;
      if (column.minWidth) return `minmax(${column.minWidth}, 1fr)`;
      return "minmax(0, 1fr)";
    };
    const template = columns.map(toTemplate).join(" ");
    const header = document.createElement("div");
    header.className = "stats-list__row stats-list__row--header";
    header.style.gridTemplateColumns = template;
    for (const column of columns) {
      const cell = document.createElement("span");
      cell.className = "stats-list__cell";
      const align = column.align ?? "left";
      if (align !== "left") cell.classList.add(`stats-list__cell--align-${align}`);
      if (column.headerClassName) cell.classList.add(column.headerClassName);
      cell.textContent = column.label;
      header.appendChild(cell);
    }
    container.appendChild(header);
    for (const row of rows) {
      const rowEl = document.createElement("div");
      rowEl.className = "stats-list__row";
      rowEl.style.gridTemplateColumns = template;
      row.forEach((cellData, index) => {
        const column = columns[index];
        const cell = document.createElement("span");
        cell.className = "stats-list__cell";
        const align = cellData.align ?? column.align ?? "left";
        if (align !== "left") {
          cell.classList.add(`stats-list__cell--align-${align}`);
          if (align === "right") cell.classList.add("qmm-num");
        }
        if (cellData.hint) cell.title = cellData.hint;
        const hasContent = Boolean(cellData.content);
        if (cellData.content) {
          cell.appendChild(cellData.content);
        }
        if (cellData.text != null) {
          if (hasContent) {
            const textSpan = document.createElement("span");
            textSpan.textContent = cellData.text;
            cell.appendChild(textSpan);
          } else {
            cell.textContent = cellData.text;
          }
        } else if (!hasContent) {
          cell.textContent = "";
        }
        rowEl.appendChild(cell);
      });
      container.appendChild(rowEl);
    }
    return container;
  }
  function formatDuration(ms) {
    const value = Math.max(0, ms || 0);
    if (value < 1e3) return `${formatInt(value)} ms`;
    const seconds = value / 1e3;
    if (seconds < 60) return `${seconds.toFixed(1)} s`;
    const minutes = seconds / 60;
    if (minutes < 60) return `${minutes.toFixed(1)} min`;
    const hours = minutes / 60;
    return `${hours.toFixed(1)} h`;
  }
  function formatDateTime(ms) {
    return DATE_TIME_FORMATTER.format(new Date(ms));
  }
  function renderMetaSection(ui, root, stats) {
    const card = ui.card("\u{1F5D3}\uFE0F Tracking", {
      tone: "muted",
      align: "stretch",
      compactHeader: true
    });
    const createdAt = Number.isFinite(stats.createdAt) ? Math.max(0, Math.floor(stats.createdAt)) : 0;
    const hasCreatedAt = createdAt > 0;
    const row = ui.flexRow({ align: "center", gap: 12, className: "stats-meta" });
    const label2 = document.createElement("span");
    label2.className = "stats-meta__label";
    label2.textContent = "Tracking started:";
    row.appendChild(label2);
    const value = document.createElement("strong");
    value.className = "stats-meta__value";
    value.textContent = hasCreatedAt ? formatDateTime(createdAt) : "Unavailable";
    row.appendChild(value);
    const resetButton = ui.btn("RESET", { variant: "danger" });
    resetButton.style.marginLeft = "auto";
    resetButton.addEventListener("click", () => {
      const freshStats = StatsService.reset();
      void initGarden(freshStats);
      void initShops(freshStats);
      void initPets(freshStats);
    });
    row.appendChild(resetButton);
    card.body.appendChild(row);
    root.appendChild(card.root);
  }
  function renderGardenSection(ui, root, stats) {
    const card = createCollapsibleCard(ui, "\u{1F331} Garden", {
      subtitle: "Field activity",
      storageId: "garden"
    });
    const rows = [
      { label: "Total planted", value: formatInt(stats.garden.totalPlanted) },
      { label: "Total harvested", value: formatInt(stats.garden.totalHarvested) },
      { label: "Total destroyed", value: formatInt(stats.garden.totalDestroyed) },
      { label: "Watering can Used", value: formatInt(stats.garden.watercanUsed) },
      {
        label: "Water time saved",
        value: formatDuration(stats.garden.waterTimeSavedMs),
        hint: `${formatInt(stats.garden.waterTimeSavedMs)} ms`
      }
    ];
    card.body.appendChild(createMetricGrid(rows));
    root.appendChild(card.root);
  }
  function renderShopSection(ui, root, stats) {
    const card = createCollapsibleCard(ui, "\u{1F3EA} Shops", {
      subtitle: "Purchases & sales",
      storageId: "shops"
    });
    const rows = [
      { label: "Seeds bought", value: formatInt(stats.shops.seedsBought) },
      { label: "Tools bought", value: formatInt(stats.shops.toolsBought) },
      { label: "Eggs bought", value: formatInt(stats.shops.eggsBought) },
      { label: "Decor bought", value: formatInt(stats.shops.decorBought) },
      { label: "Crops sold", value: `${formatInt(stats.shops.cropsSoldCount)} items` },
      {
        label: "Crop revenue",
        value: formatPrice(stats.shops.cropsSoldValue) ?? formatInt(stats.shops.cropsSoldValue)
      },
      { label: "Pets sold", value: `${formatInt(stats.shops.petsSoldCount)} pets` },
      {
        label: "Pet revenue",
        value: formatPrice(stats.shops.petsSoldValue) ?? formatInt(stats.shops.petsSoldValue)
      }
    ];
    card.body.appendChild(createMetricGrid(rows));
    root.appendChild(card.root);
  }
  function createPetRarityGroups() {
    const map2 = /* @__PURE__ */ new Map();
    for (const rarityKey of RARITY_ORDER2) {
      map2.set(rarityKey, []);
    }
    for (const species of Object.keys(petCatalog)) {
      const info = petCatalog[species];
      const rarityValue = info?.rarity ?? rarity.Common;
      const list = map2.get(rarityValue) ?? [];
      list.push(species);
      map2.set(rarityValue, list);
    }
    for (const list of map2.values()) {
      list.sort((a, b) => a.localeCompare(b));
    }
    return map2;
  }
  var petSpriteCache = /* @__PURE__ */ new Map();
  var petSpritePromises = /* @__PURE__ */ new Map();
  var petSpriteSubscribers = /* @__PURE__ */ new Map();
  var petSpriteConfig = /* @__PURE__ */ new WeakMap();
  var petSpriteListenerAttached = false;
  var petSheetBasesCache = null;
  function resetPetSheetBases() {
    petSheetBasesCache = null;
  }
  function getPetSheetBases() {
    if (petSheetBasesCache) return petSheetBasesCache;
    const urls = /* @__PURE__ */ new Set();
    try {
      Sprites.listPets().forEach((url) => urls.add(url));
    } catch {
    }
    const bases = Array.from(urls, (url) => {
      const clean = url.split(/[?#]/)[0] ?? url;
      const file = clean.split("/").pop() ?? clean;
      return file.replace(/\.[^.]+$/, "");
    });
    petSheetBasesCache = bases;
    return bases;
  }
  function toPetTileIndex(tileRef) {
    const value = typeof tileRef === "number" && Number.isFinite(tileRef) ? tileRef : Number(tileRef);
    if (!Number.isFinite(value)) return null;
    if (value <= 0) return value;
    return value - 1;
  }
  async function fetchPetSprite(species) {
    const entry = petCatalog[species];
    const tileRef = entry?.tileRef;
    if (tileRef == null) return null;
    const index = toPetTileIndex(tileRef);
    if (index == null) return null;
    const baseCandidates = new Set(getPetSheetBases());
    if (baseCandidates.size === 0) {
      baseCandidates.add("pets");
      baseCandidates.add("Pets");
    }
    for (const base of baseCandidates) {
      try {
        const tile = await Sprites.getTile(base, index, "canvas");
        const canvas = tile?.data;
        if (canvas && canvas.width > 0 && canvas.height > 0) {
          const copy2 = document.createElement("canvas");
          copy2.width = canvas.width;
          copy2.height = canvas.height;
          const ctx = copy2.getContext("2d");
          if (!ctx) continue;
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(canvas, 0, 0);
          return copy2.toDataURL();
        }
      } catch {
      }
    }
    return null;
  }
  function applyPetSprite(el2, src) {
    const cfg = petSpriteConfig.get(el2);
    if (!cfg) return;
    const { size, fallback } = cfg;
    el2.classList.add("stats-pet__sprite-icon");
    el2.style.setProperty("--stats-pet-sprite-size", `${size}px`);
    el2.innerHTML = "";
    if (src) {
      el2.style.fontSize = "";
      const img = document.createElement("img");
      img.src = src;
      img.alt = "";
      img.decoding = "async";
      img.loading = "lazy";
      img.draggable = false;
      el2.appendChild(img);
    } else {
      el2.textContent = fallback;
      el2.style.fontSize = `${Math.max(10, Math.round(size * 0.7))}px`;
    }
  }
  function subscribePetSprite(species, el2, config) {
    let subs = petSpriteSubscribers.get(species);
    if (!subs) {
      subs = /* @__PURE__ */ new Set();
      petSpriteSubscribers.set(species, subs);
    }
    subs.add(el2);
    petSpriteConfig.set(el2, config);
  }
  function notifyPetSpriteSubscribers(species, src) {
    const subs = petSpriteSubscribers.get(species);
    if (!subs) return;
    subs.forEach((el2) => {
      if (!el2.isConnected) {
        subs.delete(el2);
        petSpriteConfig.delete(el2);
        return;
      }
      applyPetSprite(el2, src);
    });
    if (subs.size === 0) {
      petSpriteSubscribers.delete(species);
    }
  }
  function loadPetSprite(species) {
    if (typeof window === "undefined") {
      return Promise.resolve(null);
    }
    const cached = petSpriteCache.get(species);
    if (cached !== void 0) {
      notifyPetSpriteSubscribers(species, cached);
      return Promise.resolve(cached);
    }
    const inflight = petSpritePromises.get(species);
    if (inflight) return inflight;
    const promise = fetchPetSprite(species).then((src) => {
      petSpriteCache.set(species, src);
      petSpritePromises.delete(species);
      notifyPetSpriteSubscribers(species, src);
      return src;
    }).catch(() => {
      petSpritePromises.delete(species);
      return null;
    });
    petSpritePromises.set(species, promise);
    return promise;
  }
  function ensurePetSpriteListener() {
    if (petSpriteListenerAttached || typeof window === "undefined") return;
    petSpriteListenerAttached = true;
    window.addEventListener("mg:sprite-detected", () => {
      petSpriteCache.clear();
      petSpritePromises.clear();
      resetPetSheetBases();
      const keys = Array.from(petSpriteSubscribers.keys());
      keys.forEach((key2) => {
        void loadPetSprite(key2);
      });
    });
  }
  function createPetSprite(species, options = {}) {
    const size = Math.max(12, options.size ?? 28);
    const defaultFallback2 = species.trim().charAt(0) || "\u{1F43E}";
    const fallbackSource = options.fallback ?? defaultFallback2;
    const fallback = fallbackSource.toString();
    const el2 = document.createElement("span");
    if (typeof window === "undefined") {
      el2.classList.add("stats-pet__sprite-icon");
      el2.style.setProperty("--stats-pet-sprite-size", `${size}px`);
      el2.textContent = fallback;
      el2.style.fontSize = `${Math.max(10, Math.round(size * 0.7))}px`;
      return el2;
    }
    ensurePetSpriteListener();
    subscribePetSprite(species, el2, { size, fallback });
    const cached = petSpriteCache.get(species);
    applyPetSprite(el2, cached ?? null);
    void loadPetSprite(species);
    return el2;
  }
  function createPetSpeciesCell(species) {
    const wrapper = document.createElement("span");
    wrapper.className = "stats-pet__species";
    const sprite = createPetSprite(species, {
      size: 28,
      fallback: species.trim().charAt(0).toUpperCase() || "\u{1F43E}"
    });
    const label2 = document.createElement("span");
    label2.className = "stats-pet__label";
    label2.textContent = species;
    wrapper.appendChild(sprite);
    wrapper.appendChild(label2);
    return { content: wrapper };
  }
  function createPetTotalValueCell(total) {
    const value = document.createElement("span");
    value.className = "stats-pet__total-value qmm-num";
    value.textContent = formatInt(total);
    return { content: value, align: "center" };
  }
  function renderPetSection(ui, root, stats) {
    const card = createCollapsibleCard(ui, "\u{1F43E} Pets", {
      subtitle: "Hatching overview",
      storageId: "pets"
    });
    const groups = createPetRarityGroups();
    for (const rarityKey of RARITY_ORDER2) {
      const speciesList = groups.get(rarityKey) ?? [];
      if (!speciesList.length) continue;
      const group = document.createElement("div");
      group.className = "stats-pet-group";
      group.style.setProperty("--stats-pet-group-border-color", RARITY_BORDER_COLORS[rarityKey]);
      const summary = document.createElement("div");
      summary.className = "stats-pet-group__summary";
      summary.textContent = "";
      const badge = rarityBadge(rarityKey);
      badge.style.margin = "0";
      summary.appendChild(badge);
      group.appendChild(summary);
      const content = document.createElement("div");
      content.className = "stats-pet-group__content";
      const columns = [
        { label: "Species", width: "2.2fr" },
        { label: "Normal", align: "center", width: "1fr" },
        { label: "Gold", align: "center", width: "1fr", headerClassName: "stats-list__header-label--gold" },
        {
          label: "Rainbow",
          align: "center",
          width: "1fr",
          headerClassName: "stats-list__header-label--rainbow"
        },
        { label: "Total", align: "center", width: "1fr" }
      ];
      const rows = [];
      for (const species of speciesList) {
        const key2 = species.toLowerCase();
        const counts = stats.pets.hatchedByType[key2] ?? { normal: 0, gold: 0, rainbow: 0 };
        const total = counts.normal + counts.gold + counts.rainbow;
        rows.push([
          createPetSpeciesCell(species),
          { text: formatInt(counts.normal), align: "center" },
          { text: formatInt(counts.gold), align: "center" },
          { text: formatInt(counts.rainbow), align: "center" },
          createPetTotalValueCell(total)
        ]);
      }
      content.appendChild(createStatList(columns, rows));
      group.appendChild(content);
      card.body.appendChild(group);
    }
    root.appendChild(card.root);
  }
  function renderAbilitySection(ui, root, stats) {
    const card = createCollapsibleCard(ui, "\u{1F9E0} Abilities", {
      subtitle: "Trigger counts",
      storageId: "abilities"
    });
    const abilityIds = Object.keys(petAbilities).sort((a, b) => {
      const nameA = petAbilities[a]?.name ?? a;
      const nameB = petAbilities[b]?.name ?? b;
      return nameA.localeCompare(nameB);
    });
    const columns = [
      { label: "Ability", width: "2.2fr" },
      { label: "Triggers", align: "right", width: "1fr" },
      { label: "Value", align: "right", width: "1.2fr" }
    ];
    const rows = [];
    for (const id of abilityIds) {
      const info = petAbilities[id];
      const statsEntry = stats.abilities[id] ?? { triggers: 0, totalValue: 0 };
      const formatted = formatAbilityTotalValue(id, statsEntry.totalValue);
      rows.push([
        { text: info?.name ?? id, hint: info?.description },
        { text: formatInt(statsEntry.triggers) },
        { text: formatted }
      ]);
    }
    card.body.appendChild(createStatList(columns, rows));
    root.appendChild(card.root);
  }
  function renderWeatherSection(ui, root, stats) {
    const card = createCollapsibleCard(ui, "\u26C5 Weather", {
      subtitle: "Events overview",
      storageId: "weather"
    });
    const columns = [
      { label: "Weather", width: "2fr" },
      { label: "TOTAL", align: "right", width: "1fr" }
    ];
    const rows = [];
    const weatherEntries = Object.keys(weatherCatalog).map((key2) => {
      const info = weatherCatalog[key2];
      const label2 = info?.atomValue ?? key2;
      const lower = key2.toLowerCase();
      const entry = stats.weather[lower] ?? { triggers: 0 };
      const spriteKey2 = getWeatherSpriteKey(key2) ?? getWeatherSpriteKey(info?.atomValue) ?? getWeatherSpriteKey(info?.displayName) ?? null;
      return { key: lower, label: label2, triggers: entry.triggers, spriteKey: spriteKey2 };
    }).sort((a, b) => a.label.localeCompare(b.label));
    for (const entry of weatherEntries) {
      rows.push([
        createWeatherNameCell({ label: entry.label, spriteKey: entry.spriteKey }),
        { text: formatInt(entry.triggers) }
      ]);
    }
    card.body.appendChild(createStatList(columns, rows));
    root.appendChild(card.root);
  }
  function renderStatsMenu(container) {
    const root = container;
    if (typeof root.__statsCleanup === "function") {
      try {
        root.__statsCleanup();
      } catch (error) {
        console.error("[StatsMenu] Cleanup error", error);
      }
      root.__statsCleanup = void 0;
    }
    const prevRoot = container.firstElementChild;
    const prevView = prevRoot?.classList.contains("qmm") ? prevRoot.querySelector(".qmm-views") ?? null : null;
    const previousScrollTop = prevView ? prevView.scrollTop : null;
    let rafId = null;
    let unsubscribed = false;
    let unsubscribe2 = () => {
    };
    const cleanup2 = () => {
      if (unsubscribed) return;
      unsubscribed = true;
      try {
        unsubscribe2();
      } catch (error) {
        console.error("[StatsMenu] Unsubscribe error", error);
      }
      if (rafId !== null) {
        cancelAnimationFrame(rafId);
        rafId = null;
      }
      if (root.__statsCleanup === cleanup2) {
        root.__statsCleanup = void 0;
      }
    };
    unsubscribe2 = StatsService.subscribe(() => {
      if (!root.isConnected) {
        cleanup2();
        return;
      }
      if (rafId !== null) return;
      rafId = requestAnimationFrame(() => {
        rafId = null;
        renderStatsMenu(container);
      });
    });
    root.__statsCleanup = cleanup2;
    const ui = new Menu({ id: "stats", compact: true });
    ui.mount(container);
    const win = ui.root.closest(".qws-win");
    if (win) {
      win.style.minWidth = `${STATS_WINDOW_MIN_WIDTH}px`;
    }
    const paddingStyle = getComputedStyle(container);
    const paddingLeft = Number.parseFloat(paddingStyle.paddingLeft) || 0;
    const paddingRight = Number.parseFloat(paddingStyle.paddingRight) || 0;
    const minContentWidth = Math.max(0, STATS_WINDOW_MIN_WIDTH - paddingLeft - paddingRight);
    container.style.minWidth = `${minContentWidth}px`;
    const view = ui.root.querySelector(".qmm-views");
    if (!view) return;
    view.innerHTML = "";
    view.style.display = "grid";
    view.style.gap = "12px";
    view.style.padding = "4px 0";
    view.style.minHeight = "0";
    view.style.alignContent = "start";
    view.style.maxHeight = "54vh";
    const stats = StatsService.getSnapshot();
    initGarden(stats).catch((error) => {
      console.error("[StatsMenu] Failed to initialize garden stats", error);
    });
    initShops(stats).catch((error) => {
      console.error("[StatsMenu] Failed to initialize shop stats", error);
    });
    initPets(stats).catch((error) => {
      console.error("[StatsMenu] Failed to initialize pet stats", error);
    });
    renderMetaSection(ui, view, stats);
    renderGardenSection(ui, view, stats);
    renderShopSection(ui, view, stats);
    renderPetSection(ui, view, stats);
    renderAbilitySection(ui, view, stats);
    renderWeatherSection(ui, view, stats);
    if (previousScrollTop !== null) {
      view.scrollTop = previousScrollTop;
    }
  }

  // src/utils/petSprites.ts
  var spriteCache3 = /* @__PURE__ */ new Map();
  var spritePromises3 = /* @__PURE__ */ new Map();
  var petSheetBasesCache2 = null;
  var listenerAttached3 = false;
  function canonicalSpecies(raw) {
    if (!raw) return raw;
    if (petCatalog[raw]) return raw;
    const pretty = raw.charAt(0).toUpperCase() + raw.slice(1).toLowerCase();
    return petCatalog[pretty] ? pretty : raw;
  }
  function toPetTileIndex2(tileRef) {
    const value = typeof tileRef === "number" && Number.isFinite(tileRef) ? tileRef : Number(tileRef);
    if (!Number.isFinite(value)) return null;
    if (value <= 0) return value;
    return value - 1;
  }
  function getPetSheetBases2() {
    if (petSheetBasesCache2) return petSheetBasesCache2;
    const urls = /* @__PURE__ */ new Set();
    try {
      const list = typeof Sprites.listPets === "function" ? Sprites.listPets() : [];
      for (const url of list) {
        if (typeof url === "string" && url.length) {
          urls.add(url);
        }
      }
    } catch {
    }
    const bases = Array.from(urls, (url) => {
      const clean = url.split(/[?#]/)[0] ?? url;
      const file = clean.split("/").pop() ?? clean;
      return file.replace(/\.[^.]+$/, "");
    });
    petSheetBasesCache2 = bases;
    return bases;
  }
  function resetCaches() {
    spriteCache3.clear();
    spritePromises3.clear();
    petSheetBasesCache2 = null;
  }
  function ensureListener() {
    if (listenerAttached3 || typeof window === "undefined") return;
    listenerAttached3 = true;
    window.addEventListener("mg:sprite-detected", () => {
      resetCaches();
    });
  }
  function keyFor(species, variant) {
    return `${species.toLowerCase()}::${variant}`;
  }
  function hasMutation(target, mutations) {
    if (!mutations) return false;
    const list = Array.isArray(mutations) ? mutations : [mutations];
    return list.map((value) => String(value ?? "").toLowerCase()).some((value) => value.includes(target));
  }
  function determinePetSpriteVariant(mutations) {
    if (hasMutation("rainbow", mutations)) return "rainbow";
    if (hasMutation("gold", mutations)) return "gold";
    return "normal";
  }
  async function fetchPetSprite2(species, variant) {
    if (typeof window === "undefined") return null;
    if (typeof Sprites.getTile !== "function") return null;
    const entry = petCatalog[species];
    const tileRef = entry?.tileRef;
    if (tileRef == null) return null;
    const index = toPetTileIndex2(tileRef);
    if (index == null) return null;
    const baseCandidates = new Set(getPetSheetBases2());
    if (baseCandidates.size === 0) {
      baseCandidates.add("pets");
      baseCandidates.add("Pets");
    }
    for (const base of baseCandidates) {
      try {
        const tile = await Sprites.getTile(base, index, "canvas");
        if (!tile) continue;
        const data = tile.data;
        if (!(data instanceof HTMLCanvasElement) || data.width === 0 || data.height === 0) {
          continue;
        }
        let canvas = null;
        if (variant === "gold" && typeof Sprites.effectGold === "function") {
          canvas = Sprites.effectGold(tile);
        } else if (variant === "rainbow" && typeof Sprites.effectRainbow === "function") {
          canvas = Sprites.effectRainbow(tile);
        } else {
          const copy2 = document.createElement("canvas");
          copy2.width = data.width;
          copy2.height = data.height;
          const ctx = copy2.getContext("2d");
          if (!ctx) continue;
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(data, 0, 0);
          canvas = copy2;
        }
        if (!canvas || canvas.width === 0 || canvas.height === 0) continue;
        return canvas.toDataURL();
      } catch {
      }
    }
    return null;
  }
  function loadPetSprite2(speciesRaw, variant = "normal") {
    if (typeof window === "undefined") {
      return Promise.resolve(null);
    }
    const species = canonicalSpecies(String(speciesRaw ?? "").trim());
    if (!species) return Promise.resolve(null);
    ensureListener();
    const key2 = keyFor(species, variant);
    const cached = spriteCache3.get(key2);
    if (cached !== void 0) {
      return Promise.resolve(cached);
    }
    const inflight = spritePromises3.get(key2);
    if (inflight) return inflight;
    const promise = fetchPetSprite2(species, variant).then((src) => {
      spriteCache3.set(key2, src);
      spritePromises3.delete(key2);
      return src;
    }).catch(() => {
      spritePromises3.delete(key2);
      return null;
    });
    spritePromises3.set(key2, promise);
    return promise;
  }
  function loadPetSpriteFromMutations(species, mutations) {
    const variant = determinePetSpriteVariant(mutations);
    return loadPetSprite2(species, variant);
  }

  // src/ui/menus/pets.ts
  function getAbilityChipColors(id) {
    const key2 = String(id || "");
    const base = (PetsService.getAbilityNameWithoutLevel?.(key2) || "").replace(/[\s\-_]+/g, "").toLowerCase();
    const is = (prefix) => key2.startsWith(prefix) || base === prefix.toLowerCase();
    if (is("ProduceScaleBoost")) return { bg: "rgba(34,139,34,0.9)", hover: "rgba(34,139,34,1)" };
    if (is("PlantGrowthBoost")) return { bg: "rgba(0,128,128,0.9)", hover: "rgba(0,128,128,1)" };
    if (is("EggGrowthBoost")) return { bg: "rgba(180,90,240,0.9)", hover: "rgba(180,90,240,1)" };
    if (is("PetAgeBoost")) return { bg: "rgba(147,112,219,0.9)", hover: "rgba(147,112,219,1)" };
    if (is("PetHatchSizeBoost")) return { bg: "rgba(128,0,128,0.9)", hover: "rgba(128,0,128,1)" };
    if (is("PetXpBoost")) return { bg: "rgba(30,144,255,0.9)", hover: "rgba(30,144,255,1)" };
    if (is("HungerBoost")) return { bg: "rgba(255,20,147,0.9)", hover: "rgba(255,20,147,1)" };
    if (is("SellBoost")) return { bg: "rgba(220,20,60,0.9)", hover: "rgba(220,20,60,1)" };
    if (is("CoinFinder")) return { bg: "rgba(180,150,0,0.9)", hover: "rgba(180,150,0,1)" };
    if (is("ProduceMutationBoost")) return { bg: "rgba(138,43,226,0.9)", hover: "rgba(138,43,226,1)" };
    if (is("DoubleHarvest")) return { bg: "rgba(0,120,180,0.9)", hover: "rgba(0,120,180,1)" };
    if (is("ProduceEater")) return { bg: "rgba(255,69,0,0.9)", hover: "rgba(255,69,0,1)" };
    if (is("ProduceRefund")) return { bg: "rgba(255,99,71,0.9)", hover: "rgba(255,99,71,1)" };
    if (is("PetMutationBoost")) return { bg: "rgba(156,65,181,0.9)", hover: "rgba(156,65,181,1)" };
    if (is("HungerRestore")) return { bg: "rgba(255,105,180,0.9)", hover: "rgba(255,105,180,1)" };
    if (is("PetRefund")) return { bg: "rgba(0,80,120,0.9)", hover: "rgba(0,80,120,1)" };
    if (is("Copycat")) return { bg: "rgba(255,140,0,0.9)", hover: "rgba(255,140,0,1)" };
    if (is("GoldGranter")) {
      return {
        bg: "linear-gradient(135deg, rgba(225,200,55,0.9) 0%, rgba(225,180,10,0.9) 40%, rgba(215,185,45,0.9) 70%, rgba(210,185,45,0.9) 100%)",
        hover: "linear-gradient(135deg, rgba(220,200,70,1) 0%, rgba(210,175,5,1) 40%, rgba(210,185,55,1) 70%, rgba(200,175,30,1) 100%)"
      };
    }
    if (is("RainbowGranter")) {
      return {
        bg: "linear-gradient(45deg, rgba(200,0,0,0.9), rgba(200,120,0,0.9), rgba(160,170,30,0.9), rgba(60,170,60,0.9), rgba(50,170,170,0.9), rgba(40,150,180,0.9), rgba(20,90,180,0.9), rgba(70,30,150,0.9))",
        hover: "linear-gradient(45deg, rgba(200,0,0,1), rgba(200,120,0,1), rgba(160,170,30,1), rgba(60,170,60,1), rgba(50,170,170,1), rgba(40,150,180,1), rgba(20,90,180,1), rgba(70,30,150,1))"
      };
    }
    if (is("SeedFinderIV")) {
      return {
        bg: "linear-gradient(130deg, rgba(0,180,216,0.9) 0%, rgba(124,42,232,0.9) 40%, rgba(160,0,126,0.9) 60%, rgba(255,215,0,0.9) 100%)",
        hover: "linear-gradient(130deg, rgba(0,180,216,1) 0%, rgba(124,42,232,1) 40%, rgba(160,0,126,1) 60%, rgba(255,215,0,1) 100%)"
      };
    }
    if (is("SeedFinder")) {
      const lv = key2.replace(/.*?([IVX]+)$/, "$1");
      if (lv === "II") return { bg: "rgba(183,121,31,0.9)", hover: "rgba(183,121,31,1)" };
      if (lv === "III") return { bg: "rgba(139,62,152,0.9)", hover: "rgba(139,62,152,1)" };
      return { bg: "rgba(94,172,70,0.9)", hover: "rgba(94,172,70,1)" };
    }
    return { bg: "rgba(100,100,100,0.9)", hover: "rgba(150,150,150,1)" };
  }
  function renderManagerTab(view, ui) {
    view.innerHTML = "";
    let teams = [];
    let selectedId = null;
    let activeTeamId = null;
    let activePetIdSet = /* @__PURE__ */ new Set();
    let isApplyingTeam = false;
    let draggingIdx = null;
    let overInsertIdx = null;
    let draggingHeight = 0;
    let invCacheMap = null;
    const lastRenderedSlotIds = [null, null, null];
    function applySubtleBorder(btn, hex, alpha = 0.22) {
      const toRgba = (h, a) => {
        const m = h.replace("#", "");
        const r = parseInt(m.length === 3 ? m[0] + m[0] : m.slice(0, 2), 16);
        const g = parseInt(m.length === 3 ? m[1] + m[1] : m.slice(2, 4), 16);
        const b = parseInt(m.length === 3 ? m[2] + m[2] : m.slice(4, 6), 16);
        return `rgba(${r},${g},${b},${a})`;
      };
      const border = toRgba(hex, alpha);
      btn.style.border = `1px solid ${border}`;
      btn.style.background = "#1f2328";
      btn.style.boxShadow = "none";
      btn.style.transition = "none";
    }
    const framed = (title, content) => {
      const cardSection = ui.card(title, { tone: "muted", align: "center" });
      cardSection.body.append(content);
      cardSection.root.style.maxWidth = "720px";
      return cardSection.root;
    };
    const row = (opts) => ui.flexRow({ justify: opts?.justify ?? "center" });
    const wrap = document.createElement("div");
    wrap.style.display = "grid";
    wrap.style.gridTemplateColumns = "minmax(220px, 280px) minmax(0, 1fr)";
    wrap.style.gap = "10px";
    wrap.style.alignItems = "stretch";
    wrap.style.height = "54vh";
    wrap.style.overflow = "hidden";
    view.appendChild(wrap);
    const left = document.createElement("div");
    left.style.display = "grid";
    left.style.gridTemplateRows = "1fr auto";
    left.style.gap = "8px";
    left.style.minHeight = "0";
    wrap.appendChild(left);
    const teamList = document.createElement("div");
    teamList.style.display = "flex";
    teamList.style.flexDirection = "column";
    teamList.style.gap = "6px";
    teamList.style.overflow = "auto";
    teamList.style.padding = "6px";
    teamList.style.border = "1px solid #4445";
    teamList.style.borderRadius = "10px";
    teamList.style.scrollBehavior = "smooth";
    teamList.style.minHeight = "0";
    left.appendChild(teamList);
    const footer = document.createElement("div");
    footer.style.display = "flex";
    footer.style.gap = "6px";
    left.appendChild(footer);
    const btnNew = ui.btn("\u2795 New", { variant: "primary", size: "sm" });
    btnNew.id = "pets.teams.new";
    btnNew.style.flex = "1 1 0";
    const btnDel = ui.btn("\u{1F5D1}\uFE0F Delete", { variant: "danger", size: "sm" });
    btnDel.id = "pets.teams.delete";
    btnDel.style.flex = "1 1 0";
    applySubtleBorder(btnNew, "#22c55e", 0.22);
    applySubtleBorder(btnDel, "#ef4444", 0.22);
    footer.append(btnNew, btnDel);
    function getSelectedTeam() {
      return teams.find((t) => t.id === selectedId) || null;
    }
    function computeInsertIndex(clientY) {
      const children = Array.from(teamList.children);
      if (!children.length) return 0;
      const first = children[0].getBoundingClientRect();
      if (clientY < first.top + first.height / 2) return 0;
      for (let i = 0; i < children.length; i++) {
        const rect = children[i].getBoundingClientRect();
        const mid = rect.top + rect.height / 2;
        if (clientY < mid) return i;
      }
      return children.length;
    }
    function abilitiesBadge(abilities) {
      const wrap2 = document.createElement("span");
      wrap2.style.display = "inline-flex";
      wrap2.style.alignItems = "center";
      wrap2.style.lineHeight = "1";
      const SPACING_PX = 8;
      const SIZE_PX = 12;
      const RADIUS_PX = 3;
      const ids = Array.isArray(abilities) ? abilities.filter(Boolean) : [];
      if (!ids.length) {
        const empty = document.createElement("span");
        empty.textContent = "No ability";
        empty.style.opacity = "0.75";
        empty.style.fontSize = "12px";
        wrap2.appendChild(empty);
        return wrap2;
      }
      ids.forEach((id, i) => {
        const chip = document.createElement("span");
        const { bg, hover } = getAbilityChipColors(id);
        chip.title = PetsService.getAbilityName(id) || id;
        chip.setAttribute("aria-label", chip.title);
        Object.assign(chip.style, {
          display: "inline-block",
          width: `${SIZE_PX}px`,
          height: `${SIZE_PX}px`,
          borderRadius: `${RADIUS_PX}px`,
          marginRight: i === ids.length - 1 ? "0" : `${SPACING_PX}px`,
          background: bg,
          transition: "transform 80ms ease, box-shadow 120ms ease, background 120ms ease",
          cursor: "default",
          boxShadow: "0 0 0 1px #0006 inset, 0 0 0 1px #ffffff1a"
        });
        chip.onmouseenter = () => {
          chip.style.background = hover;
          chip.style.transform = "scale(1.08)";
          chip.style.boxShadow = "0 0 0 1px #0006 inset, 0 0 0 1px #ffffff33";
        };
        chip.onmouseleave = () => {
          chip.style.background = bg;
          chip.style.transform = "none";
          chip.style.boxShadow = "0 0 0 1px #0006 inset, 0 0 0 1px #ffffff1a";
        };
        wrap2.appendChild(chip);
      });
      return wrap2;
    }
    function applyLiveTransforms() {
      const children = Array.from(teamList.children);
      children.forEach((el2) => el2.style.transform = "");
      if (draggingIdx === null || overInsertIdx === null) return;
      const from = draggingIdx;
      const to = overInsertIdx;
      children.forEach((el2, idx) => {
        el2.style.transition = "transform 120ms ease";
        if (idx === from) return;
        if (to > from && idx > from && idx < to) {
          el2.style.transform = `translateY(${-draggingHeight}px)`;
        }
        if (to < from && idx >= to && idx < from) {
          el2.style.transform = `translateY(${draggingHeight}px)`;
        }
      });
    }
    function clearLiveTransforms() {
      Array.from(teamList.children).forEach((el2) => {
        el2.style.transform = "";
        el2.style.transition = "";
      });
    }
    async function refreshActiveIds() {
      activeTeamId = null;
      activePetIdSet = /* @__PURE__ */ new Set();
      try {
        const pets = await PetsService.getPets();
        const equipIds = Array.isArray(pets) ? pets.map((p) => String(p?.slot?.id || "")).filter(Boolean) : [];
        activePetIdSet = new Set(equipIds);
        for (const t of teams) {
          const tIds = (t.slots || []).filter(Boolean);
          if (tIds.length !== equipIds.length) continue;
          let same = true;
          for (const id of tIds) {
            if (!activePetIdSet.has(id)) {
              same = false;
              break;
            }
          }
          if (same) {
            activeTeamId = t.id;
            break;
          }
        }
      } catch {
      }
    }
    async function refreshTeamList(skipDetectActive = false) {
      if (!skipDetectActive) {
        await refreshActiveIds();
      }
      clearLiveTransforms();
      draggingIdx = null;
      overInsertIdx = null;
      draggingHeight = 0;
      teamList.innerHTML = "";
      if (!teams.length) {
        const empty = document.createElement("div");
        empty.textContent = "No teams yet. Create one!";
        empty.style.opacity = "0.75";
        empty.style.textAlign = "center";
        empty.style.padding = "8px";
        teamList.appendChild(empty);
        hydrateEditor(null);
        return;
      }
      teams.forEach((t, idx) => {
        const item = document.createElement("div");
        const isActive = t.id === activeTeamId;
        item.dataset.index = String(idx);
        item.textContent = "";
        item.style.height = "36px";
        item.style.lineHeight = "36px";
        item.style.padding = "0 10px";
        item.style.border = "1px solid #ffffff15";
        item.style.borderRadius = "6px";
        item.style.cursor = "pointer";
        item.style.fontSize = "13px";
        item.style.overflow = "hidden";
        item.style.whiteSpace = "nowrap";
        item.style.textOverflow = "ellipsis";
        item.style.display = "flex";
        item.style.flex = "0 0 auto";
        item.style.gap = "8px";
        item.style.alignItems = "center";
        item.style.background = t.id === selectedId ? "#2a313a" : "#1f2328";
        const dot = document.createElement("span");
        dot.style.width = "10px";
        dot.style.height = "10px";
        dot.style.borderRadius = "50%";
        dot.style.boxShadow = "0 0 0 1px #0006 inset";
        dot.style.background = isActive ? "#48d170" : "#64748b";
        dot.title = isActive ? "This team is currently active" : "Inactive team";
        const label2 = document.createElement("span");
        label2.textContent = t.name || "(unnamed)";
        label2.style.overflow = "hidden";
        label2.style.textOverflow = "ellipsis";
        label2.style.whiteSpace = "nowrap";
        item.append(dot, label2);
        const grab = document.createElement("span");
        grab.className = "qmm-grab";
        grab.title = "Drag to reorder";
        grab.innerHTML = "&#8942;";
        grab.draggable = true;
        item.onmouseenter = () => item.style.borderColor = "#6aa1";
        item.onmouseleave = () => item.style.borderColor = "#ffffff15";
        item.onclick = (ev) => {
          if (ev.__byDrag) return;
          const changed = selectedId !== t.id;
          if (changed) {
            selectedId = t.id;
            refreshTeamList(true);
          }
          void hydrateEditor(getSelectedTeam());
        };
        grab.addEventListener("dragstart", (ev) => {
          draggingIdx = idx;
          draggingHeight = item.getBoundingClientRect().height;
          item.classList.add("qmm-dragging");
          ev.dataTransfer?.setData("text/plain", String(idx));
          if (ev.dataTransfer) ev.dataTransfer.effectAllowed = "move";
          try {
            const ghost = item.cloneNode(true);
            ghost.style.width = `${item.getBoundingClientRect().width}px`;
            ghost.style.position = "absolute";
            ghost.style.top = "-9999px";
            document.body.appendChild(ghost);
            ev.dataTransfer.setDragImage(ghost, ghost.offsetWidth / 2, ghost.offsetHeight / 2);
            setTimeout(() => document.body.removeChild(ghost), 0);
          } catch {
          }
        });
        grab.addEventListener("dragend", () => {
          item.classList.remove("qmm-dragging");
          clearLiveTransforms();
          draggingIdx = null;
          overInsertIdx = null;
        });
        item.addEventListener("dragover", (ev) => {
          ev.preventDefault();
          if (ev.dataTransfer) ev.dataTransfer.dropEffect = "move";
          if (draggingIdx === null) return;
          const idxOver = Number(ev.currentTarget.dataset.index || -1);
          if (idxOver < 0) return;
          const rect = item.getBoundingClientRect();
          const mid = rect.top + rect.height / 2;
          const insertIdx = ev.clientY < mid ? idxOver : idxOver + 1;
          const clamped = Math.max(0, Math.min(teams.length, insertIdx));
          if (overInsertIdx !== clamped) {
            overInsertIdx = clamped;
            applyLiveTransforms();
          }
          const edge = 28;
          const listRect = teamList.getBoundingClientRect();
          if (ev.clientY < listRect.top + edge) teamList.scrollTop -= 18;
          else if (ev.clientY > listRect.bottom - edge) teamList.scrollTop += 18;
        });
        item.addEventListener("drop", (ev) => {
          ev.preventDefault();
          ev.__byDrag = true;
          if (draggingIdx === null) return;
          let target = overInsertIdx ?? computeInsertIndex(ev.clientY);
          if (target > draggingIdx) target -= 1;
          target = Math.max(0, Math.min(teams.length - 1, target));
          if (target !== draggingIdx) {
            const a = teams.slice();
            const [it] = a.splice(draggingIdx, 1);
            a.splice(target, 0, it);
            teams = a;
            try {
              PetsService.setTeamsOrder(teams.map((x) => x.id));
            } catch {
            }
          }
          clearLiveTransforms();
          draggingIdx = null;
          overInsertIdx = null;
          draggingHeight = 0;
          refreshTeamList();
        });
        item.appendChild(grab);
        teamList.appendChild(item);
      });
    }
    teamList.addEventListener("dragover", (e) => {
      e.preventDefault();
      if (e.dataTransfer) e.dataTransfer.dropEffect = "move";
      if (draggingIdx === null) return;
      const idx = computeInsertIndex(e.clientY);
      if (overInsertIdx !== idx) {
        overInsertIdx = idx;
        applyLiveTransforms();
      }
      const edge = 28;
      const listRect = teamList.getBoundingClientRect();
      if (e.clientY < listRect.top + edge) teamList.scrollTop -= 18;
      else if (e.clientY > listRect.bottom - edge) teamList.scrollTop += 18;
    });
    teamList.addEventListener("drop", (e) => {
      e.preventDefault();
      if (draggingIdx === null) return;
      let target = overInsertIdx ?? computeInsertIndex(e.clientY);
      if (target > draggingIdx) target -= 1;
      target = Math.max(0, Math.min(teams.length - 1, target));
      if (target !== draggingIdx) {
        const a = teams.slice();
        const [it] = a.splice(draggingIdx, 1);
        a.splice(target, 0, it);
        teams = a;
        try {
          PetsService.setTeamsOrder(teams.map((x) => x.id));
        } catch {
        }
      }
      clearLiveTransforms();
      draggingIdx = null;
      overInsertIdx = null;
      draggingHeight = 0;
      refreshTeamList();
    });
    btnNew.onclick = () => {
      const created = PetsService.createTeam("New Team");
      selectedId = created.id;
      refreshTeamList();
      hydrateEditor(getSelectedTeam());
    };
    btnDel.onclick = () => {
      if (!selectedId) return;
      const ok = PetsService.deleteTeam(selectedId);
      if (!ok) return;
    };
    let unsubTeams = null;
    (async () => {
      try {
        unsubTeams = await PetsService.onTeamsChangeNow(async (all) => {
          teams = Array.isArray(all) ? all.slice() : [];
          if (selectedId && !teams.some((t) => t.id === selectedId)) {
            selectedId = teams[0]?.id ?? null;
          }
          if (!selectedId && teams.length) selectedId = teams[0].id;
          refreshTeamList();
          setTeamsForHotkeys(teams);
          await PetsService.getInventoryPets().catch(() => []);
          await hydrateEditor(getSelectedTeam());
        });
      } catch {
      }
    })();
    const right = document.createElement("div");
    right.style.display = "grid";
    right.style.gridTemplateRows = "auto 1fr";
    right.style.gap = "10px";
    right.style.minHeight = "0";
    wrap.appendChild(right);
    const header = document.createElement("div");
    header.style.display = "flex";
    header.style.alignItems = "center";
    header.style.gap = "8px";
    const headerTitle = document.createElement("div");
    headerTitle.textContent = "Team editor \u2014 ";
    headerTitle.style.fontWeight = "700";
    headerTitle.style.fontSize = "14px";
    const btnUseTeam = document.createElement("button");
    btnUseTeam.id = "pets.teams.useThisTeam";
    btnUseTeam.textContent = "Use this team";
    btnUseTeam.style.padding = "6px 10px";
    btnUseTeam.style.borderRadius = "8px";
    btnUseTeam.style.border = "1px solid #4445";
    btnUseTeam.style.background = "#1f2328";
    btnUseTeam.style.color = "#e7eef7";
    btnUseTeam.style.cursor = "pointer";
    btnUseTeam.onmouseenter = () => btnUseTeam.style.borderColor = "#6aa1";
    btnUseTeam.onmouseleave = () => btnUseTeam.style.borderColor = "#4445";
    btnUseTeam.disabled = true;
    const btnSave = document.createElement("button");
    btnSave.id = "pets.teams.save";
    btnSave.textContent = "\u{1F4BE} Save";
    btnSave.style.padding = "6px 10px";
    btnSave.style.borderRadius = "8px";
    btnSave.style.border = "1px solid #4445";
    btnSave.style.background = "#1f2328";
    btnSave.style.color = "#e7eef7";
    btnSave.style.cursor = "pointer";
    btnSave.onmouseenter = () => btnSave.style.borderColor = "#6aa1";
    btnSave.onmouseleave = () => btnSave.style.borderColor = "#4445";
    btnSave.disabled = true;
    header.append(headerTitle, btnUseTeam);
    right.appendChild(header);
    const card = document.createElement("div");
    card.style.border = "1px solid #4445";
    card.style.borderRadius = "10px";
    card.style.padding = "10px";
    card.style.display = "flex";
    card.style.flexDirection = "column";
    card.style.gap = "12px";
    card.style.overflow = "auto";
    card.style.minHeight = "0";
    card.style.background = "#0f1318";
    right.appendChild(card);
    const secName = (() => {
      const r = row();
      r.style.width = "100%";
      const nameInput = ui.inputText("Team name", "");
      nameInput.id = "pets.teams.editor.name";
      nameInput.style.flex = "1";
      nameInput.style.minWidth = "0";
      btnSave.style.marginLeft = "auto";
      btnSave.style.padding = "6px 10px";
      r.append(nameInput, btnSave);
      card.appendChild(framed("\u{1F3F7}\uFE0F Team name", r));
      return { nameInput };
    })();
    const secSearch = (() => {
      const wrapOuter = document.createElement("div");
      wrapOuter.style.display = "flex";
      wrapOuter.style.flexDirection = "column";
      wrapOuter.style.gap = "10px";
      wrapOuter.style.alignItems = "center";
      let isProgrammaticModeSet = false;
      let currentMode = "ability";
      const seg = ui.segmented(
        [
          { value: "ability", label: "\u2728 Ability" },
          { value: "species", label: "\u{1F9EC} Species" }
        ],
        "ability",
        async (val) => {
          if (isProgrammaticModeSet) return;
          currentMode = val;
          await rebuildOptionsFromInventory();
          select2.value = "";
          applyFilterToTeam();
        },
        { ariaLabel: "Search mode" }
      );
      const select2 = document.createElement("select");
      select2.className = "qmm-input";
      select2.id = "pets.teams.filter.select";
      select2.style.minWidth = "260px";
      const getMode = () => currentMode;
      const setMode = (m) => {
        currentMode = m;
        isProgrammaticModeSet = true;
        seg.set(m);
        isProgrammaticModeSet = false;
      };
      const rebuildOptionsFromInventory = async () => {
        const prev = select2.value;
        const inv = await PetsService.getInventoryPets().catch(() => []);
        select2.innerHTML = "";
        const opt0 = document.createElement("option");
        opt0.value = "";
        opt0.textContent = "\u2014 No filter \u2014";
        select2.appendChild(opt0);
        if (getMode() === "ability") {
          const nameSet = /* @__PURE__ */ new Set();
          for (const p of inv) {
            const abs = Array.isArray(p?.abilities) ? p.abilities.filter(Boolean) : [];
            for (const id of abs) {
              const base = PetsService.getAbilityNameWithoutLevel?.(id) || "";
              if (base) nameSet.add(base);
            }
          }
          for (const name of Array.from(nameSet).sort((a, b) => a.localeCompare(b))) {
            const o = document.createElement("option");
            o.value = name;
            o.textContent = name;
            select2.appendChild(o);
          }
        } else {
          const set2 = /* @__PURE__ */ new Set();
          for (const p of inv) {
            const sp = String(p?.petSpecies || "").trim();
            if (sp) set2.add(sp);
          }
          for (const v of Array.from(set2).sort((a, b) => a.localeCompare(b))) {
            const o = document.createElement("option");
            o.value = v;
            o.textContent = v.charAt(0).toUpperCase() + v.slice(1);
            select2.appendChild(o);
          }
        }
        if (Array.from(select2.options).some((o) => o.value === prev)) select2.value = prev;
      };
      const applyFilterToTeam = () => {
        const t = getSelectedTeam();
        if (!t) return;
        const val = (select2.value || "").trim();
        const raw = getMode() === "ability" ? val ? `ab:${val}` : "" : val ? `sp:${val}` : "";
        PetsService.setTeamSearch(t.id, raw);
      };
      select2.addEventListener("change", applyFilterToTeam);
      wrapOuter.append(seg, select2);
      card.appendChild(framed("\u{1F50D} Search", wrapOuter));
      const ensureOptionExists = (val, pretty) => {
        const v = (val || "").trim();
        if (!v) return;
        const has = Array.from(select2.options).some((o) => o.value === v);
        if (!has) {
          const o = document.createElement("option");
          o.value = v;
          o.textContent = pretty ?? v;
          select2.appendChild(o);
        }
      };
      return {
        getMode,
        setMode,
        select: select2,
        rebuild: rebuildOptionsFromInventory,
        apply: applyFilterToTeam,
        setFromSearchString(s) {
          const m = (s || "").match(/^(ab|sp):\s*(.*)$/i);
          if (!m) {
            setMode("ability");
            select2.value = "";
            return;
          }
          const mode = m[1].toLowerCase() === "ab" ? "ability" : "species";
          const val = (m[2] || "").trim();
          setMode(mode);
          ensureOptionExists(val, mode === "species" ? val.charAt(0).toUpperCase() + val.slice(1) : val);
          select2.value = val;
        }
      };
    })();
    const secSlots = (() => {
      const grid = document.createElement("div");
      grid.style.display = "grid";
      grid.style.gridTemplateColumns = "1fr";
      grid.style.rowGap = "10px";
      grid.style.justifyItems = "center";
      const mkRow = (idx) => {
        const root = document.createElement("div");
        const BTN = 28;
        const ICON = 40;
        root.style.display = "grid";
        root.style.gridTemplateColumns = `${ICON}px minmax(0,1fr) ${BTN}px ${BTN}px`;
        root.style.alignItems = "center";
        root.style.gap = "8px";
        root.style.width = "min(560px, 100%)";
        root.style.border = "1px solid #4445";
        root.style.borderRadius = "10px";
        root.style.padding = "8px 10px";
        root.style.background = "#0f1318";
        const iconWrap = document.createElement("div");
        Object.assign(iconWrap.style, {
          width: `${ICON}px`,
          height: `${ICON}px`,
          display: "inline-flex",
          alignItems: "center",
          justifyContent: "center"
        });
        const useEmojiFallback = () => {
          iconWrap.replaceChildren();
          const span = document.createElement("span");
          span.textContent = "\u{1F43E}";
          span.style.fontSize = `${Math.max(ICON - 6, 12)}px`;
          span.setAttribute("aria-hidden", "true");
          iconWrap.appendChild(span);
        };
        let iconRequestId = 0;
        const setIcon = (species, mutation) => {
          iconRequestId += 1;
          const requestId = iconRequestId;
          const speciesLabel = String(species ?? "").trim();
          if (!speciesLabel) {
            useEmojiFallback();
            return;
          }
          useEmojiFallback();
          loadPetSpriteFromMutations(speciesLabel, mutation).then((src) => {
            if (requestId !== iconRequestId) return;
            if (!src) {
              useEmojiFallback();
              return;
            }
            const img = new Image();
            img.src = src;
            img.alt = speciesLabel || "pet";
            img.decoding = "async";
            img.loading = "lazy";
            img.draggable = false;
            Object.assign(img.style, {
              width: "100%",
              height: "100%",
              imageRendering: "auto",
              objectFit: "contain"
            });
            iconWrap.replaceChildren(img);
          }).catch(() => {
            if (requestId !== iconRequestId) return;
            useEmojiFallback();
          });
        };
        const left2 = document.createElement("div");
        left2.style.display = "flex";
        left2.style.flexDirection = "column";
        left2.style.gap = "6px";
        left2.style.minWidth = "0";
        const nameEl = document.createElement("div");
        nameEl.style.fontWeight = "700";
        nameEl.textContent = "None";
        nameEl.style.overflow = "hidden";
        nameEl.style.textOverflow = "ellipsis";
        nameEl.style.whiteSpace = "nowrap";
        let abilitiesEl = abilitiesBadge([]);
        abilitiesEl.style.display = "inline-block";
        left2.append(nameEl, abilitiesEl);
        const btnChoose = document.createElement("button");
        btnChoose.textContent = "+";
        Object.assign(btnChoose.style, {
          width: `${BTN}px`,
          minWidth: `${BTN}px`,
          height: `${BTN}px`,
          padding: "0",
          fontSize: "16px",
          lineHeight: "1",
          borderRadius: "10px",
          boxShadow: "none",
          display: "grid",
          placeItems: "center"
        });
        btnChoose.title = "Choose a pet";
        btnChoose.setAttribute("aria-label", "Choose a pet");
        const btnClear2 = document.createElement("button");
        btnClear2.textContent = "\u2212";
        Object.assign(btnClear2.style, {
          width: `${BTN}px`,
          minWidth: `${BTN}px`,
          height: `${BTN}px`,
          padding: "0",
          fontSize: "16px",
          lineHeight: "1",
          borderRadius: "10px",
          boxShadow: "none",
          display: "grid",
          placeItems: "center"
        });
        btnClear2.title = "Remove this pet";
        btnClear2.setAttribute("aria-label", "Remove this pet");
        root.append(iconWrap, left2, btnChoose, btnClear2);
        function update(p) {
          if (!p) {
            nameEl.textContent = "None";
            setIcon(void 0, void 0);
            const fresh2 = abilitiesBadge([]);
            fresh2.style.display = "inline-block";
            left2.replaceChild(fresh2, left2.children[1]);
            abilitiesEl = fresh2;
            return;
          }
          const species = String(p.petSpecies || "").trim();
          const muts = Array.isArray(p.mutations) ? p.mutations : [];
          setIcon(species, muts);
          const speciesLabel = species ? species.charAt(0).toUpperCase() + species.slice(1) : "";
          nameEl.textContent = p.name?.trim() || speciesLabel || "Pet";
          const abs = Array.isArray(p.abilities) ? p.abilities.filter(Boolean) : [];
          const fresh = abilitiesBadge(abs);
          fresh.style.display = "inline-block";
          left2.replaceChild(fresh, left2.children[1]);
          abilitiesEl = fresh;
        }
        btnChoose.onclick = async () => {
          const t = getSelectedTeam();
          if (!t) return;
          btnChoose.disabled = true;
          btnClear2.disabled = true;
          ui.setWindowVisible(false);
          try {
            await PetsService.chooseSlotPet(t.id, idx);
            await repaintSlots(getSelectedTeam());
          } finally {
            ui.setWindowVisible(true);
            btnChoose.disabled = false;
            btnClear2.disabled = false;
          }
        };
        btnClear2.onclick = async () => {
          const t = getSelectedTeam();
          if (!t) return;
          const next = t.slots.slice(0, 3);
          next[idx] = null;
          PetsService.saveTeam({ id: t.id, slots: next });
          await repaintSlots(t);
        };
        return { root, nameEl, abilitiesEl, btnChoose, btnClear: btnClear2, update };
      };
      const r0 = mkRow(0);
      const r1 = mkRow(1);
      const r2 = mkRow(2);
      grid.append(r0.root, r1.root, r2.root);
      const extra = document.createElement("div");
      extra.style.display = "flex";
      extra.style.gap = "6px";
      extra.style.justifyContent = "center";
      const btnUseCurrent = ui.btn("Current active", { variant: "primary" });
      btnUseCurrent.id = "pets.teams.useCurrent";
      btnUseCurrent.style.minWidth = "140px";
      const btnClear = ui.btn("Clear slots", { variant: "secondary" });
      btnClear.id = "pets.teams.clearSlots";
      btnClear.style.minWidth = "140px";
      const DARK_BG = "#0f1318";
      extra.append(btnUseCurrent, btnClear);
      Object.assign(btnUseCurrent.style, {
        width: "auto",
        fontSize: "16px",
        borderRadius: "10px",
        background: DARK_BG,
        boxShadow: "none"
      });
      Object.assign(btnClear.style, {
        width: "auto",
        fontSize: "16px",
        borderRadius: "10px",
        background: DARK_BG,
        boxShadow: "none"
      });
      const wrapSlots = document.createElement("div");
      wrapSlots.style.display = "flex";
      wrapSlots.style.flexDirection = "column";
      wrapSlots.style.gap = "8px";
      wrapSlots.append(grid, extra);
      card.appendChild(framed("\u26A1 Active pets (3 slots)", wrapSlots));
      return {
        rows: [r0, r1, r2],
        btnUseCurrent,
        btnClear
      };
    })();
    async function repaintSlots(sourceTeam) {
      const t = sourceTeam ?? getSelectedTeam();
      if (!t) return;
      let inv = await PetsService.getInventoryPets().catch(() => null);
      if (!inv || inv.length === 0) {
      } else {
        invCacheMap = /* @__PURE__ */ new Map();
        for (const p of inv) {
          const id = p?.id != null ? String(p.id) : "";
          if (id) invCacheMap.set(id, p);
        }
      }
      const map2 = invCacheMap ?? /* @__PURE__ */ new Map();
      [0, 1, 2].forEach((i) => {
        const id = t.slots[i] || null;
        if (!id) {
          if (lastRenderedSlotIds[i] !== null) {
            secSlots.rows[i].update(null);
            lastRenderedSlotIds[i] = null;
          }
          return;
        }
        const pet = map2.get(id);
        if (!pet) return;
        if (lastRenderedSlotIds[i] === id) return;
        secSlots.rows[i].update(pet);
        lastRenderedSlotIds[i] = id;
      });
    }
    async function hydrateEditor(team) {
      const has = !!team;
      secName.nameInput.disabled = !has;
      secSlots.btnClear.disabled = !has;
      secSlots.btnUseCurrent.disabled = !has;
      btnUseTeam.disabled = !has;
      btnSave.disabled = !has;
      if (has) {
        const saved = PetsService.getTeamSearch(team.id) || "";
        const m = saved.match(/^(ab|sp):\s*(.*)$/i);
        const mode = m ? m[1].toLowerCase() === "ab" ? "ability" : "species" : "ability";
        secSearch.setMode(mode);
        await secSearch.rebuild();
        if (m) secSearch.setFromSearchString(saved);
      } else {
        await secSearch.rebuild();
      }
      if (!has) {
        secSlots.rows.forEach((r) => r.update(null));
        secName.nameInput.value = "";
        return;
      }
      secName.nameInput.value = String(team.name || "");
      await repaintSlots(team);
    }
    secName.nameInput.addEventListener("keydown", (ev) => {
      if (ev.key === "Enter") ev.currentTarget.blur();
    });
    secName.nameInput.addEventListener("blur", () => {
      const t = getSelectedTeam();
      if (!t) return;
      const nextName = secName.nameInput.value.trim();
      if (nextName !== t.name) {
        PetsService.saveTeam({ id: t.id, name: nextName });
      }
    });
    secSlots.btnUseCurrent.onclick = async () => {
      const t = getSelectedTeam();
      if (!t) return;
      try {
        const arr = await PetsService.getPets();
        const list = Array.isArray(arr) ? arr : [];
        const ids = list.map((p) => String(p?.slot?.id || "")).filter((x) => !!x).slice(0, 3);
        const nextSlots = [ids[0] || null, ids[1] || null, ids[2] || null];
        PetsService.saveTeam({ id: t.id, slots: nextSlots });
        await repaintSlots(t);
      } catch {
      }
    };
    secSlots.btnClear.onclick = async () => {
      const t = getSelectedTeam();
      if (!t) return;
      PetsService.saveTeam({ id: t.id, slots: [null, null, null] });
      await repaintSlots(t);
    };
    btnSave.onclick = () => {
      const t = getSelectedTeam();
      if (!t) return;
      const name = secName.nameInput.value.trim();
      const slots = t.slots.slice(0, 3);
      PetsService.saveTeam({ id: t.id, name, slots });
      void repaintSlots(t);
    };
    function sameSet(a, b) {
      if (a.length !== b.length) return false;
      const s = new Set(a);
      for (const x of b) if (!s.has(x)) return false;
      return true;
    }
    async function waitForActiveTeam(team, timeoutMs = 2e3) {
      const target = (team.slots || []).filter(Boolean);
      const t0 = performance.now();
      while (performance.now() - t0 < timeoutMs) {
        const pets = await PetsService.getPets().catch(() => null);
        const equip = Array.isArray(pets) ? pets.map((p) => String(p?.slot?.id || "")).filter(Boolean) : [];
        if (sameSet(equip, target)) return true;
        await new Promise((r) => setTimeout(r, 80));
      }
      return false;
    }
    btnUseTeam.onclick = async () => {
      const t = getSelectedTeam();
      if (!t) return;
      try {
        isApplyingTeam = true;
        activeTeamId = t.id;
        await refreshTeamList(true);
        await PetsService.useTeam(t.id);
        await waitForActiveTeam(t);
        await hydrateEditor(getSelectedTeam());
        await refreshTeamList();
      } catch (e) {
        console.warn("[Pets] Use this team failed:", e);
        await refreshTeamList();
      } finally {
        isApplyingTeam = false;
      }
    };
    let unsubPets = null;
    (async () => {
      try {
        unsubPets = await onActivePetsStructuralChangeNow(async () => {
          if (isApplyingTeam) return;
          await repaintSlots(getSelectedTeam());
          await refreshTeamList();
        });
      } catch {
      }
    })();
    installPetTeamHotkeysOnce(async (teamId) => {
      const t = teams.find((tt) => tt.id === teamId) || null;
      try {
        isApplyingTeam = true;
        if (t) {
          activeTeamId = t.id;
          await refreshTeamList(true);
        }
        await PetsService.useTeam(teamId);
        if (t) await waitForActiveTeam(t);
        await hydrateEditor(getSelectedTeam());
        await refreshTeamList();
      } catch (e) {
        console.warn("[Pets] hotkey useTeam failed:", e);
        await refreshTeamList();
      } finally {
        isApplyingTeam = false;
      }
    });
    view.__cleanup__ = (() => {
      const prev = view.__cleanup__;
      return () => {
        try {
          unsubTeams?.();
        } catch {
        }
        try {
          unsubPets?.();
        } catch {
        }
        try {
          prev?.();
        } catch {
        }
      };
    })();
  }
  function renderLogsTab(view, ui) {
    view.innerHTML = "";
    const wrap = document.createElement("div");
    wrap.style.display = "grid";
    wrap.style.gridTemplateRows = "auto 1fr";
    wrap.style.gap = "10px";
    wrap.style.height = "54vh";
    view.appendChild(wrap);
    const header = document.createElement("div");
    header.style.display = "flex";
    header.style.flexWrap = "wrap";
    header.style.alignItems = "center";
    header.style.gap = "8px";
    header.style.border = "1px solid #4445";
    header.style.borderRadius = "10px";
    header.style.padding = "8px 10px";
    header.style.background = "#0f1318";
    wrap.appendChild(header);
    const selAbility = ui.select({ id: "pets.logs.filter.ability", width: "200px" });
    const selSort = ui.select({ id: "pets.logs.sort", width: "140px" });
    [["desc", "Newest first"], ["asc", "Oldest first"]].forEach(([v, t]) => {
      const o = document.createElement("option");
      o.value = v;
      o.textContent = t;
      selSort.appendChild(o);
    });
    selSort.value = "desc";
    const inputSearch = ui.inputText("search (pet / ability / details)", "");
    inputSearch.id = "pets.logs.search";
    inputSearch.style.minWidth = "220px";
    const btnClear = ui.btn("\u{1F9F9} Clear", { size: "sm" });
    btnClear.id = "pets.logs.clear";
    btnClear.style.flex = "0 0 auto";
    header.append(
      ui.label("Ability"),
      selAbility,
      ui.label("Sort"),
      selSort,
      inputSearch,
      btnClear
    );
    const card = document.createElement("div");
    card.style.border = "1px solid #4445";
    card.style.borderRadius = "10px";
    card.style.padding = "10px";
    card.style.background = "#0f1318";
    card.style.overflow = "hidden";
    card.style.display = "grid";
    card.style.gridTemplateRows = "auto 1fr";
    card.style.minHeight = "0";
    wrap.appendChild(card);
    const headerGrid = document.createElement("div");
    headerGrid.style.display = "grid";
    headerGrid.style.gridTemplateColumns = "140px 220px 200px minmax(0,1fr)";
    headerGrid.style.columnGap = "0";
    headerGrid.style.borderBottom = "1px solid #ffffff1a";
    headerGrid.style.padding = "0 0 6px 0";
    function mkHeadCell2(txt, align = "center") {
      const el2 = document.createElement("div");
      el2.textContent = txt;
      el2.style.fontWeight = "600";
      el2.style.opacity = "0.9";
      el2.style.padding = "6px 8px";
      el2.style.textAlign = align;
      return el2;
    }
    headerGrid.append(
      mkHeadCell2("Date & Time"),
      mkHeadCell2("Pet"),
      mkHeadCell2("Ability"),
      mkHeadCell2("Details", "left")
    );
    card.appendChild(headerGrid);
    const bodyGrid = document.createElement("div");
    bodyGrid.style.display = "grid";
    bodyGrid.style.gridTemplateColumns = "140px 220px 200px minmax(0,1fr)";
    bodyGrid.style.gridAutoRows = "auto";
    bodyGrid.style.alignContent = "start";
    bodyGrid.style.overflow = "auto";
    bodyGrid.style.width = "100%";
    bodyGrid.style.minHeight = "0";
    card.appendChild(bodyGrid);
    const sessionStart = PetsService.getAbilityLogsSessionStart?.() ?? 0;
    let logs = [];
    let abilityFilter = "";
    let sortDir = "desc";
    let q = "";
    function rebuildAbilityOptions() {
      const current = selAbility.value;
      selAbility.innerHTML = "";
      const opts = [["", "All abilities"], ...PetsService.getSeenAbilityIds().map((a) => [a, a])];
      for (const [v, t] of opts) {
        const o = document.createElement("option");
        o.value = v;
        o.textContent = t;
        selAbility.appendChild(o);
      }
      selAbility.value = opts.some(([v]) => v === current) ? current : "";
    }
    function formatDateMMDDYY(timestamp) {
      const value = Number(timestamp);
      if (!Number.isFinite(value)) return "";
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) return "";
      const mm = String(date.getMonth() + 1).padStart(2, "0");
      const dd = String(date.getDate()).padStart(2, "0");
      const yy = String(date.getFullYear() % 100).padStart(2, "0");
      return `${mm}/${dd}/${yy}`;
    }
    function cell(txt, align = "center") {
      const el2 = document.createElement("div");
      el2.textContent = txt;
      el2.style.padding = "6px 8px";
      el2.style.display = "flex";
      el2.style.flexDirection = "column";
      el2.style.justifyContent = "center";
      el2.style.alignItems = align === "left" ? "flex-start" : "center";
      el2.style.textAlign = align;
      el2.style.whiteSpace = align === "left" ? "pre-wrap" : "normal";
      el2.style.wordBreak = align === "left" ? "break-word" : "normal";
      el2.style.borderBottom = "1px solid #ffffff12";
      return el2;
    }
    function row(log2) {
      const time = cell("", "center");
      time.style.gap = "2px";
      const dateLine = document.createElement("div");
      const timeLine = document.createElement("div");
      const hasDate = typeof log2.date === "string" && log2.date.trim().length > 0;
      if (hasDate) dateLine.textContent = log2.date ?? "";
      timeLine.textContent = log2.time12;
      if (hasDate) time.appendChild(dateLine);
      time.appendChild(timeLine);
      const petLabel = log2.petName || log2.species || "Pet";
      const pet = cell(petLabel, "center");
      const abName = cell(log2.abilityName || log2.abilityId, "center");
      const detText = typeof log2.data === "string" ? log2.data : (() => {
        try {
          return JSON.stringify(log2.data);
        } catch {
          return "";
        }
      })();
      const det = cell(detText, "left");
      if (log2.isActiveSession) {
        [time, pet, abName, det].forEach((el2) => {
          el2.style.background = "rgba(89, 162, 255, 0.14)";
        });
      }
      bodyGrid.append(time, pet, abName, det);
    }
    const normAbilityKey = (s) => String(s ?? "").toLowerCase().replace(/\s+/g, "").replace(/([ivx]+)$/i, "");
    function applyFilters() {
      let arr = logs.slice();
      if (abilityFilter && abilityFilter.trim()) {
        const f = normAbilityKey(abilityFilter);
        arr = arr.filter((l) => {
          const idKey = normAbilityKey(l.abilityId);
          const nameKey = normAbilityKey(PetsService.getAbilityNameWithoutLevel(l.abilityId));
          return idKey === f || nameKey === f;
        });
      }
      if (q && q.trim()) {
        const qq = q.toLowerCase();
        arr = arr.filter((l) => {
          const pet = (l.petName || l.species || "").toLowerCase();
          const abName = (l.abilityName || "").toLowerCase();
          const abId = (l.abilityId || "").toLowerCase();
          const det = (typeof l.data === "string" ? l.data : (() => {
            try {
              return JSON.stringify(l.data);
            } catch {
              return "";
            }
          })()).toLowerCase();
          return pet.includes(qq) || abName.includes(qq) || abId.includes(qq) || det.includes(qq) || (l.petId || "").toLowerCase().includes(qq);
        });
      }
      arr.sort(
        (a, b) => sortDir === "asc" ? a.performedAt - b.performedAt : b.performedAt - a.performedAt
      );
      return arr;
    }
    function repaint() {
      bodyGrid.innerHTML = "";
      const arr = applyFilters();
      if (!arr.length) {
        const empty = document.createElement("div");
        empty.textContent = "No logs yet.";
        empty.style.opacity = "0.75";
        empty.style.gridColumn = "1 / -1";
        empty.style.padding = "8px";
        bodyGrid.appendChild(empty);
        return;
      }
      arr.forEach(row);
      if (sortDir === "asc") bodyGrid.scrollTop = bodyGrid.scrollHeight + 32;
      else bodyGrid.scrollTop = 0;
    }
    selAbility.onchange = () => {
      abilityFilter = selAbility.value;
      repaint();
    };
    selSort.onchange = () => {
      sortDir = selSort.value || "desc";
      repaint();
    };
    inputSearch.addEventListener("input", () => {
      q = inputSearch.value.trim();
      repaint();
    });
    btnClear.onclick = () => {
      try {
        PetsService.clearAbilityLogs();
      } catch {
      }
    };
    let stopWatcher = null;
    let unsubLogs = null;
    (async () => {
      try {
        stopWatcher = await PetsService.startAbilityLogsWatcher();
        rebuildAbilityOptions();
        unsubLogs = PetsService.onAbilityLogs((all) => {
          logs = all.map((e) => ({
            petId: e.petId,
            petName: e.name ?? null,
            species: e.species ?? null,
            abilityId: e.abilityId,
            abilityName: e.abilityName,
            data: e.data,
            performedAt: e.performedAt,
            date: formatDateMMDDYY(e.performedAt),
            time12: e.time12,
            isActiveSession: sessionStart > 0 && e.performedAt >= sessionStart
          }));
          rebuildAbilityOptions();
          repaint();
        });
      } catch {
      }
    })();
    view.__cleanup__ = (() => {
      const prev = view.__cleanup__;
      return () => {
        try {
          unsubLogs?.();
        } catch {
        }
        try {
          stopWatcher?.();
        } catch {
        }
        try {
          prev?.();
        } catch {
        }
      };
    })();
    repaint();
  }
  function renderPetsMenu(root) {
    const ui = new Menu({ id: "pets", compact: true, windowSelector: ".qws-win" });
    ui.mount(root);
    ui.addTab("manager", "\u{1F9F0} Manager", (view) => renderManagerTab(view, ui));
    ui.addTab("logs", "\u{1F4DD} Logs", (view) => renderLogsTab(view, ui));
  }

  // src/services/misc.ts
  var LS_GHOST_KEY = "qws:player:ghostMode";
  var LS_DELAY_KEY = "qws:ghost:delayMs";
  var DEFAULT_DELAY_MS = 50;
  var readGhostEnabled = (def = false) => {
    try {
      return localStorage.getItem(LS_GHOST_KEY) === "1";
    } catch {
      return def;
    }
  };
  var writeGhostEnabled = (v) => {
    try {
      localStorage.setItem(LS_GHOST_KEY, v ? "1" : "0");
    } catch (err) {
    }
  };
  var getGhostDelayMs = () => {
    try {
      const n = Math.floor(Number(localStorage.getItem(LS_DELAY_KEY)) || DEFAULT_DELAY_MS);
      return Math.max(5, n);
    } catch {
      return DEFAULT_DELAY_MS;
    }
  };
  var setGhostDelayMs = (n) => {
    const v = Math.max(5, Math.floor(n || DEFAULT_DELAY_MS));
    try {
      localStorage.setItem(LS_DELAY_KEY, String(v));
    } catch (err) {
    }
  };
  function createGhostController() {
    let DELAY_MS = getGhostDelayMs();
    const KEYS = /* @__PURE__ */ new Set();
    const onKeyDownCapture = (e) => {
      const k = e.key.toLowerCase();
      const isMove = k === "z" || k === "q" || k === "s" || k === "d" || k === "w" || k === "a" || e.key === "ArrowUp" || e.key === "ArrowDown" || e.key === "ArrowLeft" || e.key === "ArrowRight";
      if (!isMove) return;
      e.preventDefault();
      e.stopImmediatePropagation();
      if (e.repeat) return;
      KEYS.add(k);
    };
    const onKeyUpCapture = (e) => {
      const k = e.key.toLowerCase();
      const isMove = k === "z" || k === "q" || k === "s" || k === "d" || k === "w" || k === "a" || e.key === "ArrowUp" || e.key === "ArrowDown" || e.key === "ArrowLeft" || e.key === "ArrowRight";
      if (!isMove) return;
      e.preventDefault();
      e.stopImmediatePropagation();
      KEYS.delete(k);
    };
    const onBlur = () => {
      KEYS.clear();
    };
    const onVisibility = () => {
      if (document.hidden) KEYS.clear();
    };
    function getDir() {
      let dx = 0, dy = 0;
      if (KEYS.has("z") || KEYS.has("w") || KEYS.has("arrowup")) dy -= 1;
      if (KEYS.has("s") || KEYS.has("arrowdown")) dy += 1;
      if (KEYS.has("q") || KEYS.has("a") || KEYS.has("arrowleft")) dx -= 1;
      if (KEYS.has("d") || KEYS.has("arrowright")) dx += 1;
      if (dx) dx = dx > 0 ? 1 : -1;
      if (dy) dy = dy > 0 ? 1 : -1;
      return { dx, dy };
    }
    let rafId = null;
    let lastTs = 0, accMs = 0, inMove = false;
    async function step(dx, dy) {
      let cur;
      try {
        cur = await PlayerService.getPosition();
      } catch (err) {
      }
      const cx = Math.round(cur?.x ?? 0), cy = Math.round(cur?.y ?? 0);
      try {
        await PlayerService.move(cx + dx, cy + dy);
      } catch (err) {
      }
    }
    const CAPTURE = { capture: true };
    function frame(ts) {
      if (!lastTs) lastTs = ts;
      const dt = ts - lastTs;
      lastTs = ts;
      const { dx, dy } = getDir();
      accMs += dt;
      if (dx === 0 && dy === 0) {
        accMs = Math.min(accMs, DELAY_MS * 4);
        rafId = requestAnimationFrame(frame);
        return;
      }
      if (accMs >= DELAY_MS && !inMove) {
        accMs -= DELAY_MS;
        inMove = true;
        (async () => {
          try {
            await step(dx, dy);
          } finally {
            inMove = false;
          }
        })();
      }
      accMs = Math.min(accMs, DELAY_MS * 4);
      rafId = requestAnimationFrame(frame);
    }
    return {
      start() {
        if (rafId !== null) return;
        lastTs = 0;
        accMs = 0;
        inMove = false;
        window.addEventListener("keydown", onKeyDownCapture, CAPTURE);
        window.addEventListener("keyup", onKeyUpCapture, CAPTURE);
        window.addEventListener("blur", onBlur);
        document.addEventListener("visibilitychange", onVisibility);
        rafId = requestAnimationFrame(frame);
      },
      stop() {
        if (rafId !== null) {
          cancelAnimationFrame(rafId);
          rafId = null;
        }
        KEYS.clear();
        window.removeEventListener("keydown", onKeyDownCapture, CAPTURE);
        window.removeEventListener("keyup", onKeyUpCapture, CAPTURE);
        window.removeEventListener("blur", onBlur);
        document.removeEventListener("visibilitychange", onVisibility);
      },
      setSpeed(n) {
        const v = Math.max(5, Math.floor(n || DEFAULT_DELAY_MS));
        DELAY_MS = v;
        setGhostDelayMs(v);
      },
      getSpeed() {
        return DELAY_MS;
      }
    };
  }
  var selectedMap = /* @__PURE__ */ new Map();
  var seedStockByName = /* @__PURE__ */ new Map();
  var seedSourceCache = [];
  var NF_US = new Intl.NumberFormat("en-US");
  var formatNum = (n) => NF_US.format(Math.max(0, Math.floor(n || 0)));
  async function clearUiSelectionAtoms() {
    try {
      await Atoms.inventory.mySelectedItemName.set(null);
    } catch {
    }
    try {
      await Atoms.inventory.myValidatedSelectedItemIndex.set(null);
    } catch {
    }
    try {
      await Atoms.inventory.myPossiblyNoLongerValidSelectedItemIndex.set(null);
    } catch {
    }
  }
  var OVERLAY_ID = "qws-seeddeleter-overlay";
  var LIST_ID = "qws-seeddeleter-list";
  var SUMMARY_ID = "qws-seeddeleter-summary";
  function sleep(ms) {
    return new Promise((r) => setTimeout(r, ms));
  }
  function buildDisplayNameToSpeciesFromCatalog() {
    const map2 = /* @__PURE__ */ new Map();
    try {
      const cat = plantCatalog;
      for (const species of Object.keys(cat || {})) {
        const seedName = cat?.[species]?.seed?.name && String(cat?.[species]?.seed?.name) || `${species} Seed`;
        const arr = map2.get(seedName) ?? [];
        arr.push(species);
        map2.set(seedName, arr);
      }
    } catch {
    }
    return map2;
  }
  async function buildSpeciesStockFromInventory() {
    const inv = await getMySeedInventory();
    const stock = /* @__PURE__ */ new Map();
    for (const it of inv) {
      const q = Math.max(0, Math.floor(it.quantity || 0));
      if (q > 0) stock.set(it.species, (stock.get(it.species) ?? 0) + q);
    }
    return stock;
  }
  function allocateForRequestedName(requested, nameToSpecies, speciesStock) {
    let remaining = Math.max(0, Math.floor(requested.qty || 0));
    let candidates = nameToSpecies.get(requested.name) ?? [];
    if (!candidates.length && / seed$/i.test(requested.name)) {
      const fallbackSpecies = requested.name.replace(/\s+seed$/i, "");
      if (plantCatalog?.[fallbackSpecies]) candidates = [fallbackSpecies];
    }
    if (!candidates.length || remaining <= 0) return [];
    const ranked = candidates.map((sp) => ({ sp, available: speciesStock.get(sp) ?? 0 })).filter((x) => x.available > 0).sort((a, b) => b.available - a.available);
    const out = [];
    for (const { sp, available } of ranked) {
      if (remaining <= 0) break;
      const take = Math.min(available, remaining);
      if (take > 0) {
        out.push({ species: sp, qty: take });
        remaining -= take;
      }
    }
    return out;
  }
  var _seedDeleteAbort = null;
  var _seedDeleteBusy = false;
  async function deleteSelectedSeeds(opts = {}) {
    if (_seedDeleteBusy) {
      await toastSimple("Seed deleter", "Deletion already in progress.", "info");
      return;
    }
    const batchSize = Math.max(1, Math.floor(opts.batchSize ?? 25));
    const delayMs = Math.max(0, Math.floor(opts.delayMs ?? 16));
    const selection = (opts.selection && Array.isArray(opts.selection) ? opts.selection : Array.from(selectedMap.values())).map((s) => ({ name: s.name, qty: Math.max(0, Math.floor(s.qty || 0)) })).filter((s) => s.qty > 0);
    if (selection.length === 0) {
      await toastSimple("Seed deleter", "No seeds selected.", "info");
      return;
    }
    const nameToSpecies = buildDisplayNameToSpeciesFromCatalog();
    const speciesStock = await buildSpeciesStockFromInventory();
    const allocatedBySpecies = /* @__PURE__ */ new Map();
    let requestedTotal = 0, cappedTotal = 0;
    for (const req of selection) {
      requestedTotal += req.qty;
      const chunks = allocateForRequestedName(req, nameToSpecies, speciesStock);
      const okForThis = chunks.reduce((a, c) => a + c.qty, 0);
      cappedTotal += okForThis;
      for (const c of chunks) {
        allocatedBySpecies.set(c.species, (allocatedBySpecies.get(c.species) ?? 0) + c.qty);
      }
    }
    if (cappedTotal <= 0) {
      await toastSimple("Seed deleter", "Nothing to delete (not in inventory).", "info");
      return;
    }
    if (cappedTotal < requestedTotal) {
      await toastSimple(
        "Seed deleter",
        `Requested ${formatNum(requestedTotal)} but only ${formatNum(cappedTotal)} available. Proceeding.`,
        "info"
      );
    }
    const tasks = Array.from(allocatedBySpecies.entries()).map(([species, qty]) => ({ species, qty: Math.max(0, Math.floor(qty || 0)) })).filter((t) => t.qty > 0);
    const total = tasks.reduce((acc, t) => acc + t.qty, 0);
    if (total <= 0) {
      await toastSimple("Seed deleter", "Nothing to delete.", "info");
      return;
    }
    _seedDeleteBusy = true;
    const abort = new AbortController();
    _seedDeleteAbort = abort;
    try {
      await toastSimple("Seed deleter", `Deleting ${formatNum(total)} seeds across ${tasks.length} species...`, "info");
      let done = 0;
      for (const t of tasks) {
        let remaining = t.qty;
        while (remaining > 0) {
          if (abort.signal.aborted) throw new Error("Deletion cancelled.");
          const n = Math.min(batchSize, remaining);
          for (let i = 0; i < n; i++) {
            try {
              await PlayerService.wish(t.species);
            } catch (err) {
            }
          }
          done += n;
          remaining -= n;
          try {
            opts.onProgress?.({ done, total, species: t.species, remainingForSpecies: remaining });
            window.dispatchEvent(new CustomEvent("qws:seeddeleter:progress", {
              detail: { done, total, species: t.species, remainingForSpecies: remaining }
            }));
          } catch {
          }
          if (delayMs > 0 && remaining > 0) await sleep(delayMs);
        }
      }
      if (!opts.keepSelection) selectedMap.clear();
      try {
        window.dispatchEvent(new CustomEvent("qws:seeddeleter:done", { detail: { total, speciesCount: tasks.length } }));
      } catch {
      }
      await toastSimple("Seed deleter", `Deleted ${formatNum(total)} seeds (${tasks.length} species).`, "success");
    } catch (e) {
      const msg = e?.message || "Deletion failed.";
      try {
        window.dispatchEvent(new CustomEvent("qws:seeddeleter:error", { detail: { message: msg } }));
      } catch {
      }
      await toastSimple("Seed deleter", msg, "error");
    } finally {
      _seedDeleteBusy = false;
      _seedDeleteAbort = null;
    }
  }
  function cancelSeedDeletion() {
    try {
      _seedDeleteAbort?.abort();
    } catch (err) {
    }
  }
  function isSeedDeletionRunning() {
    return _seedDeleteBusy;
  }
  try {
    window.addEventListener("qws:seeddeleter:apply", async (e) => {
      try {
        const selection = Array.isArray(e?.detail?.selection) ? e.detail.selection : void 0;
        await deleteSelectedSeeds({ selection, batchSize: 25, delayMs: 16, keepSelection: false });
      } catch {
      }
    });
  } catch {
  }
  function seedDisplayNameFromSpecies(species) {
    try {
      const node = plantCatalog?.[species];
      const n = node?.seed?.name;
      if (typeof n === "string" && n) return n;
    } catch {
    }
    return `${species} Seed`;
  }
  function normalizeSeedItem(x, _idx) {
    if (!x || typeof x !== "object") return null;
    const species = typeof x.species === "string" ? x.species.trim() : "";
    const itemType = x.itemType === "Seed" ? "Seed" : null;
    const quantity = Number.isFinite(x.quantity) ? Math.max(0, Math.floor(x.quantity)) : 0;
    if (!species || itemType !== "Seed" || quantity <= 0) return null;
    return { species, itemType: "Seed", quantity, id: `seed:${species}` };
  }
  async function getMySeedInventory() {
    try {
      const raw = await Atoms.inventory.mySeedInventory.get();
      if (!Array.isArray(raw)) return [];
      const out = [];
      raw.forEach((x, i) => {
        const s = normalizeSeedItem(x, i);
        if (s) out.push(s);
      });
      return out;
    } catch {
      return [];
    }
  }
  function buildInventoryShapeFrom(items) {
    return { items, favoritedItemIds: [] };
  }
  function setStyles(el2, styles) {
    Object.assign(el2.style, styles);
  }
  function styleOverlayBox(div) {
    div.id = OVERLAY_ID;
    setStyles(div, {
      position: "fixed",
      left: "12px",
      top: "12px",
      zIndex: "999999",
      display: "grid",
      gridTemplateRows: "auto auto 1px 1fr auto",
      gap: "6px",
      minWidth: "320px",
      maxWidth: "420px",
      maxHeight: "52vh",
      padding: "8px",
      border: "1px solid #39424c",
      borderRadius: "10px",
      background: "rgba(22,27,34,0.92)",
      boxShadow: "0 10px 30px rgba(0,0,0,0.35)",
      backdropFilter: "blur(2px)",
      userSelect: "none",
      fontFamily: "ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial",
      fontSize: "12px",
      lineHeight: "1.25"
    });
    div.dataset["qwsSeedDeleter"] = "1";
  }
  function makeDraggable(root, handle) {
    let dragging = false;
    let ox = 0, oy = 0;
    const onDown = (e) => {
      dragging = true;
      const r = root.getBoundingClientRect();
      ox = e.clientX - r.left;
      oy = e.clientY - r.top;
      document.addEventListener("mousemove", onMove);
      document.addEventListener("mouseup", onUp, { once: true });
    };
    const onMove = (e) => {
      if (!dragging) return;
      const nx = Math.max(4, e.clientX - ox);
      const ny = Math.max(4, e.clientY - oy);
      root.style.left = `${nx}px`;
      root.style.top = `${ny}px`;
    };
    const onUp = () => {
      dragging = false;
      document.removeEventListener("mousemove", onMove);
    };
    handle.addEventListener("mousedown", onDown);
  }
  function createButton2(label2, styleOverride) {
    const b = document.createElement("button");
    b.textContent = label2;
    setStyles(b, {
      padding: "4px 8px",
      borderRadius: "8px",
      border: "1px solid #4446",
      background: "#161b22",
      color: "#E7EEF7",
      cursor: "pointer",
      fontWeight: "600",
      fontSize: "12px",
      ...styleOverride
    });
    b.onmouseenter = () => b.style.borderColor = "#6aa1";
    b.onmouseleave = () => b.style.borderColor = "#4446";
    return b;
  }
  var overlayKeyGuardsOn = false;
  function isInsideOverlay(el2) {
    return !!(el2 && el2.closest?.(`#${OVERLAY_ID}`));
  }
  function keyGuardCapture(e) {
    const ae = document.activeElement;
    if (!isInsideOverlay(ae)) return;
    const tag = (ae?.tagName || "").toLowerCase();
    const isEditable = tag === "input" || tag === "textarea" || ae && ae.isContentEditable;
    if (!isEditable) return;
    if (/^[0-9]$/.test(e.key)) {
      e.stopImmediatePropagation();
    }
  }
  function installOverlayKeyGuards() {
    if (overlayKeyGuardsOn) return;
    window.addEventListener("keydown", keyGuardCapture, { capture: true });
    overlayKeyGuardsOn = true;
  }
  function removeOverlayKeyGuards() {
    if (!overlayKeyGuardsOn) return;
    window.removeEventListener("keydown", keyGuardCapture, { capture: true });
    overlayKeyGuardsOn = false;
  }
  async function closeSeedInventoryPanel() {
    try {
      await fakeInventoryHide();
    } catch {
      try {
        document.dispatchEvent(new KeyboardEvent("keydown", { key: "Escape" }));
      } catch {
      }
    }
  }
  function createSeedOverlay() {
    const box = document.createElement("div");
    styleOverlayBox(box);
    const header = document.createElement("div");
    setStyles(header, { display: "flex", alignItems: "center", gap: "4px", cursor: "move" });
    const title = document.createElement("div");
    title.textContent = "\u{1F3AF} Selection mode";
    setStyles(title, { fontWeight: "700", fontSize: "13px" });
    const hint = document.createElement("div");
    hint.textContent = "Click seeds in inventory to toggle selection.";
    setStyles(hint, { opacity: "0.8", fontSize: "11px" });
    const hr = document.createElement("div");
    setStyles(hr, { height: "1px", background: "#2d333b" });
    const list = document.createElement("div");
    list.id = LIST_ID;
    setStyles(list, {
      minHeight: "44px",
      maxHeight: "26vh",
      overflow: "auto",
      padding: "4px",
      border: "1px dashed #39424c",
      borderRadius: "8px",
      background: "rgba(15,19,24,0.84)",
      userSelect: "text"
    });
    const actions = document.createElement("div");
    setStyles(actions, { display: "flex", justifyContent: "space-between", alignItems: "center", gap: "8px" });
    const summary = document.createElement("div");
    summary.id = SUMMARY_ID;
    setStyles(summary, { fontWeight: "600" });
    summary.textContent = "Selected: 0 species \xB7 0 seeds";
    const btnClear = createButton2("Clear");
    btnClear.title = "Clear selection";
    btnClear.onclick = async () => {
      selectedMap.clear();
      refreshList();
      updateSummary();
      await clearUiSelectionAtoms();
      await repatchFakeSeedInventoryWithSelection();
    };
    _btnConfirm = createButton2("Confirm", { background: "#1F2328CC" });
    _btnConfirm.disabled = true;
    _btnConfirm.onclick = async () => {
      await closeSeedInventoryPanel();
    };
    header.append(title);
    actions.append(summary, btnClear, _btnConfirm);
    box.append(header, hint, hr, list, actions);
    makeDraggable(box, header);
    return box;
  }
  function showSeedOverlay() {
    if (document.getElementById(OVERLAY_ID)) return;
    const el2 = createSeedOverlay();
    document.body.appendChild(el2);
    installOverlayKeyGuards();
    refreshList();
    updateSummary();
  }
  function hideSeedOverlay() {
    const el2 = document.getElementById(OVERLAY_ID);
    if (el2) el2.remove();
    removeOverlayKeyGuards();
  }
  var _btnConfirm = null;
  var unsubSelectedName = null;
  function renderListRow(item) {
    const row = document.createElement("div");
    setStyles(row, {
      display: "grid",
      gridTemplateColumns: "1fr auto",
      alignItems: "center",
      gap: "6px",
      padding: "4px 6px",
      borderBottom: "1px dashed #2d333b"
    });
    const name = document.createElement("div");
    name.textContent = item.name;
    setStyles(name, {
      fontSize: "12px",
      fontWeight: "600",
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    });
    const controls = document.createElement("div");
    setStyles(controls, { display: "flex", alignItems: "center", gap: "6px" });
    const qty = document.createElement("input");
    qty.type = "number";
    qty.min = "1";
    qty.max = String(Math.max(1, item.maxQty));
    qty.step = "1";
    qty.value = String(item.qty);
    qty.className = "qmm-input";
    setStyles(qty, {
      width: "68px",
      height: "28px",
      border: "1px solid #4446",
      borderRadius: "8px",
      background: "rgba(15,19,24,0.90)",
      padding: "0 8px",
      fontSize: "12px"
    });
    const swallowDigits = (e) => {
      if (/^[0-9]$/.test(e.key)) {
        e.stopPropagation();
        e.stopImmediatePropagation();
      }
    };
    qty.addEventListener("keydown", swallowDigits);
    qty.onchange = () => {
      const v = Math.min(item.maxQty, Math.max(1, Math.floor(Number(qty.value) || 1)));
      qty.value = String(v);
      const cur = selectedMap.get(item.name);
      if (!cur) return;
      cur.qty = v;
      selectedMap.set(item.name, cur);
      updateSummary();
    };
    qty.oninput = qty.onchange;
    const remove = createButton2("Remove", { background: "transparent" });
    remove.onclick = async () => {
      selectedMap.delete(item.name);
      refreshList();
      updateSummary();
      await repatchFakeSeedInventoryWithSelection();
    };
    controls.append(qty, remove);
    row.append(name, controls);
    return row;
  }
  function refreshList() {
    const list = document.getElementById(LIST_ID);
    if (!list) return;
    list.innerHTML = "";
    const entries = Array.from(selectedMap.values()).sort((a, b) => a.name.localeCompare(b.name));
    if (entries.length === 0) {
      const empty = document.createElement("div");
      empty.textContent = "No seeds selected.";
      empty.style.opacity = "0.8";
      list.appendChild(empty);
      return;
    }
    for (const it of entries) list.appendChild(renderListRow(it));
  }
  function totalSelected() {
    let species = 0, qty = 0;
    for (const it of selectedMap.values()) {
      species += 1;
      qty += it.qty;
    }
    return { species, qty };
  }
  function updateSummary() {
    const { species, qty } = totalSelected();
    const el2 = document.getElementById(SUMMARY_ID);
    if (el2) el2.textContent = `Selected: ${species} species \xB7 ${formatNum(qty)} seeds`;
    if (_btnConfirm) {
      _btnConfirm.textContent = "Confirm";
      _btnConfirm.disabled = qty <= 0;
      _btnConfirm.style.opacity = qty <= 0 ? "0.6" : "1";
      _btnConfirm.style.cursor = qty <= 0 ? "not-allowed" : "pointer";
    }
  }
  async function repatchFakeSeedInventoryWithSelection() {
    const selectedNames = new Set(Array.from(selectedMap.keys()));
    const filtered = (Array.isArray(seedSourceCache) ? seedSourceCache : []).filter((s) => {
      const disp = seedDisplayNameFromSpecies(s.species);
      return !selectedNames.has(disp);
    });
    try {
      await fakeInventoryShow({ items: filtered, favoritedItemIds: [] }, { open: false });
    } catch {
    }
  }
  async function beginSelectedNameListener() {
    if (unsubSelectedName) return;
    const unsub = await Atoms.inventory.mySelectedItemName.onChange(async (name) => {
      const n = (name || "").trim();
      if (!n) return;
      if (selectedMap.has(n)) {
        selectedMap.delete(n);
      } else {
        const max = Math.max(1, seedStockByName.get(n) ?? 1);
        selectedMap.set(n, { name: n, qty: max, maxQty: max });
      }
      refreshList();
      updateSummary();
      await clearUiSelectionAtoms();
      await repatchFakeSeedInventoryWithSelection();
    });
    unsubSelectedName = typeof unsub === "function" ? unsub : null;
  }
  async function endSelectedNameListener() {
    const fn = unsubSelectedName;
    unsubSelectedName = null;
    try {
      await fn?.();
    } catch {
    }
  }
  async function openSeedInventoryPreview() {
    try {
      const src = await getMySeedInventory();
      if (!src.length) {
        await toastSimple("Seed inventory", "No seeds to display.", "info");
        return;
      }
      await fakeInventoryShow(buildInventoryShapeFrom(src), { open: true });
    } catch (e) {
      await toastSimple("Seed inventory", e?.message || "Failed to open seed inventory.", "error");
    }
  }
  async function openSeedSelectorFlow(setWindowVisible) {
    try {
      setWindowVisible?.(false);
      seedSourceCache = await getMySeedInventory();
      seedStockByName = /* @__PURE__ */ new Map();
      for (const s of seedSourceCache) {
        const display = seedDisplayNameFromSpecies(s.species);
        seedStockByName.set(display, Math.max(1, Math.floor(s.quantity || 0)));
      }
      selectedMap.clear();
      showSeedOverlay();
      await beginSelectedNameListener();
      await fakeInventoryShow(buildInventoryShapeFrom(seedSourceCache), { open: true });
      if (await isInventoryPanelOpen()) {
        await waitInventoryPanelClosed();
      }
    } catch (e) {
      await toastSimple("Seed inventory", e?.message || "Failed to open seed selector.", "error");
    } finally {
      await endSelectedNameListener();
      hideSeedOverlay();
      seedSourceCache = [];
      seedStockByName.clear();
      setWindowVisible?.(true);
    }
  }
  var MiscService = {
    // ghost
    readGhostEnabled,
    writeGhostEnabled,
    getGhostDelayMs,
    setGhostDelayMs,
    createGhostController,
    // seeds
    getMySeedInventory,
    openSeedInventoryPreview,
    openSeedSelectorFlow,
    //delete
    deleteSelectedSeeds,
    cancelSeedDeletion,
    isSeedDeletionRunning,
    getCurrentSeedSelection() {
      return Array.from(selectedMap.values());
    },
    clearSeedSelection() {
      selectedMap.clear();
    }
  };

  // src/ui/menus/misc.ts
  var NF_US2 = new Intl.NumberFormat("en-US");
  var formatNum2 = (n) => NF_US2.format(Math.max(0, Math.floor(n || 0)));
  async function renderMiscMenu(container) {
    const ui = new Menu({ id: "misc", compact: true });
    ui.mount(container);
    const view = ui.root.querySelector(".qmm-views");
    view.innerHTML = "";
    view.style.display = "grid";
    view.style.gap = "8px";
    view.style.minHeight = "0";
    view.style.justifyItems = "center";
    const secPlayer = (() => {
      const row = document.createElement("div");
      row.style.display = "flex";
      row.style.alignItems = "center";
      row.style.gap = "12px";
      row.style.flexWrap = "wrap";
      const pair = (labelText, controlEl, labelId) => {
        const wrap = document.createElement("div");
        wrap.style.display = "inline-flex";
        wrap.style.alignItems = "center";
        wrap.style.gap = "6px";
        const lab = ui.label(labelText);
        lab.style.fontSize = "13px";
        lab.style.margin = "0";
        lab.style.justifySelf = "start";
        if (labelId) lab.id = labelId;
        wrap.append(lab, controlEl);
        return wrap;
      };
      const ghostSwitch = ui.switch(MiscService.readGhostEnabled(false));
      ghostSwitch.id = "player.ghostMode";
      const ghostPair = pair("Ghost", ghostSwitch, "label.ghost");
      const delayInput = ui.inputNumber(10, 1e3, 5, 50);
      delayInput.id = "player.moveDelay";
      const delayWrap = delayInput.wrap ?? delayInput;
      delayWrap.style && (delayWrap.style.margin = "0");
      delayInput.style && (delayInput.style.width = "84px");
      const delayPair = pair("Delay (ms)", delayWrap, "label.delay");
      row.append(ghostPair, delayPair);
      const ghost = MiscService.createGhostController();
      delayInput.value = String(MiscService.getGhostDelayMs());
      delayInput.addEventListener("change", () => {
        const v = Math.max(10, Math.min(1e3, Math.floor(Number(delayInput.value) || 50)));
        delayInput.value = String(v);
        ghost.setSpeed?.(v);
        MiscService.setGhostDelayMs(v);
      });
      if (ghostSwitch.checked) ghost.start();
      ghostSwitch.onchange = () => {
        const on = !!ghostSwitch.checked;
        MiscService.writeGhostEnabled(on);
        on ? ghost.start() : ghost.stop();
      };
      row.__cleanup__ = () => {
        try {
          ghost.stop();
        } catch {
        }
      };
      const card = ui.card("\u{1F3AE} Player controls", { tone: "muted", align: "center" });
      card.root.style.maxWidth = "440px";
      card.body.append(row);
      return card.root;
    })();
    const secSeed = (() => {
      const grid = ui.formGrid({ columnGap: 6, rowGap: 6 });
      const selLabel = ui.label("Selected");
      selLabel.style.fontSize = "13px";
      selLabel.style.margin = "0";
      selLabel.style.justifySelf = "start";
      const selValue = document.createElement("div");
      selValue.id = "misc.seedDeleter.summary";
      selValue.style.fontSize = "13px";
      selValue.style.opacity = "0.9";
      selValue.textContent = "0 species \xB7 0 seeds";
      grid.append(selLabel, selValue);
      const actLabel = ui.label("Actions");
      actLabel.style.fontSize = "13px";
      actLabel.style.margin = "0";
      actLabel.style.justifySelf = "start";
      const actions = ui.flexRow({ gap: 6 });
      actions.style.justifyContent = "flex-start";
      const btnSelect = ui.btn("Select seeds", { variant: "primary", size: "sm" });
      const btnDelete = ui.btn("Delete", { variant: "danger", size: "sm", disabled: true });
      const btnClear = ui.btn("Clear", { size: "sm", disabled: true });
      actions.append(btnSelect, btnDelete, btnClear);
      grid.append(actLabel, actions);
      function readSelection() {
        const sel = MiscService.getCurrentSeedSelection?.() || [];
        const speciesCount = sel.length;
        let totalQty = 0;
        for (const it of sel) totalQty += Math.max(0, Math.floor(it?.qty || 0));
        return { sel, speciesCount, totalQty };
      }
      function updateSummaryUI() {
        const { speciesCount, totalQty } = readSelection();
        selValue.textContent = `${speciesCount} species \xB7 ${formatNum2(totalQty)} seeds`;
        const has = speciesCount > 0 && totalQty > 0;
        ui.setButtonEnabled(btnDelete, has);
        ui.setButtonEnabled(btnClear, has);
      }
      btnSelect.onclick = async () => {
        await MiscService.openSeedSelectorFlow(ui.setWindowVisible.bind(ui));
        updateSummaryUI();
      };
      btnClear.onclick = () => {
        try {
          MiscService.clearSeedSelection?.();
        } catch {
        }
        updateSummaryUI();
      };
      btnDelete.onclick = async () => {
        await MiscService.deleteSelectedSeeds();
        updateSummaryUI();
      };
      const card = ui.card("\u{1F5D1}\uFE0F Seed deleter", { tone: "muted", align: "center" });
      card.root.style.maxWidth = "440px";
      card.body.append(grid);
      return card.root;
    })();
    const content = document.createElement("div");
    content.style.display = "grid";
    content.style.gap = "8px";
    content.style.justifyItems = "center";
    content.append(secPlayer, secSeed);
    view.appendChild(content);
    view.__cleanup__ = () => {
      try {
        secPlayer.__cleanup__?.();
      } catch {
      }
      try {
        secSeed.__cleanup__?.();
      } catch {
      }
    };
  }

  // src/services/tools.ts
  var TOOL_LIST = [
    {
      id: "wiki",
      title: "Magic Garden Wiki",
      description: "Community-curated documentation for plants, mechanics, weather, and more.",
      url: "https://magicgarden.fandom.com/wiki/MagicCircle_Wiki",
      icon: "\u{1F4DA}",
      tags: ["guide"]
    },
    {
      id: "calculator",
      title: "Magic Garden Calculator",
      description: "Numerous optimisation statistics at your fingertips.",
      url: "https://daserix.github.io/magic-garden-calculator/",
      icon: "\u{1F9EE}",
      tags: ["calculator"]
    },
    {
      id: "mgtools",
      title: "MGTools",
      description: "Utility scripts designed to streamline your time in Magic Garden.",
      url: "https://github.com/Myke247/MGTools/",
      icon: "\u{1F6E0}\uFE0F",
      tags: ["utility"]
    },
    {
      id: "pet-revenue",
      title: "Pet Revenue Planner",
      description: "Forecast the extra income your pets generate, showing $/min and per-boost gains so you can decide which pets and crops to prioritize.",
      url: "https://docs.google.com/spreadsheets/d/1tG1LIEsXQlNRxaN2pySkwwN688_eCLgGIil_xRaPnBo/edit?gid=1430710045#gid=1430710045",
      icon: "\u{1F43E}",
      tags: ["calculator"]
    },
    {
      id: "dollar-hour",
      title: "$ per Hour Calculators",
      description: "Estimate your gold per hour: select a crop, apply weather and friend/pet boosts, set the duration, and get an instant $/h result.",
      url: "https://docs.google.com/spreadsheets/d/1ZYikURs-vBMfTQCU_fFbl25CITBrjsEZePxWc-DqOm8/edit?gid=689506777#gid=689506777",
      icon: "\u{1F4B8}",
      tags: ["calculator"]
    },
    {
      id: "should-i-invest",
      title: "Should I Invest?",
      description: "Instant ROI calculator, select crop, weather, mutation, size, and boost to see if it\u2019s worth it.",
      url: "https://docs.google.com/spreadsheets/d/1PyKd9NG3GsocFmCgwQ01ZQ783ADzcim5LS5XLSLJtqI/edit",
      icon: "\u{1F914}",
      tags: ["calculator"]
    },
    {
      id: "matrixes",
      title: "Matrixes Reference",
      description: "A reference matrix that compares and ranks each plant\u2019s $/h across all buffs and combos, with quick pick/freeze/gold suggestions.",
      url: "https://docs.google.com/spreadsheets/d/1gUdu8LBFbkN7CJzqX_nDwLW9nxdIks-0jRJTrUI19U4/edit?gid=1450892699#gid=1450892699",
      icon: "\u{1F9E9}",
      tags: ["reference"]
    },
    {
      id: "beginners-guide",
      title: "Beginner's Guide Snapshot",
      description: "A concise visual cheat sheet to get new gardeners up to speed quickly.",
      url: "https://i.imgur.com/7IHU0RJ.png",
      icon: "\u{1F331}",
      tags: ["guide", "beginner"]
    }
  ];
  var TOOL_TAGS = Array.from(
    new Set(
      TOOL_LIST.flatMap((tool) => {
        return tool.tags ?? [];
      })
    )
  ).sort((a, b) => a.localeCompare(b));
  function cloneTool(tool) {
    return {
      ...tool,
      tags: tool.tags ? [...tool.tags] : void 0
    };
  }
  function resolve(tool) {
    if (typeof tool === "string") {
      const found = TOOL_LIST.find((entry) => entry.id === tool);
      return found ? cloneTool(found) : null;
    }
    return cloneTool(tool);
  }
  function openUrl(url) {
    if (typeof GM_openInTab === "function") {
      GM_openInTab(url, { active: true, insert: true });
      return true;
    }
    if (typeof window === "undefined") return false;
    try {
      const a = document.createElement("a");
      a.href = url;
      a.target = "_blank";
      a.rel = "noopener noreferrer";
      document.body.appendChild(a);
      a.click();
      a.remove();
      return true;
    } catch {
      return false;
    }
  }
  var ToolsService = {
    list() {
      const list = TOOL_LIST.map(cloneTool);
      return list;
    },
    tags() {
      return TOOL_TAGS.map((tag) => tag);
    },
    get(id) {
      const found = TOOL_LIST.find((tool) => tool.id === id);
      const entry = found ? cloneTool(found) : null;
      return entry;
    },
    open(tool) {
      const entry = resolve(tool);
      if (!entry) {
        return false;
      }
      const ok = openUrl(entry.url);
      return ok;
    }
  };

  // src/ui/menus/tools.ts
  function createTagPill(label2) {
    const pill = document.createElement("span");
    pill.textContent = label2;
    pill.style.display = "inline-flex";
    pill.style.alignItems = "center";
    pill.style.justifyContent = "center";
    pill.style.padding = "2px 8px";
    pill.style.borderRadius = "999px";
    pill.style.background = "#ffffff11";
    pill.style.border = "1px solid #ffffff22";
    pill.style.fontSize = "11px";
    pill.style.letterSpacing = "0.02em";
    pill.style.textTransform = "uppercase";
    pill.style.opacity = "0.8";
    return pill;
  }
  function renderToolCard(ui, tool) {
    const title = `${tool.icon ? `${tool.icon} ` : ""}${tool.title}`;
    const card = ui.card(title, { tone: "muted", align: "stretch" });
    card.root.style.width = "100%";
    const body = card.body;
    body.style.display = "grid";
    body.style.gap = "10px";
    body.style.justifyItems = "stretch";
    const description = document.createElement("p");
    description.textContent = tool.description;
    description.style.margin = "0";
    description.style.fontSize = "13px";
    description.style.lineHeight = "1.45";
    description.style.opacity = "0.9";
    description.style.textAlign = "left";
    body.appendChild(description);
    if (tool.tags?.length) {
      const tags = document.createElement("div");
      tags.style.display = "flex";
      tags.style.flexWrap = "wrap";
      tags.style.gap = "6px";
      tags.style.opacity = "0.85";
      tool.tags.forEach((tag) => tags.appendChild(createTagPill(tag)));
      body.appendChild(tags);
    }
    const actions = ui.flexRow({ gap: 8, justify: "end", fullWidth: true });
    actions.style.marginTop = "4px";
    const openBtn = ui.btn("Open tool", {
      variant: "primary",
      icon: "\u{1F517}",
      fullWidth: true,
      title: "Open the tool in a new tab"
    });
    openBtn.style.flex = "1 1 auto";
    openBtn.style.minWidth = "0";
    openBtn.onclick = () => {
      const ok = ToolsService.open(tool);
      if (!ok) {
        void toastSimple("Unable to open link", "Please open the address manually.", "error");
      }
    };
    actions.append(openBtn);
    body.appendChild(actions);
    return card.root;
  }
  async function renderToolsMenu(container) {
    const ui = new Menu({ id: "tools", compact: true });
    ui.mount(container);
    const view = ui.root.querySelector(".qmm-views");
    view.innerHTML = "";
    view.style.display = "flex";
    view.style.flexDirection = "column";
    view.style.gap = "12px";
    view.style.alignItems = "center";
    view.style.padding = "8px";
    view.style.width = "100%";
    view.style.maxHeight = "54vh";
    view.style.overflowY = "auto";
    view.style.overflowX = "auto";
    const WRAPPER_WIDTH = 720;
    const wrapper = document.createElement("div");
    wrapper.style.display = "flex";
    wrapper.style.flexDirection = "column";
    wrapper.style.gap = "12px";
    wrapper.style.width = `${WRAPPER_WIDTH}px`;
    wrapper.style.minWidth = `${WRAPPER_WIDTH}px`;
    wrapper.style.maxWidth = `${WRAPPER_WIDTH}px`;
    wrapper.style.boxSizing = "border-box";
    wrapper.style.alignSelf = "center";
    const intro = ui.card("\u{1F9F0} Community tools", {
      tone: "muted",
      align: "stretch"
    });
    const introText = document.createElement("p");
    introText.textContent = "Discover community-made helpers to plan, calculate, and simplify your Magic Garden adventures.";
    introText.style.margin = "0";
    introText.style.fontSize = "13px";
    introText.style.lineHeight = "1.5";
    introText.style.opacity = "0.9";
    introText.style.textAlign = "left";
    intro.body.appendChild(introText);
    wrapper.appendChild(intro.root);
    const allTools = ToolsService.list();
    const filterSection = document.createElement("div");
    filterSection.style.display = "flex";
    filterSection.style.flexDirection = "column";
    filterSection.style.gap = "8px";
    filterSection.style.background = "#ffffff08";
    filterSection.style.border = "1px solid #ffffff11";
    filterSection.style.borderRadius = "12px";
    filterSection.style.padding = "12px";
    const filterTitle = document.createElement("span");
    filterTitle.textContent = "Filter by tags";
    filterTitle.style.fontSize = "12px";
    filterTitle.style.letterSpacing = "0.05em";
    filterTitle.style.textTransform = "uppercase";
    filterTitle.style.opacity = "0.75";
    filterTitle.style.fontWeight = "600";
    const filterControls = document.createElement("div");
    filterControls.style.display = "flex";
    filterControls.style.flexWrap = "wrap";
    filterControls.style.gap = "8px";
    const selectedTags = /* @__PURE__ */ new Set();
    const tagButtons = /* @__PURE__ */ new Map();
    let allButton;
    let cardsContainer;
    const filterBtnBaseStyle = (btn) => {
      btn.type = "button";
      btn.style.display = "inline-flex";
      btn.style.alignItems = "center";
      btn.style.justifyContent = "center";
      btn.style.padding = "4px 10px";
      btn.style.borderRadius = "999px";
      btn.style.border = "1px solid";
      btn.style.background = "#ffffff11";
      btn.style.borderColor = "#ffffff22";
      btn.style.fontSize = "11px";
      btn.style.fontWeight = "600";
      btn.style.letterSpacing = "0.03em";
      btn.style.textTransform = "uppercase";
      btn.style.color = "inherit";
      btn.style.opacity = "0.85";
      btn.style.cursor = "pointer";
      btn.style.transition = "background 120ms ease, border-color 120ms ease, opacity 120ms ease";
    };
    const setActiveState = (btn, active) => {
      if (active) {
        btn.style.background = "#2d8cff33";
        btn.style.borderColor = "#2d8cff66";
        btn.style.opacity = "1";
      } else {
        btn.style.background = "#ffffff11";
        btn.style.borderColor = "#ffffff22";
        btn.style.opacity = "0.85";
      }
    };
    const renderList = () => {
      cardsContainer.innerHTML = "";
      const filtered = selectedTags.size ? allTools.filter((tool) => tool.tags?.some((tag) => selectedTags.has(tag))) : allTools;
      if (filtered.length === 0) {
        const empty = document.createElement("p");
        empty.textContent = "No tools match the selected tags yet.";
        empty.style.margin = "12px 0 0";
        empty.style.fontSize = "13px";
        empty.style.opacity = "0.75";
        empty.style.textAlign = "center";
        cardsContainer.appendChild(empty);
        return;
      }
      filtered.forEach((tool) => {
        cardsContainer.appendChild(renderToolCard(ui, tool));
      });
    };
    const refreshButtonStates = () => {
      tagButtons.forEach((btn, tag) => {
        setActiveState(btn, selectedTags.has(tag));
      });
      setActiveState(allButton, selectedTags.size === 0);
    };
    const handleToggle = (tag) => {
      if (selectedTags.has(tag)) {
        selectedTags.delete(tag);
      } else {
        selectedTags.add(tag);
      }
      refreshButtonStates();
      renderList();
    };
    allButton = document.createElement("button");
    allButton.textContent = "All";
    filterBtnBaseStyle(allButton);
    allButton.onclick = () => {
      if (selectedTags.size === 0) return;
      selectedTags.clear();
      refreshButtonStates();
      renderList();
    };
    filterControls.appendChild(allButton);
    ToolsService.tags().forEach((tag) => {
      const btn = document.createElement("button");
      btn.textContent = tag;
      filterBtnBaseStyle(btn);
      btn.onclick = () => handleToggle(tag);
      filterControls.appendChild(btn);
      tagButtons.set(tag, btn);
    });
    filterSection.appendChild(filterTitle);
    filterSection.appendChild(filterControls);
    wrapper.appendChild(filterSection);
    cardsContainer = document.createElement("div");
    cardsContainer.style.display = "flex";
    cardsContainer.style.flexDirection = "column";
    cardsContainer.style.gap = "12px";
    renderList();
    refreshButtonStates();
    wrapper.appendChild(cardsContainer);
    view.appendChild(wrapper);
  }

  // src/utils/publicRooms.ts
  var ROOMS_JSON_URL = "https://raw.githubusercontent.com/Ariedam64/MagicGarden-modMenu/refs/heads/main/rooms.json";
  function resolveGmXhr() {
    if (typeof GM_xmlhttpRequest === "function") {
      return GM_xmlhttpRequest;
    }
    if (typeof GM !== "undefined" && typeof GM.xmlHttpRequest === "function") {
      return GM.xmlHttpRequest.bind(GM);
    }
    return void 0;
  }
  async function fetchTextWithFetch2(url, options) {
    const response = await fetch(url, { cache: "no-store", ...options });
    if (!response.ok) {
      throw new Error(`Failed to load remote resource: ${response.status} ${response.statusText}`);
    }
    return await response.text();
  }
  async function fetchTextWithGM2(url, options) {
    const xhr = resolveGmXhr();
    if (!xhr) {
      throw new Error("GM_xmlhttpRequest not available");
    }
    return await new Promise((resolve2, reject) => {
      xhr({
        method: "GET",
        url,
        headers: options?.headers,
        onload: (res) => {
          if (res.status >= 200 && res.status < 300) {
            resolve2(res.responseText ?? "");
          } else {
            reject(new Error(`GM_xmlhttpRequest failed: ${res.status}`));
          }
        },
        onerror: (res) => {
          reject(new Error(res.error ?? "GM_xmlhttpRequest error"));
        },
        ontimeout: () => reject(new Error("GM_xmlhttpRequest timeout")),
        onabort: () => reject(new Error("GM_xmlhttpRequest aborted"))
      });
    });
  }
  async function fetchText2(url, options) {
    const preferGM = isDiscordSurface();
    const hasGM = !!resolveGmXhr();
    if (preferGM && hasGM) {
      return await fetchTextWithGM2(url, options);
    }
    try {
      return await fetchTextWithFetch2(url, options);
    } catch (error) {
      if (hasGM) {
        return await fetchTextWithGM2(url, options);
      }
      throw error;
    }
  }
  async function fetchRemoteRooms() {
    const text = await fetchText2(ROOMS_JSON_URL);
    try {
      return JSON.parse(text);
    } catch (error) {
      throw new Error("Failed to parse rooms JSON", { cause: error });
    }
  }

  // src/services/room.ts
  var MAX_PLAYERS = 6;
  function deriveCategoryFromName(name) {
    const match = /^([a-zA-Z]+)/.exec(name);
    if (match && match[1]) {
      return match[1].toLowerCase();
    }
    return "other";
  }
  function deriveCategoryOrder(definitions, preferredOrder = []) {
    const available = new Set(definitions.map((room) => room.category));
    const seen = /* @__PURE__ */ new Set();
    const order = [];
    for (const category of preferredOrder) {
      if (!available.has(category)) continue;
      if (seen.has(category)) continue;
      seen.add(category);
      order.push(category);
    }
    for (const room of definitions) {
      if (seen.has(room.category)) continue;
      seen.add(room.category);
      order.push(room.category);
    }
    return order;
  }
  function createStateFromDefinitions(definitions, preferredOrder = []) {
    const cloned = definitions.map((room) => ({ ...room }));
    return {
      definitions: cloned,
      categoryOrder: deriveCategoryOrder(cloned, preferredOrder)
    };
  }
  function cloneState2(state2) {
    return {
      definitions: state2.definitions.map((room) => ({ ...room })),
      categoryOrder: [...state2.categoryOrder]
    };
  }
  var INITIAL_PUBLIC_ROOMS_STATE = createStateFromDefinitions([]);
  var publicRoomsState = cloneState2(INITIAL_PUBLIC_ROOMS_STATE);
  var remoteRoomsStatus = "idle";
  var remoteRoomsPromise = null;
  function parseRemoteRoomsPayload(payload) {
    if (!payload || typeof payload !== "object") {
      return null;
    }
    const record = payload.publicRooms;
    if (!record || typeof record !== "object") {
      return null;
    }
    const definitions = [];
    const categoryOrder = [];
    for (const [rawCategory, entries] of Object.entries(record)) {
      if (!Array.isArray(entries) || !entries.length) {
        continue;
      }
      const categoryName = typeof rawCategory === "string" ? rawCategory.trim() : "";
      if (!categoryName) {
        continue;
      }
      if (!categoryOrder.includes(categoryName)) {
        categoryOrder.push(categoryName);
      }
      for (const entry of entries) {
        if (typeof entry !== "string") {
          continue;
        }
        const separatorIndex = entry.indexOf(":");
        if (separatorIndex <= 0) {
          continue;
        }
        const name = entry.slice(0, separatorIndex).trim();
        const idRoom = entry.slice(separatorIndex + 1).trim();
        if (!name || !idRoom) {
          continue;
        }
        definitions.push({
          name,
          idRoom,
          category: categoryName
        });
      }
    }
    if (!definitions.length) {
      return null;
    }
    return createStateFromDefinitions(definitions, categoryOrder);
  }
  function setPublicRoomsState(next) {
    publicRoomsState = cloneState2(next);
  }
  function requestRemoteRoomsFetch() {
    if (remoteRoomsStatus === "pending" || remoteRoomsStatus === "fulfilled" || remoteRoomsStatus === "rejected") {
      return remoteRoomsPromise;
    }
    if (typeof window === "undefined") {
      return null;
    }
    remoteRoomsStatus = "pending";
    remoteRoomsPromise = (async () => {
      try {
        const payload = await fetchRemoteRooms();
        const parsed = parseRemoteRoomsPayload(payload);
        if (parsed) {
          setPublicRoomsState(parsed);
        }
        remoteRoomsStatus = "fulfilled";
      } catch (error) {
        remoteRoomsStatus = "rejected";
        console.warn("[MagicGarden] Unable to load remote rooms list", error);
      }
    })();
    return remoteRoomsPromise;
  }
  async function ensureRemoteRoomsLoaded() {
    const promise = requestRemoteRoomsFetch();
    if (promise) {
      await promise;
    }
  }
  var CUSTOM_ROOMS_STORAGE_KEY = "mg.customRooms";
  function getStorage2() {
    if (typeof window === "undefined") return null;
    try {
      return window.localStorage;
    } catch {
      return null;
    }
  }
  function sanitizeRoomDefinition(room) {
    if (!room) return null;
    const name = typeof room.name === "string" ? room.name.trim() : "";
    const idRoom = typeof room.idRoom === "string" ? room.idRoom.trim() : "";
    if (!name || !idRoom) return null;
    return {
      name,
      idRoom,
      category: deriveCategoryFromName(name)
    };
  }
  function loadStoredCustomRooms() {
    const storage = getStorage2();
    if (!storage) return [];
    try {
      const raw = storage.getItem(CUSTOM_ROOMS_STORAGE_KEY);
      if (!raw) return [];
      const parsed = JSON.parse(raw);
      if (!Array.isArray(parsed)) return [];
      const result = [];
      for (const entry of parsed) {
        const sanitized = sanitizeRoomDefinition(entry);
        if (sanitized) {
          result.push(sanitized);
        }
      }
      return result;
    } catch {
      return [];
    }
  }
  function persistCustomRooms(rooms) {
    const storage = getStorage2();
    if (!storage) return;
    try {
      const payload = rooms.map((room) => ({
        name: room.name,
        idRoom: room.idRoom
      }));
      storage.setItem(CUSTOM_ROOMS_STORAGE_KEY, JSON.stringify(payload));
    } catch {
    }
  }
  var customRoomsCache = null;
  function getCustomRoomsCache() {
    if (!customRoomsCache) {
      customRoomsCache = loadStoredCustomRooms();
    }
    return customRoomsCache.map((room) => ({ ...room }));
  }
  function setCustomRoomsCache(rooms) {
    customRoomsCache = rooms.map((room) => ({ ...room }));
    persistCustomRooms(customRoomsCache);
  }
  function normalizeIdentifier(value) {
    return value.trim().toLowerCase();
  }
  function fetchStatusesFor(definitions) {
    const now2 = Date.now();
    return Promise.all(
      definitions.map(async (def) => {
        try {
          const response = await requestRoomEndpoint(def.idRoom, {
            endpoint: "info",
            timeoutMs: 1e4
          });
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          const payload = response.parsed ?? (() => {
            try {
              return JSON.parse(response.body);
            } catch {
              return void 0;
            }
          })();
          const players = clampPlayerCount(typeof payload?.numPlayers === "number" ? payload.numPlayers : 0);
          const capacity = MAX_PLAYERS;
          const currentGame = typeof payload?.currentGame === "string" && payload.currentGame.trim().length ? payload.currentGame.trim() : void 0;
          const hostPlayerId = typeof payload?.hostPlayerId === "string" && payload.hostPlayerId.trim().length ? payload.hostPlayerId.trim() : void 0;
          const playerDetails = normalizeRoomPlayers(payload?.players, hostPlayerId);
          return {
            ...def,
            players,
            capacity,
            isFull: players >= capacity,
            lastUpdatedAt: now2,
            currentGame,
            hostPlayerId,
            playerDetails
          };
        } catch (error) {
          const message = normalizeError(error);
          return {
            ...def,
            players: 0,
            capacity: MAX_PLAYERS,
            isFull: false,
            lastUpdatedAt: now2,
            hostPlayerId: void 0,
            playerDetails: [],
            error: message
          };
        }
      })
    );
  }
  function clampPlayerCount(value) {
    if (!Number.isFinite(value)) return 0;
    return Math.max(0, Math.min(MAX_PLAYERS, Math.floor(value)));
  }
  function normalizeRoomPlayers(value, hostPlayerId) {
    if (!Array.isArray(value)) return [];
    const normalized = [];
    for (const entry of value) {
      if (!entry || typeof entry !== "object") continue;
      const id = typeof entry.id === "string" && entry.id.trim().length ? entry.id.trim() : void 0;
      const databaseUserId = typeof entry.databaseUserId === "string" && entry.databaseUserId.trim().length ? entry.databaseUserId.trim() : void 0;
      const rawName = typeof entry.name === "string" ? entry.name.trim() : "";
      const name = rawName || "Unknown player";
      const isConnected = typeof entry.isConnected === "boolean" ? entry.isConnected : false;
      const discordAvatarUrl = typeof entry.discordAvatarUrl === "string" && entry.discordAvatarUrl.trim().length ? entry.discordAvatarUrl.trim() : void 0;
      normalized.push({
        id,
        databaseUserId,
        name,
        isConnected,
        discordAvatarUrl,
        isHost: Boolean(hostPlayerId && (id === hostPlayerId || databaseUserId === hostPlayerId))
      });
    }
    return normalized;
  }
  function normalizeError(error) {
    if (!error) return "Erreur inconnue.";
    if (typeof error === "string") return error;
    if (error instanceof Error) return error.message || "Erreur inconnue.";
    try {
      return JSON.stringify(error);
    } catch {
      return String(error);
    }
  }
  var RoomService = {
    getPublicRooms() {
      void requestRemoteRoomsFetch();
      return publicRoomsState.definitions.map((room) => ({ ...room }));
    },
    getPublicRoomsCategoryOrder() {
      void requestRemoteRoomsFetch();
      return [...publicRoomsState.categoryOrder];
    },
    getCustomRooms() {
      return getCustomRoomsCache();
    },
    addCustomRoom(room) {
      const name = typeof room.name === "string" ? room.name.trim() : "";
      const idRoom = typeof room.idRoom === "string" ? room.idRoom.trim() : "";
      if (!name) {
        return { ok: false, error: "Room name is required." };
      }
      if (!idRoom) {
        return { ok: false, error: "Room identifier is required." };
      }
      const normalizedName = normalizeIdentifier(name);
      const normalizedId = normalizeIdentifier(idRoom);
      const allRooms = [...this.getPublicRooms(), ...getCustomRoomsCache()];
      if (allRooms.some((existing) => normalizeIdentifier(existing.idRoom) === normalizedId)) {
        return { ok: false, error: "This room already exists." };
      }
      if (allRooms.some((existing) => normalizeIdentifier(existing.name) === normalizedName)) {
        return { ok: false, error: "A room with this name already exists." };
      }
      const definition = {
        name,
        idRoom,
        category: deriveCategoryFromName(name)
      };
      const next = [...getCustomRoomsCache(), definition];
      setCustomRoomsCache(next);
      return { ok: true, room: { ...definition } };
    },
    removeCustomRoom(idRoom) {
      const normalizedId = normalizeIdentifier(idRoom);
      const rooms = getCustomRoomsCache();
      const filtered = rooms.filter((room) => normalizeIdentifier(room.idRoom) !== normalizedId);
      if (filtered.length === rooms.length) {
        return false;
      }
      setCustomRoomsCache(filtered);
      return true;
    },
    async fetchPublicRoomsStatus() {
      await ensureRemoteRoomsLoaded();
      const definitions = publicRoomsState.definitions.map((room) => ({ ...room }));
      return fetchStatusesFor(definitions);
    },
    async fetchCustomRoomsStatus() {
      const definitions = this.getCustomRooms();
      if (!definitions.length) return [];
      return fetchStatusesFor(definitions);
    },
    canJoinPublicRoom(room) {
      if (room.error) return false;
      if (room.isFull) return false;
      if (this.isDiscordActivity()) return false;
      return true;
    },
    isDiscordActivity() {
      return isDiscordSurface();
    },
    joinPublicRoom(room) {
      const result = joinRoom(room.idRoom, { siteFallbackOnDiscord: true, preferSoft: false });
      if (!result.ok) {
      }
      return result;
    }
  };

  // src/ui/menus/room.ts
  var ROOM_MENU_STYLE_ID = "mc-room-menu-loading-style";
  function ensureRoomMenuStyles() {
    if (document.getElementById(ROOM_MENU_STYLE_ID)) return;
    const style2 = document.createElement("style");
    style2.id = ROOM_MENU_STYLE_ID;
    style2.textContent = `
@keyframes room-menu-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

.qmm.qmm-room-menu .qmm-tab[data-id="public-rooms"],
.qmm.qmm-room-menu .qmm-tab[data-id="search-player"] {
  flex: 0 1 auto;
  min-width: 160px;
}
`;
    document.head.appendChild(style2);
  }
  var TAB_ID = "public-rooms";
  var CUSTOM_TAB_ID = "custom-rooms";
  var SEARCH_TAB_ID = "search-player";
  async function renderRoomMenu(root) {
    const ui = new Menu({
      id: "room",
      compact: true,
      windowSelector: ".qws-win",
      classes: "qmm-room-menu"
    });
    ui.addTab(TAB_ID, "\u{1F310} Public Rooms", (view) => renderPublicRoomsTab(view, ui));
    ui.addTab(CUSTOM_TAB_ID, "\u2B50 Custom Rooms", (view) => renderCustomRoomsTab(view, ui));
    ui.addTab(SEARCH_TAB_ID, "\u{1F50D} Search Player", (view) => renderSearchPlayerTab(view, ui));
    ui.mount(root);
  }
  function renderPublicRoomsTab(view, ui) {
    view.innerHTML = "";
    ensureRoomMenuStyles();
    const root = document.createElement("div");
    root.style.display = "flex";
    root.style.flexDirection = "column";
    root.style.alignItems = "center";
    root.style.padding = "12px";
    root.style.boxSizing = "border-box";
    root.style.height = "100%";
    root.style.minHeight = "0";
    view.appendChild(root);
    const container = document.createElement("div");
    container.style.display = "grid";
    container.style.gap = "12px";
    container.style.width = "100%";
    container.style.maxWidth = "640px";
    container.style.height = "100%";
    container.style.gridTemplateRows = "max-content max-content 1fr max-content";
    root.appendChild(container);
    const heading = document.createElement("div");
    heading.textContent = "Select a public room to quickly join a game.";
    heading.style.fontSize = "14px";
    heading.style.opacity = "0.9";
    container.appendChild(heading);
    if (RoomService.isDiscordActivity()) {
      const discordWarning = document.createElement("div");
      discordWarning.textContent = "You are using Discord: direct join is disabled. Open the official website to join a room.";
      discordWarning.style.fontSize = "13px";
      discordWarning.style.lineHeight = "1.4";
      discordWarning.style.padding = "10px 12px";
      discordWarning.style.borderRadius = "8px";
      discordWarning.style.background = "#2e1f1f";
      discordWarning.style.color = "#ffb4a2";
      discordWarning.style.border = "1px solid rgba(255, 140, 105, 0.35)";
      container.appendChild(discordWarning);
    }
    const filterBar = document.createElement("div");
    filterBar.style.display = "flex";
    filterBar.style.flexWrap = "wrap";
    filterBar.style.alignItems = "center";
    filterBar.style.gap = "8px";
    filterBar.style.margin = "12px 0 6px";
    filterBar.style.width = "100%";
    container.appendChild(filterBar);
    const listWrapper = document.createElement("div");
    listWrapper.style.height = "54vh";
    listWrapper.style.maxHeight = "54vh";
    listWrapper.style.overflowY = "auto";
    listWrapper.style.padding = "6px 2px";
    listWrapper.style.borderRadius = "10px";
    listWrapper.style.background = "rgba(12, 13, 20, 0.65)";
    listWrapper.style.boxShadow = "inset 0 0 0 1px rgba(255, 255, 255, 0.04)";
    listWrapper.style.width = "100%";
    listWrapper.style.boxSizing = "border-box";
    listWrapper.style.position = "relative";
    const floatingLoadingIndicator = document.createElement("div");
    floatingLoadingIndicator.style.position = "absolute";
    floatingLoadingIndicator.style.top = "14px";
    floatingLoadingIndicator.style.right = "14px";
    floatingLoadingIndicator.style.width = "28px";
    floatingLoadingIndicator.style.height = "28px";
    floatingLoadingIndicator.style.borderRadius = "999px";
    floatingLoadingIndicator.style.display = "flex";
    floatingLoadingIndicator.style.alignItems = "center";
    floatingLoadingIndicator.style.justifyContent = "center";
    floatingLoadingIndicator.style.background = "rgba(14, 16, 25, 0.9)";
    floatingLoadingIndicator.style.border = "1px solid rgba(255, 255, 255, 0.08)";
    floatingLoadingIndicator.style.boxShadow = "0 10px 24px rgba(0, 0, 0, 0.45)";
    floatingLoadingIndicator.style.opacity = "0";
    floatingLoadingIndicator.style.visibility = "hidden";
    floatingLoadingIndicator.style.pointerEvents = "none";
    floatingLoadingIndicator.style.transition = "opacity 160ms ease, transform 160ms ease";
    floatingLoadingIndicator.style.zIndex = "3";
    const floatingLoadingSpinner = document.createElement("div");
    floatingLoadingSpinner.style.width = "16px";
    floatingLoadingSpinner.style.height = "16px";
    floatingLoadingSpinner.style.borderRadius = "999px";
    floatingLoadingSpinner.style.border = "2px solid rgba(248, 250, 252, 0.16)";
    floatingLoadingSpinner.style.borderTopColor = "#f8fafc";
    floatingLoadingSpinner.style.animation = "room-menu-spin 1s linear infinite";
    floatingLoadingIndicator.appendChild(floatingLoadingSpinner);
    const list = document.createElement("div");
    list.style.display = "grid";
    list.style.gap = "10px";
    list.style.padding = "4px";
    listWrapper.appendChild(list);
    listWrapper.appendChild(floatingLoadingIndicator);
    container.appendChild(listWrapper);
    const updateFloatingLoadingIndicator = () => {
      floatingLoadingIndicator.style.transform = `translateY(${listWrapper.scrollTop}px)`;
    };
    let isFloatingIndicatorVisible = false;
    const setLoadingState = (loading) => {
      if (loading) {
        isFloatingIndicatorVisible = true;
        updateFloatingLoadingIndicator();
        floatingLoadingIndicator.style.visibility = "visible";
        floatingLoadingIndicator.style.opacity = "1";
      } else {
        isFloatingIndicatorVisible = false;
        floatingLoadingIndicator.style.opacity = "0";
        floatingLoadingIndicator.addEventListener(
          "transitionend",
          () => {
            if (!isFloatingIndicatorVisible) {
              floatingLoadingIndicator.style.visibility = "hidden";
            }
          },
          { once: true }
        );
        window.setTimeout(() => {
          if (!isFloatingIndicatorVisible) {
            floatingLoadingIndicator.style.visibility = "hidden";
          }
        }, 220);
      }
    };
    let savedScrollTop = 0;
    listWrapper.addEventListener("scroll", () => {
      savedScrollTop = listWrapper.scrollTop;
      if (isFloatingIndicatorVisible) {
        updateFloatingLoadingIndicator();
      }
    });
    let destroyed = false;
    let requestCounter = 0;
    let firstLoad = true;
    let selectedCategory = null;
    let selectedPlayerFilter = "any";
    let currentRooms = [];
    const filterButtons = /* @__PURE__ */ new Map();
    let lastRenderedCategories = [];
    const categoryButtonContainer = document.createElement("div");
    categoryButtonContainer.style.display = "flex";
    categoryButtonContainer.style.flexWrap = "wrap";
    categoryButtonContainer.style.alignItems = "center";
    categoryButtonContainer.style.gap = "8px";
    filterBar.appendChild(categoryButtonContainer);
    const refreshButton = ui.btn("Refresh rooms", { size: "sm", icon: "\u{1F504}" });
    refreshButton.style.flexShrink = "0";
    refreshButton.setAttribute("aria-label", "Refresh public rooms list");
    const filterActions = document.createElement("div");
    filterActions.style.display = "flex";
    filterActions.style.alignItems = "center";
    filterActions.style.gap = "8px";
    filterActions.style.marginLeft = "auto";
    filterBar.appendChild(filterActions);
    const statusBar = document.createElement("div");
    statusBar.style.fontSize = "12px";
    statusBar.style.opacity = "0.75";
    statusBar.style.marginLeft = "auto";
    statusBar.style.textAlign = "right";
    statusBar.textContent = "Loading rooms\u2026";
    const footer = document.createElement("div");
    footer.style.display = "flex";
    footer.style.alignItems = "center";
    footer.style.gap = "12px";
    footer.style.marginTop = "8px";
    footer.style.width = "100%";
    footer.appendChild(refreshButton);
    footer.appendChild(statusBar);
    container.appendChild(footer);
    let isRefreshing = false;
    const updateRefreshButtonState = () => {
      const enabled = !destroyed && !isRefreshing;
      ui.setButtonEnabled(refreshButton, enabled);
      refreshButton.setAttribute("aria-busy", isRefreshing ? "true" : "false");
    };
    const updateFilterButtonStyles = () => {
      for (const [category, button] of filterButtons) {
        const isActive = category === selectedCategory;
        button.dataset.active = isActive ? "true" : "false";
        button.setAttribute("aria-pressed", isActive ? "true" : "false");
        button.style.opacity = isActive ? "1" : "0.7";
      }
    };
    const matchesPlayerFilter = (room) => {
      switch (selectedPlayerFilter) {
        case "any":
          return true;
        case "empty":
          return room.players === 0;
        case "few":
          return room.players > 0 && room.players <= 3;
        case "crowded":
          return !room.isFull && room.players >= 4;
        case "full":
          return room.isFull;
        default:
          return true;
      }
    };
    const setCategoryFilter = (category) => {
      if (selectedCategory === category) return;
      selectedCategory = category;
      savedScrollTop = 0;
      updateFilterButtonStyles();
      renderRooms(currentRooms);
    };
    function createFilterButton(label2, category) {
      const button = ui.btn(label2, { size: "sm", variant: "ghost" });
      button.addEventListener("click", () => {
        if (category === null) {
          setCategoryFilter(null);
        } else if (selectedCategory === category) {
          setCategoryFilter(null);
        } else {
          setCategoryFilter(category);
        }
      });
      return button;
    }
    function collectCategories(rooms) {
      if (!rooms) return [];
      const seen = /* @__PURE__ */ new Set();
      const categories = [];
      for (const room of rooms) {
        if (!room || typeof room.category !== "string") continue;
        const category = room.category.trim();
        if (!category || seen.has(category)) continue;
        seen.add(category);
        categories.push(category);
      }
      return categories;
    }
    function sortCategories(categories) {
      if (!categories.length) return [];
      const preferred = RoomService.getPublicRoomsCategoryOrder();
      if (!preferred.length) {
        return [...categories];
      }
      const available = new Set(categories);
      const ordered = [];
      const used = /* @__PURE__ */ new Set();
      for (const name of preferred) {
        if (available.has(name) && !used.has(name)) {
          ordered.push(name);
          used.add(name);
        }
      }
      for (const name of categories) {
        if (!used.has(name)) {
          ordered.push(name);
          used.add(name);
        }
      }
      return ordered;
    }
    function updateCategoryButtons(rooms) {
      const categoriesFromRooms = collectCategories(rooms);
      const sourceCategories = categoriesFromRooms.length ? categoriesFromRooms : collectCategories(RoomService.getPublicRooms());
      const sortedCategories = sortCategories(sourceCategories);
      const changed = filterButtons.size === 0 || sortedCategories.length !== lastRenderedCategories.length || sortedCategories.some((category, index) => category !== lastRenderedCategories[index]);
      if (changed) {
        if (selectedCategory && !sortedCategories.includes(selectedCategory)) {
          selectedCategory = null;
          savedScrollTop = 0;
        }
        categoryButtonContainer.innerHTML = "";
        filterButtons.clear();
        const allButton = createFilterButton("All", null);
        filterButtons.set(null, allButton);
        categoryButtonContainer.appendChild(allButton);
        for (const category of sortedCategories) {
          const button = createFilterButton(category, category);
          filterButtons.set(category, button);
          categoryButtonContainer.appendChild(button);
        }
        lastRenderedCategories = [...sortedCategories];
      }
      updateFilterButtonStyles();
    }
    updateCategoryButtons();
    const renderRooms = (rooms) => {
      currentRooms = rooms;
      updateCategoryButtons(rooms);
      list.innerHTML = "";
      const visibleRooms = rooms.filter((room) => {
        if (selectedCategory !== null && room.category !== selectedCategory) {
          return false;
        }
        if (!matchesPlayerFilter(room)) {
          return false;
        }
        return true;
      });
      if (!visibleRooms.length) {
        const empty = document.createElement("div");
        empty.textContent = rooms.length ? "No rooms match the selected filter." : "No public rooms available.";
        empty.style.padding = "16px";
        empty.style.textAlign = "center";
        empty.style.opacity = "0.7";
        list.appendChild(empty);
      } else {
        for (const room of visibleRooms) {
          list.appendChild(createRoomEntry(room, ui));
        }
      }
      requestAnimationFrame(() => {
        const maxScroll = Math.max(0, listWrapper.scrollHeight - listWrapper.clientHeight);
        const nextScroll = Math.min(savedScrollTop, maxScroll);
        listWrapper.scrollTop = nextScroll;
        savedScrollTop = nextScroll;
      });
    };
    const playerFilterContainer = document.createElement("div");
    playerFilterContainer.style.display = "flex";
    playerFilterContainer.style.alignItems = "center";
    playerFilterContainer.style.gap = "6px";
    playerFilterContainer.style.padding = "4px 6px";
    playerFilterContainer.style.background = "rgba(24, 26, 36, 0.85)";
    playerFilterContainer.style.borderRadius = "10px";
    playerFilterContainer.style.boxShadow = "inset 0 0 0 1px rgba(255, 255, 255, 0.05)";
    const playerFilterLabel = document.createElement("span");
    playerFilterLabel.textContent = "Players";
    playerFilterLabel.style.fontSize = "12px";
    playerFilterLabel.style.opacity = "0.75";
    playerFilterLabel.style.paddingLeft = "2px";
    playerFilterContainer.appendChild(playerFilterLabel);
    const playerFilterSelect = document.createElement("select");
    playerFilterSelect.style.background = "rgba(17, 18, 27, 0.95)";
    playerFilterSelect.style.border = "1px solid rgba(255, 255, 255, 0.08)";
    playerFilterSelect.style.color = "#f8fafc";
    playerFilterSelect.style.borderRadius = "8px";
    playerFilterSelect.style.padding = "4px 10px";
    playerFilterSelect.style.fontSize = "12px";
    playerFilterSelect.style.fontWeight = "500";
    playerFilterSelect.style.outline = "none";
    playerFilterSelect.style.cursor = "pointer";
    playerFilterSelect.style.minWidth = "130px";
    const playerFilters = [
      { value: "any", label: "Any players" },
      { value: "empty", label: "Empty rooms" },
      { value: "few", label: "1 \u2013 3 players" },
      { value: "crowded", label: "4 \u2013 5 players" },
      { value: "full", label: "Full rooms" }
    ];
    for (const option of playerFilters) {
      const opt = document.createElement("option");
      opt.value = option.value;
      opt.textContent = option.label;
      playerFilterSelect.appendChild(opt);
    }
    playerFilterSelect.value = selectedPlayerFilter;
    playerFilterSelect.addEventListener("change", () => {
      selectedPlayerFilter = playerFilterSelect.value;
      savedScrollTop = 0;
      renderRooms(currentRooms);
    });
    playerFilterContainer.appendChild(playerFilterSelect);
    filterActions.appendChild(playerFilterContainer);
    const refreshRooms = async () => {
      if (destroyed) return;
      const currentRequest = ++requestCounter;
      isRefreshing = true;
      updateRefreshButtonState();
      setLoadingState(true);
      statusBar.textContent = firstLoad ? "Loading rooms\u2026" : "Refreshing rooms\u2026";
      try {
        const rooms = await RoomService.fetchPublicRoomsStatus();
        if (destroyed || currentRequest !== requestCounter) return;
        renderRooms(rooms);
        const time = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
          hour: "2-digit",
          minute: "2-digit",
          hour12: true
        });
        statusBar.textContent = `Last update: ${time}`;
      } catch (error) {
        if (destroyed || currentRequest !== requestCounter) return;
        statusBar.textContent = `Failed to load rooms: ${String(error?.message || error)}`;
      } finally {
        if (!destroyed && currentRequest === requestCounter) {
          setLoadingState(false);
        }
        if (currentRequest === requestCounter) {
          isRefreshing = false;
        }
        updateRefreshButtonState();
        firstLoad = false;
      }
    };
    refreshButton.addEventListener("click", () => {
      void refreshRooms();
    });
    updateRefreshButtonState();
    refreshRooms();
    const windowEl = view.closest(".qws-win");
    const computeWindowVisible = (win) => !win.classList.contains("is-hidden") && getComputedStyle(win).display !== "none";
    let visibilityObserver = null;
    if (windowEl) {
      let lastVisible = computeWindowVisible(windowEl);
      visibilityObserver = new MutationObserver(() => {
        if (destroyed) return;
        const isVisible3 = computeWindowVisible(windowEl);
        if (isVisible3 && !lastVisible) {
          void refreshRooms();
        }
        lastVisible = isVisible3;
      });
      visibilityObserver.observe(windowEl, { attributes: true, attributeFilter: ["class", "style"] });
    }
    const previousCleanup = view.__cleanup__;
    view.__cleanup__ = () => {
      destroyed = true;
      visibilityObserver?.disconnect();
      updateRefreshButtonState();
      if (typeof previousCleanup === "function") {
        try {
          previousCleanup.call(view);
        } catch {
        }
      }
    };
  }
  function renderCustomRoomsTab(view, ui) {
    view.innerHTML = "";
    ensureRoomMenuStyles();
    const root = document.createElement("div");
    root.style.display = "flex";
    root.style.flexDirection = "column";
    root.style.alignItems = "center";
    root.style.padding = "12px";
    root.style.boxSizing = "border-box";
    root.style.height = "100%";
    root.style.minHeight = "0";
    view.appendChild(root);
    const container = document.createElement("div");
    container.style.display = "grid";
    container.style.gap = "12px";
    container.style.width = "100%";
    container.style.maxWidth = "640px";
    container.style.height = "100%";
    container.style.maxHeight = "100%";
    container.style.minHeight = "0";
    container.style.gridTemplateRows = "max-content max-content max-content 1fr max-content";
    root.appendChild(container);
    const heading = document.createElement("div");
    heading.textContent = "Save your favourite rooms and access them quickly.";
    heading.style.fontSize = "14px";
    heading.style.opacity = "0.9";
    container.appendChild(heading);
    const manageCard = document.createElement("div");
    manageCard.style.display = "grid";
    manageCard.style.gap = "10px";
    manageCard.style.padding = "16px";
    manageCard.style.borderRadius = "12px";
    manageCard.style.background = "rgba(20, 22, 32, 0.95)";
    manageCard.style.boxShadow = "inset 0 0 0 1px rgba(255, 255, 255, 0.05)";
    container.appendChild(manageCard);
    const manageTitle = document.createElement("div");
    manageTitle.textContent = "Add a custom room";
    manageTitle.style.fontWeight = "600";
    manageTitle.style.fontSize = "14px";
    manageCard.appendChild(manageTitle);
    const manageForm = document.createElement("form");
    manageForm.style.display = "grid";
    manageForm.style.gap = "10px";
    manageCard.appendChild(manageForm);
    const fieldsRow = document.createElement("div");
    fieldsRow.style.display = "grid";
    fieldsRow.style.gap = "10px";
    fieldsRow.style.gridTemplateColumns = "minmax(180px, 1fr) minmax(160px, 1fr) auto";
    fieldsRow.style.alignItems = "center";
    manageForm.appendChild(fieldsRow);
    const nameInput = document.createElement("input");
    nameInput.type = "text";
    nameInput.placeholder = "Room name";
    nameInput.required = true;
    nameInput.style.background = "rgba(15, 16, 24, 0.95)";
    nameInput.style.border = "1px solid rgba(148, 163, 184, 0.25)";
    nameInput.style.borderRadius = "10px";
    nameInput.style.padding = "10px 12px";
    nameInput.style.fontSize = "13px";
    nameInput.style.color = "#f8fafc";
    nameInput.style.width = "100%";
    nameInput.autocomplete = "off";
    fieldsRow.appendChild(nameInput);
    const idInput = document.createElement("input");
    idInput.type = "text";
    idInput.placeholder = "Room code";
    idInput.required = true;
    idInput.style.background = "rgba(15, 16, 24, 0.95)";
    idInput.style.border = "1px solid rgba(148, 163, 184, 0.25)";
    idInput.style.borderRadius = "10px";
    idInput.style.padding = "10px 12px";
    idInput.style.fontSize = "13px";
    idInput.style.color = "#f8fafc";
    idInput.style.width = "100%";
    idInput.autocomplete = "off";
    fieldsRow.appendChild(idInput);
    const addBtn = ui.btn("Add room", { size: "sm", variant: "primary" });
    addBtn.type = "submit";
    addBtn.style.whiteSpace = "nowrap";
    fieldsRow.appendChild(addBtn);
    const formFeedback = document.createElement("div");
    formFeedback.style.fontSize = "12px";
    formFeedback.style.opacity = "0.85";
    formFeedback.style.minHeight = "16px";
    manageForm.appendChild(formFeedback);
    const hint = document.createElement("div");
    hint.textContent = "Custom rooms are stored locally in your browser.";
    hint.style.fontSize = "12px";
    hint.style.opacity = "0.65";
    manageCard.appendChild(hint);
    if (RoomService.isDiscordActivity()) {
      const discordWarning = document.createElement("div");
      discordWarning.textContent = "You are using Discord: direct join is disabled. Open the official website to join a room.";
      discordWarning.style.fontSize = "13px";
      discordWarning.style.lineHeight = "1.4";
      discordWarning.style.padding = "10px 12px";
      discordWarning.style.borderRadius = "8px";
      discordWarning.style.background = "#2e1f1f";
      discordWarning.style.color = "#ffb4a2";
      discordWarning.style.border = "1px solid rgba(255, 140, 105, 0.35)";
      container.appendChild(discordWarning);
    }
    const filterBar = document.createElement("div");
    filterBar.style.display = "flex";
    filterBar.style.flexWrap = "wrap";
    filterBar.style.alignItems = "center";
    filterBar.style.gap = "8px";
    filterBar.style.margin = "12px 0 6px";
    filterBar.style.width = "100%";
    container.appendChild(filterBar);
    const listWrapper = document.createElement("div");
    listWrapper.style.height = "36vh";
    listWrapper.style.maxHeight = "36vh";
    listWrapper.style.overflowY = "auto";
    listWrapper.style.padding = "6px 2px";
    listWrapper.style.borderRadius = "10px";
    listWrapper.style.background = "rgba(12, 13, 20, 0.65)";
    listWrapper.style.boxShadow = "inset 0 0 0 1px rgba(255, 255, 255, 0.04)";
    listWrapper.style.width = "100%";
    listWrapper.style.boxSizing = "border-box";
    listWrapper.style.position = "relative";
    const floatingLoadingIndicator = document.createElement("div");
    floatingLoadingIndicator.style.position = "absolute";
    floatingLoadingIndicator.style.top = "14px";
    floatingLoadingIndicator.style.right = "14px";
    floatingLoadingIndicator.style.width = "28px";
    floatingLoadingIndicator.style.height = "28px";
    floatingLoadingIndicator.style.borderRadius = "999px";
    floatingLoadingIndicator.style.display = "flex";
    floatingLoadingIndicator.style.alignItems = "center";
    floatingLoadingIndicator.style.justifyContent = "center";
    floatingLoadingIndicator.style.background = "rgba(14, 16, 25, 0.9)";
    floatingLoadingIndicator.style.border = "1px solid rgba(255, 255, 255, 0.08)";
    floatingLoadingIndicator.style.boxShadow = "0 10px 24px rgba(0, 0, 0, 0.45)";
    floatingLoadingIndicator.style.opacity = "0";
    floatingLoadingIndicator.style.visibility = "hidden";
    floatingLoadingIndicator.style.pointerEvents = "none";
    floatingLoadingIndicator.style.transition = "opacity 160ms ease, transform 160ms ease";
    floatingLoadingIndicator.style.zIndex = "3";
    const floatingLoadingSpinner = document.createElement("div");
    floatingLoadingSpinner.style.width = "16px";
    floatingLoadingSpinner.style.height = "16px";
    floatingLoadingSpinner.style.borderRadius = "999px";
    floatingLoadingSpinner.style.border = "2px solid rgba(248, 250, 252, 0.16)";
    floatingLoadingSpinner.style.borderTopColor = "#f8fafc";
    floatingLoadingSpinner.style.animation = "room-menu-spin 1s linear infinite";
    floatingLoadingIndicator.appendChild(floatingLoadingSpinner);
    const list = document.createElement("div");
    list.style.display = "grid";
    list.style.gap = "10px";
    list.style.padding = "4px";
    listWrapper.appendChild(list);
    listWrapper.appendChild(floatingLoadingIndicator);
    container.appendChild(listWrapper);
    const updateFloatingLoadingIndicator = () => {
      floatingLoadingIndicator.style.transform = `translateY(${listWrapper.scrollTop}px)`;
    };
    let isFloatingIndicatorVisible = false;
    const setLoadingState = (loading) => {
      if (loading) {
        isFloatingIndicatorVisible = true;
        updateFloatingLoadingIndicator();
        floatingLoadingIndicator.style.visibility = "visible";
        floatingLoadingIndicator.style.opacity = "1";
      } else {
        isFloatingIndicatorVisible = false;
        floatingLoadingIndicator.style.opacity = "0";
        floatingLoadingIndicator.addEventListener(
          "transitionend",
          () => {
            if (!isFloatingIndicatorVisible) {
              floatingLoadingIndicator.style.visibility = "hidden";
            }
          },
          { once: true }
        );
        window.setTimeout(() => {
          if (!isFloatingIndicatorVisible) {
            floatingLoadingIndicator.style.visibility = "hidden";
          }
        }, 220);
      }
    };
    const refreshButton = ui.btn("Refresh rooms", { size: "sm", icon: "\u{1F504}" });
    refreshButton.style.flexShrink = "0";
    refreshButton.setAttribute("aria-label", "Refresh custom rooms list");
    const statusBar = document.createElement("div");
    statusBar.style.fontSize = "12px";
    statusBar.style.opacity = "0.75";
    statusBar.textContent = "Add a custom room to get started.";
    const footer = document.createElement("div");
    footer.style.display = "flex";
    footer.style.alignItems = "center";
    footer.style.gap = "12px";
    footer.style.marginTop = "8px";
    footer.style.width = "100%";
    footer.appendChild(refreshButton);
    footer.appendChild(statusBar);
    container.appendChild(footer);
    let savedScrollTop = 0;
    listWrapper.addEventListener("scroll", () => {
      savedScrollTop = listWrapper.scrollTop;
      if (isFloatingIndicatorVisible) {
        updateFloatingLoadingIndicator();
      }
    });
    let destroyed = false;
    let requestCounter = 0;
    let firstLoad = true;
    let selectedCategory = null;
    let selectedPlayerFilter = "any";
    let currentRooms = [];
    const filterButtons = /* @__PURE__ */ new Map();
    const categoryButtonContainer = document.createElement("div");
    categoryButtonContainer.style.display = "flex";
    categoryButtonContainer.style.flexWrap = "wrap";
    categoryButtonContainer.style.alignItems = "center";
    categoryButtonContainer.style.gap = "8px";
    filterBar.appendChild(categoryButtonContainer);
    const updateFilterButtonStyles = () => {
      for (const [category, button] of filterButtons) {
        const isActive = category === selectedCategory;
        button.dataset.active = isActive ? "true" : "false";
        button.setAttribute("aria-pressed", isActive ? "true" : "false");
        button.style.opacity = isActive ? "1" : "0.7";
      }
    };
    const createFilterButton = (label2, category) => {
      const button = ui.btn(label2, { size: "sm", variant: "ghost" });
      button.addEventListener("click", () => {
        if (category === null) {
          setCategoryFilter(null);
        } else if (selectedCategory === category) {
          setCategoryFilter(null);
        } else {
          setCategoryFilter(category);
        }
      });
      filterButtons.set(category, button);
      categoryButtonContainer.appendChild(button);
    };
    const applyCategoryButtons = (definitions) => {
      const seen = /* @__PURE__ */ new Set();
      for (const room of definitions) {
        if (room.category) {
          seen.add(room.category);
        }
      }
      const categories = Array.from(seen);
      const preferredOrder = RoomService.getPublicRoomsCategoryOrder();
      if (preferredOrder.length) {
        const indexMap = new Map(preferredOrder.map((name, index) => [name, index]));
        categories.sort((a, b) => {
          const indexA = indexMap.get(a);
          const indexB = indexMap.get(b);
          if (indexA === void 0 && indexB === void 0) return a.localeCompare(b);
          if (indexA === void 0) return 1;
          if (indexB === void 0) return -1;
          return indexA - indexB;
        });
      } else {
        categories.sort((a, b) => a.localeCompare(b));
      }
      filterButtons.clear();
      categoryButtonContainer.innerHTML = "";
      createFilterButton("All", null);
      let selectedCategoryExists = selectedCategory === null;
      for (const category of categories) {
        createFilterButton(category, category);
        if (category === selectedCategory) {
          selectedCategoryExists = true;
        }
      }
      if (!selectedCategoryExists) {
        selectedCategory = null;
      }
      updateFilterButtonStyles();
    };
    const setCategoryFilter = (category) => {
      if (selectedCategory === category) return;
      selectedCategory = category;
      savedScrollTop = 0;
      updateFilterButtonStyles();
      renderRooms(currentRooms);
    };
    const matchesPlayerFilter = (room) => {
      switch (selectedPlayerFilter) {
        case "any":
          return true;
        case "empty":
          return room.players === 0;
        case "few":
          return room.players > 0 && room.players <= 3;
        case "crowded":
          return !room.isFull && room.players >= 4;
        case "full":
          return room.isFull;
        default:
          return true;
      }
    };
    const renderRooms = (rooms) => {
      currentRooms = rooms;
      list.innerHTML = "";
      const visibleRooms = rooms.filter((room) => {
        if (selectedCategory !== null && room.category !== selectedCategory) {
          return false;
        }
        if (!matchesPlayerFilter(room)) {
          return false;
        }
        return true;
      });
      if (!visibleRooms.length) {
        const empty = document.createElement("div");
        const hasDefinitions = RoomService.getCustomRooms().length > 0;
        empty.textContent = hasDefinitions ? "No rooms match the selected filter." : "No custom rooms yet. Add one above.";
        empty.style.padding = "16px";
        empty.style.textAlign = "center";
        empty.style.opacity = "0.7";
        list.appendChild(empty);
      } else {
        for (const room of visibleRooms) {
          const entry = createRoomEntry(room, ui, {
            onRemove: () => {
              if (!RoomService.removeCustomRoom(room.idRoom)) return;
              savedScrollTop = 0;
              handleRoomsChanged();
            }
          });
          list.appendChild(entry);
        }
      }
      requestAnimationFrame(() => {
        const maxScroll = Math.max(0, listWrapper.scrollHeight - listWrapper.clientHeight);
        const nextScroll = Math.min(savedScrollTop, maxScroll);
        listWrapper.scrollTop = nextScroll;
        savedScrollTop = nextScroll;
      });
    };
    const playerFilterContainer = document.createElement("div");
    playerFilterContainer.style.display = "flex";
    playerFilterContainer.style.alignItems = "center";
    playerFilterContainer.style.gap = "6px";
    playerFilterContainer.style.marginLeft = "auto";
    playerFilterContainer.style.padding = "4px 6px";
    playerFilterContainer.style.background = "rgba(24, 26, 36, 0.85)";
    playerFilterContainer.style.borderRadius = "10px";
    playerFilterContainer.style.boxShadow = "inset 0 0 0 1px rgba(255, 255, 255, 0.05)";
    const playerFilterLabel = document.createElement("span");
    playerFilterLabel.textContent = "Players";
    playerFilterLabel.style.fontSize = "12px";
    playerFilterLabel.style.opacity = "0.75";
    playerFilterLabel.style.paddingLeft = "2px";
    playerFilterContainer.appendChild(playerFilterLabel);
    const playerFilterSelect = document.createElement("select");
    playerFilterSelect.style.background = "rgba(17, 18, 27, 0.95)";
    playerFilterSelect.style.border = "1px solid rgba(255, 255, 255, 0.08)";
    playerFilterSelect.style.color = "#f8fafc";
    playerFilterSelect.style.borderRadius = "8px";
    playerFilterSelect.style.padding = "4px 10px";
    playerFilterSelect.style.fontSize = "12px";
    playerFilterSelect.style.fontWeight = "500";
    playerFilterSelect.style.outline = "none";
    playerFilterSelect.style.cursor = "pointer";
    playerFilterSelect.style.minWidth = "130px";
    const playerFilters = [
      { value: "any", label: "Any players" },
      { value: "empty", label: "Empty rooms" },
      { value: "few", label: "1 \u2013 3 players" },
      { value: "crowded", label: "4 \u2013 5 players" },
      { value: "full", label: "Full rooms" }
    ];
    for (const option of playerFilters) {
      const opt = document.createElement("option");
      opt.value = option.value;
      opt.textContent = option.label;
      playerFilterSelect.appendChild(opt);
    }
    playerFilterSelect.value = selectedPlayerFilter;
    playerFilterSelect.addEventListener("change", () => {
      selectedPlayerFilter = playerFilterSelect.value;
      savedScrollTop = 0;
      renderRooms(currentRooms);
    });
    playerFilterContainer.appendChild(playerFilterSelect);
    filterBar.appendChild(playerFilterContainer);
    let isRefreshing = false;
    const updateRefreshButtonState = () => {
      const enabled = !destroyed && !isRefreshing;
      ui.setButtonEnabled(refreshButton, enabled);
      refreshButton.setAttribute("aria-busy", isRefreshing ? "true" : "false");
    };
    updateRefreshButtonState();
    const handleRoomsChanged = () => {
      applyCategoryButtons(RoomService.getCustomRooms());
      refreshRooms();
    };
    const refreshRooms = async () => {
      if (destroyed) return;
      const definitions = RoomService.getCustomRooms();
      applyCategoryButtons(definitions);
      if (!definitions.length) {
        setLoadingState(false);
        currentRooms = [];
        renderRooms([]);
        statusBar.textContent = "Add a custom room to get started.";
        isRefreshing = false;
        updateRefreshButtonState();
        firstLoad = false;
        return;
      }
      const currentRequest = ++requestCounter;
      isRefreshing = true;
      updateRefreshButtonState();
      setLoadingState(true);
      statusBar.textContent = firstLoad ? "Loading rooms\u2026" : "Refreshing rooms\u2026";
      try {
        const rooms = await RoomService.fetchCustomRoomsStatus();
        if (destroyed || currentRequest !== requestCounter) return;
        renderRooms(rooms);
        const time = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
          hour: "2-digit",
          minute: "2-digit",
          hour12: true
        });
        statusBar.textContent = `Last update: ${time}`;
      } catch (error) {
        if (destroyed || currentRequest !== requestCounter) return;
        statusBar.textContent = `Failed to load rooms: ${String(error?.message || error)}`;
      } finally {
        if (!destroyed && currentRequest === requestCounter) {
          setLoadingState(false);
        }
        if (currentRequest === requestCounter) {
          isRefreshing = false;
        }
        updateRefreshButtonState();
        firstLoad = false;
      }
    };
    refreshButton.addEventListener("click", () => {
      void refreshRooms();
    });
    manageForm.addEventListener("submit", (event) => {
      event.preventDefault();
      const result = RoomService.addCustomRoom({ name: nameInput.value, idRoom: idInput.value });
      if (!result.ok) {
        formFeedback.textContent = result.error;
        formFeedback.style.color = "#fda4af";
        return;
      }
      formFeedback.textContent = `Added room \u201C${result.room.name}\u201D.`;
      formFeedback.style.color = "#86efac";
      nameInput.value = "";
      idInput.value = "";
      nameInput.focus();
      handleRoomsChanged();
    });
    applyCategoryButtons(RoomService.getCustomRooms());
    refreshRooms();
    view.__cleanup__ = () => {
      destroyed = true;
      updateRefreshButtonState();
    };
  }
  function renderSearchPlayerTab(view, ui) {
    view.innerHTML = "";
    ensureRoomMenuStyles();
    const root = document.createElement("div");
    root.style.display = "flex";
    root.style.flexDirection = "column";
    root.style.alignItems = "center";
    root.style.padding = "12px";
    root.style.boxSizing = "border-box";
    root.style.height = "100%";
    view.appendChild(root);
    const container = document.createElement("div");
    container.style.display = "grid";
    container.style.gap = "12px";
    container.style.width = "100%";
    container.style.maxWidth = "640px";
    container.style.gridTemplateRows = "max-content max-content max-content 1fr";
    container.style.height = "100%";
    root.appendChild(container);
    const heading = document.createElement("div");
    heading.textContent = "Search for a player across all available rooms.";
    heading.style.fontSize = "14px";
    heading.style.opacity = "0.9";
    container.appendChild(heading);
    const description = document.createElement("div");
    description.textContent = "Enter at least three characters to look for matching player names.";
    description.style.fontSize = "12px";
    description.style.opacity = "0.72";
    description.style.lineHeight = "1.45";
    container.appendChild(description);
    const form = document.createElement("form");
    form.style.display = "flex";
    form.style.flexWrap = "wrap";
    form.style.alignItems = "center";
    form.style.gap = "8px";
    container.appendChild(form);
    const searchInput = document.createElement("input");
    searchInput.type = "search";
    searchInput.placeholder = "Player name\u2026";
    searchInput.autocomplete = "off";
    searchInput.spellcheck = false;
    searchInput.style.flex = "1";
    searchInput.style.minWidth = "200px";
    searchInput.style.padding = "10px 12px";
    searchInput.style.borderRadius = "10px";
    searchInput.style.border = "1px solid rgba(255, 255, 255, 0.08)";
    searchInput.style.background = "rgba(17, 18, 27, 0.95)";
    searchInput.style.color = "#f8fafc";
    searchInput.style.fontSize = "13px";
    searchInput.style.fontWeight = "500";
    searchInput.style.outline = "none";
    searchInput.style.boxShadow = "0 6px 16px rgba(15, 23, 42, 0.45)";
    form.appendChild(searchInput);
    const searchButton = ui.btn("Search", { size: "sm", icon: "\u{1F50D}", variant: "primary" });
    searchButton.type = "submit";
    searchButton.style.flexShrink = "0";
    searchButton.title = "Search for a player across rooms";
    form.appendChild(searchButton);
    const statusMessage = document.createElement("div");
    statusMessage.style.fontSize = "12px";
    statusMessage.style.opacity = "0.75";
    statusMessage.style.minHeight = "18px";
    statusMessage.textContent = "Enter a player name to search across rooms.";
    container.appendChild(statusMessage);
    const listWrapper = document.createElement("div");
    listWrapper.style.height = "54vh";
    listWrapper.style.maxHeight = "54vh";
    listWrapper.style.overflowY = "auto";
    listWrapper.style.padding = "6px 2px";
    listWrapper.style.borderRadius = "10px";
    listWrapper.style.background = "rgba(12, 13, 20, 0.65)";
    listWrapper.style.boxShadow = "inset 0 0 0 1px rgba(255, 255, 255, 0.04)";
    listWrapper.style.width = "100%";
    listWrapper.style.boxSizing = "border-box";
    listWrapper.style.position = "relative";
    const floatingLoadingIndicator = document.createElement("div");
    floatingLoadingIndicator.style.position = "absolute";
    floatingLoadingIndicator.style.top = "14px";
    floatingLoadingIndicator.style.right = "14px";
    floatingLoadingIndicator.style.width = "28px";
    floatingLoadingIndicator.style.height = "28px";
    floatingLoadingIndicator.style.borderRadius = "999px";
    floatingLoadingIndicator.style.display = "flex";
    floatingLoadingIndicator.style.alignItems = "center";
    floatingLoadingIndicator.style.justifyContent = "center";
    floatingLoadingIndicator.style.background = "rgba(14, 16, 25, 0.9)";
    floatingLoadingIndicator.style.border = "1px solid rgba(255, 255, 255, 0.08)";
    floatingLoadingIndicator.style.boxShadow = "0 10px 24px rgba(0, 0, 0, 0.45)";
    floatingLoadingIndicator.style.opacity = "0";
    floatingLoadingIndicator.style.visibility = "hidden";
    floatingLoadingIndicator.style.pointerEvents = "none";
    floatingLoadingIndicator.style.transition = "opacity 160ms ease, transform 160ms ease";
    floatingLoadingIndicator.style.zIndex = "3";
    const floatingLoadingSpinner = document.createElement("div");
    floatingLoadingSpinner.style.width = "16px";
    floatingLoadingSpinner.style.height = "16px";
    floatingLoadingSpinner.style.borderRadius = "999px";
    floatingLoadingSpinner.style.border = "2px solid rgba(248, 250, 252, 0.16)";
    floatingLoadingSpinner.style.borderTopColor = "#f8fafc";
    floatingLoadingSpinner.style.animation = "room-menu-spin 1s linear infinite";
    floatingLoadingIndicator.appendChild(floatingLoadingSpinner);
    const list = document.createElement("div");
    list.style.display = "grid";
    list.style.gap = "10px";
    list.style.padding = "4px";
    listWrapper.appendChild(list);
    listWrapper.appendChild(floatingLoadingIndicator);
    container.appendChild(listWrapper);
    const renderEmptyState = (message) => {
      list.innerHTML = "";
      const empty = document.createElement("div");
      empty.textContent = message;
      empty.style.padding = "16px";
      empty.style.textAlign = "center";
      empty.style.opacity = "0.7";
      empty.style.fontSize = "13px";
      list.appendChild(empty);
    };
    renderEmptyState("Search results will appear here.");
    const updateFloatingLoadingIndicator = () => {
      floatingLoadingIndicator.style.transform = `translateY(${listWrapper.scrollTop}px)`;
    };
    let isFloatingIndicatorVisible = false;
    const setLoadingState = (loading) => {
      if (loading) {
        isFloatingIndicatorVisible = true;
        updateFloatingLoadingIndicator();
        floatingLoadingIndicator.style.visibility = "visible";
        floatingLoadingIndicator.style.opacity = "1";
      } else {
        isFloatingIndicatorVisible = false;
        floatingLoadingIndicator.style.opacity = "0";
        floatingLoadingIndicator.addEventListener(
          "transitionend",
          () => {
            if (!isFloatingIndicatorVisible) {
              floatingLoadingIndicator.style.visibility = "hidden";
            }
          },
          { once: true }
        );
        window.setTimeout(() => {
          if (!isFloatingIndicatorVisible) {
            floatingLoadingIndicator.style.visibility = "hidden";
          }
        }, 220);
      }
    };
    listWrapper.addEventListener("scroll", () => {
      if (isFloatingIndicatorVisible) {
        updateFloatingLoadingIndicator();
      }
    });
    let isLoading = false;
    let destroyed = false;
    let requestCounter = 0;
    let lastQueryLabel = "";
    const updateSearchButtonState = () => {
      const hasQuery = searchInput.value.trim().length >= 3;
      ui.setButtonEnabled(searchButton, hasQuery && !isLoading);
      searchButton.setAttribute("aria-busy", isLoading ? "true" : "false");
    };
    const normalizeSearchText = (value) => {
      const trimmed = value.trim();
      if (!trimmed) return "";
      try {
        return trimmed.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
      } catch {
        return trimmed.toLowerCase();
      }
    };
    const createHighlightMatcher = (players) => {
      const ids = /* @__PURE__ */ new Set();
      const databaseIds = /* @__PURE__ */ new Set();
      const names = /* @__PURE__ */ new Set();
      for (const player2 of players) {
        if (player2.id) ids.add(player2.id);
        if (player2.databaseUserId) databaseIds.add(player2.databaseUserId);
        names.add(normalizeSearchText(player2.name));
      }
      return (player2) => {
        if (player2.id && ids.has(player2.id)) return true;
        if (player2.databaseUserId && databaseIds.has(player2.databaseUserId)) return true;
        return names.has(normalizeSearchText(player2.name));
      };
    };
    const performSearch = async (rawQuery) => {
      const trimmedQuery = rawQuery.trim();
      const normalizedQuery = normalizeSearchText(trimmedQuery);
      if (!normalizedQuery) {
        statusMessage.textContent = "Enter a player name to search across rooms.";
        renderEmptyState("Search results will appear here.");
        lastQueryLabel = "";
        return;
      }
      if (trimmedQuery.length < 3) {
        statusMessage.textContent = "Please enter at least three characters.";
        renderEmptyState("Type a longer name to search for players.");
        lastQueryLabel = "";
        return;
      }
      const currentRequest = ++requestCounter;
      isLoading = true;
      updateSearchButtonState();
      setLoadingState(true);
      statusMessage.textContent = "Searching players\u2026";
      try {
        const [publicRooms, customRooms] = await Promise.all([
          RoomService.fetchPublicRoomsStatus(),
          RoomService.fetchCustomRoomsStatus().catch(() => [])
        ]);
        if (destroyed || currentRequest !== requestCounter) return;
        const allRooms = [...publicRooms, ...customRooms];
        const matchMap = /* @__PURE__ */ new Map();
        for (const room of allRooms) {
          const playerDetails = Array.isArray(room.playerDetails) ? room.playerDetails : [];
          if (!playerDetails.length) continue;
          const matchedPlayers = playerDetails.filter(
            (player2) => normalizeSearchText(player2.name).includes(normalizedQuery)
          );
          if (matchedPlayers.length) {
            const existing = matchMap.get(room.idRoom);
            if (existing) {
              for (const player2 of matchedPlayers) {
                const alreadyPresent = existing.players.some((candidate) => {
                  if (player2.id && candidate.id && player2.id === candidate.id) return true;
                  if (player2.databaseUserId && candidate.databaseUserId && player2.databaseUserId === candidate.databaseUserId) {
                    return true;
                  }
                  return normalizeSearchText(candidate.name) === normalizeSearchText(player2.name);
                });
                if (!alreadyPresent) {
                  existing.players.push(player2);
                }
              }
            } else {
              matchMap.set(room.idRoom, { room, players: [...matchedPlayers] });
            }
          }
        }
        const matches = Array.from(matchMap.values());
        if (!matches.length) {
          statusMessage.textContent = `No player found matching \u201C${trimmedQuery}\u201D.`;
          renderEmptyState("No rooms contain a player with this name.");
          lastQueryLabel = trimmedQuery;
          return;
        }
        matches.sort((a, b) => {
          const onlineInA = a.players.filter((player2) => player2.isConnected).length;
          const onlineInB = b.players.filter((player2) => player2.isConnected).length;
          if (onlineInA !== onlineInB) return onlineInB - onlineInA;
          if (a.players.length !== b.players.length) return b.players.length - a.players.length;
          return a.room.name.localeCompare(b.room.name);
        });
        const totalPlayers = matches.reduce((sum, match) => sum + match.players.length, 0);
        const roomsLabel = matches.length === 1 ? "room" : "rooms";
        const playersLabel = totalPlayers === 1 ? "player" : "players";
        statusMessage.textContent = `Found ${totalPlayers} ${playersLabel} in ${matches.length} ${roomsLabel}.`;
        list.innerHTML = "";
        let isFirstMatch = true;
        for (const match of matches) {
          const highlightMatcher = createHighlightMatcher(match.players);
          const entry = createRoomEntry(match.room, ui, {
            highlightPlayers: highlightMatcher,
            defaultDetailsOpen: true,
            scrollHighlightedPlayersIntoView: isFirstMatch
          });
          list.appendChild(entry);
          isFirstMatch = false;
        }
        lastQueryLabel = trimmedQuery;
      } catch (error) {
        if (destroyed || currentRequest !== requestCounter) return;
        const message = error?.message || String(error);
        statusMessage.textContent = `Search failed: ${message}`;
        renderEmptyState("Unable to complete the search. Please try again.");
      } finally {
        if (!destroyed && currentRequest === requestCounter) {
          isLoading = false;
          setLoadingState(false);
          updateSearchButtonState();
        }
      }
    };
    form.addEventListener("submit", (event) => {
      event.preventDefault();
      void performSearch(searchInput.value);
    });
    searchInput.addEventListener("input", () => {
      updateSearchButtonState();
      const trimmed = searchInput.value.trim();
      if (!trimmed && lastQueryLabel) {
        statusMessage.textContent = "Enter a player name to search across rooms.";
        renderEmptyState("Search results will appear here.");
        lastQueryLabel = "";
      } else if (!isLoading && trimmed.length > 0 && trimmed.length < 3) {
        statusMessage.textContent = "Type at least three characters to start a search.";
      }
    });
    updateSearchButtonState();
    view.__cleanup__ = () => {
      destroyed = true;
    };
  }
  function getCurrentRoomCode() {
    const match = /^\/r\/([^/]+)/.exec(location.pathname);
    if (!match) return null;
    try {
      return decodeURIComponent(match[1]);
    } catch {
      return match[1];
    }
  }
  function createRoomEntry(room, ui, options) {
    const isDiscord = RoomService.isDiscordActivity();
    const currentRoomCode = getCurrentRoomCode();
    const isCurrentRoom = currentRoomCode === room.idRoom;
    const playerDetails = Array.isArray(room.playerDetails) ? room.playerDetails : [];
    const wrapper = document.createElement("div");
    wrapper.style.display = "grid";
    wrapper.style.gap = "8px";
    wrapper.style.padding = "14px 16px";
    wrapper.style.borderRadius = "14px";
    wrapper.style.background = "linear-gradient(135deg, rgba(30, 33, 46, 0.95), rgba(18, 19, 28, 0.95))";
    wrapper.style.boxShadow = "0 10px 20px rgba(0, 0, 0, 0.35)";
    wrapper.style.position = "relative";
    const detailsContainer = document.createElement("div");
    detailsContainer.style.overflow = "hidden";
    detailsContainer.style.maxHeight = "0";
    detailsContainer.style.opacity = "0";
    detailsContainer.style.transition = "max-height 0.25s ease, opacity 0.2s ease, margin-top 0.2s ease";
    detailsContainer.style.marginTop = "0";
    const detailsContent = document.createElement("div");
    detailsContent.style.display = "grid";
    detailsContent.style.gap = "10px";
    detailsContent.style.paddingTop = "12px";
    detailsContent.style.paddingLeft = "6px";
    detailsContent.style.paddingRight = "6px";
    detailsContent.style.paddingBottom = "4px";
    detailsContent.style.borderTop = "1px solid rgba(148, 163, 184, 0.16)";
    detailsContainer.appendChild(detailsContent);
    const detailsTitle = document.createElement("div");
    detailsTitle.textContent = "Players";
    detailsTitle.style.fontSize = "13px";
    detailsTitle.style.fontWeight = "600";
    detailsTitle.style.letterSpacing = "0.02em";
    detailsTitle.style.color = "#e2e8f0";
    detailsContent.appendChild(detailsTitle);
    const highlightedPlayerElements = [];
    if (playerDetails.length) {
      const list = document.createElement("ul");
      list.style.listStyle = "none";
      list.style.margin = "0";
      list.style.padding = "0";
      list.style.display = "grid";
      list.style.gap = "10px";
      list.style.gridTemplateColumns = "repeat(2, minmax(0, 1fr))";
      for (const player2 of playerDetails) {
        const item = document.createElement("li");
        item.style.display = "flex";
        item.style.alignItems = "center";
        item.style.gap = "12px";
        item.style.padding = "6px 0";
        const avatarWrapper = document.createElement("div");
        avatarWrapper.style.width = "36px";
        avatarWrapper.style.height = "36px";
        avatarWrapper.style.borderRadius = "999px";
        avatarWrapper.style.overflow = "hidden";
        avatarWrapper.style.flexShrink = "0";
        avatarWrapper.style.display = "grid";
        avatarWrapper.style.placeItems = "center";
        avatarWrapper.style.border = "1px solid rgba(148, 163, 184, 0.25)";
        avatarWrapper.style.background = "linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(14, 165, 233, 0.2))";
        if (player2.discordAvatarUrl) {
          const img = document.createElement("img");
          img.src = player2.discordAvatarUrl;
          img.alt = `${player2.name}'s avatar`;
          img.loading = "lazy";
          img.style.width = "100%";
          img.style.height = "100%";
          img.style.objectFit = "cover";
          avatarWrapper.appendChild(img);
        } else {
          const initials = document.createElement("span");
          initials.textContent = player2.name.charAt(0)?.toUpperCase() || "?";
          initials.style.fontWeight = "600";
          initials.style.fontSize = "14px";
          initials.style.color = "#e2e8f0";
          avatarWrapper.appendChild(initials);
        }
        const playerInfo = document.createElement("div");
        playerInfo.style.display = "grid";
        playerInfo.style.gap = "4px";
        const nameRow2 = document.createElement("div");
        nameRow2.style.display = "flex";
        nameRow2.style.alignItems = "center";
        nameRow2.style.gap = "8px";
        const playerName = document.createElement("div");
        playerName.textContent = player2.name;
        playerName.style.fontWeight = "600";
        playerName.style.fontSize = "14px";
        playerName.style.color = "#f8fafc";
        nameRow2.appendChild(playerName);
        if (player2.isHost) {
          const hostBadge = document.createElement("span");
          hostBadge.textContent = "Host";
          hostBadge.style.fontSize = "10px";
          hostBadge.style.letterSpacing = "0.06em";
          hostBadge.style.textTransform = "uppercase";
          hostBadge.style.padding = "2px 6px";
          hostBadge.style.borderRadius = "999px";
          hostBadge.style.fontWeight = "600";
          hostBadge.style.color = "#facc15";
          hostBadge.style.background = "rgba(250, 204, 21, 0.18)";
          hostBadge.style.border = "1px solid rgba(250, 204, 21, 0.32)";
          nameRow2.appendChild(hostBadge);
        }
        const statusRow = document.createElement("div");
        statusRow.style.display = "flex";
        statusRow.style.alignItems = "center";
        statusRow.style.gap = "10px";
        statusRow.style.fontSize = "11px";
        statusRow.style.color = "rgba(226, 232, 240, 0.75)";
        const presence = document.createElement("span");
        presence.style.display = "inline-flex";
        presence.style.alignItems = "center";
        presence.style.gap = "6px";
        const presenceDot = document.createElement("span");
        presenceDot.style.width = "8px";
        presenceDot.style.height = "8px";
        presenceDot.style.borderRadius = "999px";
        presenceDot.style.background = player2.isConnected ? "#34d399" : "#f97316";
        presence.appendChild(presenceDot);
        presence.append(player2.isConnected ? "Online" : "Offline");
        statusRow.appendChild(presence);
        playerInfo.append(nameRow2, statusRow);
        item.append(avatarWrapper, playerInfo);
        if (options?.highlightPlayers?.(player2)) {
          item.style.background = "rgba(34, 197, 94, 0.12)";
          item.style.borderRadius = "12px";
          item.style.padding = "10px";
          item.style.margin = "-2px";
          item.style.boxShadow = "inset 0 0 0 1px rgba(34, 197, 94, 0.35)";
          avatarWrapper.style.border = "1px solid rgba(74, 222, 128, 0.65)";
          playerName.style.color = "#bbf7d0";
          statusRow.style.color = "rgba(190, 242, 100, 0.85)";
          presenceDot.style.background = "#4ade80";
          item.dataset.highlightedPlayer = "true";
          highlightedPlayerElements.push(item);
        }
        list.appendChild(item);
      }
      detailsContent.appendChild(list);
    } else {
      const emptyState = document.createElement("div");
      emptyState.textContent = room.error ? "Player details unavailable." : "No player details available.";
      emptyState.style.fontSize = "12px";
      emptyState.style.color = "rgba(226, 232, 240, 0.7)";
      detailsContent.appendChild(emptyState);
    }
    const accentColor = (() => {
      if (room.error) return "rgba(248, 180, 127, 0.9)";
      if (room.isFull) return "rgba(248, 113, 113, 0.85)";
      if (room.players <= 5) return "rgba(74, 222, 128, 0.75)";
      return "rgba(96, 165, 250, 0.45)";
    })();
    wrapper.style.setProperty("--accent-color", accentColor);
    wrapper.style.outline = "2px solid transparent";
    wrapper.style.outlineOffset = "0";
    wrapper.style.border = "1px solid rgba(255, 255, 255, 0.05)";
    wrapper.style.boxShadow = "0 10px 20px rgba(0, 0, 0, 0.35), inset 0 0 0 1px rgba(255, 255, 255, 0.04), 0 0 0 2px var(--accent-color)";
    const header = document.createElement("div");
    header.style.display = "flex";
    header.style.flexWrap = "wrap";
    header.style.alignItems = "center";
    header.style.justifyContent = "space-between";
    header.style.gap = "12px";
    const nameBlock = document.createElement("div");
    nameBlock.style.display = "grid";
    nameBlock.style.gap = "6px";
    const nameRow = document.createElement("div");
    nameRow.style.display = "flex";
    nameRow.style.alignItems = "center";
    nameRow.style.gap = "10px";
    const name = document.createElement("div");
    name.textContent = room.name;
    name.style.fontWeight = "600";
    name.style.fontSize = "16px";
    name.style.letterSpacing = "0.01em";
    name.style.color = "#f8fafc";
    const categoryPill = document.createElement("span");
    categoryPill.textContent = room.category;
    categoryPill.style.fontSize = "11px";
    categoryPill.style.letterSpacing = "0.08em";
    categoryPill.style.textTransform = "uppercase";
    categoryPill.style.padding = "4px 8px";
    categoryPill.style.borderRadius = "999px";
    categoryPill.style.background = "rgba(148, 163, 184, 0.12)";
    categoryPill.style.border = "1px solid rgba(148, 163, 184, 0.22)";
    categoryPill.style.color = "#cbd5f5";
    nameRow.append(name, categoryPill);
    nameBlock.appendChild(nameRow);
    if (room.currentGame && room.currentGame.toLowerCase() !== "quinoa") {
      const gameLabel = document.createElement("div");
      gameLabel.textContent = room.currentGame;
      gameLabel.style.fontSize = "12px";
      gameLabel.style.opacity = "0.7";
      gameLabel.style.color = "#e0f2fe";
      nameBlock.appendChild(gameLabel);
    }
    const occupancyBlock = document.createElement("div");
    occupancyBlock.style.display = "grid";
    occupancyBlock.style.gap = "6px";
    occupancyBlock.style.minWidth = "120px";
    const meter = document.createElement("div");
    meter.style.position = "relative";
    meter.style.height = "20px";
    meter.style.borderRadius = "999px";
    meter.style.background = "rgba(255, 255, 255, 0.08)";
    meter.style.overflow = "hidden";
    meter.style.display = "flex";
    meter.style.alignItems = "center";
    meter.style.justifyContent = "center";
    meter.style.fontWeight = "600";
    meter.style.fontSize = "12px";
    meter.style.color = "#f8fafc";
    meter.style.fontVariantNumeric = "tabular-nums";
    meter.style.textShadow = "0 1px 2px rgba(0, 0, 0, 0.55)";
    const meterFill = document.createElement("div");
    meterFill.style.position = "absolute";
    meterFill.style.left = "0";
    meterFill.style.top = "0";
    meterFill.style.bottom = "0";
    meterFill.style.height = "100%";
    meterFill.style.width = `${Math.min(100, room.players / room.capacity * 100)}%`;
    meterFill.style.background = room.isFull ? "linear-gradient(90deg, #ef4444, #f87171)" : "linear-gradient(90deg, #34d399, #2dd4bf)";
    meterFill.style.borderRadius = "inherit";
    meter.appendChild(meterFill);
    const meterLabel = document.createElement("span");
    meterLabel.textContent = `${room.players} / ${room.capacity} players`;
    meterLabel.style.position = "relative";
    meterLabel.style.zIndex = "1";
    meter.appendChild(meterLabel);
    occupancyBlock.appendChild(meter);
    const actionBlock = document.createElement("div");
    actionBlock.style.display = "grid";
    actionBlock.style.justifyItems = "end";
    actionBlock.style.gap = "6px";
    const chevron = document.createElement("span");
    chevron.textContent = "\u25BE";
    chevron.style.display = "inline-block";
    chevron.style.transition = "transform 0.2s ease";
    chevron.style.transform = "rotate(-90deg)";
    const detailsBtn = ui.btn("Details", { size: "sm", variant: "ghost", icon: chevron });
    detailsBtn.style.minWidth = "86px";
    detailsBtn.style.justifyContent = "center";
    detailsBtn.title = playerDetails.length ? "Show the players currently in this room." : room.error ? "Player details unavailable." : "No player details available.";
    actionBlock.appendChild(detailsBtn);
    const joinBtn = ui.btn("Join", { size: "sm", variant: "primary" });
    joinBtn.style.minWidth = "86px";
    joinBtn.style.boxShadow = "0 4px 10px rgba(56, 189, 248, 0.35)";
    actionBlock.appendChild(joinBtn);
    if (options?.onRemove) {
      const removeBtn = ui.btn("Remove", { size: "sm", variant: "danger" });
      removeBtn.style.minWidth = "86px";
      removeBtn.addEventListener("click", (event) => {
        event.stopPropagation();
        options.onRemove?.();
      });
      removeBtn.title = `Remove ${room.name} from custom rooms`;
      actionBlock.appendChild(removeBtn);
    }
    const reasons = [];
    if (room.error) reasons.push("Status unavailable");
    if (room.isFull) reasons.push("Room is full");
    if (isDiscord) reasons.push("Join is blocked on Discord");
    if (isCurrentRoom) reasons.push("Already in this room");
    const canJoin = !isCurrentRoom && RoomService.canJoinPublicRoom(room);
    ui.setButtonEnabled(joinBtn, canJoin);
    joinBtn.title = canJoin ? `Join ${room.name}` : reasons.join(" \xB7 ");
    joinBtn.addEventListener("click", () => {
      if (isCurrentRoom) return;
      if (!RoomService.canJoinPublicRoom(room)) return;
      RoomService.joinPublicRoom(room);
    });
    const labelSpan = detailsBtn.querySelector(".label");
    let detailsExpanded = options?.defaultDetailsOpen ?? false;
    const applyDetailsState = () => {
      if (detailsExpanded) {
        const targetHeight = `${detailsContent.scrollHeight}px`;
        detailsContainer.style.maxHeight = targetHeight;
        detailsContainer.style.opacity = "1";
        detailsContainer.style.marginTop = "8px";
        detailsBtn.setAttribute("aria-expanded", "true");
        if (labelSpan) labelSpan.textContent = "Hide details";
        chevron.style.transform = "rotate(0deg)";
      } else {
        detailsContainer.style.maxHeight = "0";
        detailsContainer.style.opacity = "0";
        detailsContainer.style.marginTop = "0";
        detailsBtn.setAttribute("aria-expanded", "false");
        if (labelSpan) labelSpan.textContent = "Details";
        chevron.style.transform = "rotate(-90deg)";
      }
    };
    detailsBtn.addEventListener("click", () => {
      detailsExpanded = !detailsExpanded;
      applyDetailsState();
    });
    header.append(nameBlock, occupancyBlock, actionBlock);
    wrapper.appendChild(header);
    const badgeRow = document.createElement("div");
    badgeRow.style.display = "flex";
    badgeRow.style.flexWrap = "wrap";
    badgeRow.style.gap = "6px";
    const addBadge = (label2, color, background) => {
      const badge = document.createElement("span");
      badge.textContent = label2;
      badge.style.fontSize = "11px";
      badge.style.padding = "4px 8px";
      badge.style.borderRadius = "999px";
      badge.style.fontWeight = "600";
      badge.style.letterSpacing = "0.04em";
      badge.style.textTransform = "uppercase";
      badge.style.color = color;
      badge.style.background = background;
      badge.style.border = `1px solid ${color}33`;
      badgeRow.appendChild(badge);
    };
    if (isCurrentRoom) {
      addBadge("Current room", "#86efac", "rgba(34, 197, 94, 0.12)");
    }
    if (room.error) {
      addBadge("Status unavailable", "#fbbf24", "rgba(250, 204, 21, 0.1)");
    }
    if (isDiscord) {
      addBadge("Discord activity", "#facc15", "rgba(251, 191, 36, 0.12)");
    }
    if (badgeRow.childElementCount > 0) {
      wrapper.appendChild(badgeRow);
    }
    wrapper.appendChild(detailsContainer);
    applyDetailsState();
    if (detailsExpanded || options?.scrollHighlightedPlayersIntoView) {
      window.requestAnimationFrame(() => {
        if (!detailsExpanded) return;
        applyDetailsState();
        if (options?.scrollHighlightedPlayersIntoView && highlightedPlayerElements.length) {
          const target = highlightedPlayerElements[0];
          window.requestAnimationFrame(() => {
            target.scrollIntoView({ block: "nearest", behavior: "smooth" });
          });
        }
      });
    }
    return wrapper;
  }

  // src/ui/menus/keybinds.ts
  function createKeybindRow(ui, action2) {
    const controls = document.createElement("div");
    controls.style.display = "flex";
    controls.style.alignItems = "center";
    controls.style.flexWrap = "nowrap";
    controls.style.gap = "8px";
    const button = ui.hotkeyButton(
      getKeybind(action2.id),
      (hk) => setKeybind(action2.id, hk),
      {
        emptyLabel: "Unassigned",
        listeningLabel: "Press a key\u2026",
        clearable: true,
        allowModifierOnly: action2.allowModifierOnly
      }
    );
    button.style.flexShrink = "0";
    controls.appendChild(button);
    let detachHoldListener = null;
    if (action2.holdDetection) {
      if (action2.id === "game.action") {
        const holdContainer = document.createElement("div");
        holdContainer.style.display = "flex";
        holdContainer.style.flexDirection = "column";
        holdContainer.style.alignItems = "center";
        holdContainer.style.gap = "4px";
        holdContainer.style.flex = "0 1 160px";
        holdContainer.style.alignSelf = "center";
        const holdButton = ui.btn("Hold", { size: "sm", variant: "secondary" });
        holdButton.style.display = "inline-flex";
        holdButton.style.alignItems = "center";
        holdButton.style.gap = "6px";
        holdButton.setAttribute("aria-label", action2.holdDetection.label);
        holdButton.title = action2.holdDetection.label;
        const holdIndicator = document.createElement("span");
        holdIndicator.textContent = "\u25CF";
        holdIndicator.style.fontSize = "10px";
        holdIndicator.style.lineHeight = "1";
        holdIndicator.setAttribute("aria-hidden", "true");
        const holdText = document.createElement("span");
        holdText.textContent = "Hold";
        holdButton.replaceChildren(holdIndicator, holdText);
        let holdEnabled = getKeybindHoldDetection(action2.id);
        const updateHoldButton = (enabled) => {
          holdEnabled = enabled;
          holdButton.setAttribute("aria-pressed", enabled ? "true" : "false");
          holdIndicator.style.color = enabled ? "#34c759" : "#ff3b30";
        };
        updateHoldButton(holdEnabled);
        holdButton.addEventListener("click", () => {
          setKeybindHoldDetection(action2.id, !holdEnabled);
        });
        detachHoldListener = onKeybindHoldDetectionChange(action2.id, (enabled) => {
          updateHoldButton(enabled);
        });
        holdContainer.appendChild(holdButton);
        if (action2.holdDetection.description) {
          const holdDesc = document.createElement("div");
          holdDesc.textContent = action2.holdDetection.description;
          holdDesc.style.fontSize = "11px";
          holdDesc.style.opacity = "0.65";
          holdDesc.style.maxWidth = "100%";
          holdDesc.style.textAlign = "center";
          holdContainer.appendChild(holdDesc);
        }
        controls.appendChild(holdContainer);
      } else {
        const holdContainer = document.createElement("div");
        holdContainer.style.display = "flex";
        holdContainer.style.flexDirection = "column";
        holdContainer.style.alignItems = "flex-start";
        holdContainer.style.gap = "2px";
        holdContainer.style.padding = "2px 4px";
        holdContainer.style.borderRadius = "8px";
        holdContainer.style.background = "rgba(255, 255, 255, 0.04)";
        holdContainer.style.flex = "0 1 180px";
        holdContainer.style.maxWidth = "180px";
        const holdLabel = document.createElement("label");
        holdLabel.style.display = "inline-flex";
        holdLabel.style.alignItems = "center";
        holdLabel.style.gap = "6px";
        holdLabel.style.fontSize = "12px";
        holdLabel.style.cursor = "pointer";
        const holdToggle = ui.switch(getKeybindHoldDetection(action2.id));
        holdToggle.style.margin = "0";
        holdToggle.setAttribute("aria-label", action2.holdDetection.label);
        const holdText = document.createElement("span");
        holdText.textContent = action2.holdDetection.label;
        holdText.style.opacity = "0.85";
        holdLabel.append(holdToggle, holdText);
        holdContainer.appendChild(holdLabel);
        if (action2.holdDetection.description) {
          const holdDesc = document.createElement("div");
          holdDesc.textContent = action2.holdDetection.description;
          holdDesc.style.fontSize = "11px";
          holdDesc.style.opacity = "0.65";
          holdDesc.style.maxWidth = "100%";
          holdContainer.appendChild(holdDesc);
        }
        holdToggle.addEventListener("change", () => {
          setKeybindHoldDetection(action2.id, holdToggle.checked);
        });
        detachHoldListener = onKeybindHoldDetectionChange(action2.id, (enabled) => {
          holdToggle.checked = enabled;
        });
        controls.appendChild(holdContainer);
      }
    }
    const actionsWrap = document.createElement("div");
    actionsWrap.style.display = "flex";
    actionsWrap.style.alignItems = "center";
    actionsWrap.style.gap = "4px";
    actionsWrap.style.marginLeft = "auto";
    const clearBtn = action2.sectionId === "game" ? null : ui.btn("", {
      icon: "\u{1F5D1}\uFE0F",
      variant: "danger",
      size: "sm",
      tooltip: "Remove this shortcut",
      ariaLabel: "Remove keybind"
    });
    if (clearBtn) {
      actionsWrap.appendChild(clearBtn);
    }
    const defaultHotkey = getDefaultKeybind(action2.id);
    const defaultString = hotkeyToString(defaultHotkey);
    let resetBtn = null;
    if (defaultHotkey) {
      resetBtn = ui.btn("", {
        icon: "\u{1F504}",
        variant: "primary",
        size: "sm",
        tooltip: "Restore default shortcut",
        ariaLabel: "Reset keybind to default"
      });
      actionsWrap.appendChild(resetBtn);
    }
    const setButtonEnabled = (btn, enabled) => {
      if (!btn) return;
      const setter = btn.setEnabled;
      if (setter) {
        setter(enabled);
      } else {
        btn.disabled = !enabled;
        btn.classList.toggle("is-disabled", !enabled);
        btn.setAttribute("aria-disabled", (!enabled).toString());
      }
    };
    const updateButtons = (current) => {
      const hasHotkey = hotkeyToString(current).length > 0;
      if (clearBtn) {
        setButtonEnabled(clearBtn, hasHotkey);
      }
      if (resetBtn) {
        const isDefault = hotkeyToString(current) === defaultString;
        setButtonEnabled(resetBtn, !isDefault);
      }
    };
    if (clearBtn) {
      clearBtn.addEventListener("click", () => {
        setKeybind(action2.id, null);
        const refreshed = getKeybind(action2.id);
        button.refreshHotkey(refreshed);
        updateButtons(refreshed);
      });
    }
    if (resetBtn) {
      resetBtn.addEventListener("click", () => {
        resetKeybind(action2.id);
        const refreshed = getKeybind(action2.id);
        button.refreshHotkey(refreshed);
        updateButtons(refreshed);
      });
    }
    controls.appendChild(actionsWrap);
    updateButtons(getKeybind(action2.id));
    const stop = onKeybindChange(action2.id, (hk) => {
      button.refreshHotkey(hk);
      updateButtons(hk);
    });
    ui.on("unmounted", stop);
    if (detachHoldListener) ui.on("unmounted", detachHoldListener);
    const row = ui.formRow(action2.label, controls, { labelWidth: "180px" });
    row.label.style.fontSize = "13px";
    row.label.style.opacity = "0.92";
    if (action2.hint) {
      const hintEl = document.createElement("div");
      hintEl.textContent = action2.hint;
      hintEl.style.fontSize = "11px";
      hintEl.style.opacity = "0.7";
      hintEl.style.marginTop = "2px";
      hintEl.style.gridColumn = "2 / 3";
      row.root.appendChild(hintEl);
    }
    return row.root;
  }
  async function renderKeybindsMenu(container) {
    const ui = new Menu({ id: "keybinds", compact: true });
    ui.mount(container);
    const view = ui.root.querySelector(".qmm-views");
    view.innerHTML = "";
    view.style.display = "flex";
    view.style.flexDirection = "column";
    view.style.gap = "12px";
    view.style.padding = "8px";
    view.style.maxHeight = "60vh";
    view.style.overflowY = "auto";
    const wrapper = document.createElement("div");
    wrapper.style.display = "grid";
    wrapper.style.gap = "12px";
    wrapper.style.width = "100%";
    wrapper.style.maxWidth = "720px";
    wrapper.style.margin = "0 auto";
    for (const section of getKeybindSections()) {
      const card = ui.card(`${section.icon} ${section.title}`, { tone: "muted", align: "stretch" });
      card.root.dataset.section = section.id;
      card.body.style.display = "flex";
      card.body.style.flexDirection = "column";
      card.body.style.gap = "10px";
      const desc = document.createElement("p");
      desc.textContent = section.description;
      desc.style.margin = "0";
      desc.style.fontSize = "12px";
      desc.style.opacity = "0.78";
      card.body.appendChild(desc);
      for (const action2 of section.actions) {
        const row = createKeybindRow(ui, action2);
        card.body.appendChild(row);
      }
      wrapper.appendChild(card.root);
    }
    view.appendChild(wrapper);
  }

  // src/utils/antiafk.ts
  function createAntiAfkController(deps) {
    const STOP_EVENTS = ["visibilitychange", "blur", "focus", "focusout", "pagehide", "freeze", "resume"];
    const listeners4 = [];
    function swallowAll() {
      const add = (target, t) => {
        const h = (e) => {
          e.stopImmediatePropagation();
          e.preventDefault?.();
        };
        target.addEventListener(t, h, { capture: true });
        listeners4.push({ t, h, target });
      };
      STOP_EVENTS.forEach((t) => {
        add(document, t);
        add(window, t);
      });
    }
    function unswallowAll() {
      for (const { t, h, target } of listeners4) try {
        target.removeEventListener(t, h, { capture: true });
      } catch {
      }
      listeners4.length = 0;
    }
    const docProto = Object.getPrototypeOf(document);
    const saved = {
      hidden: Object.getOwnPropertyDescriptor(docProto, "hidden"),
      visibilityState: Object.getOwnPropertyDescriptor(docProto, "visibilityState"),
      hasFocus: document.hasFocus ? document.hasFocus.bind(document) : null
    };
    function patchProps() {
      try {
        Object.defineProperty(docProto, "hidden", { configurable: true, get() {
          return false;
        } });
      } catch {
      }
      try {
        Object.defineProperty(docProto, "visibilityState", { configurable: true, get() {
          return "visible";
        } });
      } catch {
      }
      try {
        document.hasFocus = () => true;
      } catch {
      }
    }
    function restoreProps() {
      try {
        if (saved.hidden) Object.defineProperty(docProto, "hidden", saved.hidden);
      } catch {
      }
      try {
        if (saved.visibilityState) Object.defineProperty(docProto, "visibilityState", saved.visibilityState);
      } catch {
      }
      try {
        if (saved.hasFocus) document.hasFocus = saved.hasFocus;
      } catch {
      }
    }
    let audioCtx = null;
    let osc = null;
    let gain = null;
    const resumeIfSuspended = () => {
      if (audioCtx && audioCtx.state !== "running") audioCtx.resume?.().catch(() => {
      });
    };
    function startAudioKeepAlive() {
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: "interactive" });
        gain = audioCtx.createGain();
        gain.gain.value = 1e-5;
        osc = audioCtx.createOscillator();
        osc.frequency.value = 1;
        osc.connect(gain).connect(audioCtx.destination);
        osc.start();
        document.addEventListener("visibilitychange", resumeIfSuspended, { capture: true });
        window.addEventListener("focus", resumeIfSuspended, { capture: true });
      } catch {
        stopAudioKeepAlive();
      }
    }
    function stopAudioKeepAlive() {
      try {
        osc?.stop();
      } catch {
      }
      try {
        osc?.disconnect();
        gain?.disconnect();
      } catch {
      }
      try {
        audioCtx?.close?.();
      } catch {
      }
      document.removeEventListener("visibilitychange", resumeIfSuspended, { capture: true });
      window.removeEventListener("focus", resumeIfSuspended, { capture: true });
      osc = null;
      gain = null;
      audioCtx = null;
    }
    let hb = null;
    function startHeartbeat() {
      const targetEl = document.querySelector("canvas") || document.body || document.documentElement;
      hb = window.setInterval(() => {
        try {
          targetEl.dispatchEvent(new MouseEvent("mousemove", { bubbles: true, clientX: 1, clientY: 1 }));
        } catch {
        }
      }, 25e3);
    }
    function stopHeartbeat() {
      if (hb !== null) {
        clearInterval(hb);
        hb = null;
      }
    }
    let pingTimer = null;
    async function pingPosition() {
      try {
        const cur = await deps.getPosition();
        if (!cur) return;
        await deps.move(Math.round(cur.x), Math.round(cur.y));
      } catch {
      }
    }
    function startPing() {
      pingTimer = window.setInterval(pingPosition, 6e4);
      void pingPosition();
    }
    function stopPing() {
      if (pingTimer !== null) {
        clearInterval(pingTimer);
        pingTimer = null;
      }
    }
    return {
      start() {
        patchProps();
        swallowAll();
        startAudioKeepAlive();
        startHeartbeat();
        startPing();
      },
      stop() {
        stopPing();
        stopHeartbeat();
        stopAudioKeepAlive();
        unswallowAll();
        restoreProps();
      }
    };
  }

  // src/main.ts
  (async function() {
    "use strict";
    initSprites({
      config: {
        blackBelow: 10,
        skipAlphaBelow: 1,
        tolerance: 5e-3
      },
      onAsset: (url, kind) => {
        window.dispatchEvent(new CustomEvent("mg:sprite-detected", { detail: { url, kind } }));
      }
    });
    installPageWebSocketHook();
    mountHUD({
      onRegister(register) {
        register("players", "\u{1F465} Players", renderPlayersMenu);
        register("pets", "\u{1F43E} Pets", renderPetsMenu);
        register("room", "\u{1F3E0} Room", renderRoomMenu);
        register("locker", "\u{1F512} Locker", renderLockerMenu);
        register("alerts", "\u{1F514} Alerts", renderNotifierMenu);
        register("calculator", "\u{1F913} Calculator", renderCalculatorMenu);
        register("stats", "\u{1F4CA} Stats", renderStatsMenu);
        register("misc", "\u{1F9E9} Misc", renderMiscMenu);
        register("keybinds", "\u2328\uFE0F Keybinds", renderKeybindsMenu);
        register("tools", "\u{1F6E0}\uFE0F Tools", renderToolsMenu);
        register("debug-data", "\u{1F527} Debug", renderDebugDataMenu);
      }
    });
    initWatchers();
    const antiAfk = createAntiAfkController({
      getPosition: () => PlayerService.getPosition(),
      move: (x, y) => PlayerService.move(x, y)
    });
    antiAfk.start();
  })();
})();
