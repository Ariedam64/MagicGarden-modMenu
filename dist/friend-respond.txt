import { createClient } from "npm:@supabase/supabase-js@2";

const supabaseUrl = Deno.env.get("SUPABASE_URL") ?? "";
const serviceRoleKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "";

if (!supabaseUrl || !serviceRoleKey) {
  console.error("Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY");
}

const supabase = createClient(supabaseUrl, serviceRoleKey);

Deno.serve(async (req: Request): Promise<Response> => {
  if (req.method !== "POST") {
    return new Response("Method not allowed", { status: 405 });
  }

  const ipHeader = req.headers.get("x-forwarded-for") ?? "";
  const ip = ipHeader.split(",")[0].trim() || null;

  let body: any;
  try {
    body = await req.json();
  } catch {
    return new Response("Invalid JSON", { status: 400 });
  }

  const { playerId, otherPlayerId, action } = body ?? {};

  if (
    typeof playerId !== "string" ||
    typeof otherPlayerId !== "string" ||
    playerId.length < 3 ||
    otherPlayerId.length < 3
  ) {
    return new Response("Invalid player ids", { status: 400 });
  }

  if (playerId === otherPlayerId) {
    return new Response("Invalid self relation", { status: 400 });
  }

  if (action !== "accept" && action !== "reject") {
    return new Response("Invalid action", { status: 400 });
  }

  // Rate limit basé sur IP + playerId (celui qui répond)
  const { data: allowed, error: rateError } = await supabase.rpc(
    "check_rate_limit",
    {
      p_ip: ip,
      p_player_id: playerId,
    },
  );

  if (rateError) {
    console.error("rate limit error:", rateError);
    return new Response("Rate limiter error", { status: 500 });
  }

  if (allowed === false) {
    return new Response("Too many requests", { status: 429 });
  }

  // normaliser la paire
  const [userOneId, userTwoId] =
    playerId < otherPlayerId
      ? [playerId, otherPlayerId]
      : [otherPlayerId, playerId];

  const { data: rel, error: relError } = await supabase
    .from("player_relationships")
    .select("status, requested_by")
    .eq("user_one_id", userOneId)
    .eq("user_two_id", userTwoId)
    .maybeSingle();

  if (relError) {
    console.error("relationship fetch error:", relError);
    return new Response("DB error (relationship fetch)", { status: 500 });
  }

  if (!rel) {
    return new Response("No relationship found", { status: 404 });
  }

  if (rel.status !== "pending") {
    return new Response("Request is not pending", { status: 409 });
  }

  // Vérifier que ce n'est pas l'émetteur qui essaie de "répondre" à sa propre demande
  if (rel.requested_by === playerId) {
    return new Response("Requester cannot respond to own request", {
      status: 403,
    });
  }

  const newStatus = action === "accept" ? "accepted" : "rejected";

  const { error: updateError } = await supabase
    .from("player_relationships")
    .update({
      status: newStatus,
      updated_at: new Date().toISOString(),
    })
    .eq("user_one_id", userOneId)
    .eq("user_two_id", userTwoId);

  if (updateError) {
    console.error("relationship update error:", updateError);
    return new Response("DB error (relationship update)", { status: 500 });
  }

  return new Response(null, { status: 204 });
});
