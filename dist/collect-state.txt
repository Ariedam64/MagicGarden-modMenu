import { createClient } from "npm:@supabase/supabase-js@2";

const supabaseUrl = Deno.env.get("SUPABASE_URL") ?? "";
const serviceRoleKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "";

if (!supabaseUrl || !serviceRoleKey) {
  console.error("Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY");
}

const supabase = createClient(supabaseUrl, serviceRoleKey);

Deno.serve(async (req: Request): Promise<Response> => {
  if (req.method !== "POST") {
    return new Response("Method not allowed", { status: 405 });
  }

  const ipHeader = req.headers.get("x-forwarded-for") ?? "";
  const ip = ipHeader.split(",")[0].trim() || null;

  let body: any;
  try {
    body = await req.json();
  } catch {
    return new Response("Invalid JSON", { status: 400 });
  }

  const {
    playerId,
    playerName,
    avatarUrl,
    coins,
    room,
    state,
    privacy,
  } = body ?? {};

  // Validation minimale
  if (typeof playerId !== "string" || playerId.length < 3) {
    return new Response("Invalid playerId", { status: 400 });
  }

  // Rate limit (IP + playerId)
  const { data: allowed, error: rateError } = await supabase.rpc(
    "check_rate_limit",
    {
      p_ip: ip,
      p_player_id: playerId,
    },
  );

  if (rateError) {
    console.error("rate limit error:", rateError);
    return new Response("Rate limiter error", { status: 500 });
  }

  if (allowed === false) {
    return new Response("Too many requests", { status: 429 });
  }

  const now = new Date().toISOString();

  const normalizedPrivacy =
    privacy && typeof privacy === "object" ? privacy : null;

  // 1) players : joueur local
  {
    const { error } = await supabase.from("players").upsert(
      {
        id: playerId,
        name:
          typeof playerName === "string" && playerName.length > 0
            ? playerName
            : playerId,
        avatar_url: typeof avatarUrl === "string" ? avatarUrl : null,
        coins: typeof coins === "number" ? coins : 0,
        last_event_at: now,
        has_mod_installed: true,
      },
      { onConflict: "id" },
    );

    if (error) {
      console.error("players upsert error:", error);
      return new Response("DB error (players)", { status: 500 });
    }
  }

  // 1bis) player_privacy (table séparée)
  if (normalizedPrivacy) {
    const {
      showProfile,
      showGarden,
      showInventory,
      showCoins,
      showActivityLog,
      showJournal,
      showStats,
      hideRoomFromPublicList,
    } = normalizedPrivacy as any;

    const { error: privError } = await supabase.from("player_privacy").upsert(
      {
        player_id: playerId,
        show_profile:
          typeof showProfile === "boolean" ? showProfile : null,
        show_garden:
          typeof showGarden === "boolean" ? showGarden : null,
        show_inventory:
          typeof showInventory === "boolean" ? showInventory : null,
        show_coins:
          typeof showCoins === "boolean" ? showCoins : null,
        show_activity_log:
          typeof showActivityLog === "boolean" ? showActivityLog : null,
        show_journal:
          typeof showJournal === "boolean" ? showJournal : null,
        show_stats:
          typeof showStats === "boolean" ? showStats : null,
        hide_room_from_public_list:
          typeof hideRoomFromPublicList === "boolean"
            ? hideRoomFromPublicList
            : null,
        updated_at: now,
      },
      { onConflict: "player_id" },
    );

    if (privError) {
      console.error("player_privacy upsert error:", privError);
      return new Response("DB error (player_privacy)", { status: 500 });
    }
  }

  // 2) player_state
  {
    const { garden, inventory, stats, activityLog, journal } =
      (state ?? {}) as any;

    const { error } = await supabase.from("player_state").upsert(
      {
        player_id: playerId,
        garden: garden ?? null,
        inventory: inventory ?? null,
        stats: stats ?? null,
        activity_log: activityLog ?? null,
        journal: journal ?? null,
        updated_at: now,
      },
      { onConflict: "player_id" },
    );

    if (error) {
      console.error("player_state upsert error:", error);
      return new Response("DB error (player_state)", { status: 500 });
    }
  }

  // 3) rooms / room_players
  if (room && typeof room.id === "string") {
    const roomId = room.id;

    // privacy.hideRoomFromPublicList -> force la room en privée
    const hideRoom =
      normalizedPrivacy &&
      typeof normalizedPrivacy === "object" &&
      !!(normalizedPrivacy as any).hideRoomFromPublicList;

    const isPrivate = hideRoom || !!room.isPrivate;

    // playersCount venant du client, mais nettoyé
    let playersCount: number | null = null;
    if (typeof room.playersCount === "number") {
      const n = Math.floor(room.playersCount);
      if (n >= 0 && n <= 6) {
        playersCount = n;
      }
    }

    // Normalisation de userSlots -> rooms.user_slots
    let userSlots: any[] | null = null;
    const playersToUpsert: any[] = [];

    if (Array.isArray(room.userSlots)) {
      const cleaned: any[] = [];

      for (const slot of room.userSlots) {
        if (!slot || typeof slot !== "object") continue;

        const rawPlayerId =
          typeof (slot as any).playerId === "string"
            ? (slot as any).playerId
            : null;

        const name =
          typeof (slot as any).name === "string"
            ? (slot as any).name
            : rawPlayerId;

        let avatar_url: string | null = null;
        if (typeof (slot as any).avatarUrl === "string") {
          avatar_url = (slot as any).avatarUrl;
        } else if (typeof (slot as any).discordAvatarUrl === "string") {
          avatar_url = (slot as any).discordAvatarUrl;
        }

        const coinsCandidate = (slot as any).coins;
        const coinsNumber = Number(coinsCandidate);
        const coinsSlot =
          Number.isFinite(coinsNumber) ? coinsNumber : null;

        // pour rooms.user_slots
        const cleanedSlot: any = {};
        if (name) cleanedSlot.name = name;
        if (avatar_url) cleanedSlot.avatar_url = avatar_url;
        if (rawPlayerId) cleanedSlot.player_id = rawPlayerId;
        if (coinsSlot !== null) cleanedSlot.coins = coinsSlot;

        if (Object.keys(cleanedSlot).length > 0) {
          cleaned.push(cleanedSlot);
        }

        // pour players à upserter (autres joueurs)
        if (rawPlayerId && rawPlayerId !== playerId) {
          const row: any = {
            id: rawPlayerId,
            last_event_at: now, // juste "vu dans la room"
          };
          if (name) row.name = name;
          if (avatar_url) row.avatar_url = avatar_url;
          if (coinsSlot !== null) row.coins = coinsSlot;

          playersToUpsert.push(row);
        }
      }

      if (cleaned.length > 0) {
        userSlots = cleaned;
      }
    }

    const upsertData: any = {
      id: roomId,
      is_private: isPrivate,
      last_updated_at: now,
      last_updated_by_player_id: playerId,
    };

    if (playersCount !== null) {
      upsertData.players_count = playersCount;
    }

    if (userSlots) {
      upsertData.user_slots = userSlots;
    }

    // Upsert des autres joueurs de la room dans public.players
    if (playersToUpsert.length > 0) {
      const byId = new Map<string, any>();
      for (const p of playersToUpsert) {
        if (!p.id) continue;
        if (!byId.has(p.id)) {
          byId.set(p.id, p);
        }
      }

      let bulk: any[] = Array.from(byId.values());

      if (bulk.length > 0) {
        const ids = bulk
          .map((p) => p.id)
          .filter(
            (id: any) => typeof id === "string" && id.length > 0,
          );

        let protectedIds = new Set<string>();

        if (ids.length > 0) {
          const { data: existing, error: existingError } = await supabase
            .from("players")
            .select("id, has_mod_installed")
            .in("id", ids);

          if (existingError) {
            console.error(
              "players select for bulk filter error:",
              existingError,
            );
          } else if (existing && existing.length > 0) {
            protectedIds = new Set(
              existing
                .filter(
                  (row: any) => row.has_mod_installed === true,
                )
                .map((row: any) => row.id as string),
            );
          }

          // on enlève du bulk tous les joueurs qui ont déjà le mod
          bulk = bulk.filter((p) => !protectedIds.has(p.id));
        }

        if (bulk.length > 0) {
          const { error: bulkPlayersError } = await supabase
            .from("players")
            .upsert(bulk, { onConflict: "id" });

          if (bulkPlayersError) {
            console.error("players bulk upsert error:", bulkPlayersError);
            // on n'interrompt pas le reste
          }
        }
      }
    }

    // Upsert de la room
    {
      const { error } = await supabase
        .from("rooms")
        .upsert(upsertData, { onConflict: "id" });

      if (error) {
        console.error("rooms upsert error:", error);
        return new Response("DB error (rooms)", { status: 500 });
      }
    }

    // 3a) marquer toutes les AUTRES rooms de ce player comme quittées
    {
      const { error: closeOthersError } = await supabase
        .from("room_players")
        .update({ left_at: now })
        .eq("player_id", playerId)
        .neq("room_id", roomId)
        .is("left_at", null);

      if (closeOthersError) {
        console.error(
          "room_players close others error:",
          closeOthersError,
        );
        // on log seulement
      }
    }

    // 3b) upsert de la ligne (room_id, player_id) actuelle
    {
      const { error: rpError } = await supabase.from("room_players").upsert(
        {
          room_id: roomId,
          player_id: playerId,
          joined_at: now,
          left_at: null,
        },
        { onConflict: "room_id,player_id" },
      );

      if (rpError) {
        console.error("room_players upsert error:", rpError);
        return new Response("DB error (room_players)", { status: 500 });
      }
    }
  }

  return new Response(null, { status: 204 });
});
