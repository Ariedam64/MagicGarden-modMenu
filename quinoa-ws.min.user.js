// ==UserScript==
// @name         Arie's Mod
// @namespace    Quinoa
// @version      3.1.13
// @match        https://1227719606223765687.discordsays.com/*
// @match        https://magiccircle.gg/r/*
// @match        https://magicgarden.gg/r/*
// @match        https://starweaver.org/r/*
// @match        https://ariesmod-api.ariedam.fr/*
// @run-at       document-start
// @inject-into  page
// @grant        GM_xmlhttpRequest
// @grant        GM_info
// @grant        GM_openInTab 
// @grant        GM_getValue
// @grant        GM_setValue
// @grant        GM_registerMenuCommand
// @grant        GM_download
// @connect      raw.githubusercontent.com
// @connect      api.github.com
// @connect      ariesmod-api.ariedam.fr
// @connect      ariedam.fr
// @connect      cdn.pixabay.com
// @connect      cdn.jsdelivr.net
// @connect      magicgarden.gg
// @connect      i.imgur.com
// @connect      cdn.discordapp.com

// @downloadURL  https://github.com/Ariedam64/MagicGarden-modMenu/raw/refs/heads/main/quinoa-ws.min.user.js
// @updateURL    https://github.com/Ariedam64/MagicGarden-modMenu/raw/refs/heads/main/quinoa-ws.min.user.js
// ==/UserScript==
(() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __publicField = (obj, key2, value) => __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);

  // src/sprite/settings.ts
  var DEFAULT_CFG, MUT_META, MUT_NAMES, MUT_G1, MUT_G2, MUT_G3;
  var init_settings = __esm({
    "src/sprite/settings.ts"() {
      DEFAULT_CFG = {
        origin: "https://magicgarden.gg",
        jobOn: true,
        jobBudgetMs: 5,
        jobBurstMs: 12,
        jobBurstWindowMs: 400,
        jobCapPerTick: 20,
        cacheOn: true,
        cacheMaxEntries: 1200,
        cacheMaxCost: 5e3,
        keepCacheOnClose: true,
        srcCanvasMax: 450,
        debugLog: true,
        debugLimitDefault: 25
      };
      MUT_META = {
        Gold: { overlayTall: null, tallIconOverride: null },
        Rainbow: { overlayTall: null, tallIconOverride: null, angle: 130, angleTall: 0 },
        Wet: { overlayTall: "sprite/mutation-overlay/WetTallPlant", tallIconOverride: "sprite/mutation/Puddle" },
        Chilled: { overlayTall: "sprite/mutation-overlay/ChilledTallPlant", tallIconOverride: null },
        Frozen: { overlayTall: "sprite/mutation-overlay/FrozenTallPlant", tallIconOverride: null },
        Thunderstruck: { overlayTall: "sprite/mutation-overlay/ThunderstruckTallPlant", tallIconOverride: "sprite/mutation/ThunderstruckGround" },
        Dawnlit: { overlayTall: null, tallIconOverride: null },
        Ambershine: { overlayTall: null, tallIconOverride: null },
        Dawncharged: { overlayTall: null, tallIconOverride: null },
        Ambercharged: { overlayTall: null, tallIconOverride: null }
      };
      MUT_NAMES = Object.keys(MUT_META);
      MUT_G1 = ["", "Gold", "Rainbow"].filter(Boolean);
      MUT_G2 = ["", "Wet", "Chilled", "Frozen", "Thunderstruck"].filter(Boolean);
      MUT_G3 = ["", "Dawnlit", "Ambershine", "Dawncharged", "Ambercharged"].filter(Boolean);
    }
  });

  // src/sprite/mutations/variantBuilder.ts
  function buildVariantFromMutations(list) {
    const raw = list.filter((value) => hasMutationFilter(value));
    const selected = sortMutations(raw);
    const muts = normalizeMutListColor(raw);
    const overlayMuts = normalizeMutListOverlay(raw);
    return {
      mode: "M",
      muts,
      overlayMuts,
      selectedMuts: selected,
      sig: `M:${selected.join(",")}|${muts.join(",")}|${overlayMuts.join(",")}`
    };
  }
  function mutationAliases(mut) {
    switch (mut) {
      case "Ambershine":
        return ["Ambershine", "Amberlit"];
      case "Dawncharged":
        return ["Dawncharged", "Dawnbound"];
      case "Ambercharged":
        return ["Ambercharged", "Amberbound"];
      case "Thunderstruck":
        return ["Thunderstruck", "ThunderstruckGround"];
      default:
        return [mut];
    }
  }
  function applyFilterOnto(ctx2, sourceCanvas, name, isTall) {
    const base = FILTERS[name];
    if (!base) return;
    const f = { ...base };
    if (name === "Rainbow" && isTall && f.angTall != null) f.ang = f.angTall;
    const fullSpan = name === "Rainbow" && isTall;
    const w = sourceCanvas.width;
    const h = sourceCanvas.height;
    ctx2.save();
    const blendOp = f.masked ? pickBlendOp(f.op) : "source-in";
    ctx2.globalCompositeOperation = blendOp;
    if (f.a != null) ctx2.globalAlpha = f.a;
    if (f.masked) {
      const m = document.createElement("canvas");
      m.width = w;
      m.height = h;
      const mctx = m.getContext("2d");
      mctx.imageSmoothingEnabled = false;
      fillGrad(mctx, w, h, f, fullSpan);
      mctx.globalCompositeOperation = "destination-in";
      mctx.drawImage(sourceCanvas, 0, 0);
      ctx2.drawImage(m, 0, 0);
    } else {
      fillGrad(ctx2, w, h, f, fullSpan);
    }
    ctx2.restore();
  }
  function tallOverlayFromSheet(mutName, state3) {
    const target = String(mutName || "").toLowerCase();
    for (const k of state3.tex.keys()) {
      const m = /sprite\/mutation-overlay\/([A-Za-z0-9]+)TallPlant/i.exec(String(k));
      if (!m || !m[1]) continue;
      const prefix = m[1].toLowerCase();
      if (prefix === target) {
        const t = state3.tex.get(k);
        if (t) return { tex: t, key: k };
      }
    }
    return null;
  }
  function findOverlayTexture(itKey, mutName, state3, preferTall) {
    if (!mutName) return null;
    const base = baseNameOf(itKey);
    const aliases = mutationAliases(mutName);
    for (const name of aliases) {
      const tries = [
        `sprite/mutation/${name}${base}`,
        `sprite/mutation/${name}-${base}`,
        `sprite/mutation/${name}_${base}`,
        `sprite/mutation/${name}/${base}`,
        `sprite/mutation/${name}`
      ];
      for (const k of tries) {
        const t = state3.tex.get(k);
        if (t) return { tex: t, key: k };
      }
      if (preferTall) {
        const hit = state3.tex.get(`sprite/mutation-overlay/${name}TallPlant`) && {
          tex: state3.tex.get(`sprite/mutation-overlay/${name}TallPlant`),
          key: `sprite/mutation-overlay/${name}TallPlant`
        } || state3.tex.get(`sprite/mutation-overlay/${name}`) && {
          tex: state3.tex.get(`sprite/mutation-overlay/${name}`),
          key: `sprite/mutation-overlay/${name}`
        } || tallOverlayFromSheet(mutName, state3);
        if (hit) return hit;
      }
    }
    return null;
  }
  function findIconTexture(itKey, mutName, isTall, state3) {
    if (!mutName) return null;
    const meta = MUT_META[mutName];
    if (isTall && meta?.tallIconOverride) {
      const t = state3.tex.get(meta.tallIconOverride);
      if (t) return t;
    }
    const base = baseNameOf(itKey);
    const aliases = mutationAliases(mutName);
    for (const name of aliases) {
      const tries = [
        `sprite/mutation/${name}Icon`,
        `sprite/mutation/${name}`,
        `sprite/mutation/${name}${base}`,
        `sprite/mutation/${name}-${base}`,
        `sprite/mutation/${name}_${base}`,
        `sprite/mutation/${name}/${base}`
      ];
      for (const k of tries) {
        const t = state3.tex.get(k);
        if (t) return t;
      }
      if (isTall) {
        const t = state3.tex.get(`sprite/mutation-overlay/${name}TallPlantIcon`) || state3.tex.get(`sprite/mutation-overlay/${name}TallPlant`);
        if (t) return t;
      }
    }
    return null;
  }
  function computeIconLayout(tex, baseName, isTall) {
    const width = tex?.orig?.width ?? tex?.frame?.width ?? tex?.width ?? 1;
    const height = tex?.orig?.height ?? tex?.frame?.height ?? tex?.height ?? 1;
    const anchorX = tex?.defaultAnchor?.x ?? 0;
    const anchorY = tex?.defaultAnchor?.y ?? 0;
    let targetX = MUT_ICON_X_EXCEPT[baseName] ?? anchorX;
    const isVerticalShape = height > width * 1.5;
    let targetY = MUT_ICON_Y_EXCEPT[baseName] ?? (isVerticalShape ? anchorY : 0.4);
    const offset = {
      x: (targetX - anchorX) * width,
      y: (targetY - anchorY) * height
    };
    const minDimension = Math.min(width, height);
    const scaleFactor = Math.min(1.5, minDimension / TILE_SIZE_WORLD);
    let iconScale = BASE_ICON_SCALE * scaleFactor;
    if (isTall) iconScale *= TALL_PLANT_MUTATION_ICON_SCALE_BOOST;
    return {
      width,
      height,
      anchorX,
      anchorY,
      offset,
      iconScale,
      content: {
        x: 0,
        y: 0,
        width,
        height,
        centerX: 0.5,
        centerY: 0.5,
        top: 0
      }
    };
  }
  function textureToCanvas(tex, state3, cfg) {
    const hit = state3.srcCan.get(tex);
    if (hit) return hit;
    let c = null;
    const RDR = state3.renderer;
    try {
      if (RDR?.extract?.canvas && (RDR?.resolution ?? 1) === 1) {
        const s = new state3.ctors.Sprite(tex);
        c = RDR.extract.canvas(s);
        s.destroy?.({ children: true, texture: false, baseTexture: false });
      }
    } catch {
    }
    if (!c) {
      const fr = tex?.frame || tex?._frame;
      const orig = tex?.orig || tex?._orig;
      const trim = tex?.trim || tex?._trim;
      const rot = tex?.rotate || tex?._rotate || 0;
      const src = tex?.baseTexture?.resource?.source || tex?.baseTexture?.resource || tex?.source?.resource?.source || tex?.source?.resource || tex?._source?.resource?.source || null;
      if (!fr || !src) throw new Error("texToCanvas fail");
      c = document.createElement("canvas");
      const fullW = Math.max(1, (orig?.width ?? fr.width) | 0);
      const fullH = Math.max(1, (orig?.height ?? fr.height) | 0);
      const offX = trim?.x ?? 0;
      const offY = trim?.y ?? 0;
      c.width = fullW;
      c.height = fullH;
      const ctx2 = c.getContext("2d");
      ctx2.imageSmoothingEnabled = false;
      const rotated = rot === true || rot === 2 || rot === 8;
      if (rotated) {
        ctx2.save();
        ctx2.translate(offX + fr.height / 2, offY + fr.width / 2);
        ctx2.rotate(-Math.PI / 2);
        ctx2.drawImage(src, fr.x, fr.y, fr.width, fr.height, -fr.width / 2, -fr.height / 2, fr.width, fr.height);
        ctx2.restore();
      } else {
        ctx2.drawImage(src, fr.x, fr.y, fr.width, fr.height, offX, offY, fr.width, fr.height);
      }
    }
    state3.srcCan.set(tex, c);
    if (state3.srcCan.size > cfg.srcCanvasMax) {
      const k = state3.srcCan.keys().next().value;
      if (k !== void 0) state3.srcCan.delete(k);
    }
    return c;
  }
  function buildColorLayerSprites(tex, dims, pipeline, state3, cfg, disposables, TextureCtor) {
    const { w, h, aX, aY, basePos } = dims;
    const layers = [];
    for (const step of pipeline) {
      const clone = new state3.ctors.Sprite(tex);
      clone.anchor?.set?.(aX, aY);
      clone.position.set(basePos.x, basePos.y);
      clone.zIndex = 1;
      const layerCanvas = document.createElement("canvas");
      layerCanvas.width = w;
      layerCanvas.height = h;
      const lctx = layerCanvas.getContext("2d");
      lctx.imageSmoothingEnabled = false;
      lctx.save();
      lctx.translate(w * aX, h * aY);
      lctx.drawImage(textureToCanvas(tex, state3, cfg), -w * aX, -h * aY);
      lctx.restore();
      applyFilterOnto(lctx, layerCanvas, step.name, step.isTall);
      const filteredTex = TextureCtor.from(layerCanvas);
      disposables.push(filteredTex);
      clone.texture = filteredTex;
      layers.push(clone);
    }
    return layers;
  }
  function buildTallOverlaySprites(itKey, dims, overlayPipeline, state3, cfg, baseCanvas, TextureCtor, disposables) {
    const { w, aX, basePos } = dims;
    if (!baseCanvas) return [];
    const overlays = [];
    for (const step of overlayPipeline) {
      const hit = step.overlayTall && state3.tex.get(step.overlayTall) && { tex: state3.tex.get(step.overlayTall), key: step.overlayTall } || findOverlayTexture(itKey, step.name, state3, true);
      if (!hit?.tex) continue;
      const oCan = textureToCanvas(hit.tex, state3, cfg);
      if (!oCan) continue;
      const ow = oCan.width;
      const overlayAnchor = { x: 0, y: 0 };
      const overlayPos = { x: basePos.x - aX * ow, y: 0 };
      const overlayOffset = TALL_OVERLAY_OFFSETS[step.name];
      if (overlayOffset) {
        overlayPos.x += overlayOffset.x ?? 0;
        overlayPos.y += overlayOffset.y ?? 0;
      }
      const maskedCanvas = document.createElement("canvas");
      maskedCanvas.width = ow;
      maskedCanvas.height = oCan.height;
      const mctx = maskedCanvas.getContext("2d");
      if (!mctx) continue;
      mctx.imageSmoothingEnabled = false;
      mctx.drawImage(oCan, 0, 0);
      mctx.globalCompositeOperation = "destination-in";
      mctx.drawImage(baseCanvas, -overlayPos.x, -overlayPos.y);
      const maskedTex = TextureCtor.from(maskedCanvas);
      disposables.push(maskedTex);
      const ov = new state3.ctors.Sprite(maskedTex);
      ov.anchor?.set?.(overlayAnchor.x, overlayAnchor.y);
      ov.position.set(overlayPos.x, overlayPos.y);
      ov.scale.set(1);
      ov.alpha = 1;
      ov.zIndex = 3;
      overlays.push(ov);
    }
    return overlays;
  }
  function buildIconSprites(itKey, dims, iconPipeline, state3, iconLayout) {
    const { basePos } = dims;
    const icons = [];
    for (const step of iconPipeline) {
      if (step.name === "Gold" || step.name === "Rainbow") continue;
      const itex = findIconTexture(itKey, step.name, step.isTall, state3);
      if (!itex) continue;
      const icon = new state3.ctors.Sprite(itex);
      const iconAnchorX = itex?.defaultAnchor?.x ?? 0.5;
      const iconAnchorY = itex?.defaultAnchor?.y ?? 0.5;
      icon.anchor?.set?.(iconAnchorX, iconAnchorY);
      icon.position.set(basePos.x + iconLayout.offset.x, basePos.y + iconLayout.offset.y);
      icon.scale.set(iconLayout.iconScale);
      if (step.isTall) icon.zIndex = -1;
      if (FLOATING_MUTATION_ICONS.has(step.name)) icon.zIndex = 10;
      if (!icon.zIndex) icon.zIndex = 2;
      icons.push(icon);
    }
    return icons;
  }
  function lruEvict(state3, cfg) {
    if (!cfg.cacheOn) return;
    while (state3.lru.size > cfg.cacheMaxEntries || state3.cost > cfg.cacheMaxCost) {
      const k = state3.lru.keys().next().value;
      if (k === void 0) break;
      const e = state3.lru.get(k);
      state3.lru.delete(k);
      state3.cost = Math.max(0, state3.cost - entryCost(e));
    }
  }
  function clearVariantCache(state3) {
    state3.lru.clear();
    state3.cost = 0;
    state3.srcCan.clear();
  }
  function renderMutatedTexture(tex, itKey, V, state3, cfg) {
    try {
      if (!tex || !state3.renderer || !state3.ctors?.Container || !state3.ctors?.Sprite || !state3.ctors?.Texture) return null;
      const { Container, Sprite, Texture } = state3.ctors;
      const w = tex?.orig?.width ?? tex?.frame?.width ?? tex?.width ?? 1;
      const h = tex?.orig?.height ?? tex?.frame?.height ?? tex?.height ?? 1;
      const aX = tex?.defaultAnchor?.x ?? 0.5;
      const aY = tex?.defaultAnchor?.y ?? 0.5;
      const basePos = { x: w * aX, y: h * aY };
      const baseCanvas = textureToCanvas(tex, state3, cfg);
      const root = new Container();
      root.sortableChildren = true;
      try {
        const lock = new Sprite(tex);
        lock.anchor?.set?.(aX, aY);
        lock.position.set(basePos.x, basePos.y);
        lock.width = w;
        lock.height = h;
        lock.alpha = 0;
        lock.zIndex = -1e3;
        root.addChild(lock);
      } catch {
      }
      const base = new Sprite(tex);
      base.anchor?.set?.(aX, aY);
      base.position.set(basePos.x, basePos.y);
      base.zIndex = 0;
      root.addChild(base);
      const isTall = isTallKey(itKey);
      const pipeline = buildMutationPipeline(V.muts, isTall);
      const overlayPipeline = buildMutationPipeline(V.overlayMuts, isTall);
      const iconPipeline = buildMutationPipeline(V.selectedMuts, isTall);
      const disposables = [];
      const baseName = baseNameOf(itKey);
      const iconLayout = computeIconLayout(tex, baseName, isTall);
      const dims = { w, h, aX, aY, basePos };
      buildColorLayerSprites(tex, dims, pipeline, state3, cfg, disposables, Texture).forEach((layer) => root.addChild(layer));
      if (isTall) {
        buildTallOverlaySprites(itKey, dims, overlayPipeline, state3, cfg, baseCanvas, Texture, disposables).forEach((ov) => root.addChild(ov));
      }
      buildIconSprites(itKey, dims, iconPipeline, state3, iconLayout).forEach((icon) => root.addChild(icon));
      const RDR = state3.renderer;
      let rt = null;
      const RectCtor = state3.ctors?.Rectangle;
      const crop = RectCtor ? new RectCtor(0, 0, w, h) : null;
      if (typeof RDR?.generateTexture === "function")
        rt = RDR.generateTexture(root, { resolution: 1, region: crop ?? void 0 });
      else if (RDR?.textureGenerator?.generateTexture)
        rt = RDR.textureGenerator.generateTexture({ target: root, resolution: 1 });
      if (!rt) throw new Error("no render texture");
      const outTex = rt instanceof Texture ? rt : Texture.from(RDR.extract.canvas(rt));
      if (rt && rt !== outTex) rt.destroy?.(true);
      root.destroy({ children: true, texture: false, baseTexture: false });
      disposables.forEach(() => {
      });
      try {
        outTex.__mg_gen = true;
        outTex.label = `${itKey}|${V.sig}`;
      } catch {
      }
      return outTex;
    } catch {
      return null;
    }
  }
  function processVariantJobs(state3, cfg) {
    if (!cfg.jobOn || !state3.open || !state3.jobs.length) return false;
    const now2 = performance.now();
    const burst = now2 - state3.changedAt <= cfg.jobBurstWindowMs;
    const budget = burst ? cfg.jobBurstMs : cfg.jobBudgetMs;
    const t0 = performance.now();
    let done = 0;
    let needsLayout = false;
    while (state3.jobs.length) {
      if (performance.now() - t0 >= budget) break;
      if (done >= cfg.jobCapPerTick) break;
      const job = state3.jobs[0];
      if (job.sig !== state3.sig) {
        state3.jobs.shift();
        state3.jobMap.delete(job.k);
        continue;
      }
      const tex = job.src[job.i];
      if (!tex) {
        state3.jobs.shift();
        state3.jobMap.delete(job.k);
        continue;
      }
      const ft = renderMutatedTexture(tex, job.itKey, job.V, state3, cfg);
      if (ft) job.out.push(ft);
      job.i++;
      done++;
      if (job.i >= job.src.length) {
        state3.jobs.shift();
        state3.jobMap.delete(job.k);
        let entry = null;
        if (job.isAnim) {
          if (job.out.length >= 2) entry = { isAnim: true, frames: job.out };
          else job.out.forEach(() => {
          });
        } else {
          if (job.out[0]) entry = { isAnim: false, tex: job.out[0] };
        }
        if (entry) {
          state3.lru.set(job.k, entry);
          state3.cost += entryCost(entry);
          lruEvict(state3, cfg);
          needsLayout = true;
        }
      }
    }
    return needsLayout;
  }
  var TILE_SIZE_WORLD, BASE_ICON_SCALE, TALL_PLANT_MUTATION_ICON_SCALE_BOOST, FLOATING_MUTATION_ICONS, MUT_ICON_Y_EXCEPT, MUT_ICON_X_EXCEPT, TALL_OVERLAY_OFFSETS, MUTATION_ORDER, MUTATION_INDEX, sortMutations, SUPPORTED_BLEND_OPS, pickBlendOp, FILTERS, hasMutationFilter, isTallKey, computeVariantSignature, curVariant, normalizeMutListColor, normalizeMutListOverlay, buildMutationPipeline, angleGrad, fillGrad, baseNameOf, entryCost, processJobs;
  var init_variantBuilder = __esm({
    "src/sprite/mutations/variantBuilder.ts"() {
      init_settings();
      TILE_SIZE_WORLD = 256;
      BASE_ICON_SCALE = 0.5;
      TALL_PLANT_MUTATION_ICON_SCALE_BOOST = 2;
      FLOATING_MUTATION_ICONS = /* @__PURE__ */ new Set([
        "Dawnlit",
        "Ambershine",
        "Dawncharged",
        "Ambercharged"
      ]);
      MUT_ICON_Y_EXCEPT = {
        Banana: 0.68,
        Beet: 0.65,
        Carrot: 0.6,
        Sunflower: 0.5,
        Starweaver: 0.5,
        FavaBean: 0.25,
        BurrosTail: 0.2
      };
      MUT_ICON_X_EXCEPT = {
        Pepper: 0.6,
        Banana: 0.6
      };
      TALL_OVERLAY_OFFSETS = {
        Thunderstruck: { x: 0, y: 250 }
      };
      MUTATION_ORDER = ["Gold", "Rainbow", "Wet", "Chilled", "Frozen", "Thunderstruck", "Ambershine", "Dawnlit", "Dawncharged", "Ambercharged"];
      MUTATION_INDEX = new Map(MUTATION_ORDER.map((m, idx) => [m, idx]));
      sortMutations = (list) => {
        const uniq2 = [...new Set(list.filter(Boolean))];
        return uniq2.sort((a, b) => (MUTATION_INDEX.get(a) ?? Infinity) - (MUTATION_INDEX.get(b) ?? Infinity));
      };
      SUPPORTED_BLEND_OPS = (() => {
        try {
          const c = document.createElement("canvas");
          const g = c.getContext("2d");
          if (!g) return /* @__PURE__ */ new Set();
          const ops = ["color", "hue", "saturation", "luminosity", "overlay", "screen", "lighter", "source-atop"];
          const ok = /* @__PURE__ */ new Set();
          for (const op of ops) {
            g.globalCompositeOperation = op;
            if (g.globalCompositeOperation === op) ok.add(op);
          }
          return ok;
        } catch {
          return /* @__PURE__ */ new Set();
        }
      })();
      pickBlendOp = (desired) => {
        if (SUPPORTED_BLEND_OPS.has(desired)) return desired;
        if (SUPPORTED_BLEND_OPS.has("overlay")) return "overlay";
        if (SUPPORTED_BLEND_OPS.has("screen")) return "screen";
        if (SUPPORTED_BLEND_OPS.has("lighter")) return "lighter";
        return "source-atop";
      };
      FILTERS = {
        Gold: { op: "source-atop", colors: ["rgb(235,200,0)"], a: 0.7 },
        Rainbow: { op: "color", colors: ["#FF1744", "#FF9100", "#FFEA00", "#00E676", "#2979FF", "#D500F9"], ang: 130, angTall: 0, masked: true },
        Wet: { op: "source-atop", colors: ["rgb(50,180,200)"], a: 0.25 },
        Chilled: { op: "source-atop", colors: ["rgb(100,160,210)"], a: 0.45 },
        Frozen: { op: "source-atop", colors: ["rgb(100,130,220)"], a: 0.5 },
        Thunderstruck: { op: "source-atop", colors: ["rgb(16, 141, 163)"], a: 0.45 },
        Dawnlit: { op: "source-atop", colors: ["rgb(209,70,231)"], a: 0.5 },
        Ambershine: { op: "source-atop", colors: ["rgb(190,100,40)"], a: 0.5 },
        Dawncharged: { op: "source-atop", colors: ["rgb(140,80,200)"], a: 0.5 },
        Ambercharged: { op: "source-atop", colors: ["rgb(170,60,25)"], a: 0.5 }
      };
      hasMutationFilter = (value) => Boolean(value && FILTERS[value]);
      isTallKey = (k) => /tallplant/i.test(k);
      computeVariantSignature = (state3) => {
        if (!state3.mutOn) {
          const f = hasMutationFilter(state3.f) ? state3.f : null;
          const baseMuts = f ? [f] : [];
          return { mode: "F", muts: baseMuts, overlayMuts: baseMuts, selectedMuts: baseMuts, sig: `F:${f ?? ""}` };
        }
        const raw = state3.mutations.filter((value) => hasMutationFilter(value));
        const selected = sortMutations(raw);
        const muts = normalizeMutListColor(raw);
        const overlayMuts = normalizeMutListOverlay(raw);
        return {
          mode: "M",
          muts,
          overlayMuts,
          selectedMuts: selected,
          sig: `M:${selected.join(",")}|${muts.join(",")}|${overlayMuts.join(",")}`
        };
      };
      curVariant = computeVariantSignature;
      normalizeMutListColor = (list) => {
        const names = list.filter((m, idx, arr) => FILTERS[m] && arr.indexOf(m) === idx);
        if (!names.length) return [];
        if (names.includes("Gold")) return ["Gold"];
        if (names.includes("Rainbow")) return ["Rainbow"];
        const warm = ["Ambershine", "Dawnlit", "Dawncharged", "Ambercharged"];
        const hasWarm = names.some((n) => warm.includes(n));
        if (hasWarm) {
          return sortMutations(names.filter((n) => !["Wet", "Chilled", "Frozen", "Thunderstruck"].includes(n)));
        }
        return sortMutations(names);
      };
      normalizeMutListOverlay = (list) => {
        const names = list.filter((m, idx, arr) => MUT_META[m]?.overlayTall && arr.indexOf(m) === idx);
        return sortMutations(names);
      };
      buildMutationPipeline = (mutNames, isTall) => mutNames.map((m) => ({ name: m, meta: MUT_META[m], overlayTall: MUT_META[m]?.overlayTall, isTall }));
      angleGrad = (ctx2, w, h, ang, fullSpan = false) => {
        const rad = (ang - 90) * Math.PI / 180;
        const cx = w / 2;
        const cy = h / 2;
        if (!fullSpan) {
          const R2 = Math.min(w, h) / 2;
          return ctx2.createLinearGradient(cx - Math.cos(rad) * R2, cy - Math.sin(rad) * R2, cx + Math.cos(rad) * R2, cy + Math.sin(rad) * R2);
        }
        const dx = Math.cos(rad);
        const dy = Math.sin(rad);
        const R = Math.abs(dx) * w / 2 + Math.abs(dy) * h / 2;
        return ctx2.createLinearGradient(cx - dx * R, cy - dy * R, cx + dx * R, cy + dy * R);
      };
      fillGrad = (ctx2, w, h, f, fullSpan = false) => {
        const cols = f.colors?.length ? f.colors : ["#fff"];
        const g = f.ang != null ? angleGrad(ctx2, w, h, f.ang, fullSpan) : ctx2.createLinearGradient(0, 0, 0, h);
        if (cols.length === 1) {
          g.addColorStop(0, cols[0]);
          g.addColorStop(1, cols[0]);
        } else cols.forEach((c, i) => g.addColorStop(i / (cols.length - 1), c));
        ctx2.fillStyle = g;
        ctx2.fillRect(0, 0, w, h);
      };
      baseNameOf = (k) => {
        const p = String(k || "").split("/");
        return p[p.length - 1] || "";
      };
      entryCost = (e) => e?.isAnim ? e.frames?.length || 0 : e?.tex ? 1 : 0;
      processJobs = processVariantJobs;
    }
  });

  // src/utils/page-context.ts
  function shareGlobal(name, value) {
    try {
      pageWin[name] = value;
    } catch {
    }
    if (isIsolatedContext) {
      try {
        sandboxWin[name] = value;
      } catch {
      }
    }
  }
  function readSharedGlobal(name) {
    if (isIsolatedContext) {
      const sandboxValue = sandboxWin[name];
      if (sandboxValue !== void 0) return sandboxValue;
    }
    return pageWin[name];
  }
  var sandboxWin, pageWin, pageWindow, isIsolatedContext;
  var init_page_context = __esm({
    "src/utils/page-context.ts"() {
      sandboxWin = window;
      pageWin = typeof unsafeWindow !== "undefined" && unsafeWindow ? unsafeWindow : sandboxWin;
      pageWindow = pageWin;
      isIsolatedContext = pageWin !== sandboxWin;
    }
  });

  // src/sprite/api/spriteApi.ts
  var spriteApi_exports = {};
  __export(spriteApi_exports, {
    buildVariant: () => buildVariant,
    getBaseSprite: () => getBaseSprite,
    getSpriteWithMutations: () => getSpriteWithMutations,
    listItemsByCategory: () => listItemsByCategory
  });
  function findItem(state3, category, id) {
    const normId = normalizeKey(id);
    for (const it of state3.items) {
      const keyCat = keyCategoryOf(it.key);
      if (!matchesCategory(keyCat, category)) continue;
      const base = normalizeKey(baseNameOf2(it.key));
      if (base === normId) return it;
    }
    return null;
  }
  function listItemsByCategory(state3, category = "any") {
    return state3.items.filter((it) => matchesCategory(keyCategoryOf(it.key), category));
  }
  function buildVariant(mutations) {
    return buildVariantFromMutations(mutations);
  }
  function getSpriteWithMutations(params, state3, cfg) {
    const it = findItem(state3, params.category, params.id);
    if (!it) return null;
    const tex = it.isAnim ? it.frames?.[0] : it.first;
    if (!tex) return null;
    const V = buildVariantFromMutations(params.mutations);
    return renderMutatedTexture(tex, it.key, V, state3, cfg);
  }
  function getBaseSprite(params, state3) {
    const it = findItem(state3, params.category, params.id);
    if (!it) return null;
    return it.isAnim ? it.frames?.[0] ?? null : it.first;
  }
  var normalizeKey, categoryAlias, keyCategoryOf, matchesCategory, baseNameOf2;
  var init_spriteApi = __esm({
    "src/sprite/api/spriteApi.ts"() {
      init_variantBuilder();
      normalizeKey = (s) => String(s || "").toLowerCase().replace(/[^a-z0-9]/g, "");
      categoryAlias = {
        plant: ["plant"],
        tallplant: ["tallplant"],
        crop: ["crop"],
        decor: ["decor"],
        item: ["item"],
        pet: ["pet"],
        seed: ["seed"],
        mutation: ["mutation"],
        "mutation-overlay": ["mutation-overlay"],
        ui: ["ui"],
        any: []
      };
      keyCategoryOf = (key2) => {
        const parts = key2.split("/").filter(Boolean);
        if (parts[0] === "sprite" || parts[0] === "sprites") return parts[1] ?? "";
        return parts[0] ?? "";
      };
      matchesCategory = (keyCat, requested) => {
        if (requested === "any") return true;
        const aliases = categoryAlias[requested] || [];
        return aliases.some((a) => normalizeKey(keyCat) === normalizeKey(a));
      };
      baseNameOf2 = (key2) => {
        const parts = key2.split("/").filter(Boolean);
        return parts[parts.length - 1] || "";
      };
    }
  });

  // src/store/jotai.ts
  async function waitForAtomCache() {
    const t0 = Date.now();
    while (Date.now() - t0 < ATOM_CACHE_WAIT_MS) {
      const cache2 = getAtomCache();
      if (cache2) return cache2;
      await new Promise((r) => setTimeout(r, 100));
    }
    return null;
  }
  function findStoreViaFiber() {
    const hook = pageWindow.__REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!hook?.renderers?.size) return null;
    for (const [rid] of hook.renderers) {
      const roots = hook.getFiberRoots?.(rid);
      if (!roots) continue;
      for (const root of roots) {
        const seen = /* @__PURE__ */ new Set();
        const stack = [root.current];
        while (stack.length) {
          const f = stack.pop();
          if (!f || seen.has(f)) continue;
          seen.add(f);
          const v = f?.pendingProps?.value;
          if (v && typeof v.get === "function" && typeof v.set === "function" && typeof v.sub === "function") {
            _lastCapturedVia = "fiber";
            return v;
          }
          if (f.child) stack.push(f.child);
          if (f.sibling) stack.push(f.sibling);
          if (f.alternate) stack.push(f.alternate);
        }
      }
    }
    return null;
  }
  function makePolyfillStore() {
    return {
      get: () => {
        throw new Error("Store non captur\xE9: get indisponible");
      },
      set: () => {
        throw new Error("Store non captur\xE9: set indisponible");
      },
      sub: () => () => {
      },
      __polyfill: true
    };
  }
  async function captureViaWriteOnce() {
    let cache2 = getAtomCache() ?? null;
    if (!cache2) {
      console.log("[jotai-bridge] Waiting for jotaiAtomCache...");
      cache2 = await waitForAtomCache();
    }
    if (!cache2) {
      console.warn("[jotai-bridge] jotaiAtomCache.cache introuvable");
      _lastCapturedVia = "polyfill";
      return makePolyfillStore();
    }
    let capturedGet = null;
    let capturedSet = null;
    const patched = [];
    const restorePatched = () => {
      for (const a of patched) {
        try {
          if (a.__origWrite) {
            a.write = a.__origWrite;
            delete a.__origWrite;
          }
        } catch {
        }
      }
    };
    for (const atom of cache2.values()) {
      if (!atom || typeof atom.write !== "function" || atom.__origWrite) continue;
      const orig = atom.write;
      atom.__origWrite = orig;
      atom.write = function(get3, set3, ...args) {
        if (!capturedSet) {
          capturedGet = get3;
          capturedSet = set3;
          restorePatched();
        }
        return orig.call(this, get3, set3, ...args);
      };
      patched.push(atom);
    }
    const wait2 = (ms) => new Promise((r) => setTimeout(r, ms));
    const t0 = Date.now();
    try {
      pageWindow.dispatchEvent?.(new pageWindow.Event("visibilitychange"));
    } catch {
    }
    while (!capturedSet && Date.now() - t0 < WRITE_ONCE_MS) {
      await wait2(50);
    }
    if (!capturedSet) {
      restorePatched();
      _lastCapturedVia = "polyfill";
      console.warn("[jotai-bridge] write-once: timeout \u2192 polyfill");
      return {
        get: () => {
          throw new Error("Store non captur\xE9: get indisponible");
        },
        set: () => {
          throw new Error("Store non captur\xE9: set indisponible");
        },
        sub: () => () => {
        },
        __polyfill: true
      };
    }
    _lastCapturedVia = "write";
    return {
      get: (a) => capturedGet(a),
      set: (a, v) => capturedSet(a, v),
      sub: (a, cb) => {
        let last;
        try {
          last = capturedGet(a);
        } catch {
        }
        const id = setInterval(() => {
          let curr;
          try {
            curr = capturedGet(a);
          } catch {
            return;
          }
          if (curr !== last) {
            last = curr;
            try {
              cb();
            } catch {
            }
          }
        }, 100);
        return () => clearInterval(id);
      }
    };
  }
  async function ensureStore() {
    if (_store && !_store.__polyfill) return _store;
    if (_captureInProgress) {
      const t0 = Date.now();
      const maxWait = ATOM_CACHE_WAIT_MS + WRITE_ONCE_MS + 1e3;
      while (!_store && Date.now() - t0 < maxWait) {
        await new Promise((r) => setTimeout(r, 25));
      }
      if (_store && !_store.__polyfill) return _store;
    }
    _captureInProgress = true;
    try {
      const viaFiber = findStoreViaFiber();
      if (viaFiber) {
        _store = viaFiber;
        return _store;
      }
      const viaWrite = await captureViaWriteOnce();
      _store = viaWrite;
      return _store;
    } catch (e) {
      _captureError = e;
      throw e;
    } finally {
      _captureInProgress = false;
    }
  }
  function isStoreCaptured() {
    return !!_store && !_store.__polyfill;
  }
  function getCapturedInfo() {
    return { via: _lastCapturedVia, polyfill: !!_store?.__polyfill, error: _captureError };
  }
  async function jGet(atom) {
    const s = await ensureStore();
    return s.get(atom);
  }
  async function jSet(atom, value) {
    const s = await ensureStore();
    await s.set(atom, value);
  }
  async function jSub(atom, cb) {
    const s = await ensureStore();
    return s.sub(atom, cb);
  }
  function findAtomsByLabel(regex) {
    const cache2 = getAtomCache();
    if (!cache2) return [];
    const out = [];
    for (const a of cache2.values()) {
      const label2 = a?.debugLabel || a?.label || "";
      if (regex.test(String(label2))) out.push(a);
    }
    return out;
  }
  function getAtomByLabel(label2) {
    const escape = (s) => s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    return findAtomsByLabel(new RegExp("^" + escape(label2) + "$"))[0] || null;
  }
  var _store, _captureInProgress, _captureError, _lastCapturedVia, ATOM_CACHE_WAIT_MS, WRITE_ONCE_MS, getAtomCache;
  var init_jotai = __esm({
    "src/store/jotai.ts"() {
      init_page_context();
      _store = null;
      _captureInProgress = false;
      _captureError = null;
      _lastCapturedVia = null;
      ATOM_CACHE_WAIT_MS = 2e4;
      WRITE_ONCE_MS = 5e3;
      getAtomCache = () => pageWindow.jotaiAtomCache?.cache;
    }
  });

  // src/store/api.ts
  async function ensureStore2() {
    try {
      await ensureStore();
    } catch {
    }
  }
  async function select(label2, fallback) {
    await ensureStore2();
    const atom = getAtomByLabel(label2);
    if (!atom) return fallback;
    try {
      return await jGet(atom);
    } catch {
      return fallback;
    }
  }
  async function subscribe(label2, cb) {
    await ensureStore2();
    const atom = getAtomByLabel(label2);
    if (!atom) return () => {
    };
    const unsub = await jSub(atom, async () => {
      try {
        cb(await jGet(atom));
      } catch {
      }
    });
    return unsub;
  }
  async function subscribeImmediate(label2, cb) {
    const first = await select(label2);
    if (first !== void 0) cb(first);
    return subscribe(label2, cb);
  }
  async function set(label2, value) {
    await ensureStore2();
    const atom = getAtomByLabel(label2);
    if (!atom) return;
    await jSet(atom, value);
  }
  var Store;
  var init_api = __esm({
    "src/store/api.ts"() {
      init_jotai();
      Store = { ensure: ensureStore2, select, subscribe, subscribeImmediate, set };
    }
  });

  // src/store/hub.ts
  function toPathArray(path) {
    if (!path) return [];
    return Array.isArray(path) ? path.slice() : path.split(".").map((k) => k.match(/^\d+$/) ? Number(k) : k);
  }
  function getAtPath(root, path) {
    const segs = toPathArray(path);
    let cur = root;
    for (const s of segs) {
      if (cur == null) return void 0;
      cur = cur[s];
    }
    return cur;
  }
  function setAtPath(root, path, nextValue) {
    const segs = toPathArray(path);
    if (!segs.length) return nextValue;
    const clone = Array.isArray(root) ? root.slice() : { ...root ?? {} };
    let cur = clone;
    for (let i = 0; i < segs.length - 1; i++) {
      const key2 = segs[i];
      const src = cur[key2];
      const obj = typeof src === "object" && src !== null ? Array.isArray(src) ? src.slice() : { ...src } : {};
      cur[key2] = obj;
      cur = obj;
    }
    cur[segs[segs.length - 1]] = nextValue;
    return clone;
  }
  function makeView(sourceLabel, opts = {}) {
    const { path, write = "replace" } = opts;
    async function get3() {
      const src = await Store.select(sourceLabel);
      return path ? getAtPath(src, path) : src;
    }
    async function set3(next) {
      if (typeof write === "function") {
        const prev2 = await Store.select(sourceLabel);
        const raw2 = write(next, prev2);
        return Store.set(sourceLabel, raw2);
      }
      const prev = await Store.select(sourceLabel);
      const raw = path ? setAtPath(prev, path, next) : next;
      if (write === "merge-shallow" && !path && prev && typeof prev === "object" && typeof next === "object") {
        return Store.set(sourceLabel, { ...prev, ...next });
      }
      return Store.set(sourceLabel, raw);
    }
    async function update(fn) {
      const prev = await get3();
      const next = fn(prev);
      await set3(next);
      return next;
    }
    async function onChange(cb, isEqual = Object.is) {
      let prev;
      return Store.subscribe(sourceLabel, (src) => {
        const v = path ? getAtPath(src, path) : src;
        if (typeof prev === "undefined" || !isEqual(prev, v)) {
          const p = prev;
          prev = v;
          cb(v, p);
        }
      });
    }
    async function onChangeNow(cb, isEqual = Object.is) {
      let prev;
      return Store.subscribeImmediate(sourceLabel, (src) => {
        const v = path ? getAtPath(src, path) : src;
        if (typeof prev === "undefined" || !isEqual(prev, v)) {
          const p = prev;
          prev = v;
          cb(v, p);
        }
      });
    }
    function asSignature(opts2) {
      return makeSignatureChannel(sourceLabel, path, opts2);
    }
    return { label: sourceLabel + (path ? ":" + toPathArray(path).join(".") : ""), get: get3, set: set3, update, onChange, onChangeNow, asSignature };
  }
  function stablePick(obj, fields) {
    const out = {};
    for (const f of fields) {
      const v = getAtPath(obj, f.includes(".") ? f : [f]);
      out[f] = v;
    }
    try {
      return JSON.stringify(out);
    } catch {
      return String(out);
    }
  }
  function makeSignatureChannel(sourceLabel, path, opts) {
    const mode = opts.mode ?? "auto";
    function computeSig(whole) {
      const base = whole;
      const value = path ? getAtPath(base, path) : base;
      const sig = /* @__PURE__ */ new Map();
      if (value == null) return { sig, keys: [] };
      if ((mode === "array" || mode === "auto" && Array.isArray(value)) && Array.isArray(value)) {
        for (let i = 0; i < value.length; i++) {
          const item = value[i];
          const key2 = opts.key ? opts.key(item, i, whole) : i;
          const s = opts.sig ? opts.sig(item, i, whole) : opts.fields ? stablePick(item, opts.fields) : (() => {
            try {
              return JSON.stringify(item);
            } catch {
              return String(item);
            }
          })();
          sig.set(key2, s);
        }
      } else {
        for (const [k, item] of Object.entries(value)) {
          const key2 = opts.key ? opts.key(item, k, whole) : k;
          const s = opts.sig ? opts.sig(item, k, whole) : opts.fields ? stablePick(item, opts.fields) : (() => {
            try {
              return JSON.stringify(item);
            } catch {
              return String(item);
            }
          })();
          sig.set(key2, s);
        }
      }
      return { sig, keys: Array.from(sig.keys()) };
    }
    function mapEqual(a, b) {
      if (a === b) return true;
      if (!a || !b || a.size !== b.size) return false;
      for (const [k, v] of a) if (b.get(k) !== v) return false;
      return true;
    }
    async function sub(cb) {
      let prevSig = null;
      return Store.subscribeImmediate(sourceLabel, (src) => {
        const whole = path ? getAtPath(src, path) : src;
        const { sig } = computeSig(whole);
        if (!mapEqual(prevSig, sig)) {
          const allKeys = /* @__PURE__ */ new Set([
            ...prevSig ? Array.from(prevSig.keys()) : [],
            ...Array.from(sig.keys())
          ]);
          const changed = [];
          for (const k of allKeys) if ((prevSig?.get(k) ?? "__NONE__") !== (sig.get(k) ?? "__NONE__")) changed.push(k);
          prevSig = sig;
          cb({ value: whole, changedKeys: changed });
        }
      });
    }
    async function subKey(key2, cb) {
      let last = "__INIT__";
      return sub(({ value, changedKeys }) => {
        if (changedKeys.includes(key2)) cb({ value });
      });
    }
    async function subKeys(keys, cb) {
      const wanted = new Set(keys);
      return sub(({ value, changedKeys }) => {
        const hit = changedKeys.filter((k) => wanted.has(k));
        if (hit.length) cb({ value, changedKeys: hit });
      });
    }
    return { sub, subKey, subKeys };
  }
  function makeAtom(label2) {
    return makeView(label2);
  }
  var eq, HubEq;
  var init_hub = __esm({
    "src/store/hub.ts"() {
      init_api();
      eq = {
        shallow(a, b) {
          if (Object.is(a, b)) return true;
          if (!a || !b || typeof a !== "object" || typeof b !== "object") return false;
          const ka = Object.keys(a);
          const kb = Object.keys(b);
          if (ka.length !== kb.length) return false;
          for (const k of ka) if (!Object.is(a[k], b[k])) return false;
          return true;
        },
        idSet(a, b) {
          if (a === b) return true;
          if (!Array.isArray(a) || !Array.isArray(b) || a.length !== b.length) return false;
          const sa = new Set(a);
          for (const id of b) if (!sa.has(id)) return false;
          return true;
        }
      };
      HubEq = eq;
    }
  });

  // src/store/atoms.ts
  function slotSig(o) {
    if (!o) return "\u2205";
    return [
      o.objectType ?? o.type ?? "",
      o.species ?? o.seedSpecies ?? o.plantSpecies ?? o.eggId ?? o.decorId ?? "",
      o.plantedAt ?? o.startTime ?? 0,
      o.maturedAt ?? o.endTime ?? 0
    ].join("|");
  }
  function activePetSig(p) {
    const s = p?.slot ?? {};
    const muts = Array.isArray(s.mutations) ? s.mutations.slice().sort().join(",") : "";
    const ab = Array.isArray(s.abilities) ? s.abilities.slice().sort().join(",") : "";
    const name = s.name ?? "";
    const species = s.petSpecies ?? "";
    const xp = Number.isFinite(s.xp) ? Math.round(s.xp) : 0;
    const hunger = Number.isFinite(s.hunger) ? Math.round(s.hunger * 1e3) : 0;
    const scale = Number.isFinite(s.targetScale) ? Math.round(s.targetScale * 1e3) : 0;
    const x = Number.isFinite(p?.position?.x) ? Math.round(p.position.x) : 0;
    const y = Number.isFinite(p?.position?.y) ? Math.round(p.position.y) : 0;
    return `${species}|${name}|xp:${xp}|hg:${hunger}|sc:${scale}|m:${muts}|a:${ab}|pos:${x},${y}`;
  }
  function activePetStableSig(p) {
    const s = p?.slot ?? {};
    const muts = Array.isArray(s.mutations) ? s.mutations.slice().sort().join(",") : "";
    const ab = Array.isArray(s.abilities) ? s.abilities.slice().sort().join(",") : "";
    const name = s.name ?? "";
    const species = s.petSpecies ?? "";
    const scale = Number.isFinite(s.targetScale) ? Math.round(s.targetScale * 1e3) : 0;
    return `${species}|${name}|sc:${scale}|m:${muts}|a:${ab}`;
  }
  function onFavoriteIds(cb) {
    return favoriteIds.onChange((next) => cb(Array.isArray(next) ? next : []), HubEq.idSet);
  }
  async function onFavoriteIdsNow(cb) {
    cb(Array.isArray(await favoriteIds.get()) ? await favoriteIds.get() : []);
    return onFavoriteIds(cb);
  }
  function activePetsStructuralEq(a, b) {
    const snap = (st) => {
      const m = /* @__PURE__ */ new Map();
      const arr = Array.isArray(st) ? st : [];
      for (const it of arr) {
        const id = String(it?.slot?.id ?? "");
        if (id) m.set(id, activePetStableSig(it));
      }
      return m;
    };
    const A = snap(a);
    const B = snap(b);
    if (A.size !== B.size) return false;
    for (const [k, v] of A) if (B.get(k) !== v) return false;
    return true;
  }
  async function onActivePetsStructuralChangeNow(cb) {
    cb(await myPetInfos.get());
    return myPetInfos.onChange(cb, activePetsStructuralEq);
  }
  async function getFavoriteIdSet() {
    const arr = await favoriteIds.get();
    return new Set(Array.isArray(arr) ? arr : []);
  }
  var position, state, map, player, action, myData, myInventory, gardensWithBackfills, myCropInventory, mySeedInventory, myToolInventory, myEggInventory, myDecorInventory, mySeedSiloItems, myDecorShedItems, myPetInfos, myPetSlotInfos, totalPetSellPrice, expandedPetSlotId, myCropItemsToSell, myPetHutchPetItems, isMyInventoryAtMaxLength, myNumPetHutchItems, shops, myShopPurchases, numPlayers, totalCropSellPrice, myValidatedSelectedItemIndex, setSelectedIndexToEnd, mySelectedItemName, myPossiblyNoLongerValidSelectedItemIndex, myCurrentGardenObject, myCurrentSortedGrowSlotIndices, myCurrentGrowSlotIndex, myOwnCurrentGardenObject, isCurrentGrowSlotMature, myOwnCurrentDirtTileIndex, mySelectedItemRotation, weather, activeModal, avatarTriggerAnimationAtom, friendBonusMultiplier, garden, gardenTileObjects, favoriteIds, playerId, playerDatabaseUserId, myOwnCurrentGardenObjectType, stateChild, stateChildData, stateShops, stateUserSlots, statePlayers, myActivityLog, seedShop, toolShop, eggShop, decorShop, GardenSlotsSig, PetsByIdSig, PetsByIdStableSig, FavoriteIdsSig, Atoms;
  var init_atoms = __esm({
    "src/store/atoms.ts"() {
      init_hub();
      position = makeAtom("positionAtom");
      state = makeAtom("stateAtom");
      map = makeAtom("mapAtom");
      player = makeAtom("playerAtom");
      action = makeAtom("actionAtom");
      myData = makeAtom("myDataAtom");
      myInventory = makeAtom("myInventoryAtom");
      gardensWithBackfills = makeAtom("gardensWithBackfillsAtom");
      myCropInventory = makeAtom("myCropInventoryAtom");
      mySeedInventory = makeAtom("mySeedInventoryAtom");
      myToolInventory = makeAtom("myToolInventoryAtom");
      myEggInventory = makeAtom("myEggInventoryAtom");
      myDecorInventory = makeAtom("myDecorInventoryAtom");
      mySeedSiloItems = makeAtom("mySeedSiloItemsAtom");
      myDecorShedItems = makeAtom("myDecorShedItemsAtom");
      myPetInfos = makeAtom("myPetInfosAtom");
      myPetSlotInfos = makeAtom("myPetSlotInfosAtom");
      totalPetSellPrice = makeAtom("totalPetSellPriceAtom");
      expandedPetSlotId = makeAtom("expandedPetSlotIdAtom");
      myCropItemsToSell = makeAtom("myCropItemsToSellAtom");
      myPetHutchPetItems = makeAtom("myPetHutchPetItemsAtom");
      isMyInventoryAtMaxLength = makeAtom("isMyInventoryAtMaxLengthAtom");
      myNumPetHutchItems = makeAtom("myNumPetHutchItemsAtom");
      shops = makeAtom("shopsAtom");
      myShopPurchases = makeAtom("myShopPurchasesAtom");
      numPlayers = makeAtom("numPlayersAtom");
      totalCropSellPrice = makeAtom("totalCropSellPriceAtom");
      myValidatedSelectedItemIndex = makeAtom("myValidatedSelectedItemIndexAtom");
      setSelectedIndexToEnd = makeAtom("setSelectedIndexToEndAtom");
      mySelectedItemName = makeAtom("mySelectedItemNameAtom");
      myPossiblyNoLongerValidSelectedItemIndex = makeAtom("myPossiblyNoLongerValidSelectedItemIndexAtom");
      myCurrentGardenObject = makeAtom("myCurrentGardenObjectAtom");
      myCurrentSortedGrowSlotIndices = makeAtom("myCurrentSortedGrowSlotIndicesAtom");
      myCurrentGrowSlotIndex = makeAtom("myCurrentGrowSlotIndexAtom");
      myOwnCurrentGardenObject = makeAtom("myOwnCurrentGardenObjectAtom");
      isCurrentGrowSlotMature = makeAtom("isCurrentGrowSlotMatureAtom");
      myOwnCurrentDirtTileIndex = makeAtom("myOwnCurrentDirtTileIndexAtom");
      mySelectedItemRotation = makeAtom("mySelectedItemRotationAtom");
      weather = makeAtom("weatherAtom");
      activeModal = makeAtom("activeModalAtom");
      avatarTriggerAnimationAtom = makeAtom("avatarTriggerAnimationAtom");
      friendBonusMultiplier = makeAtom("friendBonusMultiplierAtom");
      garden = makeView("myDataAtom", { path: "garden" });
      gardenTileObjects = makeView("myDataAtom", { path: "garden.tileObjects" });
      favoriteIds = makeView("myInventoryAtom", { path: "favoritedItemIds" });
      playerId = makeView("playerAtom", { path: "id" });
      playerDatabaseUserId = makeView("playerAtom", { path: "databaseUserId" });
      myOwnCurrentGardenObjectType = makeView("myOwnCurrentGardenObjectAtom", { path: "objectType" });
      stateChild = makeView("stateAtom", { path: "child" });
      stateChildData = makeView("stateAtom", { path: "child.data" });
      stateShops = makeView("stateAtom", { path: "child.data.shops" });
      stateUserSlots = makeView("stateAtom", { path: "child.data.userSlots" });
      statePlayers = makeView("stateAtom", { path: "data.players" });
      myActivityLog = makeView("myDataAtom", { path: "activityLogs" });
      seedShop = makeView("shopsAtom", { path: "seed" });
      toolShop = makeView("shopsAtom", { path: "tool" });
      eggShop = makeView("shopsAtom", { path: "egg" });
      decorShop = makeView("shopsAtom", { path: "decor" });
      GardenSlotsSig = gardenTileObjects.asSignature({
        mode: "record",
        key: (_item, key2) => Number(key2),
        sig: (item) => slotSig(item)
      });
      PetsByIdSig = myPetInfos.asSignature({
        mode: "array",
        key: (p) => String(p?.slot?.id ?? ""),
        sig: (p) => activePetSig(p)
      });
      PetsByIdStableSig = myPetInfos.asSignature({
        mode: "array",
        key: (p) => String(p?.slot?.id ?? ""),
        sig: (p) => activePetStableSig(p)
      });
      FavoriteIdsSig = favoriteIds.asSignature({
        mode: "array",
        key: (id) => String(id),
        sig: () => "1"
      });
      Atoms = {
        ui: { activeModal },
        server: { numPlayers, friendBonusMultiplier },
        player: {
          position,
          avatarTriggerAnimationAtom,
          player,
          action,
          playerId
        },
        garden: {
          myOwnCurrentGardenObject,
          isCurrentGrowSlotMature,
          myOwnCurrentGardenObjectType,
          myOwnCurrentDirtTileIndex,
          myCurrentGrowSlotIndex
        },
        root: { state, map },
        data: {
          myData,
          garden,
          gardensWithBackfills,
          gardenTileObjects,
          myCurrentGardenObject,
          myCurrentSortedGrowSlotIndices,
          myCurrentGrowSlotIndex,
          weather
        },
        inventory: {
          myInventory,
          myCropInventory,
          mySeedInventory,
          myToolInventory,
          myEggInventory,
          myDecorInventory,
          mySeedSiloItems,
          myDecorShedItems,
          favoriteIds,
          mySelectedItemName,
          mySelectedItemRotation,
          myPossiblyNoLongerValidSelectedItemIndex,
          myValidatedSelectedItemIndex,
          setSelectedIndexToEnd,
          myCropItemsToSell
        },
        pets: {
          myPetInfos,
          myPetSlotInfos,
          totalPetSellPrice,
          expandedPetSlotId
        },
        shop: {
          shops,
          myShopPurchases,
          totalCropSellPrice,
          seedShop,
          toolShop,
          eggShop,
          decorShop
        }
      };
    }
  });

  // src/services/fakeAtoms.ts
  function _atomsByExactLabel(label2) {
    try {
      return findAtomsByLabel(new RegExp("^" + label2 + "$"));
    } catch {
      return [];
    }
  }
  function _findReadKey(atom) {
    if (atom && typeof atom.read === "function") return "read";
    for (const k of Object.keys(atom || {})) {
      const v = atom[k];
      if (typeof v === "function" && k !== "write" && k !== "onMount" && k !== "toString") {
        const ar = v.length;
        if (ar === 1 || ar === 2) return k;
      }
    }
    throw new Error("Impossible de localiser la fonction read() de l'atom");
  }
  function _getState(label2) {
    return _fakeRegistry.get(label2) || null;
  }
  async function _forceRepaintViaGate(gate) {
    if (!gate?.closeAction || !gate?.openAction) return;
    await gate.closeAction();
    await new Promise((r) => setTimeout(r, 0));
    await gate.openAction();
  }
  async function _ensureFakeInstalled(config) {
    const key2 = config.label;
    const existing = _fakeRegistry.get(key2);
    if (existing?.installed) return existing;
    const atoms = _atomsByExactLabel(config.label);
    if (!atoms.length) {
      throw new Error(`${config.label} introuvable`);
    }
    const state3 = existing ?? {
      config,
      enabled: false,
      payload: null,
      patched: /* @__PURE__ */ new Map(),
      installed: false
    };
    let gateAtom = null;
    if (config.gate?.label) gateAtom = getAtomByLabel(config.gate.label);
    for (const a of atoms) {
      const readKey = _findReadKey(a);
      const orig = a[readKey];
      a[readKey] = (get3) => {
        try {
          if (gateAtom) get3(gateAtom);
        } catch (err) {
        }
        for (const dep of config.extraDeps || []) {
          try {
            const d = getAtomByLabel(dep);
            d && get3(d);
          } catch (err) {
          }
        }
        const real = orig(get3);
        if (!state3.enabled || state3.payload == null) return real;
        return config.merge ? config.merge(real, state3.payload) : state3.payload;
      };
      state3.patched.set(a, { readKey, orig });
    }
    if (gateAtom && config.gate?.autoDisableOnClose) {
      state3.unsubGate = await jSub(gateAtom, async () => {
        let v;
        try {
          v = await jGet(gateAtom);
        } catch (err) {
          v = null;
        }
        const isOpen = config.gate?.isOpen ? config.gate.isOpen(v) : !!v;
        if (!isOpen && state3.enabled) state3.enabled = false;
      });
    }
    state3.installed = true;
    _fakeRegistry.set(key2, state3);
    return state3;
  }
  async function fakeShow(config, payload, options) {
    await ensureStore();
    const st = await _ensureFakeInstalled(config);
    st.payload = payload;
    st.enabled = true;
    if (options?.merge && !config.merge) {
      config.merge = (_real, fake) => fake;
    }
    if (options?.openGate && config.gate?.openAction) await config.gate.openAction();
    if (st.autoTimer) {
      clearTimeout(st.autoTimer);
      st.autoTimer = null;
    }
    if (options?.autoRestoreMs && options.autoRestoreMs > 0) {
      st.autoTimer = setTimeout(() => {
        void fakeHide(config.label);
      }, options.autoRestoreMs);
    }
  }
  async function fakeHide(label2) {
    const st = _getState(label2);
    if (!st) return;
    st.enabled = false;
    st.payload = null;
    if (st.autoTimer) {
      clearTimeout(st.autoTimer);
      st.autoTimer = null;
    }
    await _forceRepaintViaGate(st.config.gate);
  }
  var _fakeRegistry;
  var init_fakeAtoms = __esm({
    "src/services/fakeAtoms.ts"() {
      init_jotai();
      _fakeRegistry = /* @__PURE__ */ new Map();
    }
  });

  // src/services/fakeModal.ts
  var fakeModal_exports = {};
  __export(fakeModal_exports, {
    ACTIVITY_LOG_MODAL_ID: () => ACTIVITY_LOG_MODAL_ID,
    JOURNAL_MODAL_ID: () => JOURNAL_MODAL_ID,
    STATS_MODAL_ID: () => STATS_MODAL_ID,
    closeActivityLogModal: () => closeActivityLogModal,
    closeInventoryPanel: () => closeInventoryPanel,
    closeJournalModal: () => closeJournalModal,
    closeModal: () => closeModal,
    closeStatsModal: () => closeStatsModal,
    fakeActivityLogHide: () => fakeActivityLogHide,
    fakeActivityLogShow: () => fakeActivityLogShow,
    fakeInventoryHide: () => fakeInventoryHide,
    fakeInventoryShow: () => fakeInventoryShow,
    fakeJournalHide: () => fakeJournalHide,
    fakeJournalShow: () => fakeJournalShow,
    fakeModalHide: () => fakeModalHide,
    fakeModalShow: () => fakeModalShow,
    fakeStatsHide: () => fakeStatsHide,
    fakeStatsShow: () => fakeStatsShow,
    isActivityLogModalOpen: () => isActivityLogModalOpen,
    isActivityLogModalOpenAsync: () => isActivityLogModalOpenAsync,
    isInventoryOpen: () => isInventoryOpen,
    isInventoryPanelOpen: () => isInventoryPanelOpen,
    isJournalModalOpen: () => isJournalModalOpen,
    isJournalOpen: () => isJournalOpen,
    isModalOpen: () => isModalOpen,
    isModalOpenAsync: () => isModalOpenAsync,
    isStatsModalOpen: () => isStatsModalOpen,
    isStatsModalOpenAsync: () => isStatsModalOpenAsync,
    openActivityLogModal: () => openActivityLogModal,
    openInventoryPanel: () => openInventoryPanel,
    openJournalModal: () => openJournalModal,
    openModal: () => openModal,
    openStatsModal: () => openStatsModal,
    waitActivityLogModalClosed: () => waitActivityLogModalClosed,
    waitInventoryPanelClosed: () => waitInventoryPanelClosed,
    waitJournalModalClosed: () => waitJournalModalClosed,
    waitModalClosed: () => waitModalClosed,
    waitStatsModalClosed: () => waitStatsModalClosed
  });
  async function openModal(modalId) {
    try {
      await Atoms.ui.activeModal.set(modalId);
    } catch (err) {
    }
  }
  async function closeModal(_modalId) {
    try {
      await Atoms.ui.activeModal.set(null);
    } catch (err) {
    }
  }
  function isModalOpen(value, modalId) {
    return value === modalId;
  }
  async function isModalOpenAsync(modalId) {
    try {
      const v = await Atoms.ui.activeModal.get();
      return isModalOpen(v, modalId);
    } catch (err) {
      return false;
    }
  }
  async function waitModalClosed(modalId, timeoutMs = 12e4) {
    const t0 = performance.now();
    while (performance.now() - t0 < timeoutMs) {
      try {
        const v = await Atoms.ui.activeModal.get();
        if (!isModalOpen(v, modalId)) return true;
      } catch {
        return true;
      }
      await new Promise((r) => setTimeout(r, 80));
    }
    return false;
  }
  function gateForModal(modalId) {
    return {
      label: Atoms.ui.activeModal.label,
      isOpen: (v) => isModalOpen(v, modalId),
      openAction: () => openModal(modalId),
      closeAction: () => closeModal(modalId),
      autoDisableOnClose: true
    };
  }
  function withModalGate(cfg, modalId) {
    return { ...cfg, gate: gateForModal(modalId) };
  }
  async function fakeModalShow(modalId, payload, configs, opts) {
    const shouldOpen = opts?.open !== false;
    for (const baseCfg of configs) {
      const cfg = withModalGate(baseCfg, modalId);
      await fakeShow(cfg, payload, {
        openGate: false,
        autoRestoreMs: opts?.autoRestoreMs
      });
    }
    if (shouldOpen) await openModal(modalId);
  }
  async function fakeModalHide(_modalId, configs) {
    for (const cfg of configs) {
      try {
        await fakeHide(cfg.label);
      } catch (err) {
      }
    }
  }
  async function openInventoryPanel() {
    return openModal(INVENTORY_MODAL_ID);
  }
  async function closeInventoryPanel() {
    return closeModal(INVENTORY_MODAL_ID);
  }
  function isInventoryOpen(v) {
    return isModalOpen(v, INVENTORY_MODAL_ID);
  }
  async function isInventoryPanelOpen() {
    return isModalOpenAsync(INVENTORY_MODAL_ID);
  }
  async function waitInventoryPanelClosed(timeoutMs = 12e4) {
    return waitModalClosed(INVENTORY_MODAL_ID, timeoutMs);
  }
  async function fakeInventoryShow(payload, opts) {
    const shouldOpen = opts?.open !== false;
    await fakeShow(SHARED_MYDATA_PATCH, { inventory: payload }, {
      openGate: false,
      autoRestoreMs: opts?.autoRestoreMs
    });
    await fakeShow(INVENTORY_ATOM_PATCH, payload, {
      openGate: false,
      autoRestoreMs: opts?.autoRestoreMs
    });
    if (shouldOpen) await openInventoryPanel();
  }
  async function fakeInventoryHide() {
    await fakeHide(INVENTORY_ATOM_PATCH.label);
    await fakeHide(SHARED_MYDATA_PATCH.label);
    await closeInventoryPanel();
  }
  async function openJournalModal() {
    return openModal(JOURNAL_MODAL_ID);
  }
  async function closeJournalModal() {
    return closeModal(JOURNAL_MODAL_ID);
  }
  function isJournalOpen(v) {
    return isModalOpen(v, JOURNAL_MODAL_ID);
  }
  async function isJournalModalOpen() {
    return isModalOpenAsync(JOURNAL_MODAL_ID);
  }
  async function waitJournalModalClosed(timeoutMs = 12e4) {
    return waitModalClosed(JOURNAL_MODAL_ID, timeoutMs);
  }
  async function fakeJournalShow(payload, opts) {
    const shouldOpen = opts?.open !== false;
    await fakeHide(INVENTORY_ATOM_PATCH.label);
    await fakeShow(SHARED_MYDATA_PATCH, { journal: payload ?? {} }, {
      openGate: false,
      autoRestoreMs: opts?.autoRestoreMs
    });
    if (shouldOpen) await openJournalModal();
  }
  async function fakeJournalHide() {
    await fakeHide(SHARED_MYDATA_PATCH.label);
    await closeJournalModal();
  }
  async function openStatsModal() {
    return openModal(STATS_MODAL_ID);
  }
  async function closeStatsModal() {
    return closeModal(STATS_MODAL_ID);
  }
  function isStatsModalOpen(v) {
    return isModalOpen(v, STATS_MODAL_ID);
  }
  async function isStatsModalOpenAsync() {
    return isModalOpenAsync(STATS_MODAL_ID);
  }
  async function waitStatsModalClosed(timeoutMs = 12e4) {
    return waitModalClosed(STATS_MODAL_ID, timeoutMs);
  }
  async function fakeStatsShow(payload, opts) {
    const shouldOpen = opts?.open !== false;
    await fakeShow(SHARED_MYDATA_PATCH, { stats: payload ?? {} }, {
      openGate: false,
      autoRestoreMs: opts?.autoRestoreMs
    });
    if (shouldOpen) await openStatsModal();
  }
  async function fakeStatsHide() {
    await fakeHide(SHARED_MYDATA_PATCH.label);
    await closeStatsModal();
  }
  async function openActivityLogModal() {
    return openModal(ACTIVITY_LOG_MODAL_ID);
  }
  async function closeActivityLogModal() {
    return closeModal(ACTIVITY_LOG_MODAL_ID);
  }
  function isActivityLogModalOpen(v) {
    return isModalOpen(v, ACTIVITY_LOG_MODAL_ID);
  }
  async function isActivityLogModalOpenAsync() {
    return isModalOpenAsync(ACTIVITY_LOG_MODAL_ID);
  }
  async function waitActivityLogModalClosed(timeoutMs = 12e4) {
    return waitModalClosed(ACTIVITY_LOG_MODAL_ID, timeoutMs);
  }
  async function fakeActivityLogShow(payload, opts) {
    const shouldOpen = opts?.open !== false;
    await fakeShow(SHARED_MYDATA_PATCH, { activityLogs: payload ?? [] }, {
      openGate: false,
      autoRestoreMs: opts?.autoRestoreMs
    });
    if (shouldOpen) await openActivityLogModal();
  }
  async function fakeActivityLogHide() {
    await fakeHide(SHARED_MYDATA_PATCH.label);
    await closeActivityLogModal();
  }
  var mergeMyData, SHARED_MYDATA_PATCH, INVENTORY_ATOM_PATCH, INVENTORY_MODAL_ID, JOURNAL_MODAL_ID, STATS_MODAL_ID, ACTIVITY_LOG_MODAL_ID;
  var init_fakeModal = __esm({
    "src/services/fakeModal.ts"() {
      init_fakeAtoms();
      init_atoms();
      mergeMyData = (real, patch2) => {
        const base = real && typeof real === "object" ? real : {};
        const add = patch2 && typeof patch2 === "object" ? patch2 : {};
        return { ...base, ...add };
      };
      SHARED_MYDATA_PATCH = {
        label: Atoms.data.myData.label,
        merge: mergeMyData,
        gate: {
          label: Atoms.ui.activeModal.label,
          isOpen: (v) => v === "inventory" || v === "journal" || v === "stats" || v === "activityLog",
          autoDisableOnClose: true
        }
      };
      INVENTORY_ATOM_PATCH = {
        label: Atoms.inventory.myInventory.label,
        merge: (_real, fake) => fake,
        gate: {
          label: Atoms.ui.activeModal.label,
          isOpen: (v) => v === "inventory",
          autoDisableOnClose: true
        }
      };
      INVENTORY_MODAL_ID = "inventory";
      JOURNAL_MODAL_ID = "journal";
      STATS_MODAL_ID = "stats";
      ACTIVITY_LOG_MODAL_ID = "activityLog";
    }
  });

  // node_modules/emoji-picker-element/database.js
  function assertNonEmptyString(str) {
    if (typeof str !== "string" || !str) {
      throw new Error("expected a non-empty string, got: " + str);
    }
  }
  function assertNumber(number) {
    if (typeof number !== "number") {
      throw new Error("expected a number, got: " + number);
    }
  }
  function uniqBy(arr, func) {
    const set3 = /* @__PURE__ */ new Set();
    const res = [];
    for (const item of arr) {
      const key2 = func(item);
      if (!set3.has(key2)) {
        set3.add(key2);
        res.push(item);
      }
    }
    return res;
  }
  function uniqEmoji(emojis) {
    return uniqBy(emojis, (_) => _.unicode);
  }
  function initialMigration(db) {
    function createObjectStore(name, keyPath, indexes) {
      const store = keyPath ? db.createObjectStore(name, { keyPath }) : db.createObjectStore(name);
      if (indexes) {
        for (const [indexName, [keyPath2, multiEntry]] of Object.entries(indexes)) {
          store.createIndex(indexName, keyPath2, { multiEntry });
        }
      }
      return store;
    }
    createObjectStore(STORE_KEYVALUE);
    createObjectStore(
      STORE_EMOJI,
      /* keyPath */
      FIELD_UNICODE,
      {
        [INDEX_TOKENS]: [
          FIELD_TOKENS,
          /* multiEntry */
          true
        ],
        [INDEX_GROUP_AND_ORDER]: [[FIELD_GROUP, FIELD_ORDER]],
        [INDEX_SKIN_UNICODE]: [
          FIELD_SKIN_UNICODE,
          /* multiEntry */
          true
        ]
      }
    );
    createObjectStore(STORE_FAVORITES, void 0, {
      [INDEX_COUNT]: [""]
    });
  }
  function handleOpenOrDeleteReq(resolve2, reject, req) {
    req.onerror = () => reject(req.error);
    req.onblocked = () => reject(new Error("IDB blocked"));
    req.onsuccess = () => resolve2(req.result);
  }
  async function createDatabase(dbName) {
    const db = await new Promise((resolve2, reject) => {
      const req = indexedDB.open(dbName, DB_VERSION_CURRENT);
      openIndexedDBRequests[dbName] = req;
      req.onupgradeneeded = (e) => {
        if (e.oldVersion < DB_VERSION_INITIAL) {
          initialMigration(req.result);
        }
      };
      handleOpenOrDeleteReq(resolve2, reject, req);
    });
    db.onclose = () => closeDatabase(dbName);
    return db;
  }
  function openDatabase(dbName) {
    if (!databaseCache[dbName]) {
      databaseCache[dbName] = createDatabase(dbName);
    }
    return databaseCache[dbName];
  }
  function dbPromise(db, storeName, readOnlyOrReadWrite, cb) {
    return new Promise((resolve2, reject) => {
      const txn = db.transaction(storeName, readOnlyOrReadWrite, { durability: "relaxed" });
      const store = typeof storeName === "string" ? txn.objectStore(storeName) : storeName.map((name) => txn.objectStore(name));
      let res;
      cb(store, txn, (result) => {
        res = result;
      });
      txn.oncomplete = () => resolve2(res);
      txn.onerror = () => reject(txn.error);
    });
  }
  function closeDatabase(dbName) {
    const req = openIndexedDBRequests[dbName];
    const db = req && req.result;
    if (db) {
      db.close();
      const listeners5 = onCloseListeners[dbName];
      if (listeners5) {
        for (const listener of listeners5) {
          listener();
        }
      }
    }
    delete openIndexedDBRequests[dbName];
    delete databaseCache[dbName];
    delete onCloseListeners[dbName];
  }
  function deleteDatabase(dbName) {
    return new Promise((resolve2, reject) => {
      closeDatabase(dbName);
      const req = indexedDB.deleteDatabase(dbName);
      handleOpenOrDeleteReq(resolve2, reject, req);
    });
  }
  function addOnCloseListener(dbName, listener) {
    let listeners5 = onCloseListeners[dbName];
    if (!listeners5) {
      listeners5 = onCloseListeners[dbName] = [];
    }
    listeners5.push(listener);
  }
  function extractTokens(str) {
    return str.split(/[\s_]+/).map((word) => {
      if (!word.match(/\w/) || irregularEmoticons.has(word)) {
        return word.toLowerCase();
      }
      return word.replace(/[)(:,]/g, "").replace(//g, "'").toLowerCase();
    }).filter(Boolean);
  }
  function normalizeTokens(str) {
    return str.filter(Boolean).map((_) => _.toLowerCase()).filter((_) => _.length >= MIN_SEARCH_TEXT_LENGTH);
  }
  function transformEmojiData(emojiData) {
    const res = emojiData.map(({ annotation, emoticon, group, order, shortcodes, skins, tags, emoji, version }) => {
      const tokens = [...new Set(
        normalizeTokens([
          ...(shortcodes || []).map(extractTokens).flat(),
          ...(tags || []).map(extractTokens).flat(),
          ...extractTokens(annotation),
          emoticon
        ])
      )].sort();
      const res2 = {
        annotation,
        group,
        order,
        tags,
        tokens,
        unicode: emoji,
        version
      };
      if (emoticon) {
        res2.emoticon = emoticon;
      }
      if (shortcodes) {
        res2.shortcodes = shortcodes;
      }
      if (skins) {
        res2.skinTones = [];
        res2.skinUnicodes = [];
        res2.skinVersions = [];
        for (const { tone, emoji: emoji2, version: version2 } of skins) {
          res2.skinTones.push(tone);
          res2.skinUnicodes.push(emoji2);
          res2.skinVersions.push(version2);
        }
      }
      return res2;
    });
    return res;
  }
  function callStore(store, method, key2, cb) {
    store[method](key2).onsuccess = (e) => cb && cb(e.target.result);
  }
  function getIDB(store, key2, cb) {
    callStore(store, "get", key2, cb);
  }
  function getAllIDB(store, key2, cb) {
    callStore(store, "getAll", key2, cb);
  }
  function commit(txn) {
    if (txn.commit) {
      txn.commit();
    }
  }
  function minBy(array, func) {
    let minItem = array[0];
    for (let i = 1; i < array.length; i++) {
      const item = array[i];
      if (func(minItem) > func(item)) {
        minItem = item;
      }
    }
    return minItem;
  }
  function findCommonMembers(arrays, uniqByFunc) {
    const shortestArray = minBy(arrays, (_) => _.length);
    const results = [];
    for (const item of shortestArray) {
      if (!arrays.some((array) => array.findIndex((_) => uniqByFunc(_) === uniqByFunc(item)) === -1)) {
        results.push(item);
      }
    }
    return results;
  }
  async function isEmpty(db) {
    return !await get(db, STORE_KEYVALUE, KEY_URL);
  }
  async function hasData(db, url, eTag) {
    const [oldETag, oldUrl] = await Promise.all([KEY_ETAG, KEY_URL].map((key2) => get(db, STORE_KEYVALUE, key2)));
    return oldETag === eTag && oldUrl === url;
  }
  async function doFullDatabaseScanForSingleResult(db, predicate) {
    const BATCH_SIZE = 50;
    return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {
      let lastKey;
      const processNextBatch = () => {
        emojiStore.getAll(lastKey && IDBKeyRange.lowerBound(lastKey, true), BATCH_SIZE).onsuccess = (e) => {
          const results = e.target.result;
          for (const result of results) {
            lastKey = result.unicode;
            if (predicate(result)) {
              return cb(result);
            }
          }
          if (results.length < BATCH_SIZE) {
            return cb();
          }
          processNextBatch();
        };
      };
      processNextBatch();
    });
  }
  async function loadData(db, emojiData, url, eTag) {
    try {
      const transformedData = transformEmojiData(emojiData);
      await dbPromise(db, [STORE_EMOJI, STORE_KEYVALUE], MODE_READWRITE, ([emojiStore, metaStore], txn) => {
        let oldETag;
        let oldUrl;
        let todo = 0;
        function checkFetched() {
          if (++todo === 2) {
            onFetched();
          }
        }
        function onFetched() {
          if (oldETag === eTag && oldUrl === url) {
            return;
          }
          emojiStore.clear();
          for (const data of transformedData) {
            emojiStore.put(data);
          }
          metaStore.put(eTag, KEY_ETAG);
          metaStore.put(url, KEY_URL);
          commit(txn);
        }
        getIDB(metaStore, KEY_ETAG, (result) => {
          oldETag = result;
          checkFetched();
        });
        getIDB(metaStore, KEY_URL, (result) => {
          oldUrl = result;
          checkFetched();
        });
      });
    } finally {
    }
  }
  async function getEmojiByGroup(db, group) {
    return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {
      const range = IDBKeyRange.bound([group, 0], [group + 1, 0], false, true);
      getAllIDB(emojiStore.index(INDEX_GROUP_AND_ORDER), range, cb);
    });
  }
  async function getEmojiBySearchQuery(db, query) {
    const tokens = normalizeTokens(extractTokens(query));
    if (!tokens.length) {
      return [];
    }
    return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {
      const intermediateResults = [];
      const checkDone = () => {
        if (intermediateResults.length === tokens.length) {
          onDone();
        }
      };
      const onDone = () => {
        const results = findCommonMembers(intermediateResults, (_) => _.unicode);
        cb(results.sort((a, b) => a.order < b.order ? -1 : 1));
      };
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        const range = i === tokens.length - 1 ? IDBKeyRange.bound(token, token + "\uFFFF", false, true) : IDBKeyRange.only(token);
        getAllIDB(emojiStore.index(INDEX_TOKENS), range, (result) => {
          intermediateResults.push(result);
          checkDone();
        });
      }
    });
  }
  async function getEmojiByShortcode(db, shortcode) {
    const emojis = await getEmojiBySearchQuery(db, shortcode);
    if (!emojis.length) {
      const predicate = (_) => (_.shortcodes || []).includes(shortcode.toLowerCase());
      return await doFullDatabaseScanForSingleResult(db, predicate) || null;
    }
    return emojis.filter((_) => {
      const lowerShortcodes = (_.shortcodes || []).map((_2) => _2.toLowerCase());
      return lowerShortcodes.includes(shortcode.toLowerCase());
    })[0] || null;
  }
  async function getEmojiByUnicode(db, unicode) {
    return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => getIDB(emojiStore, unicode, (result) => {
      if (result) {
        return cb(result);
      }
      getIDB(emojiStore.index(INDEX_SKIN_UNICODE), unicode, (result2) => cb(result2 || null));
    }));
  }
  function get(db, storeName, key2) {
    return dbPromise(db, storeName, MODE_READONLY, (store, txn, cb) => getIDB(store, key2, cb));
  }
  function set2(db, storeName, key2, value) {
    return dbPromise(db, storeName, MODE_READWRITE, (store, txn) => {
      store.put(value, key2);
      commit(txn);
    });
  }
  function incrementFavoriteEmojiCount(db, unicode) {
    return dbPromise(db, STORE_FAVORITES, MODE_READWRITE, (store, txn) => getIDB(store, unicode, (result) => {
      store.put((result || 0) + 1, unicode);
      commit(txn);
    }));
  }
  function getTopFavoriteEmoji(db, customEmojiIndex2, limit) {
    if (limit === 0) {
      return [];
    }
    return dbPromise(db, [STORE_FAVORITES, STORE_EMOJI], MODE_READONLY, ([favoritesStore, emojiStore], txn, cb) => {
      const results = [];
      favoritesStore.index(INDEX_COUNT).openCursor(void 0, "prev").onsuccess = (e) => {
        const cursor = e.target.result;
        if (!cursor) {
          return cb(results);
        }
        function addResult(result) {
          results.push(result);
          if (results.length === limit) {
            return cb(results);
          }
          cursor.continue();
        }
        const unicodeOrName = cursor.primaryKey;
        const custom = customEmojiIndex2.byName(unicodeOrName);
        if (custom) {
          return addResult(custom);
        }
        getIDB(emojiStore, unicodeOrName, (emoji) => {
          if (emoji) {
            return addResult(emoji);
          }
          cursor.continue();
        });
      };
    });
  }
  function trie(arr, itemToTokens) {
    const map2 = /* @__PURE__ */ new Map();
    for (const item of arr) {
      const tokens = itemToTokens(item);
      for (const token of tokens) {
        let currentMap = map2;
        for (let i = 0; i < token.length; i++) {
          const char = token.charAt(i);
          let nextMap = currentMap.get(char);
          if (!nextMap) {
            nextMap = /* @__PURE__ */ new Map();
            currentMap.set(char, nextMap);
          }
          currentMap = nextMap;
        }
        let valuesAtCoda = currentMap.get(CODA_MARKER);
        if (!valuesAtCoda) {
          valuesAtCoda = [];
          currentMap.set(CODA_MARKER, valuesAtCoda);
        }
        valuesAtCoda.push(item);
      }
    }
    const search = (query, exact) => {
      let currentMap = map2;
      for (let i = 0; i < query.length; i++) {
        const char = query.charAt(i);
        const nextMap = currentMap.get(char);
        if (nextMap) {
          currentMap = nextMap;
        } else {
          return [];
        }
      }
      if (exact) {
        const results2 = currentMap.get(CODA_MARKER);
        return results2 || [];
      }
      const results = [];
      const queue = [currentMap];
      while (queue.length) {
        const currentMap2 = queue.shift();
        const entriesSortedByKey = [...currentMap2.entries()].sort((a, b) => a[0] < b[0] ? -1 : 1);
        for (const [key2, value] of entriesSortedByKey) {
          if (key2 === CODA_MARKER) {
            results.push(...value);
          } else {
            queue.push(value);
          }
        }
      }
      return results;
    };
    return search;
  }
  function assertCustomEmojis(customEmojis) {
    const isArray = customEmojis && Array.isArray(customEmojis);
    const firstItemIsFaulty = isArray && customEmojis.length && (!customEmojis[0] || requiredKeys$1.some((key2) => !(key2 in customEmojis[0])));
    if (!isArray || firstItemIsFaulty) {
      throw new Error("Custom emojis are in the wrong format");
    }
  }
  function customEmojiIndex(customEmojis) {
    assertCustomEmojis(customEmojis);
    const sortByName = (a, b) => a.name.toLowerCase() < b.name.toLowerCase() ? -1 : 1;
    const all = customEmojis.sort(sortByName);
    const emojiToTokens = (emoji) => {
      const set3 = /* @__PURE__ */ new Set();
      if (emoji.shortcodes) {
        for (const shortcode of emoji.shortcodes) {
          for (const token of extractTokens(shortcode)) {
            set3.add(token);
          }
        }
      }
      return set3;
    };
    const searchTrie = trie(customEmojis, emojiToTokens);
    const searchByExactMatch = (_) => searchTrie(_, true);
    const searchByPrefix = (_) => searchTrie(_, false);
    const search = (query) => {
      const tokens = extractTokens(query);
      const intermediateResults = tokens.map((token, i) => (i < tokens.length - 1 ? searchByExactMatch : searchByPrefix)(token));
      return findCommonMembers(intermediateResults, (_) => _.name).sort(sortByName);
    };
    const shortcodeToEmoji = /* @__PURE__ */ new Map();
    const nameToEmoji = /* @__PURE__ */ new Map();
    for (const customEmoji of customEmojis) {
      nameToEmoji.set(customEmoji.name.toLowerCase(), customEmoji);
      for (const shortcode of customEmoji.shortcodes || []) {
        shortcodeToEmoji.set(shortcode.toLowerCase(), customEmoji);
      }
    }
    const byShortcode = (shortcode) => shortcodeToEmoji.get(shortcode.toLowerCase());
    const byName = (name) => nameToEmoji.get(name.toLowerCase());
    return {
      all,
      search,
      byShortcode,
      byName
    };
  }
  function cleanEmoji(emoji) {
    if (!emoji) {
      return emoji;
    }
    if (isFirefoxContentScript) {
      emoji = structuredClone(emoji);
    }
    delete emoji.tokens;
    if (emoji.skinTones) {
      const len = emoji.skinTones.length;
      emoji.skins = Array(len);
      for (let i = 0; i < len; i++) {
        emoji.skins[i] = {
          tone: emoji.skinTones[i],
          unicode: emoji.skinUnicodes[i],
          version: emoji.skinVersions[i]
        };
      }
      delete emoji.skinTones;
      delete emoji.skinUnicodes;
      delete emoji.skinVersions;
    }
    return emoji;
  }
  function warnETag(eTag) {
    if (!eTag) {
      console.warn("emoji-picker-element is more efficient if the dataSource server exposes an ETag header.");
    }
  }
  function assertEmojiData(emojiData) {
    if (!emojiData || !Array.isArray(emojiData) || !emojiData[0] || typeof emojiData[0] !== "object" || requiredKeys.some((key2) => !(key2 in emojiData[0]))) {
      throw new Error("Emoji data is in the wrong format");
    }
  }
  function assertStatus(response, dataSource) {
    if (Math.floor(response.status / 100) !== 2) {
      throw new Error("Failed to fetch: " + dataSource + ":  " + response.status);
    }
  }
  async function getETag(dataSource) {
    const response = await fetch(dataSource, { method: "HEAD" });
    assertStatus(response, dataSource);
    const eTag = response.headers.get("etag");
    warnETag(eTag);
    return eTag;
  }
  async function getETagAndData(dataSource) {
    const response = await fetch(dataSource);
    assertStatus(response, dataSource);
    const eTag = response.headers.get("etag");
    warnETag(eTag);
    const emojiData = await response.json();
    assertEmojiData(emojiData);
    return [eTag, emojiData];
  }
  function arrayBufferToBinaryString(buffer) {
    var binary = "";
    var bytes = new Uint8Array(buffer);
    var length = bytes.byteLength;
    var i = -1;
    while (++i < length) {
      binary += String.fromCharCode(bytes[i]);
    }
    return binary;
  }
  function binaryStringToArrayBuffer(binary) {
    var length = binary.length;
    var buf = new ArrayBuffer(length);
    var arr = new Uint8Array(buf);
    var i = -1;
    while (++i < length) {
      arr[i] = binary.charCodeAt(i);
    }
    return buf;
  }
  async function jsonChecksum(object) {
    const inString = JSON.stringify(object);
    let inBuffer = binaryStringToArrayBuffer(inString);
    const outBuffer = await crypto.subtle.digest("SHA-1", inBuffer);
    const outBinString = arrayBufferToBinaryString(outBuffer);
    const res = btoa(outBinString);
    return res;
  }
  async function doCheckForUpdates(db, dataSource) {
    let emojiData;
    let eTag = await getETag(dataSource);
    if (!eTag) {
      const eTagAndData = await getETagAndData(dataSource);
      eTag = eTagAndData[0];
      emojiData = eTagAndData[1];
      if (!eTag) {
        eTag = await jsonChecksum(emojiData);
      }
    }
    if (await hasData(db, dataSource, eTag)) ;
    else {
      if (!emojiData) {
        const eTagAndData = await getETagAndData(dataSource);
        emojiData = eTagAndData[1];
      }
      await loadData(db, emojiData, dataSource, eTag);
    }
  }
  async function loadDataForFirstTime(db, dataSource) {
    let [eTag, emojiData] = await getETagAndData(dataSource);
    if (!eTag) {
      eTag = await jsonChecksum(emojiData);
    }
    await loadData(db, emojiData, dataSource, eTag);
  }
  async function checkForUpdates(db, dataSource) {
    try {
      await doCheckForUpdates(db, dataSource);
    } catch (err) {
      if (err.name !== "InvalidStateError") {
        throw err;
      }
    }
  }
  var DB_VERSION_CURRENT, DB_VERSION_INITIAL, STORE_EMOJI, STORE_KEYVALUE, STORE_FAVORITES, FIELD_TOKENS, INDEX_TOKENS, FIELD_UNICODE, INDEX_COUNT, FIELD_GROUP, FIELD_ORDER, INDEX_GROUP_AND_ORDER, KEY_ETAG, KEY_URL, KEY_PREFERRED_SKINTONE, MODE_READONLY, MODE_READWRITE, INDEX_SKIN_UNICODE, FIELD_SKIN_UNICODE, DEFAULT_DATA_SOURCE, DEFAULT_LOCALE, openIndexedDBRequests, databaseCache, onCloseListeners, irregularEmoticons, MIN_SEARCH_TEXT_LENGTH, CODA_MARKER, requiredKeys$1, isFirefoxContentScript, requiredKeys, Database;
  var init_database = __esm({
    "node_modules/emoji-picker-element/database.js"() {
      DB_VERSION_CURRENT = 1;
      DB_VERSION_INITIAL = 1;
      STORE_EMOJI = "emoji";
      STORE_KEYVALUE = "keyvalue";
      STORE_FAVORITES = "favorites";
      FIELD_TOKENS = "tokens";
      INDEX_TOKENS = "tokens";
      FIELD_UNICODE = "unicode";
      INDEX_COUNT = "count";
      FIELD_GROUP = "group";
      FIELD_ORDER = "order";
      INDEX_GROUP_AND_ORDER = "group-order";
      KEY_ETAG = "eTag";
      KEY_URL = "url";
      KEY_PREFERRED_SKINTONE = "skinTone";
      MODE_READONLY = "readonly";
      MODE_READWRITE = "readwrite";
      INDEX_SKIN_UNICODE = "skinUnicodes";
      FIELD_SKIN_UNICODE = "skinUnicodes";
      DEFAULT_DATA_SOURCE = "https://cdn.jsdelivr.net/npm/emoji-picker-element-data@^1/en/emojibase/data.json";
      DEFAULT_LOCALE = "en";
      openIndexedDBRequests = {};
      databaseCache = {};
      onCloseListeners = {};
      irregularEmoticons = /* @__PURE__ */ new Set([
        ":D",
        "XD",
        ":'D",
        "O:)",
        ":X",
        ":P",
        ";P",
        "XP",
        ":L",
        ":Z",
        ":j",
        "8D",
        "XO",
        "8)",
        ":B",
        ":O",
        ":S",
        ":'o",
        "Dx",
        "X(",
        "D:",
        ":C",
        ">0)",
        ":3",
        "</3",
        "<3",
        "\\M/",
        ":E",
        "8#"
      ]);
      MIN_SEARCH_TEXT_LENGTH = 2;
      CODA_MARKER = "";
      requiredKeys$1 = [
        "name",
        "url"
      ];
      isFirefoxContentScript = typeof wrappedJSObject !== "undefined";
      requiredKeys = [
        "annotation",
        "emoji",
        "group",
        "order",
        "version"
      ];
      Database = class {
        constructor({ dataSource = DEFAULT_DATA_SOURCE, locale = DEFAULT_LOCALE, customEmoji = [] } = {}) {
          this.dataSource = dataSource;
          this.locale = locale;
          this._dbName = `emoji-picker-element-${this.locale}`;
          this._db = void 0;
          this._lazyUpdate = void 0;
          this._custom = customEmojiIndex(customEmoji);
          this._clear = this._clear.bind(this);
          this._ready = this._init();
        }
        async _init() {
          const db = this._db = await openDatabase(this._dbName);
          addOnCloseListener(this._dbName, this._clear);
          const dataSource = this.dataSource;
          const empty = await isEmpty(db);
          if (empty) {
            await loadDataForFirstTime(db, dataSource);
          } else {
            this._lazyUpdate = checkForUpdates(db, dataSource);
          }
        }
        async ready() {
          const checkReady = async () => {
            if (!this._ready) {
              this._ready = this._init();
            }
            return this._ready;
          };
          await checkReady();
          if (!this._db) {
            await checkReady();
          }
        }
        async getEmojiByGroup(group) {
          assertNumber(group);
          await this.ready();
          return uniqEmoji(await getEmojiByGroup(this._db, group)).map(cleanEmoji);
        }
        async getEmojiBySearchQuery(query) {
          assertNonEmptyString(query);
          await this.ready();
          const customs = this._custom.search(query);
          const natives = uniqEmoji(await getEmojiBySearchQuery(this._db, query)).map(cleanEmoji);
          return [
            ...customs,
            ...natives
          ];
        }
        async getEmojiByShortcode(shortcode) {
          assertNonEmptyString(shortcode);
          await this.ready();
          const custom = this._custom.byShortcode(shortcode);
          if (custom) {
            return custom;
          }
          return cleanEmoji(await getEmojiByShortcode(this._db, shortcode));
        }
        async getEmojiByUnicodeOrName(unicodeOrName) {
          assertNonEmptyString(unicodeOrName);
          await this.ready();
          const custom = this._custom.byName(unicodeOrName);
          if (custom) {
            return custom;
          }
          return cleanEmoji(await getEmojiByUnicode(this._db, unicodeOrName));
        }
        async getPreferredSkinTone() {
          await this.ready();
          return await get(this._db, STORE_KEYVALUE, KEY_PREFERRED_SKINTONE) || 0;
        }
        async setPreferredSkinTone(skinTone) {
          assertNumber(skinTone);
          await this.ready();
          return set2(this._db, STORE_KEYVALUE, KEY_PREFERRED_SKINTONE, skinTone);
        }
        async incrementFavoriteEmojiCount(unicodeOrName) {
          assertNonEmptyString(unicodeOrName);
          await this.ready();
          return incrementFavoriteEmojiCount(this._db, unicodeOrName);
        }
        async getTopFavoriteEmoji(limit) {
          assertNumber(limit);
          await this.ready();
          return (await getTopFavoriteEmoji(this._db, this._custom, limit)).map(cleanEmoji);
        }
        set customEmoji(customEmojis) {
          this._custom = customEmojiIndex(customEmojis);
        }
        get customEmoji() {
          return this._custom.all;
        }
        async _shutdown() {
          await this.ready();
          try {
            await this._lazyUpdate;
          } catch (err) {
          }
        }
        // clear references to IDB, e.g. during a close event
        _clear() {
          this._db = this._ready = this._lazyUpdate = void 0;
        }
        async close() {
          await this._shutdown();
          await closeDatabase(this._dbName);
        }
        async delete() {
          await this._shutdown();
          await deleteDatabase(this._dbName);
        }
      };
    }
  });

  // node_modules/emoji-picker-element/picker.js
  function hasZwj(emoji) {
    return emoji.unicode.includes("\u200D");
  }
  function testColorEmojiSupported(text) {
    const feature1 = getTextFeature(text, "#000");
    const feature2 = getTextFeature(text, "#fff");
    return feature1 && feature2 && compareFeatures(feature1, feature2);
  }
  function determineEmojiSupportLevel() {
    const entries = Object.entries(versionsAndTestEmoji);
    try {
      for (const [emoji, version] of entries) {
        if (testColorEmojiSupported(emoji)) {
          return version;
        }
      }
    } catch (e) {
    } finally {
    }
    return entries[0][1];
  }
  function applySkinTone(str, skinTone) {
    if (skinTone === 0) {
      return str;
    }
    const zwjIndex = str.indexOf(ZWJ);
    if (zwjIndex !== -1) {
      return str.substring(0, zwjIndex) + String.fromCodePoint(LIGHT_SKIN_TONE + skinTone - 1) + str.substring(zwjIndex);
    }
    if (str.endsWith(VARIATION_SELECTOR)) {
      str = str.substring(0, str.length - 1);
    }
    return str + SKINTONE_MODIFIER + String.fromCodePoint(LIGHT_SKIN_TONE_MODIFIER + skinTone - 1);
  }
  function halt(event) {
    event.preventDefault();
    event.stopPropagation();
  }
  function incrementOrDecrement(decrement, val, arr) {
    val += decrement ? -1 : 1;
    if (val < 0) {
      val = arr.length - 1;
    } else if (val >= arr.length) {
      val = 0;
    }
    return val;
  }
  function uniqBy2(arr, func) {
    const set3 = /* @__PURE__ */ new Set();
    const res = [];
    for (const item of arr) {
      const key2 = func(item);
      if (!set3.has(key2)) {
        set3.add(key2);
        res.push(item);
      }
    }
    return res;
  }
  function summarizeEmojisForUI(emojis, emojiSupportLevel) {
    const toSimpleSkinsMap = (skins) => {
      const res = {};
      for (const skin of skins) {
        if (typeof skin.tone === "number" && skin.version <= emojiSupportLevel) {
          res[skin.tone] = skin.unicode;
        }
      }
      return res;
    };
    return emojis.map(({ unicode, skins, shortcodes, url, name, category, annotation }) => ({
      unicode,
      name,
      shortcodes,
      url,
      category,
      annotation,
      id: unicode || name,
      skins: skins && toSimpleSkinsMap(skins)
    }));
  }
  function resizeObserverAction(node, abortSignal, onUpdate) {
    let resizeObserver;
    if (resizeObserverSupported) {
      resizeObserver = new ResizeObserver(onUpdate);
      resizeObserver.observe(node);
    } else {
      rAF(onUpdate);
    }
    abortSignal.addEventListener("abort", () => {
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
    });
  }
  function calculateTextWidth(node) {
    {
      const range = document.createRange();
      range.selectNode(node.firstChild);
      return range.getBoundingClientRect().width;
    }
  }
  function checkZwjSupport(zwjEmojisToCheck, baselineEmoji, emojiToDomNode) {
    let allSupported = true;
    for (const emoji of zwjEmojisToCheck) {
      const domNode = emojiToDomNode(emoji);
      if (!domNode) {
        continue;
      }
      const emojiWidth = calculateTextWidth(domNode);
      if (typeof baselineEmojiWidth === "undefined") {
        baselineEmojiWidth = calculateTextWidth(baselineEmoji);
      }
      const supported = emojiWidth / 1.8 < baselineEmojiWidth;
      supportedZwjEmojis.set(emoji.unicode, supported);
      if (!supported) {
        allSupported = false;
      }
    }
    return allSupported;
  }
  function uniq(arr) {
    return uniqBy2(arr, (_) => _);
  }
  function resetScrollTopIfPossible(element) {
    if (element) {
      element.scrollTop = 0;
    }
  }
  function getFromMap(cache2, key2, func) {
    let cached = cache2.get(key2);
    if (!cached) {
      cached = func();
      cache2.set(key2, cached);
    }
    return cached;
  }
  function toString(value) {
    return "" + value;
  }
  function parseTemplate(htmlString) {
    const template = document.createElement("template");
    template.innerHTML = htmlString;
    return template;
  }
  function replaceChildren(parentNode, newChildren) {
    if (hasReplaceChildren) {
      parentNode.replaceChildren(...newChildren);
    } else {
      parentNode.innerHTML = "";
      parentNode.append(...newChildren);
    }
  }
  function doChildrenNeedRerender(parentNode, newChildren) {
    let oldChild = parentNode.firstChild;
    let oldChildrenCount = 0;
    while (oldChild) {
      const newChild = newChildren[oldChildrenCount];
      if (newChild !== oldChild) {
        return true;
      }
      oldChild = oldChild.nextSibling;
      oldChildrenCount++;
    }
    return oldChildrenCount !== newChildren.length;
  }
  function patchChildren(newChildren, instanceBinding) {
    const { targetNode } = instanceBinding;
    let { targetParentNode } = instanceBinding;
    let needsRerender = false;
    if (targetParentNode) {
      needsRerender = doChildrenNeedRerender(targetParentNode, newChildren);
    } else {
      needsRerender = true;
      instanceBinding.targetNode = void 0;
      instanceBinding.targetParentNode = targetParentNode = targetNode.parentNode;
    }
    if (needsRerender) {
      replaceChildren(targetParentNode, newChildren);
    }
  }
  function patch(expressions, instanceBindings) {
    for (const instanceBinding of instanceBindings) {
      const {
        targetNode,
        currentExpression,
        binding: {
          expressionIndex,
          attributeName,
          attributeValuePre,
          attributeValuePost
        }
      } = instanceBinding;
      const expression = expressions[expressionIndex];
      if (currentExpression === expression) {
        continue;
      }
      instanceBinding.currentExpression = expression;
      if (attributeName) {
        if (expression === null) {
          targetNode.removeAttribute(attributeName);
        } else {
          const newValue = attributeValuePre + toString(expression) + attributeValuePost;
          targetNode.setAttribute(attributeName, newValue);
        }
      } else {
        let newNode;
        if (Array.isArray(expression)) {
          patchChildren(expression, instanceBinding);
        } else if (expression instanceof Element) {
          newNode = expression;
          targetNode.replaceWith(newNode);
        } else {
          targetNode.nodeValue = toString(expression);
        }
        if (newNode) {
          instanceBinding.targetNode = newNode;
        }
      }
    }
  }
  function parse(tokens) {
    let htmlString = "";
    let withinTag = false;
    let withinAttribute = false;
    let elementIndexCounter = -1;
    const elementsToBindings = /* @__PURE__ */ new Map();
    const elementIndexes = [];
    let skipTokenChars = 0;
    for (let i = 0, len = tokens.length; i < len; i++) {
      const token = tokens[i];
      htmlString += token.slice(skipTokenChars);
      if (i === len - 1) {
        break;
      }
      for (let j = 0; j < token.length; j++) {
        const char = token.charAt(j);
        switch (char) {
          case "<": {
            const nextChar = token.charAt(j + 1);
            if (nextChar === "/") {
              elementIndexes.pop();
            } else {
              withinTag = true;
              elementIndexes.push(++elementIndexCounter);
            }
            break;
          }
          case ">": {
            withinTag = false;
            withinAttribute = false;
            break;
          }
          case "=": {
            withinAttribute = true;
            break;
          }
        }
      }
      const elementIndex = elementIndexes[elementIndexes.length - 1];
      const bindings = getFromMap(elementsToBindings, elementIndex, () => []);
      let attributeName;
      let attributeValuePre;
      let attributeValuePost;
      if (withinAttribute) {
        const attributePreMatch = /(\S+)="?([^"=]*)$/.exec(token);
        attributeName = attributePreMatch[1];
        attributeValuePre = attributePreMatch[2];
        const attributePostMatch = /^([^">]*)("?)/.exec(tokens[i + 1]);
        attributeValuePost = attributePostMatch[1];
        htmlString = htmlString.slice(0, -1 * attributePreMatch[0].length);
        skipTokenChars = attributePostMatch[0].length;
      } else {
        skipTokenChars = 0;
      }
      const binding = {
        attributeName,
        attributeValuePre,
        attributeValuePost,
        expressionIndex: i
      };
      bindings.push(binding);
      if (!withinTag && !withinAttribute) {
        htmlString += " ";
      }
    }
    const template = parseTemplate(htmlString);
    return {
      template,
      elementsToBindings
    };
  }
  function applyBindings(bindings, element, instanceBindings) {
    for (let i = 0; i < bindings.length; i++) {
      const binding = bindings[i];
      const targetNode = binding.attributeName ? element : element.firstChild;
      const instanceBinding = {
        binding,
        targetNode,
        targetParentNode: void 0,
        currentExpression: void 0
      };
      instanceBindings.push(instanceBinding);
    }
  }
  function traverseAndSetupBindings(rootElement, elementsToBindings) {
    const instanceBindings = [];
    let topLevelBindings;
    if (elementsToBindings.size === 1 && (topLevelBindings = elementsToBindings.get(0))) {
      applyBindings(topLevelBindings, rootElement, instanceBindings);
    } else {
      const treeWalker = document.createTreeWalker(rootElement, NodeFilter.SHOW_ELEMENT);
      let element = rootElement;
      let elementIndex = -1;
      do {
        const bindings = elementsToBindings.get(++elementIndex);
        if (bindings) {
          applyBindings(bindings, element, instanceBindings);
        }
      } while (element = treeWalker.nextNode());
    }
    return instanceBindings;
  }
  function parseHtml(tokens) {
    const { template, elementsToBindings } = getFromMap(parseCache, tokens, () => parse(tokens));
    const dom = template.cloneNode(true).content.firstElementChild;
    const instanceBindings = traverseAndSetupBindings(dom, elementsToBindings);
    return function updateDomInstance(expressions) {
      patch(expressions, instanceBindings);
      return dom;
    };
  }
  function createFramework(state3) {
    const domInstances = getFromMap(domInstancesCache, state3, () => /* @__PURE__ */ new Map());
    let domInstanceCacheKey = unkeyedSymbol;
    function html(tokens, ...expressions) {
      const domInstancesForTokens = getFromMap(domInstances, tokens, () => /* @__PURE__ */ new Map());
      const updateDomInstance = getFromMap(domInstancesForTokens, domInstanceCacheKey, () => parseHtml(tokens));
      return updateDomInstance(expressions);
    }
    function map2(array, callback, keyFunction) {
      return array.map((item, index) => {
        const originalCacheKey = domInstanceCacheKey;
        domInstanceCacheKey = keyFunction(item);
        try {
          return callback(item, index);
        } finally {
          domInstanceCacheKey = originalCacheKey;
        }
      });
    }
    return { map: map2, html };
  }
  function render(container, state3, helpers, events, actions, refs, abortSignal, actionContext, firstRender) {
    const { labelWithSkin, titleForEmoji, unicodeWithSkin } = helpers;
    const { html, map: map2 } = createFramework(state3);
    function emojiList(emojis, searchMode, prefix) {
      return map2(emojis, (emoji, i) => {
        return html`<button role="${searchMode ? "option" : "menuitem"}" aria-selected="${searchMode ? i === state3.activeSearchItem : null}" aria-label="${labelWithSkin(emoji, state3.currentSkinTone)}" title="${titleForEmoji(emoji)}" class="${"emoji" + (searchMode && i === state3.activeSearchItem ? " active" : "") + (emoji.unicode ? "" : " custom-emoji")}" id="${`${prefix}-${emoji.id}`}" style="${emoji.unicode ? null : `--custom-emoji-background: url(${JSON.stringify(emoji.url)})`}">${emoji.unicode ? unicodeWithSkin(emoji, state3.currentSkinTone) : ""}</button>`;
      }, (emoji) => `${prefix}-${emoji.id}`);
    }
    const section = () => {
      return html`<section data-ref="rootElement" class="picker" aria-label="${state3.i18n.regionLabel}" style="${state3.pickerStyle || ""}"><div class="pad-top"></div><div class="search-row"><div class="search-wrapper"><input id="search" class="search" type="search" role="combobox" enterkeyhint="search" placeholder="${state3.i18n.searchLabel}" autocapitalize="none" autocomplete="off" spellcheck="true" aria-expanded="${!!(state3.searchMode && state3.currentEmojis.length)}" aria-controls="search-results" aria-describedby="search-description" aria-autocomplete="list" aria-activedescendant="${state3.activeSearchItemId ? `emo-${state3.activeSearchItemId}` : null}" data-ref="searchElement" data-on-input="onSearchInput" data-on-keydown="onSearchKeydown"><label class="sr-only" for="search">${state3.i18n.searchLabel}</label> <span id="search-description" class="sr-only">${state3.i18n.searchDescription}</span></div><div class="skintone-button-wrapper ${state3.skinTonePickerExpandedAfterAnimation ? "expanded" : ""}"><button id="skintone-button" class="emoji ${state3.skinTonePickerExpanded ? "hide-focus" : ""}" aria-label="${state3.skinToneButtonLabel}" title="${state3.skinToneButtonLabel}" aria-describedby="skintone-description" aria-haspopup="listbox" aria-expanded="${state3.skinTonePickerExpanded}" aria-controls="skintone-list" data-on-click="onClickSkinToneButton">${state3.skinToneButtonText || ""}</button></div><span id="skintone-description" class="sr-only">${state3.i18n.skinToneDescription}</span><div data-ref="skinToneDropdown" id="skintone-list" class="skintone-list hide-focus ${state3.skinTonePickerExpanded ? "" : "hidden no-animate"}" style="transform:translateY(${state3.skinTonePickerExpanded ? 0 : "calc(-1 * var(--num-skintones) * var(--total-emoji-size))"})" role="listbox" aria-label="${state3.i18n.skinTonesLabel}" aria-activedescendant="skintone-${state3.activeSkinTone}" aria-hidden="${!state3.skinTonePickerExpanded}" tabIndex="-1" data-on-focusout="onSkinToneOptionsFocusOut" data-on-click="onSkinToneOptionsClick" data-on-keydown="onSkinToneOptionsKeydown" data-on-keyup="onSkinToneOptionsKeyup">${map2(state3.skinTones, (skinTone, i) => {
        return html`<div id="skintone-${i}" class="emoji ${i === state3.activeSkinTone ? "active" : ""}" aria-selected="${i === state3.activeSkinTone}" role="option" title="${state3.i18n.skinTones[i]}" aria-label="${state3.i18n.skinTones[i]}">${skinTone}</div>`;
      }, (skinTone) => skinTone)}</div></div><div class="nav" role="tablist" style="grid-template-columns:repeat(${state3.groups.length},1fr)" aria-label="${state3.i18n.categoriesLabel}" data-on-keydown="onNavKeydown" data-on-click="onNavClick">${map2(state3.groups, (group) => {
        return html`<button role="tab" class="nav-button" aria-controls="tab-${group.id}" aria-label="${state3.i18n.categories[group.name]}" aria-selected="${!state3.searchMode && state3.currentGroup.id === group.id}" title="${state3.i18n.categories[group.name]}" data-group-id="${group.id}"><div class="nav-emoji emoji">${group.emoji}</div></button>`;
      }, (group) => group.id)}</div><div class="indicator-wrapper"><div class="indicator" style="transform:translateX(${/* istanbul ignore next */
      (state3.isRtl ? -1 : 1) * state3.currentGroupIndex * 100}%)"></div></div><div class="message ${state3.message ? "" : "gone"}" role="alert" aria-live="polite">${state3.message || ""}</div><div data-ref="tabpanelElement" class="tabpanel ${!state3.databaseLoaded || state3.message ? "gone" : ""}" role="${state3.searchMode ? "region" : "tabpanel"}" aria-label="${state3.searchMode ? state3.i18n.searchResultsLabel : state3.i18n.categories[state3.currentGroup.name]}" id="${state3.searchMode ? null : `tab-${state3.currentGroup.id}`}" tabIndex="0" data-on-click="onEmojiClick"><div data-action="calculateEmojiGridStyle">${map2(state3.currentEmojisWithCategories, (emojiWithCategory, i) => {
        return html`<div><div id="menu-label-${i}" class="category ${state3.currentEmojisWithCategories.length === 1 && state3.currentEmojisWithCategories[0].category === "" ? "gone" : ""}" aria-hidden="true">${state3.searchMode ? state3.i18n.searchResultsLabel : emojiWithCategory.category ? emojiWithCategory.category : state3.currentEmojisWithCategories.length > 1 ? state3.i18n.categories.custom : state3.i18n.categories[state3.currentGroup.name]}</div><div class="emoji-menu ${i !== 0 && !state3.searchMode && state3.currentGroup.id === -1 ? "visibility-auto" : ""}" style="${`--num-rows: ${Math.ceil(emojiWithCategory.emojis.length / state3.numColumns)}`}" data-action="updateOnIntersection" role="${state3.searchMode ? "listbox" : "menu"}" aria-labelledby="menu-label-${i}" id="${state3.searchMode ? "search-results" : null}">${emojiList(
          emojiWithCategory.emojis,
          state3.searchMode,
          /* prefix */
          "emo"
        )}</div></div>`;
      }, (emojiWithCategory) => emojiWithCategory.category)}</div></div><div class="favorites onscreen emoji-menu ${state3.message ? "gone" : ""}" role="menu" aria-label="${state3.i18n.favoritesLabel}" data-on-click="onEmojiClick">${emojiList(
        state3.currentFavorites,
        /* searchMode */
        false,
        /* prefix */
        "fav"
      )}</div><button data-ref="baselineEmoji" aria-hidden="true" tabindex="-1" class="abs-pos hidden emoji baseline-emoji"></button></section>`;
    };
    const rootDom = section();
    const forElementWithAttribute = (attributeName, callback) => {
      for (const element of container.querySelectorAll(`[${attributeName}]`)) {
        callback(element, element.getAttribute(attributeName));
      }
    };
    if (firstRender) {
      container.appendChild(rootDom);
      for (const eventName of ["click", "focusout", "input", "keydown", "keyup"]) {
        forElementWithAttribute(`data-on-${eventName}`, (element, listenerName) => {
          element.addEventListener(eventName, events[listenerName]);
        });
      }
      forElementWithAttribute("data-ref", (element, ref) => {
        refs[ref] = element;
      });
      abortSignal.addEventListener("abort", () => {
        container.removeChild(rootDom);
      });
    }
    forElementWithAttribute("data-action", (element, action2) => {
      let boundActions = actionContext.get(action2);
      if (!boundActions) {
        actionContext.set(action2, boundActions = /* @__PURE__ */ new WeakSet());
      }
      if (!boundActions.has(element)) {
        boundActions.add(element);
        actions[action2](element);
      }
    });
  }
  function createState(abortSignal) {
    let destroyed = false;
    let currentObserver;
    const propsToObservers = /* @__PURE__ */ new Map();
    const dirtyObservers = /* @__PURE__ */ new Set();
    let queued;
    const flush = () => {
      if (destroyed) {
        return;
      }
      const observersToRun = [...dirtyObservers];
      dirtyObservers.clear();
      try {
        for (const observer2 of observersToRun) {
          observer2();
        }
      } finally {
        queued = false;
        if (dirtyObservers.size) {
          queued = true;
          qM(flush);
        }
      }
    };
    const state3 = new Proxy({}, {
      get(target, prop) {
        if (currentObserver) {
          let observers = propsToObservers.get(prop);
          if (!observers) {
            observers = /* @__PURE__ */ new Set();
            propsToObservers.set(prop, observers);
          }
          observers.add(currentObserver);
        }
        return target[prop];
      },
      set(target, prop, newValue) {
        if (target[prop] !== newValue) {
          target[prop] = newValue;
          const observers = propsToObservers.get(prop);
          if (observers) {
            for (const observer2 of observers) {
              dirtyObservers.add(observer2);
            }
            if (!queued) {
              queued = true;
              qM(flush);
            }
          }
        }
        return true;
      }
    });
    const createEffect = (callback) => {
      const runnable = () => {
        const oldObserver = currentObserver;
        currentObserver = runnable;
        try {
          return callback();
        } finally {
          currentObserver = oldObserver;
        }
      };
      return runnable();
    };
    abortSignal.addEventListener("abort", () => {
      destroyed = true;
    });
    return {
      state: state3,
      createEffect
    };
  }
  function arraysAreEqualByFunction(left, right, areEqualFunc) {
    if (left.length !== right.length) {
      return false;
    }
    for (let i = 0; i < left.length; i++) {
      if (!areEqualFunc(left[i], right[i])) {
        return false;
      }
    }
    return true;
  }
  function intersectionObserverAction(node, abortSignal, listener) {
    {
      const root = node.closest(".tabpanel");
      let observer2 = intersectionObserverCache.get(root);
      if (!observer2) {
        observer2 = new IntersectionObserver(listener, {
          root,
          // trigger if we are 1/2 scroll container height away so that the images load a bit quicker while scrolling
          rootMargin: "50% 0px 50% 0px",
          // trigger if any part of the emoji grid is intersecting
          threshold: 0
        });
        intersectionObserverCache.set(root, observer2);
        abortSignal.addEventListener("abort", () => {
          observer2.disconnect();
        });
      }
      observer2.observe(node);
    }
  }
  function createRoot(shadowRoot, props) {
    const refs = {};
    const abortController = new AbortController();
    const abortSignal = abortController.signal;
    const { state: state3, createEffect } = createState(abortSignal);
    const actionContext = /* @__PURE__ */ new Map();
    assign(state3, {
      skinToneEmoji: void 0,
      i18n: void 0,
      database: void 0,
      customEmoji: void 0,
      customCategorySorting: void 0,
      emojiVersion: void 0
    });
    assign(state3, props);
    assign(state3, {
      initialLoad: true,
      currentEmojis: [],
      currentEmojisWithCategories: [],
      rawSearchText: "",
      searchText: "",
      searchMode: false,
      activeSearchItem: -1,
      message: void 0,
      skinTonePickerExpanded: false,
      skinTonePickerExpandedAfterAnimation: false,
      currentSkinTone: 0,
      activeSkinTone: 0,
      skinToneButtonText: void 0,
      pickerStyle: void 0,
      skinToneButtonLabel: "",
      skinTones: [],
      currentFavorites: [],
      defaultFavoriteEmojis: void 0,
      numColumns: DEFAULT_NUM_COLUMNS,
      isRtl: false,
      currentGroupIndex: 0,
      groups,
      databaseLoaded: false,
      activeSearchItemId: void 0
    });
    createEffect(() => {
      if (state3.currentGroup !== state3.groups[state3.currentGroupIndex]) {
        state3.currentGroup = state3.groups[state3.currentGroupIndex];
      }
    });
    const focus = (id) => {
      shadowRoot.getElementById(id).focus();
    };
    const emojiToDomNode = (emoji) => shadowRoot.getElementById(`emo-${emoji.id}`);
    const fireEvent = (name, detail) => {
      refs.rootElement.dispatchEvent(new CustomEvent(name, {
        detail,
        bubbles: true,
        composed: true
      }));
    };
    const compareEmojiArrays = (a, b) => a.id === b.id;
    const compareCurrentEmojisWithCategories = (a, b) => {
      const { category: aCategory, emojis: aEmojis } = a;
      const { category: bCategory, emojis: bEmojis } = b;
      if (aCategory !== bCategory) {
        return false;
      }
      return arraysAreEqualByFunction(aEmojis, bEmojis, compareEmojiArrays);
    };
    const updateCurrentEmojis = (newEmojis) => {
      if (!arraysAreEqualByFunction(state3.currentEmojis, newEmojis, compareEmojiArrays)) {
        state3.currentEmojis = newEmojis;
      }
    };
    const updateSearchMode = (newSearchMode) => {
      if (state3.searchMode !== newSearchMode) {
        state3.searchMode = newSearchMode;
      }
    };
    const updateCurrentEmojisWithCategories = (newEmojisWithCategories) => {
      if (!arraysAreEqualByFunction(state3.currentEmojisWithCategories, newEmojisWithCategories, compareCurrentEmojisWithCategories)) {
        state3.currentEmojisWithCategories = newEmojisWithCategories;
      }
    };
    const unicodeWithSkin = (emoji, currentSkinTone) => currentSkinTone && emoji.skins && emoji.skins[currentSkinTone] || emoji.unicode;
    const labelWithSkin = (emoji, currentSkinTone) => uniq([
      emoji.name || unicodeWithSkin(emoji, currentSkinTone),
      emoji.annotation,
      ...emoji.shortcodes || EMPTY_ARRAY
    ].filter(Boolean)).join(", ");
    const titleForEmoji = (emoji) => emoji.annotation || (emoji.shortcodes || EMPTY_ARRAY).join(", ");
    const helpers = {
      labelWithSkin,
      titleForEmoji,
      unicodeWithSkin
    };
    const events = {
      onClickSkinToneButton,
      onEmojiClick,
      onNavClick,
      onNavKeydown,
      onSearchKeydown,
      onSkinToneOptionsClick,
      onSkinToneOptionsFocusOut,
      onSkinToneOptionsKeydown,
      onSkinToneOptionsKeyup,
      onSearchInput
    };
    const actions = {
      calculateEmojiGridStyle,
      updateOnIntersection
    };
    let firstRender = true;
    createEffect(() => {
      render(shadowRoot, state3, helpers, events, actions, refs, abortSignal, actionContext, firstRender);
      firstRender = false;
    });
    if (!state3.emojiVersion) {
      detectEmojiSupportLevel().then((level) => {
        if (!level) {
          state3.message = state3.i18n.emojiUnsupportedMessage;
        }
      });
    }
    createEffect(() => {
      async function handleDatabaseLoading() {
        let showingLoadingMessage = false;
        const timeoutHandle = setTimeout(() => {
          showingLoadingMessage = true;
          state3.message = state3.i18n.loadingMessage;
        }, TIMEOUT_BEFORE_LOADING_MESSAGE);
        try {
          await state3.database.ready();
          state3.databaseLoaded = true;
        } catch (err) {
          console.error(err);
          state3.message = state3.i18n.networkErrorMessage;
        } finally {
          clearTimeout(timeoutHandle);
          if (showingLoadingMessage) {
            showingLoadingMessage = false;
            state3.message = "";
          }
        }
      }
      if (state3.database) {
        handleDatabaseLoading();
      }
    });
    createEffect(() => {
      state3.pickerStyle = `
      --num-groups: ${state3.groups.length}; 
      --indicator-opacity: ${state3.searchMode ? 0 : 1}; 
      --num-skintones: ${NUM_SKIN_TONES};`;
    });
    createEffect(() => {
      if (state3.customEmoji && state3.database) {
        updateCustomEmoji();
      }
    });
    createEffect(() => {
      if (state3.customEmoji && state3.customEmoji.length) {
        if (state3.groups !== allGroups) {
          state3.groups = allGroups;
        }
      } else if (state3.groups !== groups) {
        if (state3.currentGroupIndex) {
          state3.currentGroupIndex--;
        }
        state3.groups = groups;
      }
    });
    createEffect(() => {
      async function updatePreferredSkinTone() {
        if (state3.databaseLoaded) {
          state3.currentSkinTone = await state3.database.getPreferredSkinTone();
        }
      }
      updatePreferredSkinTone();
    });
    createEffect(() => {
      state3.skinTones = Array(NUM_SKIN_TONES).fill().map((_, i) => applySkinTone(state3.skinToneEmoji, i));
    });
    createEffect(() => {
      state3.skinToneButtonText = state3.skinTones[state3.currentSkinTone];
    });
    createEffect(() => {
      state3.skinToneButtonLabel = state3.i18n.skinToneLabel.replace("{skinTone}", state3.i18n.skinTones[state3.currentSkinTone]);
    });
    createEffect(() => {
      async function updateDefaultFavoriteEmojis() {
        const { database } = state3;
        const favs = (await Promise.all(MOST_COMMONLY_USED_EMOJI.map((unicode) => database.getEmojiByUnicodeOrName(unicode)))).filter(Boolean);
        state3.defaultFavoriteEmojis = favs;
      }
      if (state3.databaseLoaded) {
        updateDefaultFavoriteEmojis();
      }
    });
    function updateCustomEmoji() {
      const { customEmoji, database } = state3;
      const databaseCustomEmoji = customEmoji || EMPTY_ARRAY;
      if (database.customEmoji !== databaseCustomEmoji) {
        database.customEmoji = databaseCustomEmoji;
      }
    }
    createEffect(() => {
      async function updateFavorites() {
        updateCustomEmoji();
        const { database, defaultFavoriteEmojis, numColumns } = state3;
        const dbFavorites = await database.getTopFavoriteEmoji(numColumns);
        const favorites = await summarizeEmojis(uniqBy2([
          ...dbFavorites,
          ...defaultFavoriteEmojis
        ], (_) => _.unicode || _.name).slice(0, numColumns));
        state3.currentFavorites = favorites;
      }
      if (state3.databaseLoaded && state3.defaultFavoriteEmojis) {
        updateFavorites();
      }
    });
    function calculateEmojiGridStyle(node) {
      resizeObserverAction(node, abortSignal, () => {
        {
          const style3 = getComputedStyle(refs.rootElement);
          const newNumColumns = parseInt(style3.getPropertyValue("--num-columns"), 10);
          const newIsRtl = style3.getPropertyValue("direction") === "rtl";
          state3.numColumns = newNumColumns;
          state3.isRtl = newIsRtl;
        }
      });
    }
    function updateOnIntersection(node) {
      intersectionObserverAction(node, abortSignal, (entries) => {
        for (const { target, isIntersecting } of entries) {
          target.classList.toggle("onscreen", isIntersecting);
        }
      });
    }
    createEffect(() => {
      async function updateEmojis() {
        const { searchText, currentGroup, databaseLoaded, customEmoji } = state3;
        if (!databaseLoaded) {
          state3.currentEmojis = [];
          state3.searchMode = false;
        } else if (searchText.length >= MIN_SEARCH_TEXT_LENGTH2) {
          const newEmojis = await getEmojisBySearchQuery(searchText);
          if (state3.searchText === searchText) {
            updateCurrentEmojis(newEmojis);
            updateSearchMode(true);
          }
        } else {
          const { id: currentGroupId } = currentGroup;
          if (currentGroupId !== -1 || customEmoji && customEmoji.length) {
            const newEmojis = await getEmojisByGroup(currentGroupId);
            if (state3.currentGroup.id === currentGroupId) {
              updateCurrentEmojis(newEmojis);
              updateSearchMode(false);
            }
          }
        }
      }
      updateEmojis();
    });
    const resetScrollTopInRaf = () => {
      rAF(() => resetScrollTopIfPossible(refs.tabpanelElement));
    };
    createEffect(() => {
      const { currentEmojis, emojiVersion } = state3;
      const zwjEmojisToCheck = currentEmojis.filter((emoji) => emoji.unicode).filter((emoji) => hasZwj(emoji) && !supportedZwjEmojis.has(emoji.unicode));
      if (!emojiVersion && zwjEmojisToCheck.length) {
        updateCurrentEmojis(currentEmojis);
        rAF(() => checkZwjSupportAndUpdate(zwjEmojisToCheck));
      } else {
        const newEmojis = emojiVersion ? currentEmojis : currentEmojis.filter(isZwjSupported);
        updateCurrentEmojis(newEmojis);
        resetScrollTopInRaf();
      }
    });
    function checkZwjSupportAndUpdate(zwjEmojisToCheck) {
      const allSupported = checkZwjSupport(zwjEmojisToCheck, refs.baselineEmoji, emojiToDomNode);
      if (allSupported) {
        resetScrollTopInRaf();
      } else {
        state3.currentEmojis = [...state3.currentEmojis];
      }
    }
    function isZwjSupported(emoji) {
      return !emoji.unicode || !hasZwj(emoji) || supportedZwjEmojis.get(emoji.unicode);
    }
    async function filterEmojisByVersion(emojis) {
      const emojiSupportLevel = state3.emojiVersion || await detectEmojiSupportLevel();
      return emojis.filter(({ version }) => !version || version <= emojiSupportLevel);
    }
    async function summarizeEmojis(emojis) {
      return summarizeEmojisForUI(emojis, state3.emojiVersion || await detectEmojiSupportLevel());
    }
    async function getEmojisByGroup(group) {
      const emoji = group === -1 ? state3.customEmoji : await state3.database.getEmojiByGroup(group);
      return summarizeEmojis(await filterEmojisByVersion(emoji));
    }
    async function getEmojisBySearchQuery(query) {
      return summarizeEmojis(await filterEmojisByVersion(await state3.database.getEmojiBySearchQuery(query)));
    }
    createEffect(() => {
    });
    createEffect(() => {
      function calculateCurrentEmojisWithCategories() {
        const { searchMode, currentEmojis } = state3;
        if (searchMode) {
          return [
            {
              category: "",
              emojis: currentEmojis
            }
          ];
        }
        const categoriesToEmoji = /* @__PURE__ */ new Map();
        for (const emoji of currentEmojis) {
          const category = emoji.category || "";
          let emojis = categoriesToEmoji.get(category);
          if (!emojis) {
            emojis = [];
            categoriesToEmoji.set(category, emojis);
          }
          emojis.push(emoji);
        }
        return [...categoriesToEmoji.entries()].map(([category, emojis]) => ({ category, emojis })).sort((a, b) => state3.customCategorySorting(a.category, b.category));
      }
      const newEmojisWithCategories = calculateCurrentEmojisWithCategories();
      updateCurrentEmojisWithCategories(newEmojisWithCategories);
    });
    createEffect(() => {
      state3.activeSearchItemId = state3.activeSearchItem !== -1 && state3.currentEmojis[state3.activeSearchItem].id;
    });
    createEffect(() => {
      const { rawSearchText } = state3;
      rIC(() => {
        state3.searchText = (rawSearchText || "").trim();
        state3.activeSearchItem = -1;
      });
    });
    function onSearchKeydown(event) {
      if (!state3.searchMode || !state3.currentEmojis.length) {
        return;
      }
      const goToNextOrPrevious = (previous) => {
        halt(event);
        state3.activeSearchItem = incrementOrDecrement(previous, state3.activeSearchItem, state3.currentEmojis);
      };
      switch (event.key) {
        case "ArrowDown":
          return goToNextOrPrevious(false);
        case "ArrowUp":
          return goToNextOrPrevious(true);
        case "Enter":
          if (state3.activeSearchItem === -1) {
            state3.activeSearchItem = 0;
          } else {
            halt(event);
            return clickEmoji(state3.currentEmojis[state3.activeSearchItem].id);
          }
      }
    }
    function onNavClick(event) {
      const { target } = event;
      const closestTarget = target.closest(".nav-button");
      if (!closestTarget) {
        return;
      }
      const groupId = parseInt(closestTarget.dataset.groupId, 10);
      refs.searchElement.value = "";
      state3.rawSearchText = "";
      state3.searchText = "";
      state3.activeSearchItem = -1;
      state3.currentGroupIndex = state3.groups.findIndex((_) => _.id === groupId);
    }
    function onNavKeydown(event) {
      const { target, key: key2 } = event;
      const doFocus = (el2) => {
        if (el2) {
          halt(event);
          el2.focus();
        }
      };
      switch (key2) {
        case "ArrowLeft":
          return doFocus(target.previousElementSibling);
        case "ArrowRight":
          return doFocus(target.nextElementSibling);
        case "Home":
          return doFocus(target.parentElement.firstElementChild);
        case "End":
          return doFocus(target.parentElement.lastElementChild);
      }
    }
    async function getDetailForClickEvent(unicodeOrName) {
      const emoji = await state3.database.getEmojiByUnicodeOrName(unicodeOrName);
      const emojiSummary = [...state3.currentEmojis, ...state3.currentFavorites].find((_) => _.id === unicodeOrName);
      const skinTonedUnicode = emojiSummary.unicode && unicodeWithSkin(emojiSummary, state3.currentSkinTone);
      await state3.database.incrementFavoriteEmojiCount(unicodeOrName);
      return {
        emoji,
        skinTone: state3.currentSkinTone,
        ...skinTonedUnicode && { unicode: skinTonedUnicode },
        ...emojiSummary.name && { name: emojiSummary.name }
      };
    }
    async function clickEmoji(unicodeOrName) {
      const promiseForDetail = getDetailForClickEvent(unicodeOrName);
      fireEvent("emoji-click-sync", promiseForDetail);
      fireEvent("emoji-click", await promiseForDetail);
    }
    function onEmojiClick(event) {
      const { target } = event;
      if (!target.classList.contains("emoji")) {
        return;
      }
      halt(event);
      const id = target.id.substring(4);
      clickEmoji(id);
    }
    function changeSkinTone(skinTone) {
      state3.currentSkinTone = skinTone;
      state3.skinTonePickerExpanded = false;
      focus("skintone-button");
      fireEvent("skin-tone-change", { skinTone });
      state3.database.setPreferredSkinTone(skinTone);
    }
    function onSkinToneOptionsClick(event) {
      const { target: { id } } = event;
      const match = id && id.match(/^skintone-(\d)/);
      if (!match) {
        return;
      }
      halt(event);
      const skinTone = parseInt(match[1], 10);
      changeSkinTone(skinTone);
    }
    function onClickSkinToneButton(event) {
      state3.skinTonePickerExpanded = !state3.skinTonePickerExpanded;
      state3.activeSkinTone = state3.currentSkinTone;
      if (state3.skinTonePickerExpanded) {
        halt(event);
        rAF(() => focus("skintone-list"));
      }
    }
    createEffect(() => {
      if (state3.skinTonePickerExpanded) {
        refs.skinToneDropdown.addEventListener("transitionend", () => {
          state3.skinTonePickerExpandedAfterAnimation = true;
        }, { once: true });
      } else {
        state3.skinTonePickerExpandedAfterAnimation = false;
      }
    });
    function onSkinToneOptionsKeydown(event) {
      if (!state3.skinTonePickerExpanded) {
        return;
      }
      const changeActiveSkinTone = async (nextSkinTone) => {
        halt(event);
        state3.activeSkinTone = nextSkinTone;
      };
      switch (event.key) {
        case "ArrowUp":
          return changeActiveSkinTone(incrementOrDecrement(true, state3.activeSkinTone, state3.skinTones));
        case "ArrowDown":
          return changeActiveSkinTone(incrementOrDecrement(false, state3.activeSkinTone, state3.skinTones));
        case "Home":
          return changeActiveSkinTone(0);
        case "End":
          return changeActiveSkinTone(state3.skinTones.length - 1);
        case "Enter":
          halt(event);
          return changeSkinTone(state3.activeSkinTone);
        case "Escape":
          halt(event);
          state3.skinTonePickerExpanded = false;
          return focus("skintone-button");
      }
    }
    function onSkinToneOptionsKeyup(event) {
      if (!state3.skinTonePickerExpanded) {
        return;
      }
      switch (event.key) {
        case " ":
          halt(event);
          return changeSkinTone(state3.activeSkinTone);
      }
    }
    async function onSkinToneOptionsFocusOut(event) {
      const { relatedTarget } = event;
      if (!relatedTarget || relatedTarget.id !== "skintone-list") {
        state3.skinTonePickerExpanded = false;
      }
    }
    function onSearchInput(event) {
      state3.rawSearchText = event.target.value;
    }
    return {
      $set(newState) {
        assign(state3, newState);
      },
      $destroy() {
        abortController.abort();
      }
    };
  }
  function rescueElementPrototype(element) {
    if (!(element instanceof PickerElement)) {
      Object.setPrototypeOf(element, customElements.get(element.tagName.toLowerCase()).prototype);
    }
  }
  var allGroups, groups, MIN_SEARCH_TEXT_LENGTH2, NUM_SKIN_TONES, rIC, versionsAndTestEmoji, TIMEOUT_BEFORE_LOADING_MESSAGE, DEFAULT_SKIN_TONE_EMOJI, DEFAULT_NUM_COLUMNS, MOST_COMMONLY_USED_EMOJI, FONT_FAMILY, DEFAULT_CATEGORY_SORTING, getTextFeature, compareFeatures, promise, detectEmojiSupportLevel, supportedZwjEmojis, VARIATION_SELECTOR, SKINTONE_MODIFIER, ZWJ, LIGHT_SKIN_TONE, LIGHT_SKIN_TONE_MODIFIER, rAF, resizeObserverSupported, baselineEmojiWidth, parseCache, domInstancesCache, unkeyedSymbol, hasReplaceChildren, qM, intersectionObserverCache, EMPTY_ARRAY, assign, DEFAULT_DATA_SOURCE2, DEFAULT_LOCALE2, enI18n, baseStyles, PROPS, EXTRA_STYLES, PickerElement, definitions;
  var init_picker = __esm({
    "node_modules/emoji-picker-element/picker.js"() {
      init_database();
      allGroups = [
        [-1, "\u2728", "custom"],
        [0, "\u{1F600}", "smileys-emotion"],
        [1, "\u{1F44B}", "people-body"],
        [3, "\u{1F431}", "animals-nature"],
        [4, "\u{1F34E}", "food-drink"],
        [5, "\u{1F3E0}\uFE0F", "travel-places"],
        [6, "\u26BD", "activities"],
        [7, "\u{1F4DD}", "objects"],
        [8, "\u26D4\uFE0F", "symbols"],
        [9, "\u{1F3C1}", "flags"]
      ].map(([id, emoji, name]) => ({ id, emoji, name }));
      groups = allGroups.slice(1);
      MIN_SEARCH_TEXT_LENGTH2 = 2;
      NUM_SKIN_TONES = 6;
      rIC = typeof requestIdleCallback === "function" ? requestIdleCallback : setTimeout;
      versionsAndTestEmoji = {
        "\u{1FAEA}": 17,
        // distorted face
        "\u{1FAE9}": 16,
        // face with bags under eyes
        "\u{1FAE8}": 15.1,
        // shaking head, technically from v15 but see note above
        "\u{1FAE0}": 14,
        "\u{1F972}": 13.1,
        // smiling face with tear, technically from v13 but see note above
        "\u{1F97B}": 12.1,
        // sari, technically from v12 but see note above
        "\u{1F970}": 11,
        "\u{1F929}": 5,
        "\u{1F471}\u200D\u2640\uFE0F": 4,
        "\u{1F923}": 3,
        "\u{1F441}\uFE0F\u200D\u{1F5E8}\uFE0F": 2,
        "\u{1F600}": 1,
        "\u{1F610}\uFE0F": 0.7,
        "\u{1F603}": 0.6
      };
      TIMEOUT_BEFORE_LOADING_MESSAGE = 1e3;
      DEFAULT_SKIN_TONE_EMOJI = "\u{1F590}\uFE0F";
      DEFAULT_NUM_COLUMNS = 8;
      MOST_COMMONLY_USED_EMOJI = [
        "\u{1F60A}",
        "\u{1F612}",
        "\u2764\uFE0F",
        "\u{1F44D}\uFE0F",
        "\u{1F60D}",
        "\u{1F602}",
        "\u{1F62D}",
        "\u263A\uFE0F",
        "\u{1F614}",
        "\u{1F629}",
        "\u{1F60F}",
        "\u{1F495}",
        "\u{1F64C}",
        "\u{1F618}"
      ];
      FONT_FAMILY = '"Twemoji Mozilla","Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji","EmojiOne Color","Android Emoji",sans-serif';
      DEFAULT_CATEGORY_SORTING = (a, b) => a < b ? -1 : a > b ? 1 : 0;
      getTextFeature = (text, color) => {
        const canvas = document.createElement("canvas");
        canvas.width = canvas.height = 1;
        const ctx2 = canvas.getContext("2d", {
          // Improves the performance of `getImageData()`
          // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/getContextAttributes#willreadfrequently
          willReadFrequently: true
        });
        ctx2.textBaseline = "top";
        ctx2.font = `100px ${FONT_FAMILY}`;
        ctx2.fillStyle = color;
        ctx2.scale(0.01, 0.01);
        ctx2.fillText(text, 0, 0);
        return ctx2.getImageData(0, 0, 1, 1).data;
      };
      compareFeatures = (feature1, feature2) => {
        const feature1Str = [...feature1].join(",");
        const feature2Str = [...feature2].join(",");
        return feature1Str === feature2Str && !feature1Str.startsWith("0,0,0,");
      };
      detectEmojiSupportLevel = () => {
        if (!promise) {
          promise = new Promise((resolve2) => rIC(() => resolve2(determineEmojiSupportLevel())));
        }
        return promise;
      };
      supportedZwjEmojis = /* @__PURE__ */ new Map();
      VARIATION_SELECTOR = "\uFE0F";
      SKINTONE_MODIFIER = "\uD83C";
      ZWJ = "\u200D";
      LIGHT_SKIN_TONE = 127995;
      LIGHT_SKIN_TONE_MODIFIER = 57339;
      rAF = requestAnimationFrame;
      resizeObserverSupported = typeof ResizeObserver === "function";
      parseCache = /* @__PURE__ */ new WeakMap();
      domInstancesCache = /* @__PURE__ */ new WeakMap();
      unkeyedSymbol = Symbol("un-keyed");
      hasReplaceChildren = "replaceChildren" in Element.prototype;
      qM = typeof queueMicrotask === "function" ? queueMicrotask : (callback) => Promise.resolve().then(callback);
      intersectionObserverCache = /* @__PURE__ */ new WeakMap();
      EMPTY_ARRAY = [];
      ({ assign } = Object);
      DEFAULT_DATA_SOURCE2 = "https://cdn.jsdelivr.net/npm/emoji-picker-element-data@^1/en/emojibase/data.json";
      DEFAULT_LOCALE2 = "en";
      enI18n = {
        categoriesLabel: "Categories",
        emojiUnsupportedMessage: "Your browser does not support color emoji.",
        favoritesLabel: "Favorites",
        loadingMessage: "Loading\u2026",
        networkErrorMessage: "Could not load emoji.",
        regionLabel: "Emoji picker",
        searchDescription: "When search results are available, press up or down to select and enter to choose.",
        searchLabel: "Search",
        searchResultsLabel: "Search results",
        skinToneDescription: "When expanded, press up or down to select and enter to choose.",
        skinToneLabel: "Choose a skin tone (currently {skinTone})",
        skinTonesLabel: "Skin tones",
        skinTones: [
          "Default",
          "Light",
          "Medium-Light",
          "Medium",
          "Medium-Dark",
          "Dark"
        ],
        categories: {
          custom: "Custom",
          "smileys-emotion": "Smileys and emoticons",
          "people-body": "People and body",
          "animals-nature": "Animals and nature",
          "food-drink": "Food and drink",
          "travel-places": "Travel and places",
          activities: "Activities",
          objects: "Objects",
          symbols: "Symbols",
          flags: "Flags"
        }
      };
      baseStyles = ':host{--emoji-size:1.375rem;--emoji-padding:0.5rem;--category-emoji-size:var(--emoji-size);--category-emoji-padding:var(--emoji-padding);--indicator-height:3px;--input-border-radius:0.5rem;--input-border-size:1px;--input-font-size:1rem;--input-line-height:1.5;--input-padding:0.25rem;--num-columns:8;--outline-size:2px;--border-size:1px;--border-radius:0;--skintone-border-radius:1rem;--category-font-size:1rem;display:flex;width:min-content;height:400px}:host,:host(.light){color-scheme:light;--background:#fff;--border-color:#e0e0e0;--indicator-color:#385ac1;--input-border-color:#999;--input-font-color:#111;--input-placeholder-color:#999;--outline-color:#999;--category-font-color:#111;--button-active-background:#e6e6e6;--button-hover-background:#d9d9d9}:host(.dark){color-scheme:dark;--background:#222;--border-color:#444;--indicator-color:#5373ec;--input-border-color:#ccc;--input-font-color:#efefef;--input-placeholder-color:#ccc;--outline-color:#fff;--category-font-color:#efefef;--button-active-background:#555555;--button-hover-background:#484848}@media (prefers-color-scheme:dark){:host{color-scheme:dark;--background:#222;--border-color:#444;--indicator-color:#5373ec;--input-border-color:#ccc;--input-font-color:#efefef;--input-placeholder-color:#ccc;--outline-color:#fff;--category-font-color:#efefef;--button-active-background:#555555;--button-hover-background:#484848}}:host([hidden]){display:none}button{margin:0;padding:0;border:0;background:0 0;box-shadow:none;-webkit-tap-highlight-color:transparent}button::-moz-focus-inner{border:0}input{padding:0;margin:0;line-height:1.15;font-family:inherit}input[type=search]{-webkit-appearance:none}:focus{outline:var(--outline-color) solid var(--outline-size);outline-offset:calc(-1*var(--outline-size))}:host([data-js-focus-visible]) :focus:not([data-focus-visible-added]){outline:0}:focus:not(:focus-visible){outline:0}.hide-focus{outline:0}*{box-sizing:border-box}.picker{contain:content;display:flex;flex-direction:column;background:var(--background);border:var(--border-size) solid var(--border-color);border-radius:var(--border-radius);width:100%;height:100%;overflow:hidden;--total-emoji-size:calc(var(--emoji-size) + (2 * var(--emoji-padding)));--total-category-emoji-size:calc(var(--category-emoji-size) + (2 * var(--category-emoji-padding)))}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.hidden{opacity:0;pointer-events:none}.abs-pos{position:absolute;left:0;top:0}.gone{display:none!important}.skintone-button-wrapper,.skintone-list{background:var(--background);z-index:3}.skintone-button-wrapper.expanded{z-index:1}.skintone-list{position:absolute;inset-inline-end:0;top:0;z-index:2;overflow:visible;border-bottom:var(--border-size) solid var(--border-color);border-radius:0 0 var(--skintone-border-radius) var(--skintone-border-radius);will-change:transform;transition:transform .2s ease-in-out;transform-origin:center 0}@media (prefers-reduced-motion:reduce){.skintone-list{transition-duration:.001s}}@supports not (inset-inline-end:0){.skintone-list{right:0}}.skintone-list.no-animate{transition:none}.tabpanel{overflow-y:auto;scrollbar-gutter:stable;-webkit-overflow-scrolling:touch;will-change:transform;min-height:0;flex:1;contain:content}.emoji-menu{display:grid;grid-template-columns:repeat(var(--num-columns),var(--total-emoji-size));justify-content:space-around;align-items:flex-start;width:100%}.emoji-menu.visibility-auto{content-visibility:auto;contain-intrinsic-size:calc(var(--num-columns)*var(--total-emoji-size)) calc(var(--num-rows)*var(--total-emoji-size))}.category{padding:var(--emoji-padding);font-size:var(--category-font-size);color:var(--category-font-color)}.emoji,button.emoji{font-size:var(--emoji-size);display:flex;align-items:center;justify-content:center;border-radius:100%;height:var(--total-emoji-size);width:var(--total-emoji-size);line-height:1;overflow:hidden;font-family:var(--emoji-font-family);cursor:pointer}@media (hover:hover) and (pointer:fine){.emoji:hover,button.emoji:hover{background:var(--button-hover-background)}}.emoji.active,.emoji:active,button.emoji.active,button.emoji:active{background:var(--button-active-background)}.onscreen .custom-emoji::after{content:"";width:var(--emoji-size);height:var(--emoji-size);background-repeat:no-repeat;background-position:center center;background-size:contain;background-image:var(--custom-emoji-background)}.nav,.nav-button{align-items:center}.nav{display:grid;justify-content:space-between;contain:content}.nav-button{display:flex;justify-content:center}.nav-emoji{font-size:var(--category-emoji-size);width:var(--total-category-emoji-size);height:var(--total-category-emoji-size)}.indicator-wrapper{display:flex;border-bottom:1px solid var(--border-color)}.indicator{width:calc(100%/var(--num-groups));height:var(--indicator-height);opacity:var(--indicator-opacity);background-color:var(--indicator-color);will-change:transform,opacity;transition:opacity .1s linear,transform .25s ease-in-out}@media (prefers-reduced-motion:reduce){.indicator{will-change:opacity;transition:opacity .1s linear}}.pad-top,input.search{background:var(--background);width:100%}.pad-top{height:var(--emoji-padding);z-index:3}.search-row{display:flex;align-items:center;position:relative;padding-inline-start:var(--emoji-padding);padding-bottom:var(--emoji-padding)}.search-wrapper{flex:1;min-width:0}input.search{padding:var(--input-padding);border-radius:var(--input-border-radius);border:var(--input-border-size) solid var(--input-border-color);color:var(--input-font-color);font-size:var(--input-font-size);line-height:var(--input-line-height)}input.search::placeholder{color:var(--input-placeholder-color)}.favorites{overflow-y:auto;scrollbar-gutter:stable;display:flex;flex-direction:row;border-top:var(--border-size) solid var(--border-color);contain:content}.message{padding:var(--emoji-padding)}';
      PROPS = [
        "customEmoji",
        "customCategorySorting",
        "database",
        "dataSource",
        "i18n",
        "locale",
        "skinToneEmoji",
        "emojiVersion"
      ];
      EXTRA_STYLES = `:host{--emoji-font-family:${FONT_FAMILY}}`;
      PickerElement = class extends HTMLElement {
        constructor(props) {
          super();
          this.attachShadow({ mode: "open" });
          const style3 = document.createElement("style");
          style3.textContent = baseStyles + EXTRA_STYLES;
          this.shadowRoot.appendChild(style3);
          this._ctx = {
            // Set defaults
            locale: DEFAULT_LOCALE2,
            dataSource: DEFAULT_DATA_SOURCE2,
            skinToneEmoji: DEFAULT_SKIN_TONE_EMOJI,
            customCategorySorting: DEFAULT_CATEGORY_SORTING,
            customEmoji: null,
            i18n: enI18n,
            emojiVersion: null,
            ...props
          };
          for (const prop of PROPS) {
            if (prop !== "database" && Object.prototype.hasOwnProperty.call(this, prop)) {
              this._ctx[prop] = this[prop];
              delete this[prop];
            }
          }
          this._dbFlush();
        }
        connectedCallback() {
          rescueElementPrototype(this);
          if (!this._cmp) {
            this._cmp = createRoot(this.shadowRoot, this._ctx);
          }
        }
        disconnectedCallback() {
          rescueElementPrototype(this);
          qM(() => {
            if (!this.isConnected && this._cmp) {
              this._cmp.$destroy();
              this._cmp = void 0;
              const { database } = this._ctx;
              database.close().catch((err) => console.error(err));
            }
          });
        }
        static get observedAttributes() {
          return ["locale", "data-source", "skin-tone-emoji", "emoji-version"];
        }
        attributeChangedCallback(attrName, oldValue, newValue) {
          this._set(
            // convert from kebab-case to camelcase
            // see https://github.com/sveltejs/svelte/issues/3852#issuecomment-665037015
            attrName.replace(/-([a-z])/g, (_, up) => up.toUpperCase()),
            // convert string attribute to float if necessary
            attrName === "emoji-version" ? parseFloat(newValue) : newValue
          );
        }
        _set(prop, newValue) {
          this._ctx[prop] = newValue;
          if (this._cmp) {
            this._cmp.$set({ [prop]: newValue });
          }
          if (["locale", "dataSource"].includes(prop)) {
            this._dbFlush();
          }
        }
        _dbCreate() {
          const { locale, dataSource, database } = this._ctx;
          if (!database || database.locale !== locale || database.dataSource !== dataSource) {
            this._set("database", new Database({ locale, dataSource }));
          }
        }
        // Update the Database in one microtask if the locale/dataSource change. We do one microtask
        // so we don't create two Databases if e.g. both the locale and the dataSource change
        _dbFlush() {
          qM(() => this._dbCreate());
        }
      };
      definitions = {};
      for (const prop of PROPS) {
        definitions[prop] = {
          get() {
            if (prop === "database") {
              this._dbCreate();
            }
            return this._ctx[prop];
          },
          set(val) {
            if (prop === "database") {
              throw new Error("database is read-only");
            }
            this._set(prop, val);
          }
        };
      }
      Object.defineProperties(PickerElement.prototype, definitions);
      if (!customElements.get("emoji-picker")) {
        customElements.define("emoji-picker", PickerElement);
      }
    }
  });

  // node_modules/emoji-picker-element/index.js
  var emoji_picker_element_exports = {};
  __export(emoji_picker_element_exports, {
    Database: () => Database,
    Picker: () => PickerElement
  });
  var init_emoji_picker_element = __esm({
    "node_modules/emoji-picker-element/index.js"() {
      init_picker();
      init_database();
    }
  });

  // src/sprite/state.ts
  init_settings();
  function createInitialState() {
    return {
      started: false,
      open: false,
      loaded: false,
      version: null,
      base: null,
      ctors: null,
      app: null,
      renderer: null,
      cat: "__all__",
      q: "",
      f: "",
      mutOn: false,
      mutations: [],
      scroll: 0,
      items: [],
      filtered: [],
      cats: /* @__PURE__ */ new Map(),
      tex: /* @__PURE__ */ new Map(),
      lru: /* @__PURE__ */ new Map(),
      cost: 0,
      jobs: [],
      jobMap: /* @__PURE__ */ new Set(),
      srcCan: /* @__PURE__ */ new Map(),
      atlasBases: /* @__PURE__ */ new Set(),
      dbgCount: {},
      sig: "",
      changedAt: 0,
      needsLayout: false,
      overlay: null,
      bg: null,
      grid: null,
      dom: null,
      selCat: null,
      count: null,
      pool: [],
      active: /* @__PURE__ */ new Map(),
      anim: /* @__PURE__ */ new Set()
    };
  }
  function createSpriteContext() {
    return {
      cfg: { ...DEFAULT_CFG },
      state: createInitialState()
    };
  }

  // src/sprite/utils/async.ts
  var sleep = (ms) => new Promise((resolve2) => setTimeout(resolve2, ms));
  async function waitWithTimeout(p, ms, label2) {
    const t0 = performance.now();
    while (performance.now() - t0 < ms) {
      const result = await Promise.race([p, sleep(50).then(() => null)]);
      if (result !== null) return result;
    }
    throw new Error(`${label2} timeout`);
  }

  // src/sprite/pixi/hooks.ts
  function createPixiHooks() {
    let appResolver;
    let rdrResolver;
    const appReady = new Promise((resolve2) => appResolver = resolve2);
    const rendererReady = new Promise((resolve2) => rdrResolver = resolve2);
    let APP = null;
    let RDR = null;
    let PIXI_VER = null;
    const hook = (name, cb) => {
      const root = globalThis.unsafeWindow || globalThis;
      const prev = root[name];
      root[name] = function() {
        try {
          cb.apply(this, arguments);
        } finally {
          if (typeof prev === "function") {
            try {
              prev.apply(this, arguments);
            } catch {
            }
          }
        }
      };
    };
    hook("__PIXI_APP_INIT__", (a, v) => {
      if (!APP) {
        APP = a;
        PIXI_VER = v;
        appResolver(a);
      }
    });
    hook("__PIXI_RENDERER_INIT__", (r, v) => {
      if (!RDR) {
        RDR = r;
        PIXI_VER = v;
        rdrResolver(r);
      }
    });
    const tryResolveExisting = () => {
      const root = globalThis.unsafeWindow || globalThis;
      if (!APP) {
        const maybeApp = root.__PIXI_APP__ || root.PIXI_APP || root.app;
        if (maybeApp) {
          APP = maybeApp;
          appResolver(APP);
        }
      }
      if (!RDR) {
        const maybeRdr = root.__PIXI_RENDERER__ || root.PIXI_RENDERER__ || root.renderer || APP?.renderer;
        if (maybeRdr) {
          RDR = maybeRdr;
          rdrResolver(RDR);
        }
      }
    };
    tryResolveExisting();
    let fallbackPolls = 0;
    const fallbackInterval = setInterval(() => {
      if (APP && RDR) {
        clearInterval(fallbackInterval);
        return;
      }
      tryResolveExisting();
      fallbackPolls += 1;
      if (fallbackPolls >= 50) {
        clearInterval(fallbackInterval);
      }
    }, 100);
    return {
      get app() {
        return APP;
      },
      get renderer() {
        return RDR;
      },
      get pixiVersion() {
        return PIXI_VER;
      },
      appReady,
      rendererReady
    };
  }
  async function waitForPixi(handles, timeoutMs = 15e3) {
    const app = await waitWithTimeout(handles.appReady, timeoutMs, "PIXI app");
    const renderer = await waitWithTimeout(handles.rendererReady, timeoutMs, "PIXI renderer");
    return { app, renderer, version: handles.pixiVersion };
  }

  // src/sprite/utils/pixi.ts
  function findAny(root, pred, lim = 25e3) {
    const stack = [root];
    const seen = /* @__PURE__ */ new Set();
    let n = 0;
    while (stack.length && n++ < lim) {
      const node = stack.pop();
      if (!node || seen.has(node)) continue;
      seen.add(node);
      if (pred(node)) return node;
      const children = node.children;
      if (Array.isArray(children)) {
        for (let i = children.length - 1; i >= 0; i -= 1) stack.push(children[i]);
      }
    }
    return null;
  }
  function getCtors(app) {
    const P = globalThis.PIXI || globalThis.unsafeWindow?.PIXI;
    if (P?.Texture && P?.Sprite && P?.Container && P?.Rectangle) {
      return { Container: P.Container, Sprite: P.Sprite, Texture: P.Texture, Rectangle: P.Rectangle, Text: P.Text || null };
    }
    const stage = app?.stage;
    const anySpr = findAny(stage, (x) => x?.texture?.frame && x?.constructor && x?.texture?.constructor && x?.texture?.frame?.constructor);
    if (!anySpr) throw new Error("No Sprite found (ctors).");
    const anyTxt = findAny(stage, (x) => (typeof x?.text === "string" || typeof x?.text === "number") && x?.style);
    return {
      Container: stage.constructor,
      Sprite: anySpr.constructor,
      Texture: anySpr.texture.constructor,
      Rectangle: anySpr.texture.frame.constructor,
      Text: anyTxt?.constructor || null
    };
  }
  var baseTexOf = (tex) => tex?.baseTexture ?? tex?.source?.baseTexture ?? tex?.source ?? tex?._baseTexture ?? null;
  function rememberBaseTex(tex, atlasBases) {
    const base = baseTexOf(tex);
    if (base) atlasBases.add(base);
  }

  // src/sprite/utils/path.ts
  var splitKey = (key2) => String(key2 || "").split("/").filter(Boolean);
  var joinPath = (base, path) => base.replace(/\/?$/, "/") + String(path || "").replace(/^\//, "");
  var dirOf = (path) => path.lastIndexOf("/") >= 0 ? path.slice(0, path.lastIndexOf("/") + 1) : "";
  var relPath = (base, path) => typeof path === "string" ? path.startsWith("/") ? path.slice(1) : dirOf(base) + path : path;
  function categoryOf(key2, cfg) {
    const parts = splitKey(key2);
    const start2 = parts[0] === "sprite" || parts[0] === "sprites" ? 1 : 0;
    const width = Math.max(1, cfg.catLevels | 0);
    return parts.slice(start2, start2 + width).join("/") || "misc";
  }
  function animParse(key2) {
    const parts = splitKey(key2);
    const last = parts[parts.length - 1];
    const match = last && last.match(/^(.*?)(?:[_-])(\d{1,6})(\.[a-z0-9]+)?$/i);
    if (!match) return null;
    const baseName = (match[1] || "") + (match[3] || "");
    const idx = Number(match[2]);
    if (!baseName || !Number.isFinite(idx)) return null;
    return { baseKey: parts.slice(0, -1).concat(baseName).join("/"), idx, frameKey: key2 };
  }

  // src/sprite/data/assetFetcher.ts
  function fetchFallback(url, type) {
    return fetch(url).then(async (res) => {
      if (!res.ok) throw new Error(`HTTP ${res.status} (${url})`);
      if (type === "blob") return { status: res.status, response: await res.blob(), responseText: "" };
      const text = await res.text();
      return {
        status: res.status,
        response: type === "json" ? JSON.parse(text) : text,
        responseText: text
      };
    }).catch((err) => {
      throw new Error(`Network (${url}): ${err instanceof Error ? err.message : String(err)}`);
    });
  }
  function gm(url, type = "text") {
    if (typeof GM_xmlhttpRequest === "function") {
      return new Promise(
        (resolve2, reject) => GM_xmlhttpRequest({
          method: "GET",
          url,
          responseType: type,
          onload: (r) => r.status >= 200 && r.status < 300 ? resolve2(r) : reject(new Error(`HTTP ${r.status} (${url})`)),
          onerror: () => reject(new Error(`Network (${url})`)),
          ontimeout: () => reject(new Error(`Timeout (${url})`))
        })
      );
    }
    return fetchFallback(url, type);
  }
  var getJSON = async (url) => JSON.parse((await gm(url, "text")).responseText);
  var getBlob = async (url) => (await gm(url, "blob")).response;
  function blobToImage(blob) {
    return new Promise((resolve2, reject) => {
      const url = URL.createObjectURL(blob);
      const img = new Image();
      img.decoding = "async";
      img.onload = () => {
        URL.revokeObjectURL(url);
        resolve2(img);
      };
      img.onerror = () => {
        URL.revokeObjectURL(url);
        reject(new Error("decode fail"));
      };
      img.src = url;
    });
  }
  function extractAtlasJsons(manifest) {
    const jsons = /* @__PURE__ */ new Set();
    for (const bundle of manifest.bundles || []) {
      for (const asset of bundle.assets || []) {
        for (const src of asset.src || []) {
          if (typeof src !== "string") continue;
          if (!src.endsWith(".json")) continue;
          if (src === "manifest.json") continue;
          if (src.startsWith("audio/")) continue;
          jsons.add(src);
        }
      }
    }
    return jsons;
  }
  async function loadAtlasJsons(base, manifest) {
    const jsons = extractAtlasJsons(manifest);
    const seen = /* @__PURE__ */ new Set();
    const data = {};
    const loadOne = async (path) => {
      if (seen.has(path)) return;
      seen.add(path);
      const json = await getJSON(joinPath(base, path));
      data[path] = json;
      if (json?.meta?.related_multi_packs) {
        for (const rel of json.meta.related_multi_packs) {
          await loadOne(relPath(path, rel));
        }
      }
    };
    for (const p of jsons) {
      await loadOne(p);
    }
    return data;
  }

  // src/sprite/pixi/atlasToTextures.ts
  var isAtlas = (j) => j && typeof j === "object" && j.frames && j.meta && typeof j.meta.image === "string";
  function mkRect(Rectangle, x, y, w, h) {
    return new Rectangle(x, y, w, h);
  }
  function mkSubTex(Texture, baseTex, frame, orig, trim, rotate, anchor) {
    let t;
    try {
      t = new Texture({ source: baseTex.source, frame, orig, trim: trim || void 0, rotate: rotate || 0 });
    } catch {
      t = new Texture(baseTex.baseTexture ?? baseTex, frame, orig, trim || void 0, rotate || 0);
    }
    try {
      if (t && !t.label) t.label = frame?.width && frame?.height ? `sub:${frame.width}x${frame.height}` : "subtex";
    } catch {
    }
    if (anchor) {
      const target = t;
      if (target.defaultAnchor?.set) {
        try {
          target.defaultAnchor.set(anchor.x, anchor.y);
        } catch {
        }
      }
      if (target.defaultAnchor && !target.defaultAnchor.set) {
        target.defaultAnchor.x = anchor.x;
        target.defaultAnchor.y = anchor.y;
      }
      if (!target.defaultAnchor) {
        target.defaultAnchor = { x: anchor.x, y: anchor.y };
      }
    }
    try {
      t?.updateUvs?.();
    } catch {
    }
    return t;
  }
  function buildAtlasTextures(data, baseTex, texMap, atlasBases, ctors) {
    const { Texture, Rectangle } = ctors;
    try {
      if (baseTex && !baseTex.label) baseTex.label = data?.meta?.image || "atlasBase";
    } catch {
    }
    rememberBaseTex(baseTex, atlasBases);
    for (const [k, fd] of Object.entries(data.frames)) {
      const fr = fd.frame;
      const rot = fd.rotated ? 2 : 0;
      const w = fd.rotated ? fr.h : fr.w;
      const h = fd.rotated ? fr.w : fr.h;
      const frame = mkRect(Rectangle, fr.x, fr.y, w, h);
      const ss = fd.sourceSize || { w: fr.w, h: fr.h };
      const orig = mkRect(Rectangle, 0, 0, ss.w, ss.h);
      let trim = null;
      if (fd.trimmed && fd.spriteSourceSize) {
        const s = fd.spriteSourceSize;
        trim = mkRect(Rectangle, s.x, s.y, s.w, s.h);
      }
      const t = mkSubTex(Texture, baseTex, frame, orig, trim, rot, fd.anchor || null);
      try {
        t.label = k;
      } catch {
      }
      rememberBaseTex(t, atlasBases);
      texMap.set(k, t);
    }
  }

  // src/sprite/data/catalogIndexer.ts
  function buildItemsFromTextures(tex, cfg) {
    const keys = [...tex.keys()].sort((a, b) => a.localeCompare(b));
    const used = /* @__PURE__ */ new Set();
    const items = [];
    const cats = /* @__PURE__ */ new Map();
    const addToCat = (key2, item) => {
      const cat = categoryOf(key2, cfg);
      if (!cats.has(cat)) cats.set(cat, []);
      cats.get(cat).push(item);
    };
    for (const key2 of keys) {
      const texEntry = tex.get(key2);
      if (!texEntry || used.has(key2)) continue;
      const anim = animParse(key2);
      if (!anim) {
        const item = { key: key2, isAnim: false, first: texEntry };
        items.push(item);
        addToCat(key2, item);
        continue;
      }
      const frames = [];
      for (const candidate of keys) {
        const maybe = animParse(candidate);
        if (!maybe || maybe.baseKey !== anim.baseKey) continue;
        const t = tex.get(candidate);
        if (!t) continue;
        frames.push({ idx: maybe.idx, tex: t });
        used.add(candidate);
      }
      frames.sort((a, b) => a.idx - b.idx);
      const ordered = frames.map((f) => f.tex);
      if (ordered.length === 1) {
        const item = { key: anim.baseKey, isAnim: false, first: ordered[0] };
        items.push(item);
        addToCat(anim.baseKey, item);
      } else if (ordered.length > 1) {
        const item = {
          key: anim.baseKey,
          isAnim: true,
          frames: ordered,
          first: ordered[0],
          count: ordered.length
        };
        items.push(item);
        addToCat(anim.baseKey, item);
      }
    }
    return { items, cats };
  }

  // src/sprite/api/expose.ts
  init_variantBuilder();
  function exposeApi(state3, hud) {
    const root = globalThis.unsafeWindow || globalThis;
    const api = {
      open() {
        hud.root?.style && (hud.root.style.display = "block");
        state3.open = true;
      },
      close() {
        hud.root?.style && (hud.root.style.display = "none");
        state3.open = false;
      },
      toggle() {
        state3.open ? api.close() : api.open();
      },
      setCategory(cat) {
        state3.cat = cat || "__all__";
      },
      setFilterText(text) {
        state3.q = String(text || "").trim();
      },
      setSpriteFilter(name) {
        state3.f = name;
        state3.mutOn = false;
      },
      setMutation(on, ...muts) {
        state3.mutOn = !!on;
        state3.f = "";
        state3.mutations = state3.mutOn ? muts.filter(Boolean).map((name) => name) : [];
      },
      filters() {
        return [];
      },
      categories() {
        return [...state3.cats.keys()].sort((a, b) => a.localeCompare(b));
      },
      cacheStats() {
        return { entries: state3.lru.size, cost: state3.cost };
      },
      clearCache() {
        clearVariantCache(state3);
      },
      curVariant: () => curVariant(state3)
    };
    root.MGSpriteCatalog = api;
    return api;
  }

  // src/sprite/index.ts
  init_variantBuilder();

  // src/ui/spriteIconCache.ts
  init_page_context();
  var SPRITE_PRELOAD_CATEGORIES = [
    "plant",
    "tallplant",
    "decor",
    "item",
    "pet",
    "seed",
    "ui",
    "mutation",
    "mutation-overlay"
  ];
  var spriteDataUrlCache = /* @__PURE__ */ new Map();
  var spriteDataUrlResolved = /* @__PURE__ */ new Map();
  var spriteWarmupQueued = false;
  var spriteWarmupStarted = false;
  var warmupState = { total: 0, done: 0, completed: false };
  var prefetchedWarmupKeys = [];
  var warmupCompletedKeys = /* @__PURE__ */ new Set();
  var WARMUP_RETRY_MS = 100;
  var WARMUP_DELAY_MS = 8;
  var WARMUP_BATCH = 3;
  var warmupListeners = /* @__PURE__ */ new Set();
  function notifyWarmup(state3) {
    warmupState = state3;
    warmupListeners.forEach((listener) => {
      try {
        listener(warmupState);
      } catch {
      }
    });
  }
  function getSpriteWarmupState() {
    return warmupState;
  }
  function onSpriteWarmupProgress(listener) {
    warmupListeners.add(listener);
    try {
      listener(warmupState);
    } catch {
    }
    return () => {
      warmupListeners.delete(listener);
    };
  }
  function primeWarmupKeys(keys) {
    prefetchedWarmupKeys.push(...keys);
  }
  function primeSpriteData(category, spriteId, dataUrl) {
    const cacheKey = cacheKeyFor(category, spriteId);
    if (!spriteDataUrlCache.has(cacheKey)) {
      spriteDataUrlCache.set(cacheKey, Promise.resolve(dataUrl));
    }
    spriteDataUrlResolved.set(cacheKey, dataUrl);
    if (!warmupCompletedKeys.has(cacheKey)) {
      warmupCompletedKeys.add(cacheKey);
      const nextDone = warmupState.done + 1;
      const completed = warmupState.total > 0 ? nextDone >= warmupState.total : false;
      notifyWarmup({ total: Math.max(warmupState.total, nextDone), done: nextDone, completed });
    }
  }
  var normalizeSpriteId = (value) => String(value || "").toLowerCase().replace(/[^a-z0-9]/g, "");
  var baseNameFromKey = (key2) => {
    const parts = key2.split("/").filter(Boolean);
    return parts[parts.length - 1] ?? key2;
  };
  var normalizeMutationList = (mutations) => {
    const list = Array.from(
      new Set((mutations ?? []).map((value) => String(value ?? "").trim()).filter(Boolean))
    );
    if (!list.length) {
      return { list, key: "" };
    }
    const key2 = list.map((val) => normalizeSpriteId(val)).filter(Boolean).sort().join(",");
    return { list, key: key2 ? `|m=${key2}` : "" };
  };
  var cacheKeyFor = (category, spriteId, mutationKey) => `${category}:${normalizeSpriteId(spriteId)}${mutationKey ?? ""}`;
  var scheduleNonBlocking = (cb) => {
    return new Promise((resolve2) => {
      const runner = () => {
        Promise.resolve().then(cb).then(resolve2).catch(() => resolve2(cb()));
      };
      if (typeof window.requestIdleCallback === "function") {
        window.requestIdleCallback(runner, { timeout: 50 });
      } else if (typeof requestAnimationFrame === "function") {
        requestAnimationFrame(runner);
      } else {
        setTimeout(runner, 0);
      }
    });
  };
  function getSpriteService() {
    const win = pageWindow ?? globalThis;
    return win?.__MG_SPRITE_SERVICE__ ?? win?.unsafeWindow?.__MG_SPRITE_SERVICE__ ?? null;
  }
  var parseKeyToCategoryId = (key2) => {
    const parts = key2.split("/").filter(Boolean);
    if (!parts.length) return null;
    const start2 = parts[0] === "sprite" || parts[0] === "sprites" ? 1 : 0;
    const category = parts[start2] ?? "";
    const id = parts.slice(start2 + 1).join("/") || parts[parts.length - 1] || "";
    if (!category || !id) return null;
    return { category, id };
  };
  function whenServiceReady(handle) {
    if (!handle || !handle.ready || typeof handle.ready.then !== "function") {
      return Promise.resolve();
    }
    return handle.ready.then(
      () => {
      },
      () => {
      }
    );
  }
  async function ensureSpriteDataCached(service, category, spriteId, logTag, options) {
    if (!service?.renderToCanvas) {
      return null;
    }
    const { list: mutationList, key: mutationKey } = normalizeMutationList(options?.mutations);
    const cacheKey = cacheKeyFor(category, spriteId, mutationKey);
    let promise2 = spriteDataUrlCache.get(cacheKey);
    if (!promise2) {
      promise2 = scheduleNonBlocking(async () => {
        try {
          const canvas = service.renderToCanvas?.({
            category,
            id: spriteId,
            mutations: mutationList
          });
          if (!canvas) return null;
          const dataUrl = canvas.toDataURL("image/png");
          if (dataUrl) {
            spriteDataUrlResolved.set(cacheKey, dataUrl);
          }
          return dataUrl;
        } catch (error) {
          console.error("[SpriteIconCache]", "failed to cache sprite", { category, spriteId, logTag, error });
          return null;
        }
      });
      spriteDataUrlCache.set(cacheKey, promise2);
    }
    return promise2;
  }
  var spriteMatchCache = /* @__PURE__ */ new Map();
  function getMatchCacheKey(categories, id) {
    const normalizedCategories = categories.map((category) => category.toLowerCase()).join("|");
    return `${normalizedCategories}|${normalizeSpriteId(id)}`;
  }
  function findCachedSpriteMatch(categories, candidateIds) {
    for (const candidate of candidateIds) {
      const cacheKey = getMatchCacheKey(categories, candidate);
      if (!spriteMatchCache.has(cacheKey)) continue;
      const match = spriteMatchCache.get(cacheKey);
      if (match) {
        return { match, candidate };
      }
    }
    return null;
  }
  function findSpriteMatch(service, categories, id) {
    if (!service.list) return null;
    const cacheKey = getMatchCacheKey(categories, id);
    if (spriteMatchCache.has(cacheKey)) {
      return spriteMatchCache.get(cacheKey) ?? null;
    }
    const normalizedTarget = normalizeSpriteId(id);
    const categoryLists = categories.map((category) => ({
      category,
      items: service.list?.(category) ?? []
    }));
    let matched = null;
    const tryMatch = (category, base) => {
      if (normalizeSpriteId(base) === normalizedTarget) {
        matched = { category, spriteId: base };
        return true;
      }
      return false;
    };
    for (const { category, items } of categoryLists) {
      for (const it of items) {
        const key2 = typeof it?.key === "string" ? it.key : "";
        if (!key2) continue;
        const base = baseNameFromKey(key2);
        if (tryMatch(category, base)) {
          spriteMatchCache.set(cacheKey, matched);
          return matched;
        }
      }
    }
    for (const { category, items } of categoryLists) {
      for (const it of items) {
        const key2 = typeof it?.key === "string" ? it.key : "";
        if (!key2) continue;
        const base = baseNameFromKey(key2);
        const normBase = normalizeSpriteId(base);
        if (!normBase) continue;
        if (normalizedTarget.includes(normBase) || normBase.includes(normalizedTarget) || normBase.startsWith(normalizedTarget) || normalizedTarget.startsWith(normBase)) {
          matched = { category, spriteId: base };
          spriteMatchCache.set(cacheKey, matched);
          return matched;
        }
      }
    }
    spriteMatchCache.set(cacheKey, null);
    return null;
  }
  function attachSpriteIcon(target, categories, id, size, logTag, options) {
    const candidateIds = Array.isArray(id) ? id.map((value) => String(value ?? "").trim()).filter(Boolean) : [String(id ?? "").trim()].filter(Boolean);
    if (!candidateIds.length) return;
    const cachedMatch = findCachedSpriteMatch(categories, candidateIds);
    if (cachedMatch) {
      const { match, candidate } = cachedMatch;
      const { key: mutationKey } = normalizeMutationList(options?.mutations);
      const spriteKey = `${match.category}:${match.spriteId}${mutationKey}`;
      const cacheKey = cacheKeyFor(match.category, match.spriteId, mutationKey);
      const cachedUrl = spriteDataUrlResolved.get(cacheKey);
      const existingImg = target.querySelector("img[data-sprite-key]");
      if (existingImg && existingImg.dataset.spriteKey === spriteKey) {
        return;
      }
      if (cachedUrl) {
        const img = document.createElement("img");
        img.src = cachedUrl;
        img.width = size;
        img.height = size;
        img.alt = "";
        img.decoding = "async";
        img.loading = "lazy";
        img.draggable = false;
        img.style.width = `${size}px`;
        img.style.height = `${size}px`;
        img.style.objectFit = "contain";
        img.style.imageRendering = "auto";
        img.style.display = "block";
        img.dataset.spriteKey = spriteKey;
        img.dataset.spriteCategory = match.category;
        img.dataset.spriteId = match.spriteId;
        target.replaceChildren(img);
        options?.onSpriteApplied?.(img, {
          category: match.category,
          spriteId: match.spriteId,
          candidate
        });
        return;
      }
    }
    const service = getSpriteService();
    if (!service?.renderToCanvas) return;
    void whenServiceReady(service).then(
      () => scheduleNonBlocking(async () => {
        let selected = null;
        for (const candidate of candidateIds) {
          const match = findSpriteMatch(service, categories, candidate);
          if (match) {
            selected = { match, candidate };
            break;
          }
        }
        if (!selected) {
          options?.onNoSpriteFound?.({ categories, candidates: candidateIds });
          return;
        }
        const resolved = selected;
        const { key: mutationKey } = normalizeMutationList(options?.mutations);
        const spriteKey = `${resolved.match.category}:${resolved.match.spriteId}${mutationKey}`;
        const existingImg = target.querySelector("img[data-sprite-key]");
        if (existingImg && existingImg.dataset.spriteKey === spriteKey) {
          return;
        }
        const dataUrl = await ensureSpriteDataCached(
          service,
          resolved.match.category,
          resolved.match.spriteId,
          logTag,
          {
            mutations: options?.mutations
          }
        );
        if (!dataUrl) return;
        const img = document.createElement("img");
        img.src = dataUrl;
        img.width = size;
        img.height = size;
        img.alt = "";
        img.decoding = "async";
        img.loading = "lazy";
        img.draggable = false;
        img.style.width = `${size}px`;
        img.style.height = `${size}px`;
        img.style.objectFit = "contain";
        img.style.imageRendering = "auto";
        img.style.display = "block";
        img.dataset.spriteKey = spriteKey;
        img.dataset.spriteCategory = resolved.match.category;
        img.dataset.spriteId = resolved.match.spriteId;
        requestAnimationFrame(() => {
          target.replaceChildren(img);
          options?.onSpriteApplied?.(img, {
            category: resolved.match.category,
            spriteId: resolved.match.spriteId,
            candidate: resolved.candidate
          });
        });
      })
    );
  }
  function attachWeatherSpriteIcon(target, tag, size) {
    if (tag === "NoWeatherEffect") return;
    attachSpriteIcon(target, ["mutation"], tag, size, "weather");
  }
  function warmupSpriteCache() {
    if (spriteWarmupQueued || spriteWarmupStarted || typeof window === "undefined") return;
    spriteWarmupQueued = true;
    notifyWarmup({ total: warmupState.total, done: warmupState.done, completed: false });
    const scheduleRetry = () => {
      window.setTimeout(() => {
        spriteWarmupQueued = false;
        warmupSpriteCache();
      }, WARMUP_RETRY_MS);
    };
    let service = getSpriteService();
    if (!service && prefetchedWarmupKeys.length === 0) {
      scheduleRetry();
      return;
    }
    const tasks = [];
    const seen = new Set(warmupCompletedKeys);
    if (service?.list) {
      SPRITE_PRELOAD_CATEGORIES.forEach((category) => {
        const items = service.list?.(category) ?? [];
        items.forEach((item) => {
          const key2 = typeof item?.key === "string" ? item.key : "";
          if (!key2) return;
          const base = baseNameFromKey(key2);
          if (!base) return;
          const k = `${category}:${base.toLowerCase()}`;
          if (seen.has(k)) return;
          seen.add(k);
          tasks.push({ category, id: base });
        });
      });
    }
    if (prefetchedWarmupKeys.length) {
      prefetchedWarmupKeys.forEach((key2) => {
        const parsed = parseKeyToCategoryId(key2);
        if (!parsed) return;
        const k = `${parsed.category}:${parsed.id.toLowerCase()}`;
        if (seen.has(k)) return;
        seen.add(k);
        tasks.push(parsed);
      });
      prefetchedWarmupKeys = [];
    }
    if (!tasks.length) {
      if (warmupState.completed) {
        spriteWarmupQueued = false;
        return;
      }
      scheduleRetry();
      return;
    }
    spriteWarmupStarted = true;
    const total = Math.max(warmupState.total, tasks.length);
    const startingDone = Math.min(warmupState.done, total);
    notifyWarmup({ total, done: startingDone, completed: total === 0 || startingDone >= total });
    const processNext = () => {
      service = service || getSpriteService();
      if (!service?.renderToCanvas || !service?.list) {
        setTimeout(processNext, WARMUP_RETRY_MS);
        return;
      }
      if (!tasks.length) {
        spriteWarmupQueued = false;
        console.log("[SpriteIconCache]", "warmup complete", {
          categories: SPRITE_PRELOAD_CATEGORIES,
          totalCached: spriteDataUrlCache.size
        });
        notifyWarmup({ total, done: warmupState.done, completed: true });
        return;
      }
      let processed = 0;
      const batch = tasks.splice(0, WARMUP_BATCH);
      batch.forEach((entry) => {
        ensureSpriteDataCached(service, entry.category, entry.id, "warmup").then((result) => {
          if (result == null && !service?.renderToCanvas) {
            tasks.unshift(entry);
            return;
          }
          const completionKey = cacheKeyFor(entry.category, entry.id);
          if (!warmupCompletedKeys.has(completionKey)) {
            warmupCompletedKeys.add(completionKey);
            const nextDone = Math.min(warmupState.done + 1, total);
            notifyWarmup({ total, done: nextDone, completed: nextDone >= total });
          }
        }).finally(() => {
          processed += 1;
          if (processed >= batch.length) {
            setTimeout(processNext, WARMUP_DELAY_MS);
          }
        });
      });
    };
    processNext();
  }

  // src/utils/gameVersion.ts
  var gameVersion = null;
  function initGameVersion(doc) {
    if (gameVersion !== null) {
      return;
    }
    const d = doc ?? (typeof document !== "undefined" ? document : null);
    if (!d) {
      return;
    }
    const scripts = d.scripts;
    for (let i = 0; i < scripts.length; i++) {
      const script = scripts.item(i);
      if (!script) continue;
      const src = script.src;
      if (!src) continue;
      const match = src.match(/\/(?:r\/\d+\/)?version\/([^/]+)/);
      if (match && match[1]) {
        gameVersion = match[1];
        return;
      }
    }
  }

  // src/sprite/index.ts
  var ctx = createSpriteContext();
  var hooks = createPixiHooks();
  var parseFrameCategory = (key2) => {
    const parts = String(key2 || "").split("/").filter(Boolean);
    if (!parts.length) return null;
    const start2 = parts[0] === "sprite" || parts[0] === "sprites" ? 1 : 0;
    const category = parts[start2] ?? "";
    const id = parts.slice(start2 + 1).join("/") || parts[parts.length - 1] || "";
    if (!category || !id) return null;
    return { category, id };
  };
  var yieldToBrowser = () => {
    return new Promise((resolve2) => {
      const win = typeof window !== "undefined" ? window : null;
      if (win?.requestIdleCallback) {
        win.requestIdleCallback(() => resolve2(), { timeout: 32 });
      } else if (typeof requestAnimationFrame === "function") {
        requestAnimationFrame(() => resolve2());
      } else {
        setTimeout(resolve2, 0);
      }
    });
  };
  var delay = (ms) => new Promise((resolve2) => setTimeout(resolve2, ms));
  async function warmupSpritesFromAtlases(atlasJsons, blobs) {
    const FRAME_YIELD_EVERY = 6;
    const MAX_CHUNK_MS = 10;
    let framesSinceYield = 0;
    let chunkStart = typeof performance !== "undefined" ? performance.now() : Date.now();
    const resetChunk = () => {
      chunkStart = typeof performance !== "undefined" ? performance.now() : Date.now();
    };
    const yieldIfNeeded = async () => {
      const now2 = typeof performance !== "undefined" ? performance.now() : Date.now();
      const elapsed = now2 - chunkStart;
      if (framesSinceYield >= FRAME_YIELD_EVERY || elapsed >= MAX_CHUNK_MS) {
        framesSinceYield = 0;
        await yieldToBrowser();
        resetChunk();
      }
    };
    for (const [path, data] of Object.entries(atlasJsons)) {
      if (!isAtlas(data)) continue;
      const frames = data.frames || {};
      if (!frames || !Object.keys(frames).length) continue;
      const imgPath = relPath(path, data.meta.image);
      const blob = blobs.get(imgPath);
      if (!blob) continue;
      let img;
      try {
        img = await blobToImage(blob);
      } catch (error) {
        console.warn("[MG SpriteCatalog] warmup decode failed", { imgPath, error });
        continue;
      }
      for (const [frameKey, frameData] of Object.entries(frames)) {
        const parsed = parseFrameCategory(frameKey);
        if (!parsed) continue;
        try {
          const dataUrl = drawFrameToDataURL(img, frameKey, frameData);
          if (!dataUrl) continue;
          primeSpriteData(parsed.category, parsed.id, dataUrl);
        } catch (error) {
          console.warn("[MG SpriteCatalog] warmup frame failed", { frameKey, error });
        }
        framesSinceYield += 1;
        await yieldIfNeeded();
      }
      framesSinceYield = 0;
      await yieldToBrowser();
      resetChunk();
    }
  }
  var prefetchPromise = null;
  function detectGameVersion() {
    try {
      initGameVersion();
      if (gameVersion) return gameVersion;
    } catch {
    }
    const root = globalThis.unsafeWindow || globalThis;
    const gv = root.gameVersion || root.MG_gameVersion || root.__MG_GAME_VERSION__;
    if (gv) {
      if (typeof gv.getVersion === "function") return gv.getVersion();
      if (typeof gv.get === "function") return gv.get();
      if (typeof gv === "string") return gv;
    }
    const scriptUrls = Array.from(document.scripts || []).map((s) => s.src).filter(Boolean);
    const linkUrls = Array.from(document.querySelectorAll("link[href]") || []).map(
      (l) => l.href
    );
    const urls = [...scriptUrls, ...linkUrls];
    for (const u of urls) {
      const m = u.match(/\/version\/([^/]+)\//);
      if (m?.[1]) return m[1];
    }
    throw new Error("Version not found.");
  }
  async function resolveGameVersionWithRetry(timeoutMs = 6e3) {
    const deadline = Date.now() + timeoutMs;
    let lastError = null;
    while (Date.now() < deadline) {
      try {
        const v = detectGameVersion();
        if (v) return v;
      } catch (err) {
        lastError = err;
      }
      await delay(120);
    }
    throw lastError ?? new Error("Version not found.");
  }
  function drawFrameToDataURL(img, frameKey, data) {
    try {
      const fr = data.frame;
      const trimmed = data.trimmed && data.spriteSourceSize;
      const sourceSize = data.sourceSize || { w: fr.w, h: fr.h };
      const canvas = document.createElement("canvas");
      canvas.width = sourceSize.w;
      canvas.height = sourceSize.h;
      const ctx2 = canvas.getContext("2d");
      if (!ctx2) return null;
      ctx2.imageSmoothingEnabled = false;
      if (data.rotated) {
        ctx2.save();
        ctx2.translate(sourceSize.w / 2, sourceSize.h / 2);
        ctx2.rotate(-Math.PI / 2);
        ctx2.drawImage(
          img,
          fr.x,
          fr.y,
          fr.h,
          fr.w,
          -fr.h / 2,
          -fr.w / 2,
          fr.h,
          fr.w
        );
        ctx2.restore();
      } else {
        const dx = trimmed ? data.spriteSourceSize.x : 0;
        const dy = trimmed ? data.spriteSourceSize.y : 0;
        ctx2.drawImage(img, fr.x, fr.y, fr.w, fr.h, dx, dy, fr.w, fr.h);
      }
      return canvas.toDataURL("image/png");
    } catch {
      return null;
    }
  }
  async function prefetchAtlas(base) {
    try {
      const manifest = await getJSON(joinPath(base, "manifest.json"));
      const atlasJsons = await loadAtlasJsons(base, manifest);
      const blobs = /* @__PURE__ */ new Map();
      for (const [path, data] of Object.entries(atlasJsons)) {
        if (!isAtlas(data)) continue;
        const imgPath = relPath(path, data.meta.image);
        try {
          const blob = await getBlob(joinPath(base, imgPath));
          blobs.set(imgPath, blob);
        } catch {
        }
      }
      const warmupKeys = [];
      Object.entries(atlasJsons).forEach(([, data]) => {
        if (!isAtlas(data)) return;
        Object.keys(data.frames || {}).forEach((frameKey) => warmupKeys.push(frameKey));
      });
      if (warmupKeys.length) {
        try {
          primeWarmupKeys(warmupKeys);
        } catch {
        }
      }
      try {
        warmupSpriteCache();
      } catch {
      }
      if (warmupKeys.length) {
        warmupSpritesFromAtlases(atlasJsons, blobs).catch(() => {
        });
      }
      return { base, atlasJsons, blobs };
    } catch {
      return null;
    }
  }
  async function loadTextures(base, prefetched) {
    const usePrefetched = prefetched && prefetched.base === base ? prefetched : null;
    const atlasJsons = usePrefetched?.atlasJsons ?? await loadAtlasJsons(base, await getJSON(joinPath(base, "manifest.json")));
    const ctors = ctx.state.ctors;
    if (!ctors?.Texture || !ctors?.Rectangle) throw new Error("PIXI constructors missing");
    for (const [path, data] of Object.entries(atlasJsons)) {
      if (!isAtlas(data)) continue;
      const imgPath = relPath(path, data.meta.image);
      const blob = usePrefetched?.blobs.get(imgPath) ?? usePrefetched?.blobs.get(relPath(path, data.meta.image)) ?? await getBlob(joinPath(base, imgPath));
      const img = await blobToImage(blob);
      const baseTex = ctors.Texture.from(img);
      buildAtlasTextures(data, baseTex, ctx.state.tex, ctx.state.atlasBases, {
        Texture: ctors.Texture,
        Rectangle: ctors.Rectangle
      });
    }
    const { items, cats } = buildItemsFromTextures(ctx.state.tex, ctx.cfg);
    ctx.state.items = items;
    ctx.state.filtered = items.slice();
    ctx.state.cats = cats;
    ctx.state.loaded = true;
  }
  function ensureDocumentReady() {
    if (document.readyState !== "loading") return Promise.resolve();
    return new Promise((resolve2) => {
      const onReady = () => {
        document.removeEventListener("DOMContentLoaded", onReady);
        resolve2();
      };
      document.addEventListener("DOMContentLoaded", onReady);
    });
  }
  async function resolvePixiFast() {
    const root = globalThis.unsafeWindow || globalThis;
    const check = () => {
      const app = root.__PIXI_APP__ || root.PIXI_APP || root.app || null;
      const renderer = root.__PIXI_RENDERER__ || root.PIXI_RENDERER__ || root.renderer || app?.renderer || null;
      if (app && renderer) {
        return { app, renderer, version: root.__PIXI_VERSION__ || null };
      }
      return null;
    };
    const hit = check();
    if (hit) return hit;
    const maxMs = 5e3;
    const start2 = performance.now();
    while (performance.now() - start2 < maxMs) {
      await new Promise((r) => setTimeout(r, 50));
      const retry = check();
      if (retry) return retry;
    }
    const waited = await waitForPixi(hooks);
    return { app: waited.app, renderer: waited.renderer, version: waited.version };
  }
  async function start() {
    if (ctx.state.started) return;
    ctx.state.started = true;
    let version;
    const retryDeadline = typeof performance !== "undefined" ? performance.now() + 8e3 : Date.now() + 8e3;
    for (; ; ) {
      try {
        version = await resolveGameVersionWithRetry();
        console.info("[MG SpriteCatalog] game version resolved", version);
        break;
      } catch (err) {
        const now2 = typeof performance !== "undefined" ? performance.now() : Date.now();
        if (now2 >= retryDeadline) {
          console.error("[MG SpriteCatalog] failed to resolve game version", err);
          throw err;
        }
        console.warn("[MG SpriteCatalog] retrying game version detection...");
        await delay(200);
      }
    }
    const base = `${ctx.cfg.origin.replace(/\/$/, "")}/version/${version}/assets/`;
    if (!prefetchPromise) {
      prefetchPromise = prefetchAtlas(base);
    }
    const { app, renderer: _renderer, version: pixiVersion } = await resolvePixiFast();
    await ensureDocumentReady();
    ctx.state.ctors = getCtors(app);
    const renderer = _renderer || app?.renderer || app?.render || null;
    ctx.state.app = app;
    ctx.state.renderer = renderer;
    ctx.state.version = pixiVersion || version || version === "" ? pixiVersion ?? version : detectGameVersion();
    ctx.state.base = base;
    ctx.state.sig = curVariant(ctx.state).sig;
    const prefetched = await (prefetchPromise ?? Promise.resolve(null));
    await loadTextures(ctx.state.base, prefetched);
    const hud = {
      open() {
        ctx.state.open = true;
      },
      close() {
        ctx.state.open = false;
      },
      toggle() {
        ctx.state.open ? this.close() : this.open();
      },
      layout() {
      },
      root: void 0
    };
    ctx.state.open = true;
    app.ticker?.add?.(() => {
      processJobs(ctx.state, ctx.cfg);
    });
    exposeApi(ctx.state, hud);
    const g = globalThis;
    const uw = g.unsafeWindow || g;
    const spriteApi = await Promise.resolve().then(() => (init_spriteApi(), spriteApi_exports));
    const ensureOverlayHost = () => {
      const id = "mg-sprite-overlay";
      let host = document.getElementById(id);
      if (!host) {
        host = document.createElement("div");
        host.id = id;
        host.style.cssText = "position:fixed;top:8px;left:8px;z-index:2147480000;display:flex;flex-wrap:wrap;gap:8px;pointer-events:auto;background:transparent;align-items:flex-start;";
        document.body.appendChild(host);
      }
      return host;
    };
    const getSpriteDim = (tex, key2) => {
      const sources = [
        tex?.orig,
        tex?._orig,
        tex?.frame,
        tex?._frame,
        tex
      ];
      for (const src of sources) {
        const value = src?.[key2];
        if (typeof value === "number" && Number.isFinite(value) && value > 0) {
          return value;
        }
      }
      return null;
    };
    const padCanvasToSpriteBounds = (source, tex) => {
      const rawW = source.width || 1;
      const rawH = source.height || 1;
      const baseW = Math.max(rawW, Math.round(getSpriteDim(tex, "width") ?? rawW) || rawW);
      const baseH = Math.max(rawH, Math.round(getSpriteDim(tex, "height") ?? rawH) || rawH);
      const trim = tex?.trim ?? tex?._trim ?? null;
      let offsetX = trim && typeof trim.x === "number" ? Math.round(trim.x) : Math.round((baseW - rawW) / 2);
      let offsetY = trim && typeof trim.y === "number" ? Math.round(trim.y) : Math.round((baseH - rawH) / 2);
      offsetX = Math.max(0, Math.min(baseW - rawW, offsetX));
      offsetY = Math.max(0, Math.min(baseH - rawH, offsetY));
      if (baseW === rawW && baseH === rawH && offsetX === 0 && offsetY === 0) {
        return source;
      }
      const canvas = document.createElement("canvas");
      canvas.width = baseW;
      canvas.height = baseH;
      const ctx2 = canvas.getContext("2d");
      if (!ctx2) return source;
      ctx2.imageSmoothingEnabled = false;
      ctx2.clearRect(0, 0, baseW, baseH);
      ctx2.drawImage(source, offsetX, offsetY);
      return canvas;
    };
    const renderTextureToCanvas = (tex) => {
      try {
        const spr = new ctx.state.ctors.Sprite(tex);
        const extracted = ctx.state.renderer.extract.canvas(spr, { resolution: 1 });
        spr.destroy?.({ children: true, texture: false, baseTexture: false });
        return padCanvasToSpriteBounds(extracted, tex);
      } catch {
        return null;
      }
    };
    const service = {
      ready: Promise.resolve(),
      // overwritten below
      state: ctx.state,
      cfg: ctx.cfg,
      list(category = "any") {
        return spriteApi.listItemsByCategory(ctx.state, category);
      },
      getBaseSprite(params) {
        return spriteApi.getBaseSprite(params, ctx.state);
      },
      getSpriteWithMutations(params) {
        return spriteApi.getSpriteWithMutations(params, ctx.state, ctx.cfg);
      },
      buildVariant(mutations) {
        return spriteApi.buildVariant(mutations);
      },
      renderToCanvas(arg) {
        const tex = arg?.isTexture || arg?.frame ? arg : service.getSpriteWithMutations(arg);
        if (!tex) return null;
        return renderTextureToCanvas(tex);
      },
      async renderToDataURL(arg, type = "image/png", quality) {
        const c = service.renderToCanvas(arg);
        if (!c) return null;
        return c.toDataURL(type, quality);
      },
      // Render and append to a fixed overlay; each sprite gets its own wrapper.
      renderOnCanvas(arg, opts = {}) {
        const c = service.renderToCanvas(arg);
        if (!c) return null;
        c.style.background = "transparent";
        c.style.display = "block";
        let mutW = c.width || c.clientWidth;
        let mutH = c.height || c.clientHeight;
        let baseW = mutW;
        let baseH = mutH;
        if (arg && !arg.isTexture && !arg.frame) {
          const baseTex = service.getBaseSprite(arg);
          if (baseTex) {
            baseW = baseTex?.orig?.width ?? baseTex?._orig?.width ?? baseTex?.frame?.width ?? baseTex?._frame?.width ?? baseTex?.width ?? baseW;
            baseH = baseTex?.orig?.height ?? baseTex?._orig?.height ?? baseTex?.frame?.height ?? baseTex?._frame?.height ?? baseTex?.height ?? baseH;
          }
        }
        const scaleToBase = Math.min(baseW / mutW, baseH / mutH, 1);
        let logicalW = mutW * scaleToBase;
        let logicalH = mutH * scaleToBase;
        const { maxWidth, maxHeight, allowScaleUp } = opts;
        if (maxWidth || maxHeight) {
          const scaleW = maxWidth ? maxWidth / logicalW : 1;
          const scaleH = maxHeight ? maxHeight / logicalH : 1;
          let scale = Math.min(scaleW || 1, scaleH || 1);
          if (!allowScaleUp) scale = Math.min(scale, 1);
          logicalW = Math.floor(logicalW * scale);
          logicalH = Math.floor(logicalH * scale);
        }
        if (logicalW) c.style.width = `${logicalW}px`;
        if (logicalH) c.style.height = `${logicalH}px`;
        const wrap = document.createElement("div");
        wrap.style.cssText = "display:inline-flex;align-items:flex-start;justify-content:flex-start;padding:0;margin:0;background:transparent;border:none;flex:0 0 auto;";
        wrap.appendChild(c);
        ensureOverlayHost().appendChild(wrap);
        return { wrap, canvas: c };
      },
      clearOverlay() {
        const host = document.getElementById("mg-sprite-overlay");
        if (host) host.remove();
      },
      renderAnimToCanvases(params) {
        const item = ctx.state.items.find((it) => it.key === `sprite/${params.category}/${params.id}` || it.key === params.id);
        if (!item) return [];
        if (item.isAnim && item.frames?.length) {
          const texes = params?.mutations?.length ? [service.getSpriteWithMutations(params)] : item.frames;
          return texes.map((t2) => renderTextureToCanvas(t2)).filter(Boolean);
        }
        const t = service.getSpriteWithMutations(params);
        return t ? [renderTextureToCanvas(t)] : [];
      }
    };
    service.ready = Promise.resolve();
    uw.__MG_SPRITE_STATE__ = ctx.state;
    uw.__MG_SPRITE_CFG__ = ctx.cfg;
    uw.__MG_SPRITE_API__ = spriteApi;
    uw.__MG_SPRITE_SERVICE__ = service;
    uw.getSpriteWithMutations = service.getSpriteWithMutations;
    uw.getBaseSprite = service.getBaseSprite;
    uw.buildSpriteVariant = service.buildVariant;
    uw.listSpritesByCategory = service.list;
    uw.renderSpriteToCanvas = service.renderToCanvas;
    uw.renderSpriteToDataURL = service.renderToDataURL;
    uw.MG_SPRITE_HELPERS = service;
    console.log("[MG SpriteCatalog] ready", {
      version: ctx.state.version,
      pixi: version,
      textures: ctx.state.tex.size,
      items: ctx.state.items.length,
      cats: ctx.state.cats.size
    });
  }
  var __mg_ready = start();
  __mg_ready.catch((err) => console.error("[MG SpriteCatalog] failed", err));

  // src/core/state.ts
  init_page_context();
  var NativeWS = pageWindow.WebSocket;
  var NativeWorker = pageWindow.Worker;
  var sockets = [];
  var quinoaWS = null;
  function setQWS(ws, why) {
    if (!quinoaWS) {
      quinoaWS = ws;
      shareGlobal("quinoaWS", ws);
      try {
        console.log("[QuinoaWS] selected ->", why);
      } catch {
      }
    }
  }
  var workerFound = false;
  var Workers = typeof Set !== "undefined" ? /* @__PURE__ */ new Set() : {
    _a: [],
    add(w) {
      this._a.push(w);
    },
    delete(w) {
      const i = this._a.indexOf(w);
      if (i >= 0) this._a.splice(i, 1);
    },
    forEach(fn) {
      for (let i = 0; i < this._a.length; i++) fn(this._a[i]);
    }
  };
  function label(rs) {
    return ["CONNECTING", "OPEN", "CLOSING", "CLOSED"][rs ?? -1] || "none";
  }

  // src/hooks/ws-hook.ts
  init_page_context();

  // src/core/parse.ts
  async function parseWSData(d) {
    try {
      if (typeof d === "string") return JSON.parse(d);
      if (d instanceof Blob) return JSON.parse(await d.text());
      if (d instanceof ArrayBuffer) return JSON.parse(new TextDecoder().decode(d));
    } catch {
    }
    return null;
  }

  // src/hooks/ws-hook.ts
  init_atoms();

  // src/services/locker.ts
  init_atoms();

  // src/data/hardcoded-data.clean.js
  var rarity = {
    Common: "Common",
    Uncommon: "Uncommon",
    Rare: "Rare",
    Legendary: "Legendary",
    Mythic: "Mythical",
    Divine: "Divine",
    Celestial: "Celestial"
  };
  var harvestType = {
    Single: "Single",
    Multiple: "Multiple"
  };
  var tileRefsPlants = {
    Aloe: "sprite/plant/Aloe",
    Apple: "sprite/plant/Apple",
    BabyBeet: "sprite/plant/BabyBeet",
    BabyCarrot: "sprite/plant/BabyCarrot",
    Banana: "sprite/plant/Banana",
    Beet: "sprite/plant/Beet",
    Blueberry: "sprite/plant/Blueberry",
    BurrosTail: "sprite/plant/BurrosTail",
    BushyTree: "sprite/plant/BushyTree",
    Cabbage: "sprite/plant/Cabbage",
    CabbagePlant: "sprite/plant/CabbagePlant",
    Cacao: "sprite/plant/Cacao",
    CacaoTree: "sprite/plant/CacaoTree",
    Camellia: "sprite/plant/Camellia",
    Carrot: "sprite/plant/Carrot",
    Chrysanthemum: "sprite/plant/Chrysanthemum",
    Coconut: "sprite/plant/Coconut",
    Corn: "sprite/plant/Corn",
    Daffodil: "sprite/plant/Daffodil",
    DawnCelestialCrop: "sprite/plant/DawnCelestialCrop",
    Delphinium: "sprite/plant/Delphinium",
    DirtPatch: "sprite/plant/DirtPatch",
    DragonFruit: "sprite/plant/DragonFruit",
    DragonFruitTree: "sprite/plant/DragonFruitTree",
    Echeveria: "sprite/plant/Echeveria",
    FavaBean: "sprite/plant/FavaBean",
    FlowerBush: "sprite/plant/FlowerBush",
    Gentian: "sprite/plant/Gentian",
    Grape: "sprite/plant/Grape",
    Hedge: "sprite/plant/Hedge",
    Lemon: "sprite/plant/Lemon",
    Lily: "sprite/plant/Lily",
    Lychee: "sprite/plant/Lychee",
    MoonCelestialCrop: "sprite/plant/MoonCelestialCrop",
    Mushroom: "sprite/plant/Mushroom",
    PalmTree: "sprite/plant/PalmTree",
    PassionFruit: "sprite/plant/PassionFruit",
    Peach: "sprite/plant/Peach",
    Pear: "sprite/plant/Pear",
    Pepper: "sprite/plant/Pepper",
    PineTree: "sprite/plant/PineTree",
    Poinsettia: "sprite/plant/Poinsettia",
    Pumpkin: "sprite/plant/Pumpkin",
    RoseRed: "sprite/plant/RoseRed",
    Shrub: "sprite/plant/Shrub",
    SproutFlower: "sprite/plant/SproutFlower",
    SproutFruit: "sprite/plant/SproutFruit",
    SproutVine: "sprite/plant/SproutVine",
    Squash: "sprite/plant/Squash",
    Starweaver: "sprite/plant/Starweaver",
    StemFlower: "sprite/plant/StemFlower",
    Strawberry: "sprite/plant/Strawberry",
    Sunflower: "sprite/plant/Sunflower",
    Tomato: "sprite/plant/Tomato",
    Tree: "sprite/plant/Tree",
    Trellis: "sprite/plant/Trellis",
    Tulip: "sprite/plant/Tulip",
    VioletCort: "sprite/plant/VioletCort",
    Watermelon: "sprite/plant/Watermelon"
  };
  var tileRefsTallPlants = {
    Bamboo: "sprite/tall-plant/Bamboo",
    Cactus: "sprite/tall-plant/Cactus",
    DawnCelestialPlant: "sprite/tall-plant/DawnCelestialPlant",
    DawnCelestialPlantActive: "sprite/tall-plant/DawnCelestialPlantActive",
    DawnCelestialPlatform: "sprite/tall-plant/DawnCelestialPlatform",
    DawnCelestialPlatformTopmostLayer: "sprite/tall-plant/DawnCelestialPlatformTopmostLayer",
    MoonCelestialPlant: "sprite/tall-plant/MoonCelestialPlant",
    MoonCelestialPlantActive: "sprite/tall-plant/MoonCelestialPlantActive",
    MoonCelestialPlatform: "sprite/tall-plant/MoonCelestialPlatform",
    StarweaverPlant: "sprite/tall-plant/StarweaverPlant",
    StarweaverPlatform: "sprite/tall-plant/StarweaverPlatform"
  };
  var tileRefsSeeds = {
    Aloe: "sprite/seed/Aloe",
    Apple: "sprite/seed/Apple",
    Bamboo: "sprite/seed/Bamboo",
    Banana: "sprite/seed/Banana",
    Beet: "sprite/seed/Beet",
    Blueberry: "sprite/seed/Blueberry",
    BurrosTail: "sprite/seed/BurrosTail",
    Cabbage: "sprite/seed/Cabbage",
    Cacao: "sprite/seed/Cacao",
    Cactus: "sprite/seed/Cactus",
    Camellia: "sprite/seed/Camellia",
    Carrot: "sprite/seed/Carrot",
    Chrysanthemum: "sprite/seed/Chrysanthemum",
    Coconut: "sprite/seed/Coconut",
    Corn: "sprite/seed/Corn",
    Daffodil: "sprite/seed/Daffodil",
    DawnCelestial: "sprite/seed/DawnCelestial",
    Delphinium: "sprite/seed/Delphinium",
    DragonFruit: "sprite/seed/DragonFruit",
    Echeveria: "sprite/seed/Echeveria",
    FavaBean: "sprite/seed/FavaBean",
    Gentian: "sprite/seed/Gentian",
    Grape: "sprite/seed/Grape",
    Lemon: "sprite/seed/Lemon",
    Lily: "sprite/seed/Lily",
    Lychee: "sprite/seed/Lychee",
    MoonCelestial: "sprite/seed/MoonCelestial",
    Mushroom: "sprite/seed/Mushroom",
    PassionFruit: "sprite/seed/PassionFruit",
    Peach: "sprite/seed/Peach",
    Pear: "sprite/seed/Pear",
    Pepper: "sprite/seed/Pepper",
    Pinecone: "sprite/seed/Pinecone",
    Poinsettia: "sprite/seed/Poinsettia",
    Pumpkin: "sprite/seed/Pumpkin",
    Rose: "sprite/seed/Rose",
    Squash: "sprite/seed/Squash",
    Starweaver: "sprite/seed/Starweaver",
    Strawberry: "sprite/seed/Strawberry",
    Sunflower: "sprite/seed/Sunflower",
    Tomato: "sprite/seed/Tomato",
    Tulip: "sprite/seed/Tulip",
    VioletCort: "sprite/seed/VioletCort",
    Watermelon: "sprite/seed/Watermelon"
  };
  var tileRefsItems = {
    // UI / systme (pas dans V.Item)
    Coin: 1,
    InventoryBag: 7,
    MoneyBag: 11,
    JournalStamp: 22,
    Donut: 23,
    ToolsRestocked: 24,
    SeedsRestocked: 25,
    EggsRestocked: 26,
    DecorRestocked: 27,
    Leaderboard: 28,
    Stats: 29,
    ActivityLog: 30,
    ChatBubble: 39,
    ArrowKeys: 41,
    Touchpad: 42,
    // V.Item
    AmberlitPotion: "sprite/item/AmberlitPotion",
    ChilledPotion: "sprite/item/ChilledPotion",
    CropCleanser: "sprite/item/CropCleanser",
    DawnlitPotion: "sprite/item/DawnlitPotion",
    FrozenPotion: "sprite/item/FrozenPotion",
    GoldPotion: "sprite/item/GoldPotion",
    PlanterPot: "sprite/item/PlanterPot",
    RainbowPotion: "sprite/item/RainbowPotion",
    Shovel: "sprite/item/Shovel",
    WateringCan: "sprite/item/WateringCan",
    WetPotion: "sprite/item/WetPotion"
  };
  var tileRefsPets = {
    Bee: "sprite/pet/Bee",
    Bunny: "sprite/pet/Bunny",
    Butterfly: "sprite/pet/Butterfly",
    Capybara: "sprite/pet/Capybara",
    Chicken: "sprite/pet/Chicken",
    CommonEgg: "sprite/pet/CommonEgg",
    Cow: "sprite/pet/Cow",
    Dragonfly: "sprite/pet/Dragonfly",
    FireHorse: "sprite/pet/FireHorse",
    FireHorseActive: "sprite/pet/FireHorseActive",
    Goat: "sprite/pet/Goat",
    Horse: "sprite/pet/Horse",
    HorseEgg: "sprite/pet/HorseEgg",
    LegendaryEgg: "sprite/pet/LegendaryEgg",
    MythicalEgg: "sprite/pet/MythicalEgg",
    Peacock: "sprite/pet/Peacock",
    Pig: "sprite/pet/Pig",
    Pony: "sprite/pet/Pony",
    RareEgg: "sprite/pet/RareEgg",
    Snail: "sprite/pet/Snail",
    SnowEgg: "sprite/pet/SnowEgg",
    SnowFox: "sprite/pet/SnowFox",
    Squirrel: "sprite/pet/Squirrel",
    Stoat: "sprite/pet/Stoat",
    Turkey: "sprite/pet/Turkey",
    Turtle: "sprite/pet/Turtle",
    UncommonEgg: "sprite/pet/UncommonEgg",
    WhiteCaribou: "sprite/pet/WhiteCaribou",
    WinterEgg: "sprite/pet/WinterEgg",
    Worm: "sprite/pet/Worm",
    // Pas dans V.Pet (garder pour compatibilit)
    DivineEgg: 16,
    CelestialEgg: 17
  };
  var tileRefsMutations = {
    Ambercharged: "sprite/mutation/Ambercharged",
    Amberlit: "sprite/mutation/Amberlit",
    Chilled: "sprite/mutation/Chilled",
    Dawncharged: "sprite/mutation/Dawncharged",
    Dawnlit: "sprite/mutation/Dawnlit",
    Frozen: "sprite/mutation/Frozen",
    Puddle: "sprite/mutation/Puddle",
    Thunderstruck: "sprite/mutation/Thunderstruck",
    ThunderstruckGround: "sprite/mutation/ThunderstruckGround",
    Wet: "sprite/mutation/Wet"
  };
  var tileRefsMutationLabels = {
    Wet: "Wet",
    Chilled: "Chilled",
    Frozen: "Frozen",
    Puddle: "Puddle",
    Dawnlit: "Dawnlit",
    Amberlit: "Amberlit",
    Dawncharged: "Dawnbound",
    Ambercharged: "Amberbound",
    Thunderstruck: "Thunderstruck",
    ThunderstruckGround: "Thunderstruck"
  };
  var tileRefsDecor = {
    Birdhouse: "sprite/decor/Birdhouse",
    Cauldron: "sprite/decor/Cauldron",
    ColoredStringLights: "sprite/decor/ColoredStringLights",
    ColoredStringLightsSideways: "sprite/decor/ColoredStringLightsSideways",
    DecorShed: "sprite/decor/DecorShed",
    HayBale: "sprite/decor/HayBale",
    HayBaleSideways: "sprite/decor/HayBaleSideways",
    LargeGravestone: "sprite/decor/LargeGravestone",
    LargeGravestoneSideways: "sprite/decor/LargeGravestoneSideways",
    LargeRock: "sprite/decor/LargeRock",
    MarbleArch: "sprite/decor/MarbleArch",
    MarbleArchSideways: "sprite/decor/MarbleArchSideways",
    MarbleBench: "sprite/decor/MarbleBench",
    MarbleBenchBackwards: "sprite/decor/MarbleBenchBackwards",
    MarbleBenchSideways: "sprite/decor/MarbleBenchSideways",
    MarbleBlobling: "sprite/decor/MarbleBlobling",
    MarbleBridge: "sprite/decor/MarbleBridge",
    MarbleBridgeSideways: "sprite/decor/MarbleBridgeSideways",
    MarbleCaribou: "sprite/decor/MarbleCaribou",
    MarbleFountain: "sprite/decor/MarbleFountain",
    MarbleLampPost: "sprite/decor/MarbleLampPost",
    MediumGravestone: "sprite/decor/MediumGravestone",
    MediumGravestoneSideways: "sprite/decor/MediumGravestoneSideways",
    MediumRock: "sprite/decor/MediumRock",
    MiniFairyCottage: "sprite/decor/MiniFairyCottage",
    MiniFairyForge: "sprite/decor/MiniFairyForge",
    MiniFairyKeep: "sprite/decor/MiniFairyKeep",
    MiniWizardTower: "sprite/decor/MiniWizardTower",
    PaperLantern: "sprite/decor/PaperLantern",
    PaperLanternSideways: "sprite/decor/PaperLanternSideways",
    PetHutch: "sprite/decor/PetHutch",
    SeedSilo: "sprite/decor/SeedSilo",
    SmallGravestone: "sprite/decor/SmallGravestone",
    SmallGravestoneSideways: "sprite/decor/SmallGravestoneSideways",
    SmallRock: "sprite/decor/SmallRock",
    StoneArch: "sprite/decor/StoneArch",
    StoneArchSideways: "sprite/decor/StoneArchSideways",
    StoneBench: "sprite/decor/StoneBench",
    StoneBenchSideways: "sprite/decor/StoneBenchSideways",
    StoneBirdBath: "sprite/decor/StoneBirdBath",
    StoneBridge: "sprite/decor/StoneBridge",
    StoneBridgeSideways: "sprite/decor/StoneBridgeSideways",
    StoneCaribou: "sprite/decor/StoneCaribou",
    StoneGnome: "sprite/decor/StoneGnome",
    StoneLampPost: "sprite/decor/StoneLampPost",
    StrawScarecrow: "sprite/decor/StrawScarecrow",
    StringLights: "sprite/decor/StringLights",
    StringLightsSideways: "sprite/decor/StringLightsSideways",
    WoodArch: "sprite/decor/WoodArch",
    WoodArchSide: "sprite/decor/WoodArchSide",
    WoodBench: "sprite/decor/WoodBench",
    WoodBenchBackwards: "sprite/decor/WoodBenchBackwards",
    WoodBenchSideways: "sprite/decor/WoodBenchSideways",
    WoodBridge: "sprite/decor/WoodBridge",
    WoodBridgeSideways: "sprite/decor/WoodBridgeSideways",
    WoodCaribou: "sprite/decor/WoodCaribou",
    WoodLampPost: "sprite/decor/WoodLampPost",
    WoodOwl: "sprite/decor/WoodOwl",
    WoodPergola: "sprite/decor/WoodPergola",
    WoodWindmill: "sprite/decor/WoodWindmill"
  };
  var plantCatalog = {
    Carrot: {
      seed: {
        tileRef: tileRefsSeeds.Carrot,
        name: "Carrot Seed",
        coinPrice: 10,
        creditPrice: 7,
        rarity: rarity.Common
      },
      plant: {
        tileRef: tileRefsPlants.BabyCarrot,
        name: "Carrot Plant",
        harvestType: harvestType.Single,
        baseTileScale: 0.7
      },
      crop: {
        tileRef: tileRefsPlants.Carrot,
        name: "Carrot",
        baseSellPrice: 20,
        baseWeight: 0.1,
        baseTileScale: 0.6,
        maxScale: 3
      }
    },
    Cabbage: {
      seed: {
        tileRef: tileRefsSeeds.Cabbage,
        name: "Cabbage Seed",
        coinPrice: 30,
        creditPrice: 12,
        rarity: rarity.Common
      },
      plant: {
        tileRef: tileRefsPlants.CabbagePlant,
        name: "Cabbage Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [{
          x: 0,
          y: -0.05,
          rotation: 0
        }],
        secondsToMature: 45,
        baseTileScale: 1,
        rotateSlotOffsetsRandomly: false
      },
      crop: {
        tileRef: tileRefsPlants.Cabbage,
        name: "Cabbage",
        baseSellPrice: 42,
        baseWeight: 1,
        baseTileScale: 0.8,
        maxScale: 3
      }
    },
    Strawberry: {
      seed: {
        tileRef: tileRefsSeeds.Strawberry,
        name: "Strawberry Seed",
        coinPrice: 50,
        creditPrice: 21,
        rarity: rarity.Common
      },
      plant: {
        tileRef: tileRefsPlants.SproutFruit,
        name: "Strawberry Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.2, y: -0.1, rotation: 0 },
          { x: 0.175, y: -0.2, rotation: 0 },
          { x: -0.18, y: 0.22, rotation: 0 },
          { x: 0.2, y: 0.2, rotation: 0 },
          { x: 0.01, y: 0.01, rotation: 0 }
        ],
        secondsToMature: 70,
        baseTileScale: 1,
        rotateSlotOffsetsRandomly: true
      },
      crop: {
        tileRef: tileRefsPlants.Strawberry,
        name: "Strawberry",
        baseSellPrice: 14,
        baseWeight: 0.05,
        baseTileScale: 0.25,
        maxScale: 2
      }
    },
    Aloe: {
      seed: {
        tileRef: tileRefsSeeds.Aloe,
        name: "Aloe Seed",
        coinPrice: 135,
        creditPrice: 18,
        rarity: rarity.Common
      },
      plant: {
        tileRef: tileRefsPlants.AloePlant,
        name: "Aloe Plant",
        harvestType: harvestType.Single,
        baseTileScale: 0.9
      },
      crop: {
        tileRef: tileRefsPlants.Aloe,
        name: "Aloe",
        baseSellPrice: 310,
        baseWeight: 1.5,
        baseTileScale: 0.7,
        maxScale: 2.5
      }
    },
    Beet: {
      seed: {
        tileRef: tileRefsSeeds.Beet,
        name: "Beet Seed",
        coinPrice: 210,
        creditPrice: 25,
        rarity: rarity.Common
      },
      plant: {
        tileRef: tileRefsPlants.BabyBeet,
        name: "Beet Plant",
        harvestType: harvestType.Single,
        baseTileScale: 0.7
      },
      crop: {
        tileRef: tileRefsPlants.Beet,
        name: "Beet",
        baseSellPrice: 350,
        baseWeight: 0.3,
        baseTileScale: 0.2,
        maxScale: 3
      }
    },
    Rose: {
      seed: {
        tileRef: tileRefsSeeds.Rose,
        name: "Rose Seed",
        coinPrice: 229,
        creditPrice: 27,
        rarity: rarity.Uncommon
      },
      plant: {
        tileRef: tileRefsPlants.RoseRed,
        name: "Rose Plant",
        harvestType: harvestType.Single,
        baseTileScale: 1
      },
      crop: {
        tileRef: tileRefsPlants.RoseRed,
        name: "Rose",
        baseSellPrice: 300,
        baseWeight: 0.01,
        baseTileScale: 1,
        maxScale: 4
      }
    },
    FavaBean: {
      seed: {
        tileRef: tileRefsSeeds.FavaBean,
        name: "Fava Bean",
        coinPrice: 250,
        creditPrice: 30,
        rarity: rarity.Uncommon
      },
      plant: {
        tileRef: tileRefsPlants.SproutFlower,
        name: "Fava Bean Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.1, y: 0.15, rotation: 35 },
          { x: -0.23, y: 0.22, rotation: 35 },
          { x: 0.05, y: 0.3, rotation: 35 },
          { x: 0.18, y: 0.25, rotation: 35 },
          { x: 0.22, y: -0.02, rotation: 35 },
          { x: 0.1, y: -0.15, rotation: 35 },
          { x: -0.1, y: -0.17, rotation: 35 },
          { x: -0.25, y: -0.11, rotation: 35 }
        ],
        secondsToMature: 900,
        baseTileScale: 1.1,
        rotateSlotOffsetsRandomly: true
      },
      crop: {
        tileRef: tileRefsPlants.FavaBean,
        name: "Fava Bean Pod",
        baseSellPrice: 30,
        baseWeight: 0.03,
        baseTileScale: 0.3,
        maxScale: 3
      }
    },
    Delphinium: {
      seed: {
        tileRef: tileRefsSeeds.Delphinium,
        name: "Delphinium Seed",
        coinPrice: 300,
        creditPrice: 12,
        rarity: rarity.Uncommon
      },
      plant: {
        tileRef: tileRefsPlants.Delphinium,
        name: "Delphinium Plant",
        harvestType: harvestType.Single,
        baseTileScale: 0.8,
        tileTransformOrigin: "bottom",
        nudgeY: -0.43,
        nudgeYMultiplier: 0.05
      },
      crop: {
        tileRef: tileRefsPlants.Delphinium,
        name: "Delphinium",
        baseSellPrice: 530,
        baseWeight: 0.02,
        baseTileScale: 0.8,
        maxScale: 3
      }
    },
    Blueberry: {
      seed: {
        tileRef: tileRefsSeeds.Blueberry,
        name: "Blueberry Seed",
        coinPrice: 400,
        creditPrice: 49,
        rarity: rarity.Uncommon
      },
      plant: {
        tileRef: tileRefsPlants.SproutFruit,
        name: "Blueberry Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.2, y: -0.1, rotation: 0 },
          { x: 0.175, y: -0.2, rotation: 0 },
          { x: -0.18, y: 0.22, rotation: 0 },
          { x: 0.2, y: 0.2, rotation: 0 },
          { x: 0.01, y: 0.01, rotation: 0 }
        ],
        secondsToMature: 105,
        baseTileScale: 1,
        rotateSlotOffsetsRandomly: true
      },
      crop: {
        tileRef: tileRefsPlants.Blueberry,
        name: "Blueberry",
        baseSellPrice: 23,
        baseWeight: 0.01,
        baseTileScale: 0.25,
        maxScale: 2
      }
    },
    Apple: {
      seed: {
        tileRef: tileRefsSeeds.Apple,
        name: "Apple Seed",
        coinPrice: 500,
        creditPrice: 67,
        rarity: rarity.Uncommon,
        unavailableSurfaces: ["discord"]
      },
      plant: {
        tileRef: tileRefsTallPlants.Tree,
        name: "Apple Tree",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.35, y: -2.4, rotation: 0 },
          { x: -0.5, y: -2, rotation: 0 },
          { x: 0.1, y: -2.2, rotation: 0 },
          { x: -0.2, y: -1.65, rotation: 0 },
          { x: 0.55, y: -1.9, rotation: 0 },
          { x: 0.3, y: -1.7, rotation: 0 },
          { x: 0.4, y: 0.1, rotation: 0 }
        ],
        secondsToMature: 360 * 60,
        baseTileScale: 3,
        rotateSlotOffsetsRandomly: true,
        tileTransformOrigin: "bottom",
        nudgeY: -0.25
      },
      crop: {
        tileRef: tileRefsPlants.Apple,
        name: "Apple",
        baseSellPrice: 73,
        baseWeight: 0.18,
        baseTileScale: 0.5,
        maxScale: 2
      }
    },
    OrangeTulip: {
      seed: {
        tileRef: tileRefsSeeds.Tulip,
        name: "Tulip Seed",
        coinPrice: 600,
        creditPrice: 14,
        rarity: rarity.Uncommon
      },
      plant: {
        tileRef: tileRefsPlants.Tulip,
        name: "Tulip Plant",
        harvestType: harvestType.Single,
        baseTileScale: 0.5
      },
      crop: {
        tileRef: tileRefsPlants.Tulip,
        name: "Tulip",
        baseSellPrice: 767,
        baseWeight: 0.01,
        baseTileScale: 0.5,
        maxScale: 3
      }
    },
    Tomato: {
      seed: {
        tileRef: tileRefsSeeds.Tomato,
        name: "Tomato Seed",
        coinPrice: 800,
        creditPrice: 79,
        rarity: rarity.Uncommon
      },
      plant: {
        tileRef: tileRefsPlants.SproutVine,
        name: "Tomato Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.3, y: -0.3, rotation: 0 },
          { x: 0.3, y: 0.3, rotation: 0 }
        ],
        secondsToMature: 1100,
        baseTileScale: 1,
        rotateSlotOffsetsRandomly: false
      },
      crop: {
        tileRef: tileRefsPlants.Tomato,
        name: "Tomato",
        baseSellPrice: 27,
        baseWeight: 0.3,
        baseTileScale: 0.33,
        maxScale: 2
      }
    },
    Daffodil: {
      seed: {
        tileRef: tileRefsSeeds.Daffodil,
        name: "Daffodil Seed",
        coinPrice: 1e3,
        creditPrice: 19,
        rarity: rarity.Rare
      },
      plant: {
        tileRef: tileRefsPlants.Daffodil,
        name: "Daffodil Plant",
        harvestType: harvestType.Single,
        baseTileScale: 0.5
      },
      crop: {
        tileRef: tileRefsPlants.Daffodil,
        name: "Daffodil",
        baseSellPrice: 1090,
        baseWeight: 0.01,
        baseTileScale: 0.5,
        maxScale: 3
      }
    },
    Corn: {
      seed: {
        tileRef: tileRefsSeeds.Corn,
        name: "Corn Kernel",
        coinPrice: 1300,
        creditPrice: 135,
        rarity: rarity.Rare
      },
      plant: {
        tileRef: tileRefsPlants.SproutVegetable,
        name: "Corn Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [{ x: 0, y: -0.1, rotation: 0 }],
        secondsToMature: 130,
        baseTileScale: 1,
        rotateSlotOffsetsRandomly: false
      },
      crop: {
        tileRef: tileRefsPlants.Corn,
        name: "Corn",
        baseSellPrice: 36,
        baseWeight: 1.2,
        baseTileScale: 0.7,
        maxScale: 2
      }
    },
    Watermelon: {
      seed: {
        tileRef: tileRefsSeeds.Watermelon,
        name: "Watermelon Seed",
        coinPrice: 2500,
        creditPrice: 195,
        rarity: rarity.Rare
      },
      plant: {
        tileRef: tileRefsPlants.Watermelon,
        name: "Watermelon Plant",
        harvestType: harvestType.Single,
        baseTileScale: 0.8
      },
      crop: {
        tileRef: tileRefsPlants.Watermelon,
        name: "Watermelon",
        baseSellPrice: 2708,
        baseWeight: 4.5,
        baseTileScale: 0.8,
        maxScale: 3
      }
    },
    Pumpkin: {
      seed: {
        tileRef: tileRefsSeeds.Pumpkin,
        name: "Pumpkin Seed",
        coinPrice: 3e3,
        creditPrice: 210,
        rarity: rarity.Rare
      },
      plant: {
        tileRef: tileRefsPlants.Pumpkin,
        name: "Pumpkin Plant",
        harvestType: harvestType.Single,
        baseTileScale: 0.8
      },
      crop: {
        tileRef: tileRefsPlants.Pumpkin,
        name: "Pumpkin",
        baseSellPrice: 3700,
        baseWeight: 6,
        baseTileScale: 0.8,
        maxScale: 3
      }
    },
    Echeveria: {
      seed: {
        tileRef: tileRefsSeeds.Echeveria,
        name: "Echeveria Cutting",
        coinPrice: 4200,
        creditPrice: 113,
        rarity: rarity.Rare
      },
      plant: {
        tileRef: tileRefsPlants.Echeveria,
        name: "Echeveria Plant",
        harvestType: harvestType.Single,
        baseTileScale: 0.8
      },
      crop: {
        tileRef: tileRefsPlants.Echeveria,
        name: "Echeveria",
        baseSellPrice: 4600,
        baseWeight: 0.8,
        baseTileScale: 0.8,
        maxScale: 2.75
      }
    },
    Pear: {
      seed: {
        tileRef: tileRefsSeeds.Pear,
        name: "Pear Seed",
        coinPrice: 6e3,
        creditPrice: 122,
        rarity: rarity.Rare
      },
      plant: {
        tileRef: tileRefsPlants.Tree,
        name: "Pear Tree",
        harvestType: harvestType.Multiple,
        slotOffsets: [{
          x: -0.5,
          y: -1,
          rotation: 0
        }, {
          x: -0.35,
          y: -0.4,
          rotation: 0
        }, {
          x: 0.1,
          y: -0.45,
          rotation: 0
        }, {
          x: 0,
          y: -0.9,
          rotation: 0
        }, {
          x: 0.4,
          y: -0.7,
          rotation: 0
        }, {
          x: 0.5,
          y: -1.1,
          rotation: 0
        }, {
          x: -0.3,
          y: 1.2,
          rotation: 0
        }],
        secondsToMature: 360 * 60,
        baseTileScale: 3,
        rotateSlotOffsetsRandomly: true,
        tileTransformOrigin: "bottom",
        nudgeY: -0.25
      },
      crop: {
        tileRef: tileRefsPlants.Pear,
        name: "Pear",
        baseSellPrice: 250,
        baseWeight: 0.17,
        baseTileScale: 0.5,
        maxScale: 2
      }
    },
    Gentian: {
      seed: {
        tileRef: tileRefsSeeds.Gentian,
        name: "Gentian Seed",
        coinPrice: 9e3,
        creditPrice: 30,
        rarity: rarity.Rare
      },
      plant: {
        tileRef: tileRefsPlants.Gentian,
        name: "Gentian Plant",
        harvestType: harvestType.Single,
        baseTileScale: 0.5
      },
      crop: {
        tileRef: tileRefsPlants.Gentian,
        name: "Gentian",
        baseSellPrice: 1e4,
        baseWeight: 0.02,
        baseTileScale: 0.5,
        maxScale: 3
      }
    },
    Coconut: {
      seed: {
        tileRef: tileRefsSeeds.Coconut,
        name: "Coconut Seed",
        coinPrice: 1e4,
        creditPrice: 235,
        rarity: rarity.Legendary
      },
      plant: {
        tileRef: tileRefsTallPlants.PalmTree,
        name: "Coconut Tree",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.2, y: -2.6, rotation: 0 },
          { x: -0.3, y: -2.4, rotation: 0 },
          { x: 0.2, y: -2.5, rotation: 0 },
          { x: -0.25, y: -2.1, rotation: 0 },
          { x: 0, y: -2.3, rotation: 0 },
          { x: 0.3, y: -2.2, rotation: 0 },
          { x: 0.05, y: -2, rotation: 0 }
        ],
        secondsToMature: 720 * 60,
        baseTileScale: 3,
        rotateSlotOffsetsRandomly: true,
        tileTransformOrigin: "bottom",
        nudgeY: -0.35
      },
      crop: {
        tileRef: tileRefsPlants.Coconut,
        name: "Coconut",
        baseSellPrice: 302,
        baseWeight: 5,
        baseTileScale: 0.25,
        maxScale: 3
      }
    },
    PineTree: {
      seed: {
        tileRef: tileRefsSeeds.Pinecone,
        name: "Pinecone",
        coinPrice: 12e3,
        creditPrice: 30,
        rarity: rarity.Legendary
      },
      plant: {
        tileRef: tileRefsPlants.PineTree,
        name: "Pine Tree",
        harvestType: harvestType.Single,
        baseTileScale: 1.5
      },
      crop: {
        tileRef: tileRefsPlants.PineTree,
        name: "Pine Tree",
        baseSellPrice: 15e3,
        baseWeight: 1e3,
        baseTileScale: 1.5,
        maxScale: 3.5
      }
    },
    Banana: {
      seed: {
        tileRef: tileRefsSeeds.Banana,
        name: "Banana Seed",
        coinPrice: 15e3,
        creditPrice: 199,
        rarity: rarity.Legendary,
        getCanSpawnInGuild: (guildId) => {
          const last = guildId.slice(-1);
          const r = parseInt(last, 10);
          return !isNaN(r) && r % 2 === 0;
        },
        unavailableSurfaces: ["web"]
      },
      plant: {
        tileRef: tileRefsTallPlants.PalmTree,
        name: "Banana Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.3, y: -1.7, rotation: 10 },
          { x: -0.2, y: -1.7, rotation: -10 },
          { x: -0.1, y: -1.7, rotation: -30 },
          { x: 0, y: -1.7, rotation: -50 },
          { x: 0.1, y: -1.7, rotation: -70 }
        ],
        secondsToMature: 14400,
        baseTileScale: 2.5,
        rotateSlotOffsetsRandomly: false,
        tileTransformOrigin: "bottom",
        nudgeY: -0.4
      },
      crop: {
        tileRef: tileRefsPlants.Banana,
        name: "Banana",
        baseSellPrice: 1750,
        baseWeight: 0.12,
        baseTileScale: 0.5,
        maxScale: 1.7
      }
    },
    Lily: {
      seed: {
        tileRef: tileRefsSeeds.Lily,
        name: "Lily Seed",
        coinPrice: 2e4,
        creditPrice: 34,
        rarity: rarity.Legendary
      },
      plant: {
        tileRef: tileRefsPlants.Lily,
        name: "Lily Plant",
        harvestType: harvestType.Single,
        baseTileScale: 0.75,
        nudgeY: -0.1
      },
      crop: {
        tileRef: tileRefsPlants.Lily,
        name: "Lily",
        baseSellPrice: 20123,
        baseWeight: 0.02,
        baseTileScale: 0.5,
        maxScale: 2.75
      }
    },
    Camellia: {
      seed: {
        tileRef: tileRefsSeeds.Camellia,
        name: "Camellia Seed",
        coinPrice: 55e3,
        creditPrice: 289,
        rarity: rarity.Legendary
      },
      plant: {
        tileRef: tileRefsPlants.Hedge,
        name: "Camellia Hedge",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: 0, y: -0.9, rotation: 0 },
          { x: -0.28, y: -0.6, rotation: 0 },
          { x: 0.28, y: -0.6, rotation: 0 },
          { x: -0.35, y: -0.2, rotation: 0 },
          { x: 0.32, y: -0.2, rotation: 0 },
          { x: -0.3, y: 0.25, rotation: 0 },
          { x: 0.28, y: 0.25, rotation: 0 },
          { x: 0, y: 0, rotation: 0 }
        ],
        secondsToMature: 1440 * 60,
        baseTileScale: 2,
        rotateSlotOffsetsRandomly: true,
        tileTransformOrigin: "bottom",
        nudgeY: -0.4,
        nudgeYMultiplier: 0.5
      },
      crop: {
        tileRef: tileRefsPlants.Camellia,
        name: "Camellia",
        baseSellPrice: 4875,
        baseWeight: 0.3,
        baseTileScale: 0.4,
        maxScale: 2.5
      }
    },
    Squash: {
      seed: {
        tileRef: tileRefsSeeds.Squash,
        name: "Squash Seed",
        coinPrice: 55e3,
        creditPrice: 199,
        rarity: rarity.Legendary
      },
      plant: {
        tileRef: tileRefsPlants.SproutFlower,
        name: "Squash Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.08, y: 0.2, rotation: 35 },
          { x: 0.2, y: 0, rotation: 35 },
          { x: -0.2, y: -0.1, rotation: 35 }
        ],
        secondsToMature: 1500,
        baseTileScale: 1.2,
        rotateSlotOffsetsRandomly: true
      },
      crop: {
        tileRef: tileRefsPlants.Squash,
        name: "Squash",
        baseSellPrice: 3500,
        baseWeight: 0.3,
        baseTileScale: 0.4,
        maxScale: 2.5
      }
    },
    Peach: {
      seed: {
        tileRef: tileRefsSeeds.Peach,
        name: "Peach Seed",
        coinPrice: 85e3,
        creditPrice: 299,
        rarity: rarity.Legendary
      },
      plant: {
        tileRef: tileRefsPlants.Tree,
        name: "Peach Tree",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.66, y: -0.34, rotation: 0 },
          { x: -0.2, y: -0.1, rotation: 0 },
          { x: 0.35, y: -0.25, rotation: 0 },
          { x: 0.76, y: -0.56, rotation: 0 },
          { x: -0.08, y: -0.69, rotation: 0 },
          { x: 0.36, y: -1.03, rotation: 0 },
          { x: -0.54, y: -0.97, rotation: 0 }
        ],
        secondsToMature: 7200,
        rotateSlotOffsetsRandomly: true,
        baseTileScale: 3
      },
      crop: {
        tileRef: tileRefsPlants.Peach,
        name: "Peach",
        baseSellPrice: 9e3,
        baseWeight: 0.18,
        baseTileScale: 0.5,
        maxScale: 3
      }
    },
    BurrosTail: {
      seed: {
        tileRef: tileRefsSeeds.BurrosTail,
        name: "Burro's Tail Cutting",
        coinPrice: 93e3,
        creditPrice: 338,
        rarity: rarity.Legendary
      },
      plant: {
        tileRef: tileRefsPlants.Trellis,
        name: "Burro's Tail Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.13, y: -0.1, rotation: 0 },
          { x: 0.17, y: 0.13, rotation: 0 }
        ],
        secondsToMature: 1800,
        baseTileScale: 0.8,
        rotateSlotOffsetsRandomly: false
      },
      crop: {
        tileRef: tileRefsPlants.BurrosTail,
        name: "Burro's Tail",
        baseSellPrice: 6e3,
        baseWeight: 0.4,
        baseTileScale: 0.4,
        maxScale: 2.5
      }
    },
    Mushroom: {
      seed: {
        tileRef: tileRefsSeeds.Mushroom,
        name: "Mushroom Spore",
        coinPrice: 15e4,
        creditPrice: 249,
        rarity: rarity.Mythic
      },
      plant: {
        tileRef: tileRefsPlants.MushroomPlant,
        name: "Mushroom Plant",
        harvestType: harvestType.Single,
        baseTileScale: 0.8
      },
      crop: {
        tileRef: tileRefsPlants.Mushroom,
        name: "Mushroom",
        baseSellPrice: 16e4,
        baseWeight: 25,
        baseTileScale: 0.65,
        maxScale: 3.5
      }
    },
    Cactus: {
      seed: {
        tileRef: tileRefsSeeds.Cactus,
        name: "Cactus Seed",
        coinPrice: 25e4,
        creditPrice: 250,
        rarity: rarity.Mythic
      },
      plant: {
        tileRef: tileRefsTallPlants.Cactus,
        name: "Cactus Plant",
        harvestType: harvestType.Single,
        baseTileScale: 2.5,
        tileTransformOrigin: "bottom",
        nudgeY: -0.4,
        nudgeYMultiplier: 0.3
      },
      crop: {
        tileRef: tileRefsTallPlants.Cactus,
        name: "Cactus",
        baseSellPrice: 261e3,
        baseWeight: 1500,
        baseTileScale: 2.5,
        maxScale: 1.8
      }
    },
    Bamboo: {
      seed: {
        tileRef: tileRefsSeeds.Bamboo,
        name: "Bamboo Seed",
        coinPrice: 4e5,
        creditPrice: 300,
        rarity: rarity.Mythic
      },
      plant: {
        tileRef: tileRefsTallPlants.Bamboo,
        name: "Bamboo Plant",
        harvestType: harvestType.Single,
        baseTileScale: 2.5,
        tileTransformOrigin: "bottom",
        nudgeY: -0.45,
        nudgeYMultiplier: 0.3
      },
      crop: {
        tileRef: tileRefsTallPlants.Bamboo,
        name: "Bamboo Shoot",
        baseSellPrice: 5e5,
        baseWeight: 1,
        baseTileScale: 2.5,
        maxScale: 2
      }
    },
    Poinsettia: {
      seed: {
        tileRef: tileRefsSeeds.Poinsettia,
        name: "Poinsettia Seed",
        coinPrice: 5e5,
        creditPrice: 500,
        rarity: rarity.Mythic
      },
      plant: {
        tileRef: tileRefsTallPlants.Shrub,
        name: "Poinsettia Bush",
        harvestType: harvestType.Multiple,
        slotOffsets: [{
          x: 0.05,
          y: -0.4,
          rotation: 0
        }, {
          x: -0.3,
          y: -0.15,
          rotation: 0
        }, {
          x: 0.3,
          y: -0.1,
          rotation: 0
        }, {
          x: -0.02,
          y: 0.17,
          rotation: 0
        }],
        secondsToMature: 10800,
        baseTileScale: 1,
        rotateSlotOffsetsRandomly: true
      },
      crop: {
        tileRef: tileRefsTallPlants.Poinsettia,
        name: "Poinsettia",
        baseSellPrice: 3e4,
        baseWeight: 0.02,
        baseTileScale: 0.3,
        maxScale: 2
      }
    },
    VioletCort: {
      seed: {
        tileRef: tileRefsSeeds.VioletCort,
        name: "Violet Cort Spore",
        coinPrice: 52e4,
        creditPrice: 530,
        rarity: rarity.Mythic
      },
      plant: {
        tileRef: tileRefsPlants.VioletCort,
        name: "Violet Cort Plant",
        harvestType: harvestType.Single,
        baseTileScale: 0.55
      },
      crop: {
        tileRef: tileRefsPlants.VioletCort,
        name: "Violet Cort",
        baseSellPrice: 6e5,
        baseWeight: 2,
        baseTileScale: 0.65,
        maxScale: 3.5
      }
    },
    Chrysanthemum: {
      seed: {
        tileRef: tileRefsSeeds.Chrysanthemum,
        name: "Chrysanthemum Seed",
        coinPrice: 67e4,
        creditPrice: 567,
        rarity: rarity.Mythic
      },
      plant: {
        tileRef: tileRefsPlants.FlowerBush,
        name: "Chrysanthemum Bush",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: 0, y: 0, rotation: 0 },
          { x: -0.28, y: 0.22, rotation: 0 },
          { x: 0.28, y: 0.22, rotation: 0 },
          { x: 0, y: 0.33, rotation: 0 },
          { x: -0.25, y: -0.2, rotation: 0 },
          { x: 0.25, y: -0.2, rotation: 0 },
          { x: 0, y: -0.28, rotation: 0 }
        ],
        secondsToMature: 1440 * 60,
        baseTileScale: 1,
        rotateSlotOffsetsRandomly: false,
        tileTransformOrigin: "bottom"
      },
      crop: {
        tileRef: tileRefsPlants.Chrysanthemum,
        name: "Chrysanthemum",
        baseSellPrice: 18e3,
        baseWeight: 0.01,
        baseTileScale: 0.3,
        maxScale: 2.75
      }
    },
    Grape: {
      seed: {
        tileRef: tileRefsSeeds.Grape,
        name: "Grape Seed",
        coinPrice: 85e4,
        creditPrice: 599,
        rarity: rarity.Mythic,
        getCanSpawnInGuild: (guildId) => guildId.endsWith("1"),
        unavailableSurfaces: ["web"]
      },
      plant: {
        tileRef: tileRefsPlants.SproutVine,
        name: "Grape Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [{ x: 0, y: 0, rotation: 0 }],
        secondsToMature: 1440 * 60,
        baseTileScale: 1,
        rotateSlotOffsetsRandomly: true
      },
      crop: {
        tileRef: tileRefsPlants.Grape,
        name: "Grape",
        baseSellPrice: 12500,
        baseWeight: 3,
        baseTileScale: 0.5,
        maxScale: 2
      }
    },
    Pepper: {
      seed: {
        tileRef: tileRefsSeeds.Pepper,
        name: "Pepper Seed",
        coinPrice: 1e6,
        creditPrice: 629,
        rarity: rarity.Divine
      },
      plant: {
        tileRef: tileRefsPlants.SproutVine,
        name: "Pepper Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.02, y: 0.219, rotation: 0 },
          { x: 0.172, y: 0.172, rotation: 0 },
          { x: -0.172, y: 0.137, rotation: 0 },
          { x: 0.168, y: -0.035, rotation: 0 },
          { x: -0.082, y: -0.047, rotation: 0 },
          { x: -0.207, y: -0.074, rotation: 0 },
          { x: 0.18, y: -0.176, rotation: 0 },
          { x: -0.273, y: -0.195, rotation: 0 },
          { x: -0.074, y: -0.25, rotation: 0 }
        ],
        secondsToMature: 560,
        baseTileScale: 1,
        rotateSlotOffsetsRandomly: true
      },
      crop: {
        tileRef: tileRefsPlants.Pepper,
        name: "Pepper",
        baseSellPrice: 7220,
        baseWeight: 0.5,
        baseTileScale: 0.3,
        maxScale: 2
      }
    },
    Lemon: {
      seed: {
        tileRef: tileRefsSeeds.Lemon,
        name: "Lemon Seed",
        coinPrice: 2e6,
        creditPrice: 500,
        rarity: rarity.Divine,
        getCanSpawnInGuild: (guildId) => guildId.endsWith("2"),
        unavailableSurfaces: ["web"]
      },
      plant: {
        tileRef: tileRefsTallPlants.Tree,
        name: "Lemon Tree",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.5, y: -1.5, rotation: 0 },
          { x: 0.4, y: -1.6, rotation: 0 },
          { x: -0.3, y: -1.18, rotation: 0 },
          { x: 0.2, y: -1.2, rotation: 0 },
          { x: 0.01, y: -1.5, rotation: 0 },
          { x: -0.05, y: -1.8, rotation: 0 }
        ],
        secondsToMature: 720 * 60,
        baseTileScale: 2.3,
        rotateSlotOffsetsRandomly: true,
        tileTransformOrigin: "bottom",
        nudgeY: -0.25
      },
      crop: {
        tileRef: tileRefsPlants.Lemon,
        name: "Lemon",
        baseSellPrice: 1e4,
        baseWeight: 0.5,
        baseTileScale: 0.25,
        maxScale: 3
      }
    },
    PassionFruit: {
      seed: {
        tileRef: tileRefsSeeds.PassionFruit,
        name: "Passion Fruit Seed",
        coinPrice: 275e4,
        creditPrice: 679,
        rarity: rarity.Divine
      },
      plant: {
        tileRef: tileRefsPlants.SproutVine,
        name: "Passion Fruit Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.3, y: -0.3, rotation: 0 },
          { x: 0.3, y: 0.3, rotation: 0 }
        ],
        secondsToMature: 1440 * 60,
        baseTileScale: 1.1,
        rotateSlotOffsetsRandomly: false
      },
      crop: {
        tileRef: tileRefsPlants.PassionFruit,
        name: "Passion Fruit",
        baseSellPrice: 24500,
        baseWeight: 9.5,
        baseTileScale: 0.35,
        maxScale: 2
      }
    },
    DragonFruit: {
      seed: {
        tileRef: tileRefsSeeds.DragonFruit,
        name: "Dragon Fruit Seed",
        coinPrice: 5e6,
        creditPrice: 715,
        rarity: rarity.Divine
      },
      plant: {
        tileRef: tileRefsPlants.PalmTree,
        name: "Dragon Fruit Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.3, y: -0.4, rotation: 0 },
          { x: -0.4, y: -0.05, rotation: 0 },
          { x: 0.36, y: -0.3, rotation: 0 },
          { x: -0.25, y: 0.3, rotation: 0 },
          { x: 0, y: -0.1, rotation: 0 },
          { x: 0.4, y: 0.1, rotation: 0 },
          { x: 0.1, y: 0.2, rotation: 0 }
        ],
        secondsToMature: 600,
        baseTileScale: 1.6,
        rotateSlotOffsetsRandomly: true
      },
      crop: {
        tileRef: tileRefsPlants.DragonFruit,
        name: "Dragon Fruit",
        baseSellPrice: 24500,
        baseWeight: 8.4,
        baseTileScale: 0.4,
        maxScale: 2
      }
    },
    Cacao: {
      seed: {
        tileRef: tileRefsSeeds.Cacao,
        name: "Cacao Bean",
        coinPrice: 1e7,
        creditPrice: 750,
        rarity: rarity.Divine
      },
      plant: {
        tileRef: tileRefsTallPlants.CacaoTree,
        name: "Cacao Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: 0.28, y: -1.17, rotation: 20 },
          { x: -0.3, y: -1.07, rotation: 20 },
          { x: -0.05, y: -1.42, rotation: 20 },
          { x: 0.45, y: -1.67, rotation: 20 },
          { x: -0.5, y: -1.57, rotation: 20 },
          { x: -0.05, y: -1.87, rotation: 20 }
        ],
        secondsToMature: 1440 * 60,
        baseTileScale: 2.8,
        rotateSlotOffsetsRandomly: true,
        tileTransformOrigin: "bottom",
        nudgeY: -0.32
      },
      crop: {
        tileRef: tileRefsPlants.Cacao,
        name: "Cacao Fruit",
        baseSellPrice: 7e4,
        baseWeight: 0.5,
        baseTileScale: 0.4,
        maxScale: 2.5
      }
    },
    Lychee: {
      seed: {
        tileRef: tileRefsSeeds.Lychee,
        name: "Lychee Pit",
        coinPrice: 25e6,
        creditPrice: 819,
        rarity: rarity.Divine,
        getCanSpawnInGuild: (guildId) => guildId.endsWith("2"),
        unavailableSurfaces: ["web"]
      },
      plant: {
        tileRef: tileRefsPlants.BushyTree,
        name: "Lychee Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: -0.4, y: -0.1, rotation: 0 },
          { x: 0.3, y: -0.2, rotation: 0 },
          { x: -0.3, y: 0.22, rotation: 0 },
          { x: 0.2, y: 0.2, rotation: 0 },
          { x: 0.01, y: -0.1, rotation: 0 },
          { x: -0.2, y: -0.3, rotation: 0 }
        ],
        secondsToMature: 1440 * 60,
        baseTileScale: 1.2,
        rotateSlotOffsetsRandomly: true
      },
      crop: {
        tileRef: tileRefsPlants.Lychee,
        name: "Lychee Fruit",
        baseSellPrice: 5e4,
        baseWeight: 9,
        baseTileScale: 0.2,
        maxScale: 2
      }
    },
    Sunflower: {
      seed: {
        tileRef: tileRefsSeeds.Sunflower,
        name: "Sunflower Seed",
        coinPrice: 1e8,
        creditPrice: 900,
        rarity: rarity.Divine
      },
      plant: {
        tileRef: tileRefsPlants.StemFlower,
        name: "Sunflower Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [{ x: 0.01, y: -0.6, rotation: 0 }],
        secondsToMature: 1440 * 60,
        rotateSlotOffsetsRandomly: false,
        tileTransformOrigin: "bottom",
        baseTileScale: 0.8,
        nudgeY: -0.35
      },
      crop: {
        tileRef: tileRefsPlants.Sunflower,
        name: "Sunflower",
        baseSellPrice: 75e4,
        baseWeight: 10,
        baseTileScale: 0.5,
        maxScale: 2.5
      }
    },
    Starweaver: {
      seed: {
        tileRef: tileRefsSeeds.Starweaver,
        name: "Starweaver Pod",
        coinPrice: 1e9,
        creditPrice: 1e3,
        rarity: rarity.Celestial
      },
      plant: {
        tileRef: tileRefsTallPlants.StarweaverPlant,
        name: "Starweaver Plant",
        harvestType: harvestType.Multiple,
        slotOffsets: [{ x: 0, y: -0.918, rotation: 0 }],
        secondsToMature: 1440 * 60,
        baseTileScale: 1.5,
        rotateSlotOffsetsRandomly: false,
        tileTransformOrigin: "bottom",
        nudgeY: -0.27,
        immatureTileRef: tileRefsTallPlants.StarweaverPlatform,
        isFixedScale: true,
        growingAnimationTiles: { frames: 10, row: 8, fps: 20, nudgeY: -0.2 }
      },
      crop: {
        tileRef: tileRefsPlants.Starweaver,
        name: "Starweaver Fruit",
        baseSellPrice: 1e7,
        baseWeight: 10,
        baseTileScale: 0.6,
        maxScale: 2
      }
    },
    DawnCelestial: {
      seed: {
        tileRef: tileRefsSeeds.DawnCelestial,
        name: "Dawnbinder Pod",
        coinPrice: 1e10,
        creditPrice: 1129,
        rarity: rarity.Celestial
      },
      plant: {
        tileRef: tileRefsTallPlants.DawnCelestialPlant,
        name: "Dawnbinder",
        harvestType: harvestType.Multiple,
        secondsToMature: 1440 * 60,
        slotOffsets: [{ x: -0.015, y: -0.95, rotation: 0 }],
        baseTileScale: 2.3,
        rotateSlotOffsetsRandomly: false,
        tileTransformOrigin: "bottom",
        nudgeY: -0.2,
        abilities: ["DawnKisser"],
        activeState: {
          tileRef: tileRefsTallPlants.DawnCelestialPlantActive,
          activeAnimationTiles: { frames: 10, row: 6, fps: 20, nudgeY: -0.1 }
        },
        topmostLayerTileRef: tileRefsTallPlants.DawnCelestialPlatformTopmostLayer,
        immatureTileRef: tileRefsTallPlants.DawnCelestialPlatform,
        isFixedScale: true,
        growingAnimationTiles: { frames: 10, row: 8, fps: 20, nudgeY: -0.2 }
      },
      crop: {
        tileRef: tileRefsPlants.DawnCelestialCrop,
        name: "Dawnbinder Bulb",
        baseSellPrice: 11e6,
        baseWeight: 6,
        baseTileScale: 0.4,
        maxScale: 2.5,
        transformOrigin: "top"
      }
    },
    MoonCelestial: {
      seed: {
        tileRef: tileRefsSeeds.MoonCelestial,
        name: "Moonbinder Pod",
        coinPrice: 5e10,
        creditPrice: 1249,
        rarity: rarity.Celestial
      },
      plant: {
        tileRef: tileRefsTallPlants.MoonCelestialPlant,
        name: "Moonbinder",
        harvestType: harvestType.Multiple,
        slotOffsets: [
          { x: 0.01, y: -1.81, rotation: 0 },
          { x: -0.26, y: -0.82, rotation: -20 },
          { x: 0.23, y: -1, rotation: 20 }
        ],
        secondsToMature: 1440 * 60,
        baseTileScale: 2.5,
        rotateSlotOffsetsRandomly: false,
        tileTransformOrigin: "bottom",
        nudgeY: -0.2,
        abilities: ["MoonKisser"],
        activeState: {
          tileRef: tileRefsTallPlants.MoonCelestialPlantActive,
          activeAnimationTiles: { frames: 10, row: 6, fps: 20, nudgeY: -0.1 }
        },
        immatureTileRef: tileRefsTallPlants.MoonCelestialPlatform,
        isFixedScale: true,
        growingAnimationTiles: { frames: 10, row: 8, fps: 20, nudgeY: -0.2 }
      },
      crop: {
        tileRef: tileRefsPlants.MoonCelestialCrop,
        name: "Moonbinder Bulb",
        baseSellPrice: 11e6,
        baseWeight: 2,
        baseTileScale: 0.4,
        maxScale: 2,
        transformOrigin: "bottom"
      }
    }
  };
  var mutationCatalog = {
    Gold: { name: "Gold", baseChance: 0.01, coinMultiplier: 25 },
    Rainbow: { name: "Rainbow", baseChance: 1e-3, coinMultiplier: 50 },
    Wet: { name: "Wet", baseChance: 0, coinMultiplier: 2, tileRef: tileRefsMutations.Wet },
    Chilled: { name: "Chilled", baseChance: 0, coinMultiplier: 2, tileRef: tileRefsMutations.Chilled },
    Frozen: { name: "Frozen", baseChance: 0, coinMultiplier: 6, tileRef: tileRefsMutations.Frozen },
    Thunderstruck: { name: "Thunderstruck", baseChance: 0, coinMultiplier: 5, tileRef: tileRefsMutations.Thunderstruck },
    Dawnlit: { name: "Dawnlit", baseChance: 0, coinMultiplier: 4, tileRef: tileRefsMutations.Dawnlit },
    Amberlit: { name: "Amberlit", baseChance: 0, coinMultiplier: 6, tileRef: tileRefsMutations.Amberlit },
    Dawncharged: { name: "Dawnbound", baseChance: 0, coinMultiplier: 7, tileRef: tileRefsMutations.Dawncharged },
    Ambercharged: { name: "Amberbound", baseChance: 0, coinMultiplier: 10, tileRef: tileRefsMutations.Ambercharged }
  };
  var eggCatalog = {
    CommonEgg: { tileRef: tileRefsPets.CommonEgg, name: "Common Egg", coinPrice: 1e5, creditPrice: 19, rarity: rarity.Common, initialTileScale: 0.3, baseTileScale: 0.8, secondsToHatch: 600, faunaSpawnWeights: { Worm: 60, Snail: 35, Bee: 5 } },
    UncommonEgg: { tileRef: tileRefsPets.UncommonEgg, name: "Uncommon Egg", coinPrice: 1e6, creditPrice: 48, rarity: rarity.Uncommon, initialTileScale: 0.3, baseTileScale: 0.8, secondsToHatch: 3600, faunaSpawnWeights: { Chicken: 65, Bunny: 25, Dragonfly: 10 } },
    RareEgg: { tileRef: tileRefsPets.RareEgg, name: "Rare Egg", coinPrice: 1e7, creditPrice: 99, rarity: rarity.Rare, initialTileScale: 0.3, baseTileScale: 0.8, secondsToHatch: 21600, faunaSpawnWeights: { Pig: 90, Cow: 10 } },
    LegendaryEgg: { tileRef: tileRefsPets.LegendaryEgg, name: "Legendary Egg", coinPrice: 1e8, creditPrice: 249, rarity: rarity.Legendary, initialTileScale: 0.3, baseTileScale: 0.8, secondsToHatch: 43200, faunaSpawnWeights: { Squirrel: 60, Turtle: 30, Goat: 10 } },
    MythicalEgg: { tileRef: tileRefsPets.MythicalEgg, name: "Mythical Egg", coinPrice: 1e9, creditPrice: 599, rarity: rarity.Mythic, initialTileScale: 0.3, baseTileScale: 0.8, secondsToHatch: 86400, faunaSpawnWeights: { Butterfly: 75, Capybara: 5, Peacock: 20 } },
    WinterEgg: {
      tileRef: tileRefsPets.WinterEgg,
      name: "Winter Egg",
      coinPrice: 8e8,
      creditPrice: 199,
      rarity: rarity.Legendary,
      initialTileScale: 0.3,
      baseTileScale: 0.8,
      secondsToHatch: 43200,
      faunaSpawnWeights: { SnowFox: 75, Stoat: 20, WhiteCaribou: 5 },
      expiryDate: /* @__PURE__ */ new Date("2026-01-12T01:00:00.000Z")
    },
    SnowEgg: {
      tileRef: tileRefsPets.SnowEgg,
      name: "Snow Egg",
      coinPrice: 2e8,
      creditPrice: 269,
      rarity: rarity.Legendary,
      secondsToHatch: 43200,
      faunaSpawnWeights: {
        SnowFox: 75,
        Stoat: 20,
        WhiteCaribou: 5
      },
      requiredWeather: "Frost"
    },
    HorseEgg: {
      tileRef: tileRefsPets.HorseEgg,
      name: "Horse Egg",
      coinPrice: 2e8,
      creditPrice: 379,
      rarity: rarity.Legendary,
      initialTileScale: 0.3,
      baseTileScale: 0.8,
      secondsToHatch: 43200,
      faunaSpawnWeights: {
        Pony: 60,
        Horse: 35,
        FireHorse: 5
      }
      // expiryDate: A6, // TODO: fill in actual expiry date from game source
    }
  };
  var petCatalog = {
    Worm: {
      tileRef: tileRefsPets.Worm,
      name: "Worm",
      description: "",
      coinsToFullyReplenishHunger: 500,
      innateAbilityWeights: { SeedFinderI: 50, ProduceEater: 50 },
      baseTileScale: 0.6,
      maxScale: 2,
      maturitySellPrice: 5e3,
      matureWeight: 0.1,
      moveProbability: 0.1,
      hoursToMature: 12,
      rarity: rarity.Common,
      tileTransformOrigin: "bottom",
      nudgeY: -0.25,
      diet: ["Carrot", "Strawberry", "Aloe", "Tomato", "Apple"]
    },
    Snail: {
      tileRef: tileRefsPets.Snail,
      name: "Snail",
      description: "",
      coinsToFullyReplenishHunger: 1e3,
      innateAbilityWeights: { CoinFinderI: 100 },
      baseTileScale: 0.6,
      maxScale: 2,
      maturitySellPrice: 1e4,
      matureWeight: 0.15,
      moveProbability: 0.01,
      hoursToMature: 12,
      rarity: rarity.Common,
      tileTransformOrigin: "bottom",
      nudgeY: -0.25,
      diet: ["Blueberry", "Tomato", "Corn", "Daffodil", "Chrysanthemum"]
    },
    Bee: {
      tileRef: tileRefsPets.Bee,
      name: "Bee",
      coinsToFullyReplenishHunger: 1500,
      innateAbilityWeights: { ProduceScaleBoost: 50, ProduceMutationBoost: 50 },
      baseTileScale: 0.6,
      maxScale: 2.5,
      maturitySellPrice: 3e4,
      matureWeight: 0.2,
      moveProbability: 0.5,
      hoursToMature: 12,
      rarity: rarity.Common,
      diet: ["Strawberry", "Blueberry", "Daffodil", "Lily", "Chrysanthemum"]
    },
    Chicken: {
      tileRef: tileRefsPets.Chicken,
      name: "Chicken",
      coinsToFullyReplenishHunger: 3e3,
      innateAbilityWeights: { EggGrowthBoost: 80, PetRefund: 20 },
      baseTileScale: 0.8,
      maxScale: 2,
      maturitySellPrice: 5e4,
      matureWeight: 3,
      moveProbability: 0.2,
      hoursToMature: 24,
      rarity: rarity.Uncommon,
      tileTransformOrigin: "bottom",
      nudgeY: -0.2,
      diet: ["Aloe", "Corn", "Watermelon", "Pumpkin"]
    },
    Bunny: {
      tileRef: tileRefsPets.Bunny,
      name: "Bunny",
      coinsToFullyReplenishHunger: 750,
      innateAbilityWeights: { CoinFinderII: 60, SellBoostI: 40 },
      baseTileScale: 0.7,
      maxScale: 2,
      maturitySellPrice: 75e3,
      matureWeight: 2,
      moveProbability: 0.3,
      hoursToMature: 24,
      rarity: rarity.Uncommon,
      tileTransformOrigin: "bottom",
      nudgeY: -0.2,
      diet: ["Carrot", "Strawberry", "Blueberry", "OrangeTulip", "Apple"]
    },
    Dragonfly: {
      tileRef: tileRefsPets.Dragonfly,
      name: "Dragonfly",
      coinsToFullyReplenishHunger: 250,
      innateAbilityWeights: { HungerRestore: 70, PetMutationBoost: 30 },
      baseTileScale: 0.6,
      maxScale: 2.5,
      maturitySellPrice: 15e4,
      matureWeight: 0.2,
      moveProbability: 0.7,
      hoursToMature: 24,
      rarity: rarity.Uncommon,
      tileTransformOrigin: "center",
      diet: ["Apple", "OrangeTulip", "Echeveria"]
    },
    Pig: {
      tileRef: tileRefsPets.Pig,
      name: "Pig",
      coinsToFullyReplenishHunger: 5e4,
      innateAbilityWeights: { SellBoostII: 30, PetAgeBoost: 30, PetHatchSizeBoost: 30 },
      baseTileScale: 1,
      maxScale: 2.5,
      maturitySellPrice: 5e5,
      matureWeight: 200,
      moveProbability: 0.2,
      hoursToMature: 72,
      rarity: rarity.Rare,
      tileTransformOrigin: "bottom",
      nudgeY: -0.15,
      diet: ["Watermelon", "Pumpkin", "Mushroom", "Bamboo"]
    },
    Cow: {
      tileRef: tileRefsPets.Cow,
      name: "Cow",
      coinsToFullyReplenishHunger: 25e3,
      innateAbilityWeights: { SeedFinderII: 30, HungerBoost: 30, PlantGrowthBoost: 30 },
      baseTileScale: 1.1,
      maxScale: 2.5,
      maturitySellPrice: 1e6,
      matureWeight: 600,
      moveProbability: 0.1,
      hoursToMature: 72,
      rarity: rarity.Rare,
      tileTransformOrigin: "bottom",
      nudgeY: -0.15,
      diet: ["Coconut", "Banana", "BurrosTail", "Mushroom"]
    },
    Turkey: {
      tileRef: tileRefsPets.Turkey,
      name: "Turkey",
      coinsToFullyReplenishHunger: 500,
      innateAbilityWeights: { RainDance: 60, EggGrowthBoostII_NEW: 35, DoubleHatch: 5 },
      baseTileScale: 1,
      maxScale: 2.5,
      maturitySellPrice: 3e6,
      matureWeight: 10,
      moveProbability: 0.25,
      hoursToMature: 72,
      rarity: rarity.Rare,
      tileTransformOrigin: "bottom",
      nudgeY: -0.15,
      diet: ["FavaBean", "Corn", "Squash"]
    },
    Squirrel: {
      tileRef: tileRefsPets.Squirrel,
      name: "Squirrel",
      coinsToFullyReplenishHunger: 15e3,
      innateAbilityWeights: { CoinFinderIII: 70, SellBoostIII: 20, PetMutationBoostII: 10 },
      baseTileScale: 0.6,
      maxScale: 2,
      maturitySellPrice: 5e6,
      matureWeight: 0.5,
      moveProbability: 0.4,
      hoursToMature: 100,
      rarity: rarity.Legendary,
      tileTransformOrigin: "bottom",
      nudgeY: -0.1,
      diet: ["Pumpkin", "Banana", "Grape"]
    },
    Turtle: {
      tileRef: tileRefsPets.Turtle,
      name: "Turtle",
      coinsToFullyReplenishHunger: 1e5,
      innateAbilityWeights: { HungerRestoreII: 25, HungerBoostII: 25, PlantGrowthBoostII: 25, EggGrowthBoostII: 25 },
      baseTileScale: 1,
      maxScale: 2.5,
      maturitySellPrice: 1e7,
      matureWeight: 150,
      moveProbability: 0.05,
      hoursToMature: 100,
      rarity: rarity.Legendary,
      tileTransformOrigin: "bottom",
      nudgeY: -0.15,
      diet: ["Watermelon", "BurrosTail", "Bamboo", "Pepper"]
    },
    Goat: {
      tileRef: tileRefsPets.Goat,
      name: "Goat",
      coinsToFullyReplenishHunger: 2e4,
      innateAbilityWeights: { PetHatchSizeBoostII: 10, PetAgeBoostII: 40, PetXpBoost: 40 },
      baseTileScale: 1,
      maxScale: 2,
      maturitySellPrice: 2e7,
      matureWeight: 100,
      moveProbability: 0.2,
      hoursToMature: 100,
      rarity: rarity.Legendary,
      tileTransformOrigin: "bottom",
      nudgeY: -0.1,
      diet: ["Pumpkin", "Coconut", "Pepper", "Camellia", "PassionFruit"]
    },
    SnowFox: {
      tileRef: tileRefsPets.SnowFox,
      name: "Snow Fox",
      coinsToFullyReplenishHunger: 14e3,
      innateAbilityWeights: {
        SnowGranter: 30,
        SnowyCoinFinder: 30,
        SnowyPetXpBoost: 30
      },
      maxScale: 2,
      maturitySellPrice: 7e6,
      matureWeight: 7.5,
      moveProbability: 0.35,
      moveTweenDurationMs: 400,
      hoursToMature: 100,
      rarity: rarity.Legendary,
      diet: ["Echeveria", "Squash", "Grape"]
    },
    Stoat: {
      tileRef: tileRefsPets.Stoat,
      name: "Stoat",
      coinsToFullyReplenishHunger: 1e4,
      innateAbilityWeights: {
        SnowGranter: 40,
        SnowyHungerBoost: 40,
        SnowyCropMutationBoost: 20
      },
      maxScale: 2,
      maturitySellPrice: 1e7,
      matureWeight: 0.4,
      moveProbability: 0.3,
      moveTweenDurationMs: 600,
      hoursToMature: 100,
      rarity: rarity.Legendary,
      diet: ["Banana", "Pepper", "Cactus"]
    },
    WhiteCaribou: {
      tileRef: tileRefsPets.WhiteCaribou,
      name: "Caribou",
      coinsToFullyReplenishHunger: 3e4,
      innateAbilityWeights: {
        FrostGranter: 50,
        SnowyPlantGrowthBoost: 40,
        SnowyCropSizeBoost: 10
      },
      maxScale: 2.5,
      maturitySellPrice: 15e6,
      matureWeight: 300,
      moveProbability: 0.2,
      moveTweenDurationMs: 1e3,
      hoursToMature: 100,
      rarity: rarity.Legendary,
      diet: ["Camellia", "BurrosTail", "Mushroom"]
    },
    Pony: {
      tileRef: tileRefsPets.Pony,
      name: "Pony",
      coinsToFullyReplenishHunger: 4e3,
      innateAbilityWeights: {
        SellBoostIII: 25,
        CoinFinderIII: 25,
        HungerRestoreII: 25,
        SeedFinderII: 25
      },
      maxScale: 2,
      maturitySellPrice: 1e7,
      matureWeight: 200,
      moveProbability: 0.3,
      moveTweenDurationMs: 600,
      hoursToMature: 72,
      rarity: rarity.Legendary,
      tileTransformOrigin: "bottom",
      diet: ["Beet", "Pear", "Coconut"]
    },
    Horse: {
      tileRef: tileRefsPets.Horse,
      name: "Horse",
      coinsToFullyReplenishHunger: 25e3,
      innateAbilityWeights: {
        DawnBoost: 30,
        DawnlitGranter: 40,
        DawnPlantGrowthBoost: 10,
        PetAgeBoostII: 20
      },
      maxScale: 2.5,
      maturitySellPrice: 5e7,
      matureWeight: 80,
      moveProbability: 0.4,
      moveTweenDurationMs: 500,
      hoursToMature: 100,
      rarity: rarity.Legendary,
      tileTransformOrigin: "bottom",
      diet: ["Squash", "Echeveria", "Gentian"]
    },
    FireHorse: {
      tileRef: tileRefsPets.FireHorse,
      name: "Fire Horse",
      coinsToFullyReplenishHunger: 2e5,
      innateAbilityWeights: {
        AmberMoonBoost: 30,
        PetHatchSizeBoostII: 20,
        AmberlitGranter: 40,
        AmberPlantGrowthBoost: 10
      },
      maxScale: 2.5,
      maturitySellPrice: 15e7,
      matureWeight: 700,
      moveProbability: 0.4,
      moveTweenDurationMs: 800,
      hoursToMature: 144,
      rarity: rarity.Mythic,
      tileTransformOrigin: "bottom",
      diet: ["DragonFruit", "Poinsettia", "Cacao"]
    },
    Butterfly: {
      tileRef: tileRefsPets.Butterfly,
      name: "Butterfly",
      coinsToFullyReplenishHunger: 25e3,
      innateAbilityWeights: { ProduceScaleBoostII: 40, ProduceMutationBoostII: 40, SeedFinderIII: 20 },
      baseTileScale: 0.6,
      maxScale: 2.5,
      maturitySellPrice: 5e7,
      matureWeight: 0.2,
      moveProbability: 0.6,
      hoursToMature: 144,
      rarity: rarity.Mythic,
      tileTransformOrigin: "center",
      diet: ["Daffodil", "Lily", "Grape", "Lemon", "Sunflower"]
    },
    Capybara: {
      tileRef: tileRefsPets.Capybara,
      name: "Capybara",
      coinsToFullyReplenishHunger: 15e4,
      innateAbilityWeights: { DoubleHarvest: 50, ProduceRefund: 50 },
      baseTileScale: 1,
      maxScale: 2.5,
      maturitySellPrice: 2e8,
      matureWeight: 50,
      moveProbability: 0.2,
      hoursToMature: 144,
      rarity: rarity.Mythic,
      tileTransformOrigin: "bottom",
      nudgeY: -0.1,
      diet: ["Lemon", "PassionFruit", "DragonFruit", "Lychee"]
    },
    Peacock: {
      tileRef: tileRefsPets.Peacock,
      name: "Peacock",
      coinsToFullyReplenishHunger: 1e5,
      innateAbilityWeights: { SellBoostIV: 40, PetXpBoostII: 50, PetRefundII: 10 },
      baseTileScale: 1.2,
      maxScale: 2.5,
      maturitySellPrice: 1e8,
      matureWeight: 5,
      moveProbability: 0.2,
      hoursToMature: 144,
      rarity: rarity.Mythic,
      tileTransformOrigin: "bottom",
      nudgeY: -0.1,
      diet: ["Cactus", "Sunflower", "Lychee"]
    }
  };
  var petAbilities = {
    ProduceScaleBoost: {
      name: "Crop Size Boost I",
      description: "Increases the scale of garden crops",
      trigger: "continuous",
      baseProbability: 0.3,
      baseParameters: { scaleIncreasePercentage: 6 }
    },
    ProduceScaleBoostII: {
      name: "Crop Size Boost II",
      description: "Increases the scale of garden crops",
      trigger: "continuous",
      baseProbability: 0.4,
      baseParameters: { scaleIncreasePercentage: 10 }
    },
    ProduceScaleBoostIII: {
      name: "Crop Size Boost III",
      trigger: "continuous",
      baseProbability: 0.5,
      baseParameters: { scaleIncreasePercentage: 14 }
    },
    SnowyCropSizeBoost: {
      name: "Snowy Crop Size Boost",
      trigger: "continuous",
      baseProbability: 0.8,
      baseParameters: {
        scaleIncreasePercentage: 12,
        requiredWeather: "Frost"
      }
    },
    DoubleHarvest: {
      name: "Double Harvest",
      description: "Chance to duplicate harvested crops",
      trigger: "harvest",
      baseProbability: 5,
      baseParameters: {}
    },
    DoubleHatch: {
      name: "Double Hatch",
      description: "Chance to hatch an extra pet from eggs",
      trigger: "hatchEgg",
      baseProbability: 3,
      baseParameters: {}
    },
    ProduceEater: {
      name: "Crop Eater",
      description: "Harvests non-mutated crops and sells them",
      trigger: "continuous",
      baseProbability: 60,
      baseParameters: { cropSellPriceIncreasePercentage: 150 }
    },
    SellBoostI: {
      name: "Sell Boost I",
      description: "Receive bonus coins when selling crops",
      trigger: "sellAllCrops",
      baseProbability: 10,
      baseParameters: { cropSellPriceIncreasePercentage: 20 }
    },
    SellBoostII: {
      name: "Sell Boost II",
      description: "Receive bonus coins when selling crops",
      trigger: "sellAllCrops",
      baseProbability: 12,
      baseParameters: { cropSellPriceIncreasePercentage: 30 }
    },
    SellBoostIII: {
      name: "Sell Boost III",
      description: "Receive bonus coins when selling crops",
      trigger: "sellAllCrops",
      baseProbability: 14,
      baseParameters: { cropSellPriceIncreasePercentage: 40 }
    },
    SellBoostIV: {
      name: "Sell Boost IV",
      description: "Receive bonus coins when selling crops",
      trigger: "sellAllCrops",
      baseProbability: 16,
      baseParameters: { cropSellPriceIncreasePercentage: 50 }
    },
    ProduceRefund: {
      name: "Crop Refund",
      description: "Chance to get crops back when selling",
      trigger: "sellAllCrops",
      baseProbability: 20,
      baseParameters: {}
    },
    PlantGrowthBoost: {
      name: "Plant Growth Boost I",
      description: "Reduces the time for plants to grow",
      trigger: "continuous",
      baseProbability: 24,
      baseParameters: { plantGrowthReductionMinutes: 3 }
    },
    PlantGrowthBoostII: {
      name: "Plant Growth Boost II",
      description: "Reduces the time for plants to grow",
      trigger: "continuous",
      baseProbability: 27,
      baseParameters: { plantGrowthReductionMinutes: 5 }
    },
    PlantGrowthBoostIII: {
      name: "Plant Growth Boost III",
      trigger: "continuous",
      baseProbability: 30,
      baseParameters: { plantGrowthReductionMinutes: 7 }
    },
    SnowyPlantGrowthBoost: {
      name: "Snow Plant Growth Boost",
      trigger: "continuous",
      baseProbability: 40,
      baseParameters: {
        plantGrowthReductionMinutes: 6,
        requiredWeather: "Frost"
      }
    },
    DawnPlantGrowthBoost: {
      name: "Dawn Plant Growth Boost",
      trigger: "continuous",
      baseProbability: 60,
      baseParameters: { plantGrowthReductionMinutes: 6, requiredWeather: "Dawn" }
    },
    AmberPlantGrowthBoost: {
      name: "Amber Plant Growth Boost",
      trigger: "continuous",
      baseProbability: 80,
      baseParameters: { plantGrowthReductionMinutes: 6, requiredWeather: "AmberMoon" }
    },
    ProduceMutationBoost: {
      name: "Weather Mutation Boost I",
      trigger: "continuous",
      baseParameters: { mutationChanceIncreasePercentage: 15 }
    },
    ProduceMutationBoostII: {
      name: "Weather Mutation Boost II",
      trigger: "continuous",
      baseParameters: { mutationChanceIncreasePercentage: 20 }
    },
    ProduceMutationBoostIII: {
      name: "Weather Mutation Boost III",
      trigger: "continuous",
      baseParameters: { mutationChanceIncreasePercentage: 25 }
    },
    SnowyCropMutationBoost: {
      name: "Snow Boost",
      trigger: "continuous",
      baseParameters: { mutationChanceIncreasePercentage: 32, requiredWeather: "Frost" }
    },
    DawnBoost: {
      name: "Dawn Boost",
      trigger: "continuous",
      baseParameters: { mutationChanceIncreasePercentage: 36, requiredWeather: "Dawn" }
    },
    AmberMoonBoost: {
      name: "Amber Moon Boost",
      trigger: "continuous",
      baseParameters: { mutationChanceIncreasePercentage: 40, requiredWeather: "AmberMoon" }
    },
    PetMutationBoost: {
      name: "Pet Mutation Boost I",
      description: "Increases the chance of hatched pets gaining mutations",
      trigger: "hatchEgg",
      baseParameters: { mutationChanceIncreasePercentage: 7 }
    },
    PetMutationBoostII: {
      name: "Pet Mutation Boost II",
      description: "Increases the chance of hatched pets gaining mutations",
      trigger: "hatchEgg",
      baseParameters: { mutationChanceIncreasePercentage: 10 }
    },
    PetMutationBoostIII: {
      name: "Pet Mutation Boost III",
      trigger: "hatchEgg",
      baseParameters: { mutationChanceIncreasePercentage: 13 }
    },
    GoldGranter: {
      name: "Gold Granter",
      description: "Grants the Gold mutation to a garden crop",
      trigger: "continuous",
      baseProbability: 0.72,
      baseParameters: { grantedMutations: ["Gold"] }
    },
    RainbowGranter: {
      name: "Rainbow Granter",
      description: "Grants the Rainbow mutation to a garden crop",
      trigger: "continuous",
      baseProbability: 0.72,
      baseParameters: { grantedMutations: ["Rainbow"] }
    },
    RainDance: {
      name: "Rain Dance",
      description: "Grants the Wet mutation to a garden crop",
      trigger: "continuous",
      baseProbability: 10,
      baseParameters: { grantedMutations: ["Wet"] }
    },
    EggGrowthBoost: {
      name: "Egg Growth Boost I",
      description: "Reduces the time for eggs to hatch",
      trigger: "continuous",
      baseProbability: 21,
      baseParameters: { eggGrowthTimeReductionMinutes: 7 }
    },
    // utilis par la dinde: EggGrowthBoostII_NEW
    EggGrowthBoostII_NEW: {
      name: "Egg Growth Boost II",
      description: "Reduces the time for eggs to hatch",
      trigger: "continuous",
      baseProbability: 24,
      baseParameters: { eggGrowthTimeReductionMinutes: 9 }
    },
    // ancien EggGrowthBoostIII remplac par ce bloc
    EggGrowthBoostII: {
      name: "Egg Growth Boost III",
      description: "Reduces the time for eggs to hatch",
      trigger: "continuous",
      baseProbability: 27,
      baseParameters: { eggGrowthTimeReductionMinutes: 11 }
    },
    SnowyEggGrowthBoost: {
      name: "Snowy Egg Growth Boost",
      trigger: "continuous",
      baseProbability: 35,
      baseParameters: {
        eggGrowthTimeReductionMinutes: 10,
        requiredWeather: "Frost"
      }
    },
    PetAgeBoost: {
      name: "Hatch XP Boost I",
      description: "Hatched pets start with bonus XP",
      trigger: "hatchEgg",
      baseProbability: 50,
      baseParameters: { bonusXp: 8e3 }
    },
    PetAgeBoostII: {
      name: "Hatch XP Boost II",
      description: "Hatched pets start with bonus XP",
      trigger: "hatchEgg",
      baseProbability: 60,
      baseParameters: { bonusXp: 12e3 }
    },
    PetAgeBoostIII: {
      name: "Hatch XP Boost III",
      trigger: "hatchEgg",
      baseProbability: 70,
      baseParameters: { bonusXp: 16e3 }
    },
    PetHatchSizeBoost: {
      name: "Max Strength Boost I",
      description: "Increases the maximum strength of hatched pets",
      trigger: "hatchEgg",
      baseProbability: 12,
      baseParameters: { maxStrengthIncreasePercentage: 2.4 }
    },
    PetHatchSizeBoostII: {
      name: "Max Strength Boost II",
      description: "Increases the maximum strength of hatched pets",
      trigger: "hatchEgg",
      baseProbability: 14,
      baseParameters: { maxStrengthIncreasePercentage: 3.5 }
    },
    PetHatchSizeBoostIII: {
      name: "Max Strength Boost III",
      trigger: "hatchEgg",
      baseProbability: 16,
      baseParameters: { maxStrengthIncreasePercentage: 4.6 }
    },
    PetXpBoost: {
      name: "XP Boost I",
      description: "Gives bonus XP to active pets",
      trigger: "continuous",
      baseProbability: 30,
      baseParameters: { bonusXp: 300 }
    },
    PetXpBoostII: {
      name: "XP Boost II",
      description: "Gives bonus XP to active pets",
      trigger: "continuous",
      baseProbability: 35,
      baseParameters: { bonusXp: 400 }
    },
    PetXpBoostIII: {
      name: "XP Boost III",
      trigger: "continuous",
      baseProbability: 40,
      baseParameters: { bonusXp: 500 }
    },
    SnowyPetXpBoost: {
      name: "Snow XP Boost",
      trigger: "continuous",
      baseProbability: 50,
      baseParameters: {
        bonusXp: 450,
        requiredWeather: "Frost"
      }
    },
    HungerRestore: {
      name: "Hunger Restore I",
      description: "Restores the hunger of a random active pet",
      trigger: "continuous",
      baseProbability: 12,
      baseParameters: { hungerRestorePercentage: 30 }
    },
    HungerRestoreII: {
      name: "Hunger Restore II",
      description: "Restores the hunger of a random active pet",
      trigger: "continuous",
      baseProbability: 14,
      baseParameters: { hungerRestorePercentage: 35 }
    },
    HungerRestoreIII: {
      name: "Hunger Restore III",
      trigger: "continuous",
      baseProbability: 16,
      baseParameters: { hungerRestorePercentage: 40 }
    },
    SnowyHungerRestore: {
      name: "Snowy Hunger Restore",
      trigger: "continuous",
      baseProbability: 20,
      baseParameters: {
        hungerRestorePercentage: 38,
        requiredWeather: "Frost"
      }
    },
    HungerBoost: {
      name: "Hunger Boost I",
      description: "Reduces the hunger depletion rate of active pets",
      trigger: "continuous",
      baseParameters: { hungerDepletionRateDecreasePercentage: 12 }
    },
    HungerBoostII: {
      name: "Hunger Boost II",
      description: "Reduces the hunger depletion rate of active pets",
      trigger: "continuous",
      baseParameters: { hungerDepletionRateDecreasePercentage: 16 }
    },
    HungerBoostIII: {
      name: "Hunger Boost III",
      trigger: "continuous",
      baseParameters: { hungerDepletionRateDecreasePercentage: 20 }
    },
    SnowyHungerBoost: {
      name: "Snowy Hunger Boost",
      trigger: "continuous",
      baseParameters: {
        hungerDepletionRateDecreasePercentage: 30,
        requiredWeather: "Frost"
      }
    },
    PetRefund: {
      name: "Pet Refund I",
      description: "Chance to receive the pet back as an egg when sold",
      trigger: "sellPet",
      baseProbability: 5,
      baseParameters: {}
    },
    PetRefundII: {
      name: "Pet Refund II",
      description: "Chance to receive the pet back as an egg when sold",
      trigger: "sellPet",
      baseProbability: 7,
      baseParameters: {}
    },
    Copycat: {
      name: "Copycat",
      description: "Chance to copy the ability of another active pet",
      trigger: "continuous",
      baseProbability: 1,
      baseParameters: {}
    },
    CoinFinderI: {
      name: "Coin Finder I",
      description: "Finds coins in your garden",
      trigger: "continuous",
      baseProbability: 35,
      baseParameters: { baseMaxCoinsFindable: 12e4 }
    },
    CoinFinderII: {
      name: "Coin Finder II",
      description: "Finds coins in your garden",
      trigger: "continuous",
      baseProbability: 13,
      baseParameters: { baseMaxCoinsFindable: 12e5 }
    },
    CoinFinderIII: {
      name: "Coin Finder III",
      description: "Finds coins in your garden",
      trigger: "continuous",
      baseProbability: 6,
      baseParameters: { baseMaxCoinsFindable: 1e7 }
    },
    SnowyCoinFinder: {
      name: "Snowy Coin Finder",
      trigger: "continuous",
      baseProbability: 15,
      baseParameters: {
        baseMaxCoinsFindable: 5e6,
        requiredWeather: "Frost"
      }
    },
    SeedFinderI: {
      name: "Seed Finder I",
      description: "Finds common and uncommon seeds in your garden",
      trigger: "continuous",
      baseProbability: 40,
      baseParameters: {}
    },
    SeedFinderII: {
      name: "Seed Finder II",
      description: "Finds rare and legendary seeds in your garden",
      trigger: "continuous",
      baseProbability: 20,
      baseParameters: {}
    },
    SeedFinderIII: {
      name: "Seed Finder III",
      description: "Finds mythical seeds in your garden",
      trigger: "continuous",
      baseProbability: 10,
      baseParameters: {}
    },
    SeedFinderIV: {
      name: "Seed Finder IV",
      description: "Finds divine and celestial seeds in your garden",
      trigger: "continuous",
      baseProbability: 0.01,
      baseParameters: {}
    },
    MoonKisser: {
      name: "Moon Kisser",
      description: "Empowers amber moon crops with special mutations",
      trigger: "continuous",
      baseParameters: {}
    },
    DawnKisser: {
      name: "Dawn Kisser",
      description: "Empowers dawn crops with special mutations",
      trigger: "continuous",
      baseParameters: {}
    },
    SnowGranter: {
      name: "Snow Granter",
      description: "Number of times Snow Granter triggered",
      trigger: "continuous",
      baseProbability: 8,
      baseParameters: {
        grantedMutations: ["Chilled"]
      }
    },
    FrostGranter: {
      name: "Frost Granter",
      description: "Number of times Frost Granter triggered",
      trigger: "continuous",
      baseProbability: 6,
      baseParameters: {
        grantedMutations: ["Frozen"]
      }
    },
    DawnlitGranter: {
      name: "Dawnlit Granter",
      trigger: "continuous",
      baseProbability: 4,
      baseParameters: { grantedMutations: ["Dawnlit"] }
    },
    AmberlitGranter: {
      name: "Amberlit Granter",
      trigger: "continuous",
      baseProbability: 2,
      baseParameters: { grantedMutations: ["Ambershine"] }
    }
  };
  var toolCatalog = {
    WateringCan: {
      tileRef: tileRefsItems.WateringCan,
      name: "Watering Can",
      coinPrice: 5e3,
      creditPrice: 2,
      rarity: rarity.Common,
      description: "Speeds up growth of plant by 5 minutes. SINGLE USE.",
      isOneTimePurchase: false,
      baseTileScale: 0.6,
      maxInventoryQuantity: 99
    },
    PlanterPot: {
      tileRef: tileRefsItems.PlanterPot,
      name: "Planter Pot",
      coinPrice: 25e3,
      creditPrice: 5,
      rarity: rarity.Common,
      description: "Extract a plant to your inventory (can be replanted). SINGLE USE.",
      isOneTimePurchase: false,
      baseTileScale: 0.8
    },
    Shovel: {
      tileRef: tileRefsItems.Shovel,
      name: "Garden Shovel",
      coinPrice: 1e6,
      creditPrice: 100,
      rarity: rarity.Uncommon,
      description: "Remove plants from your garden. UNLIMITED USES.",
      isOneTimePurchase: true,
      baseTileScale: 0.7
    },
    RainbowPotion: {
      tileRef: tileRefsItems.RainbowPotion,
      name: "Rainbow Potion",
      coinPrice: 1 / 0,
      creditPrice: 1 / 0,
      rarity: rarity.Celestial,
      description: "Adds the Rainbow mutation to a crop in your garden. SINGLE USE.",
      isOneTimePurchase: true,
      baseTileScale: 1
    },
    CropCleanser: {
      tileRef: tileRefsItems.CropCleanser,
      name: "Crop Cleanser",
      coinPrice: 8e4,
      creditPrice: 7,
      rarity: rarity.Common,
      isOneTimePurchase: false,
      baseTileScale: 1,
      maxInventoryQuantity: 99
    }
  };
  var decorCatalog = {
    // Rochers
    SmallRock: {
      tileRef: tileRefsDecor.SmallRock,
      name: "Small Garden Rock",
      coinPrice: 1e3,
      creditPrice: 2,
      rarity: rarity.Common,
      baseTileScale: 1,
      isOneTimePurchase: false
    },
    MediumRock: {
      tileRef: tileRefsDecor.MediumRock,
      name: "Medium Garden Rock",
      coinPrice: 2500,
      creditPrice: 5,
      rarity: rarity.Common,
      baseTileScale: 1,
      isOneTimePurchase: false
    },
    LargeRock: {
      tileRef: tileRefsDecor.LargeRock,
      name: "Large Garden Rock",
      coinPrice: 5e3,
      creditPrice: 10,
      rarity: rarity.Common,
      baseTileScale: 1,
      isOneTimePurchase: false
    },
    WoodCaribou: {
      tileRef: tileRefsDecor.WoodCaribou,
      name: "Wood Caribou",
      coinPrice: 9e3,
      creditPrice: 14,
      rarity: rarity.Common,
      baseTileScale: 1,
      isOneTimePurchase: false
    },
    // Bois
    WoodBench: {
      tileRef: tileRefsDecor.WoodBench,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.WoodBenchSideways, flipH: true, baseTileScale: 1.46, nudgeY: -0.3 },
        180: { tileRef: tileRefsDecor.WoodBenchBackwards },
        270: { tileRef: tileRefsDecor.WoodBenchSideways, baseTileScale: 1.46, nudgeY: -0.3 }
      },
      name: "Wood Bench",
      coinPrice: 1e4,
      creditPrice: 15,
      rarity: rarity.Common,
      baseTileScale: 1,
      isOneTimePurchase: false,
      nudgeY: -0.3,
      avatarNudgeY: -0.18
    },
    WoodArch: {
      tileRef: tileRefsDecor.WoodArch,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.WoodArchSide, flipH: true, baseTileScale: 2.1, nudgeY: -0.48 },
        180: { tileRef: tileRefsDecor.WoodArch, flipH: true },
        270: { tileRef: tileRefsDecor.WoodArchSide, baseTileScale: 2.1, nudgeY: -0.48 }
      },
      name: "Wood Arch",
      coinPrice: 2e4,
      creditPrice: 25,
      rarity: rarity.Common,
      baseTileScale: 1.53,
      isOneTimePurchase: false,
      nudgeY: -0.5
    },
    WoodBridge: {
      tileRef: tileRefsDecor.WoodBridge,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.WoodBridgeSideways, flipH: true, baseTileScale: 1.7, nudgeY: -0.28 },
        180: { tileRef: tileRefsDecor.WoodBridge, flipH: true },
        270: { tileRef: tileRefsDecor.WoodBridgeSideways, baseTileScale: 1.7, nudgeY: -0.28 }
      },
      name: "Wood Bridge",
      coinPrice: 4e4,
      creditPrice: 35,
      rarity: rarity.Common,
      baseTileScale: 1.22,
      isOneTimePurchase: false,
      nudgeY: -0.35,
      avatarNudgeY: -0.44
    },
    WoodLampPost: {
      tileRef: tileRefsDecor.WoodLampPost,
      name: "Wood Lamp Post",
      coinPrice: 8e4,
      creditPrice: 49,
      rarity: rarity.Common,
      baseTileScale: 1.5,
      isOneTimePurchase: false,
      nudgeY: -0.6
    },
    WoodOwl: {
      tileRef: tileRefsDecor.WoodOwl,
      name: "Wood Owl",
      coinPrice: 9e4,
      creditPrice: 59,
      rarity: rarity.Common,
      baseTileScale: 1.3,
      isOneTimePurchase: false,
      nudgeY: -0.4
    },
    WoodBirdhouse: {
      tileRef: tileRefsDecor.Birdhouse,
      name: "Wood Birdhouse",
      coinPrice: 1e5,
      creditPrice: 69,
      rarity: rarity.Common,
      baseTileScale: 1.5,
      isOneTimePurchase: false,
      nudgeY: -0.6
    },
    WoodWindmill: {
      tileRef: tileRefsDecor.WoodWindmill,
      name: "Wood Windmill",
      coinPrice: 5e5,
      creditPrice: 74,
      rarity: rarity.Common,
      baseTileScale: 1.5,
      isOneTimePurchase: false,
      nudgeY: -0.47
    },
    WoodPergola: {
      tileRef: tileRefsDecor.WoodPergola,
      name: "Wood Pergola",
      coinPrice: 3e4,
      creditPrice: 30,
      rarity: rarity.Common,
      baseTileScale: 1,
      isOneTimePurchase: false
    },
    StoneCaribou: {
      tileRef: tileRefsDecor.StoneCaribou,
      name: "Stone Caribou",
      coinPrice: 75e4,
      creditPrice: 72,
      rarity: rarity.Uncommon,
      baseTileScale: 1.2,
      isOneTimePurchase: false
    },
    // Pierre
    StoneBench: {
      tileRef: tileRefsDecor.StoneBench,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.StoneBenchSideways, flipH: true, baseTileScale: 1.47, nudgeY: -0.3 },
        180: { tileRef: tileRefsDecor.StoneBench, flipH: true },
        270: { tileRef: tileRefsDecor.StoneBenchSideways, baseTileScale: 1.47, nudgeY: -0.3 }
      },
      name: "Stone Bench",
      coinPrice: 1e6,
      creditPrice: 75,
      rarity: rarity.Uncommon,
      baseTileScale: 1,
      isOneTimePurchase: false,
      nudgeY: -0.3,
      avatarNudgeY: -0.18
    },
    StoneArch: {
      tileRef: tileRefsDecor.StoneArch,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.StoneArchSideways, flipH: true, baseTileScale: 2.1, nudgeY: -0.44 },
        180: { tileRef: tileRefsDecor.StoneArch, flipH: true },
        270: { tileRef: tileRefsDecor.StoneArchSideways, baseTileScale: 2.1, nudgeY: -0.44 }
      },
      name: "Stone Arch",
      coinPrice: 4e6,
      creditPrice: 124,
      rarity: rarity.Uncommon,
      baseTileScale: 1.53,
      isOneTimePurchase: false,
      nudgeY: -0.5
    },
    StoneBridge: {
      tileRef: tileRefsDecor.StoneBridge,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.StoneBridgeSideways, flipH: true, baseTileScale: 1.7, nudgeY: -0.28 },
        180: { tileRef: tileRefsDecor.StoneBridge, flipH: true },
        270: { tileRef: tileRefsDecor.StoneBridgeSideways, baseTileScale: 1.7, nudgeY: -0.28 }
      },
      name: "Stone Bridge",
      coinPrice: 5e6,
      creditPrice: 179,
      rarity: rarity.Uncommon,
      baseTileScale: 1.22,
      isOneTimePurchase: false,
      nudgeY: -0.35,
      avatarNudgeY: -0.44
    },
    StoneLampPost: {
      tileRef: tileRefsDecor.StoneLampPost,
      name: "Stone Lamp Post",
      coinPrice: 8e6,
      creditPrice: 199,
      rarity: rarity.Uncommon,
      baseTileScale: 1.5,
      isOneTimePurchase: false,
      nudgeY: -0.6
    },
    StoneGnome: {
      tileRef: tileRefsDecor.StoneGnome,
      name: "Stone Gnome",
      coinPrice: 9e6,
      creditPrice: 219,
      rarity: rarity.Uncommon,
      baseTileScale: 1.3,
      isOneTimePurchase: false,
      nudgeY: -0.4
    },
    StoneBirdbath: {
      tileRef: tileRefsDecor.StoneBirdBath,
      name: "Stone Birdbath",
      coinPrice: 1e7,
      creditPrice: 249,
      rarity: rarity.Uncommon,
      baseTileScale: 1.2,
      isOneTimePurchase: false,
      nudgeY: -0.46
    },
    MarbleCaribou: {
      tileRef: tileRefsDecor.MarbleCaribou,
      name: "Marble Caribou",
      coinPrice: 5e7,
      creditPrice: 299,
      rarity: rarity.Rare,
      baseTileScale: 1.4,
      isOneTimePurchase: false
    },
    // Marbre
    MarbleBench: {
      tileRef: tileRefsDecor.MarbleBench,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.MarbleBenchSideways, flipH: true, baseTileScale: 1.55, nudgeY: -0.35 },
        180: { tileRef: tileRefsDecor.MarbleBenchBackwards },
        270: { tileRef: tileRefsDecor.MarbleBenchSideways, baseTileScale: 1.55, nudgeY: -0.35 }
      },
      name: "Marble Bench",
      coinPrice: 75e6,
      creditPrice: 349,
      rarity: rarity.Rare,
      baseTileScale: 1,
      isOneTimePurchase: false,
      nudgeY: -0.3,
      avatarNudgeY: -0.18
    },
    MarbleArch: {
      tileRef: tileRefsDecor.MarbleArch,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.MarbleArchSideways, flipH: true, baseTileScale: 2.38, nudgeY: -0.57 },
        180: { tileRef: tileRefsDecor.MarbleArch, flipH: true },
        270: { tileRef: tileRefsDecor.MarbleArchSideways, baseTileScale: 2.38, nudgeY: -0.57 }
      },
      name: "Marble Arch",
      coinPrice: 1e8,
      creditPrice: 399,
      rarity: rarity.Rare,
      baseTileScale: 1.53,
      isOneTimePurchase: false,
      nudgeY: -0.5
    },
    MarbleBridge: {
      tileRef: tileRefsDecor.MarbleBridge,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.MarbleBridgeSideways, flipH: true, baseTileScale: 1.7, nudgeY: -0.28 },
        180: { tileRef: tileRefsDecor.MarbleBridge, flipH: true },
        270: { tileRef: tileRefsDecor.MarbleBridgeSideways, baseTileScale: 1.7, nudgeY: -0.28 }
      },
      name: "Marble Bridge",
      coinPrice: 15e7,
      creditPrice: 429,
      rarity: rarity.Rare,
      baseTileScale: 1.22,
      isOneTimePurchase: false,
      nudgeY: -0.35,
      avatarNudgeY: -0.44
    },
    MarbleLampPost: {
      tileRef: tileRefsDecor.MarbleLampPost,
      name: "Marble Lamp Post",
      coinPrice: 2e8,
      creditPrice: 449,
      rarity: rarity.Rare,
      baseTileScale: 1.5,
      isOneTimePurchase: false,
      nudgeY: -0.6
    },
    MarbleBlobling: {
      tileRef: tileRefsDecor.MarbleBlobling,
      name: "Marble Blobling",
      coinPrice: 3e8,
      creditPrice: 499,
      rarity: rarity.Rare,
      baseTileScale: 1.5,
      isOneTimePurchase: false,
      nudgeY: -0.56
    },
    MarbleFountain: {
      tileRef: tileRefsDecor.MarbleFountain,
      name: "Marble Fountain",
      coinPrice: 45e7,
      creditPrice: 449,
      rarity: rarity.Rare,
      baseTileScale: 1.5,
      isOneTimePurchase: false,
      nudgeY: -0.3
    },
    // Spciaux
    MiniFairyCottage: {
      tileRef: tileRefsDecor.MiniFairyCottage,
      name: "Mini Fairy Cottage",
      coinPrice: 5e8,
      creditPrice: 549,
      rarity: rarity.Rare,
      baseTileScale: 1.1,
      isOneTimePurchase: false,
      nudgeY: -0.37
    },
    Cauldron: {
      tileRef: tileRefsDecor.Cauldron,
      name: "Cauldron",
      coinPrice: 666e6,
      creditPrice: 666,
      rarity: rarity.Legendary,
      baseTileScale: 1.5,
      isOneTimePurchase: false,
      nudgeY: -0.25,
      expiryDate: /* @__PURE__ */ new Date("2025-11-07T01:00:00.000Z")
    },
    StrawScarecrow: {
      tileRef: tileRefsDecor.StrawScarecrow,
      name: "Straw Scarecrow",
      coinPrice: 1e9,
      creditPrice: 599,
      rarity: rarity.Legendary,
      baseTileScale: 1.8,
      isOneTimePurchase: false,
      nudgeY: -0.65
    },
    MiniFairyForge: {
      tileRef: tileRefsDecor.MiniFairyForge,
      name: "Mini Fairy Forge",
      coinPrice: 5e9,
      creditPrice: 979,
      rarity: rarity.Legendary,
      baseTileScale: 1,
      isOneTimePurchase: false,
      nudgeY: -0.3
    },
    MiniFairyKeep: {
      tileRef: tileRefsDecor.MiniFairyKeep,
      name: "Mini Fairy Keep",
      coinPrice: 25e9,
      creditPrice: 1249,
      rarity: rarity.Mythic,
      baseTileScale: 1.05,
      isOneTimePurchase: false,
      nudgeY: -0.33
    },
    PetHutch: {
      tileRef: tileRefsDecor.PetHutch,
      name: "Pet Hutch",
      coinPrice: 8e10,
      creditPrice: 499,
      rarity: rarity.Divine,
      baseTileScale: 2.1,
      isOneTimePurchase: true,
      nudgeY: -0.45
    },
    DecorShed: {
      tileRef: tileRefsDecor.DecorShed,
      name: "Decor Shed",
      coinPrice: 6e10,
      creditPrice: 399,
      rarity: rarity.Divine,
      baseTileScale: 1,
      isOneTimePurchase: true
    },
    SeedSilo: {
      tileRef: tileRefsDecor.SeedSilo,
      name: "Seed Silo",
      coinPrice: 1e11,
      creditPrice: 699,
      rarity: rarity.Divine,
      baseTileScale: 1,
      isOneTimePurchase: true
    },
    MiniWizardTower: {
      tileRef: tileRefsDecor.MiniWizardTower,
      name: "Mini Wizard Tower",
      coinPrice: 75e9,
      creditPrice: 1379,
      rarity: rarity.Mythic,
      baseTileScale: 1.8,
      isOneTimePurchase: false,
      nudgeY: -0.59
    },
    // Saisonniers (Halloween)
    HayBale: {
      tileRef: tileRefsDecor.HayBale,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.HayBaleSideways, flipH: true },
        180: { tileRef: tileRefsDecor.HayBale, flipH: true },
        270: { tileRef: tileRefsDecor.HayBaleSideways }
      },
      name: "Hay Bale",
      coinPrice: 7e3,
      creditPrice: 12,
      rarity: rarity.Common,
      baseTileScale: 1.8,
      isOneTimePurchase: false,
      nudgeY: -0.42,
      expiryDate: /* @__PURE__ */ new Date("2025-11-07T01:00:00.000Z")
    },
    StringLights: {
      tileRef: tileRefsDecor.StringLights,
      rotationVariants: {
        90: {
          tileRef: tileRefsDecor.StringLightsSideways,
          flipH: true
        },
        180: {
          tileRef: tileRefsDecor.StringLights,
          flipH: true
        },
        270: {
          tileRef: tileRefsDecor.StringLightsSideways
        }
      },
      name: "String Lights",
      coinPrice: 7e3,
      creditPrice: 12,
      rarity: rarity.Common,
      baseTileScale: 1,
      isOneTimePurchase: false
    },
    ColoredStringLights: {
      tileRef: tileRefsDecor.ColoredStringLights,
      rotationVariants: {
        90: {
          tileRef: tileRefsDecor.ColoredStringLightsSideways,
          flipH: true
        },
        180: {
          tileRef: tileRefsDecor.ColoredStringLights,
          flipH: true
        },
        270: {
          tileRef: tileRefsDecor.ColoredStringLightsSideways
        }
      },
      name: "Colored String Lights",
      coinPrice: 8e3,
      creditPrice: 13,
      rarity: rarity.Common,
      baseTileScale: 1,
      isOneTimePurchase: false
    },
    PaperLantern: {
      tileRef: tileRefsDecor.PaperLantern,
      rotationVariants: {
        90: {
          tileRef: tileRefsDecor.PaperLanternSideways,
          flipH: true
        },
        180: {
          tileRef: tileRefsDecor.PaperLantern,
          flipH: true
        },
        270: {
          tileRef: tileRefsDecor.PaperLanternSideways
        }
      },
      name: "Paper Lantern",
      coinPrice: 9e3,
      creditPrice: 13,
      rarity: rarity.Common,
      baseTileScale: 1,
      isOneTimePurchase: false
      // expiryDate: A6, // TODO: fill in actual expiry date from game source
    },
    SmallGravestone: {
      tileRef: tileRefsDecor.SmallGravestone,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.SmallGravestoneSideways, flipH: true, baseTileScale: 1.12, nudgeY: -0.32 },
        180: { tileRef: tileRefsDecor.SmallGravestone, flipH: true },
        270: { tileRef: tileRefsDecor.SmallGravestoneSideways, baseTileScale: 1.12, nudgeY: -0.32 }
      },
      name: "Small Gravestone",
      coinPrice: 8e3,
      creditPrice: 12,
      rarity: rarity.Common,
      baseTileScale: 1,
      isOneTimePurchase: false,
      nudgeY: -0.38,
      expiryDate: /* @__PURE__ */ new Date("2025-11-07T01:00:00.000Z")
    },
    MediumGravestone: {
      tileRef: tileRefsDecor.MediumGravestone,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.MediumGravestoneSideways, flipH: true, baseTileScale: 1.32, nudgeY: -0.33 },
        180: { tileRef: tileRefsDecor.MediumGravestone, flipH: true },
        270: { tileRef: tileRefsDecor.MediumGravestoneSideways, baseTileScale: 1.32, nudgeY: -0.33 }
      },
      name: "Medium Gravestone",
      coinPrice: 5e5,
      creditPrice: 72,
      rarity: rarity.Uncommon,
      baseTileScale: 1.2,
      isOneTimePurchase: false,
      nudgeY: -0.45,
      expiryDate: /* @__PURE__ */ new Date("2025-11-07T01:00:00.000Z")
    },
    LargeGravestone: {
      tileRef: tileRefsDecor.LargeGravestone,
      rotationVariants: {
        90: { tileRef: tileRefsDecor.LargeGravestoneSideways, flipH: true, baseTileScale: 1.5, nudgeY: -0.39 },
        180: { tileRef: tileRefsDecor.LargeGravestone, flipH: true },
        270: { tileRef: tileRefsDecor.LargeGravestoneSideways, baseTileScale: 1.5, nudgeY: -0.39 }
      },
      name: "Large Gravestone",
      coinPrice: 5e7,
      creditPrice: 299,
      rarity: rarity.Rare,
      baseTileScale: 1.4,
      isOneTimePurchase: false,
      nudgeY: -0.51,
      expiryDate: /* @__PURE__ */ new Date("2025-11-07T01:00:00.000Z")
    }
  };
  var weatherCatalog = {
    Rain: {
      atomValue: "Rain",
      description: "Gives the Wet mutation to mature garden crops",
      type: "weather",
      cycle: { kind: "weather", startWindowMin: 20, startWindowMax: 35, durationMinutes: 5 },
      weightInCycle: 0.75,
      // 75% des events mto
      appliesRandomCropPercent: 30,
      // ~30% des cultures applicables
      conditions: { requiresMature: true, requiresNoExistingModifier: true },
      mutations: [
        { name: "Wet", multiplier: 2 },
        { name: "Frozen", multiplier: 6, conditional: "applies if crop already has Chilled" }
      ],
      stacking: {
        compatible: ["Golden", "Rainbow", "Giant"],
        incompatible: ["Wet", "Chilled", "Frozen"]
      },
      screenEffect: "Rain on screen",
      notes: ["Primary vs Snow (75%)", "Affecte une culture applicable au hasard"]
    },
    Frost: {
      atomValue: "Frost",
      description: "Gives the Frozen mutation to mature garden crops",
      type: "weather",
      displayName: "Snow",
      cycle: { kind: "weather", startWindowMin: 20, startWindowMax: 35, durationMinutes: 5 },
      weightInCycle: 0.25,
      // 25% des events mto
      appliesRandomCropPercent: 30,
      conditions: { requiresMature: true, requiresNoExistingModifier: true },
      mutations: [
        { name: "Chilled", multiplier: 2 },
        { name: "Frozen", multiplier: 6, conditional: "applies if crop already has Wet" }
      ],
      stacking: {
        compatible: ["Golden", "Rainbow", "Giant"],
        incompatible: ["Wet", "Chilled", "Frozen"]
      },
      screenEffect: "Snow on screen",
      notes: ["Secondary vs Rain (25%)", "Frozen recommand\xE9 pour champignon/cactus/bambou"]
    },
    Sunny: {
      atomValue: null,
      description: "No special effects",
      type: "base",
      cycle: { kind: "base" },
      appliesRandomCropPercent: 0,
      conditions: { requiresMature: false, requiresNoExistingModifier: false },
      mutations: [],
      stacking: {
        compatible: ["Golden", "Rainbow", "Giant"],
        incompatible: []
      },
      screenEffect: "Blue skies",
      notes: ["\xC9tat par d\xE9faut, aucun effet"]
    },
    AmberMoon: {
      atomValue: "Amber Moon",
      description: "Gives the Amberglow mutation to mature garden crops",
      type: "lunar",
      displayName: "Harvest Moon",
      cycle: { kind: "lunar", periodMinutes: 240, durationMinutes: 10 },
      weightInCycle: 0.33,
      // 33% des events lunaires
      appliesRandomCropPercent: 30,
      conditions: { requiresMature: true, requiresNoExistingModifier: true },
      mutations: [
        { name: "Amberlit", multiplier: 6 },
        { name: "Amberbound", multiplier: 10 }
      ],
      stacking: { compatible: ["Gold", "Rainbow"], incompatible: ["Dawnlit", "Amberlit"] },
      screenEffect: "Nightfall glow (orange)",
      notes: ["1 fois / 4h", "Ne se cumule pas avec Dawnlit"]
    },
    Dawn: {
      atomValue: "Dawn",
      description: "Gives the Dawnlit mutation to mature garden crops",
      type: "lunar",
      cycle: { kind: "lunar", periodMinutes: 240, durationMinutes: 10 },
      weightInCycle: 0.67,
      // 67% des events lunaires
      appliesRandomCropPercent: 30,
      conditions: { requiresMature: true, requiresNoExistingModifier: true },
      mutations: [
        { name: "Dawnlit", multiplier: 4 },
        { name: "Dawnbound", multiplier: 7 }
      ],
      stacking: { compatible: ["Gold", "Rainbow"], incompatible: ["Amberlit", "Dawnlit"] },
      screenEffect: "Sunrise glow (purple)",
      notes: ["1 fois / 4h", "Ne se cumule pas avec Amberglow"]
    },
    Thunderstorm: {
      atomValue: "Thunderstorm",
      mutations: [
        { name: "Thunderstruck", multiplier: 5 }
      ]
    }
  };
  var coin = {
    img64: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAAIGNIUk0AAHomAACAhAAA+gAAAIDoAAB1MAAA6mAAADqYAAAXcJy6UTwAAAAGYktHRAD/AP8A/6C9p5MAAAAHdElNRQfpCR4CFRRuokQwAAAr0ElEQVR42u29eZRlV3Xm+dvn3HvfHENGRE5KSSkJISGExCAJlQFDmRmDmAzGVcY2dIMBYSiXMXZjTA1tL1tgMxZVBparbJahbKAAA2JqxCAJAZKQUGpINKZSyiEyY3zzu8M5u/8490WE2pRRpjIlcOdeK9bKjOHFu/s7Z4/f3gEn5ISckBNyQk7ICTkhJ+SEnJATckJOyAk5ISfkfyPySL+Bo5HXv/7l3H3Pfl78vF/iKRddyGPOOYeoWkF0hBePxFWWl7rccO2NfOfKa7jsvR/lwgvP47rrdj3Sb/1fhrz7fe/i37z6Em697Tsc3P9DDh28AdUFVJU/+N2/sCuHlpLhMK8Mu8uV/mChMvSDys037Y4BUXV0+zdy3/3f4sD+6/nIh/4cVeXfvuz5j/Rj/UT5mbwhl/3n13Ldrd/kta/8Pc7YeTZnnr0DqZ/Nj3ZdNd2q2s3VevWxszOt7Z3F+Vnj3emTE5NbTWwjKFTxaJRIVtDv9YZ76s3mvYV3C/Pzh3Y3qlv3/cE7Ll/85N9cXLTnlauvuoHDyx3mZqd40av+/SP92MDPGCDvf9/bSLOMFz3/+TzmjNP50Ef/Z/S8X/zFUydmaxfUpipPN9Y8oZrEp6DDmcgOK34wT9G+H1O0UT8E70BBo5hoZhYak6jEeK169a0VzarzWbf4UZFxlZfq96+9fvmO57+0Obxn1yG+9oUb2bJtkpf/n+96RHXwMwHI/J4r+dJXvs0zf+lCdp71PG784eUnnTQ79a/rVX1+HPELkc13SDWNJO7hWQaWMTrE9ZYZ3X831VEfozlePMYLXgxs24LZth0vCcZXgAgpHOnhDqQNNfHJi7nZdP3IVj5/eNF/7TGPn9q7fE+fd7/7f/Hc55/HL73k7f//A+SvP/zHDAYZL37xszj5zGdx561fOmtmeuIV1Ur1lRXJHyP5fOTSO8hGd2DrGZW5OdREiMlAPVLkjPbtx66uEnmHN4rxgBryiSbxztMgqiMIKinic4pDh9BDSwgViso0mpzi1W77cS5znx4Us5/YdtYP79xz41ZOe8Jv8/tvfC5/8Vdf/5cPyAff+05+49d/hR/ffhdPfurL+fFNXzx98+zMbzVr0atjWd3pR/dSdG7BD/ciro3RFK3WSE45HanVQTwqiqgnX1qiOLifiivwKKIgClkcE+84FTs1g2LxCCoe0+tQ3LuHOBuFz2FRU0OTk3DJ6Xeksum/zHebnzx7tr10xU1tpuo5Fzz7Tx423diHG4wD917D5OQUJ22Z4sDhzqa6WXrd3OzE+xrVwctltHsqX7wKXbkak95D5PtE3hGpQT1ovYJpVAGDigEMBoPvdLFFgaggIiCCqoCNMc0WWAE83gjGGHQwQEYjDB6MYrzD5Avg7p0R7T6nFfkL2/3o3nOf8Ud7i8PP4rK3v4Bd993H7bcv/csB5A2veglf++YnyLOCsx/3LA7cv/sZp5w898GJqrzR5rvn3NLX8MvXYNN9GBlg8RgsXhSkADyFjYiaE2AtECHE4WOYIsMMowZBEBWsGrwKMjkBcYSoARQjoN5R9HpY9SgSwBWDkGGLtomLxdMj235Be/5ZdIfbbnZuf/a63/tXPOMxp/G3n7nhuOopejjA+PZX/56nP/dXmd9zDYcWVlqV6vWv27q58fbYHdhSrNxI1rmBpDhE4hVUcAogoGAkKNMCvjfErw7wLibtZ2TdlLwzRJdXkE4XfAQWbOSpJAbT8Gi8THTSLFKJAo6imHqNPKnih4pRD7jy91lUADoY19vS0NGf2Vp27p5V3jHxw70HDjb+LfPX7mTrRe88bro67j5kee+P+NJnv8XLXv109ty5f+fO07b9SaXqX2VGt1m38E3M6G5QjxGPqBLMkQ+OgAhxFt/zpCuOfkfpDwyml5OPBqjLsfjyA0TAGUUFrAoeg6/XkU0TVE/aRP3UOarbGkRVT3HwXlhaxAYEEBQAL4ITwahDiCi0xSCf+kZ3OP22fHTnTTcvvYBTJ67iCS/9x58/QD76gXcyN7ONZ73gYlZWhhdNN2sfaMTDi133u7iVq4myZawWKBFeBDUFogWGBM2EUSejO58xmi+g5xHnkMgjFSWJPUlUYK1DbPAFiENFUQS8QdRQOHAF5EVEahvI9CYmzthMY7PFZ4tYV2A0uHfRAKYXg6hHsIiPQQ09P3XjwX719a24ff0737uL5zw54VV/tOfnB5D/+oF3ko4y/t3bL6M7f9MzkkT/W2wOnV0sXwGr1xG5UXkLXFAgwUmTWQYLjv59I7LFEUVeEBlLpeZI6gNsZYhGikGDU6ZUIoLo2CVqeeI9wXMoqAUXURQRI2fwSZXqzCSN7U2iGqg42HBLRT3eaHn3ALX0sqkf7Tucv2br1pkfzV38SX73khrv/+LomOrtuDj1A3u+x/z8Eq+79I/Ze8e3Xzg9HX8k0v2Pyhe+gmlfS+SDzXamCOErBusiskVlefeQ1Ts7+LYnMY7mxID6dJ+4NcRWMowpiNRhANSEkFYFRfDiAY8oqBicmHDaseH7bQFxRpx4Ii0ouj1Gq32MWOJaBWwAV8bgShFuLRaDI7J+a2Lt2bvu7HyndvDLq7/yrk+w7/KPceMBf8x0d8xvyPXfvZw779rHS178ZAbD/F83a/o3ke49JTv0DUznVmLN8RLjRRHJEI1gYGnvGdG+L0WHGdUoJ5nIsI2UyI4QcYhG5YfiUXIjuDhG4hiTRMRJeE0zHBF5JVeHcx4tPHiP8R7FYFTCrREfHHiWMDJKNNOkddIcWosQr1gffJngEQ05jOIppMFqr/qFu64r3nTqjsb+VsUy+fLP/WwC8s7f/23+5D0foXPoB3R6+UUz0/W/Tdh3dnb4cmz3NmJNUaAwQbHWK+mKsHR7m/SQwwhUmhmN1ggTD1FxiAogeAEwEFuo1zBb54i3b8U2W1CpYeIYshF67z7MaICaHHWgmafIMnyek2cO1+4RpTkGRU0wbR6L94JpNameshVTjzE+nHoVDe5JFRXFG493LZb3T3z2+u/Nv6Fel4VsVPC8y67/2QNkYf/3KFJlablz+s4dm/++Hh2+MFu8HOneRKIjVKs441BJsUXM4IBn8ccDXGdEtZJRn8qJajmIw/pwIr0RfGSQeo1kokncqEO1ip+ZId5xMhonIWJVj/EF+f37kaUljLj1qE0NWqki27aQ9YeM9u6H/Qcw/S6G0mdgQjLZqFM5dQumlgCKlxAvGAXw+NIMar/C/bv1b793XfutExNROy2EV37o2oesw2PmQ+687ZuoKsur3Ykzdm55Xy0aPDdf/jKmey2xL0AUZwTEY/OI3n0Zi7f1kL7SbGS0pofE1RQxOUiBE8VFlmiiSW3LHNW5TUStOiQxIlCoYJqTSJygCEYVNcGBF90u1juEEMYKinpFJyZJtm2nctJ24rkZClXy/gDjHK68MTbNcWlGXK8hsQ1HVkL8IYQqgMERxSMiy/lulEzffSC+sh677FfOn+MzN8w/8oD894+8myi2fPQfrjS//PTzfr9Vc5cW3W+La3+H2BUIcQDDZJg8on33iNUf94lSpTHVpTaVIUkWnCiKNwbfrFPdupna5hlso4pGBm8EUER8SB6TJJRSBChvgzEG3+tisxwRRUUQ8agUeCJsYyqUVFotku1bMa06WacHoxQjIXpzeU6e5yT1GiaKUNZwAZEQNJgC27Bih+6Jtp8Vb/jAwpUXn5PoS5+wjX+86dAjC8jnv/h5Tt1e48JzT3vOpsnoPWZ4a71Y+hqx64ZISELiZV1E996UlR/3iHKlMTWiMtlDI1eWMDwuNsSzc9S3bSFu1dHI4oXwGmUSNzYhDo+daCI2ZPOCRSxoPoJ+HxlHTIRipPOCaTaQShJKJWKJpieJWy3c8ipmGEJxb4Qiy/GFI6nVMNYEzAGV0qdh8FZoRCJ+OT//WedP3Pmyxzd3v++K+9m1v/fIAfK5v/8g9VrEcnu0dWaq9uHYHzgrP/xl4vQgkQ9mQI0n8obefsfS7h5RCo2pEfFUHyOCojhxSFKltnUb8dw0xDacxPL3hFB0rOCgIK8OaTaQSg0hBoLZEhTX7YIW4fu9IGJQr5DE2EYNlfDKaiJMPUbU4bp9XJZjFCIVijRDBZJGPZQBkJB4GkU0xqgSJRF+qNW0456w64C76sLTpuZ/82mn87ffve+o9GkeChivveQSilw45YyLadX0txIZPsWtXIukd5VZsysz4ITREiz9uI8ZQW2qQzLVxuAxqjg8vlmldso2kplJxIS3FW7W+CPU1UPCpzijiHNopwveoRpyEFSQSgtfbwQYNZhAEKwWuG4bzV3ISUUR7yGKMDObsNtPwsdNIm8xCtY7sqVlsnYv5DlGEUKwYDS8Lx/lTJyUMFlLz5ypuv+8p51NLrTb/PmLtz38gLzmLS/hqU87l3tv//r5rUb0RhneStG+Ees9qKWwBi8W34elH7fxvYxaY0R1wqFGcMaTWY9p1Zncvo2oVceVd8L8MwFgabmwHly/j+bBX1Bae4kibLNVluj/Pw+bpvjBsLx9Y5AtptkimqhTn5smJUI11F2Nc2QLi2iaw9rhCOV8RfHiiCci6pti6pF7wemT5v945e+9iAMrw4cfkHQofOYzt9iZyYk3VmT5FL/8PSK/gBEQDB4BZ+ncPSRbcNSSnMbEALEZiuDE45oVGtu3YOtV/PiJ1wzV/x4Mo2BQZJTh+wOUMtGTkC9EjSY+rqCUURYg3mALj+92QAu8hMwcjTC1BlKLSDY18M0JchehWIwq0huSL6+GW6XlURFAQulGIkdza42GyeyUHb3lE3/5+fOedu7JfPhXzz5inR61D/ncp97HBU98DGedNXfBVKvyp9q7ua6rP0DIoKwziViy+YLV3UMMSmvTAFsdhWhKFFOt0jhpG7bZWHPcyD+fHAWoQpgrKKrgjcFONEHKxxEQY/DDFB0Ny1xDygQvBAOm1YQ4KfGPQhPLjfDDAZGpMVjqYo1iRYm8J3OOqNnExBEipeEsTaggWBMxms+xuZvCRLz768tfO3nS+CeebLnmnsGD1utR3xBVZcvOZ0ijZv+N8UuzxcouREeEwoQNZYeB0L1riKQZtYkUU8vwodEKsaW6eTNRo4GqrgFh9J//veUlAMBLiHfoDWA0WgNSRcFaTGsCby1aNmtVyoQiG+L7fUKReFwlBmlO4pIq8USCaTXIUwPehpA9zShWe2uRXjB1Uv5fsQ3BbqoSqTBjePmlT51+4nnb65yzKTsivR4VIF/5woc57/zHs/uWb5xZrdZfooN7sOk9iOQYD6IelYTeoZzhUkZSLag2+kjZ5/DGEm2aI9rULE2QIB5M+bAq/5zRYu17XOlZbZbhugPwsgaKF4NtNKAaMm7YELGVHUPyEAR44xD1mKSBqTXQKKM+O0WRR6hacitYD361hy+Ktd8vKhi1wadEnsoMYBxNI5unav517/razXZ//8h6gEcFSJYOOOOsC5idajw3YnSq79wKdFEpCKVviw6F3n0DxCvRZIbEKUZ98CvNOpW5aZwtHeuawkqV6U+p6ZRXRMYtWzzSWYUiBxTjS7JDkmAarUALCj8RSiEo2u+jWYaKQTQQJjAGmZzEGaE6EeErVfI8RjREWEWW4gY9dPwWNOQlHvDiiSfBRmDEMB3nL3zzBdOPO2NCef2TjjMgp57+aHbd9INaox5dQnafMNobohyxZahqGS4OyZZHJBVPVM+D08WjcURtbhqJTSAlBD09AIEHV2CTtRuFKDIaoKMB40gLFVQE22rhbRzCYV37KjbPKXrdAL6atTdhG3Wo1DGxEE81GaWGyJeKV4fv9kB1w00MH6gS1yOohHyoGcVbJ1rTL3/VRWdwxxEk7kcHyPZtTNbix1mTPbEY3Ir6dnjYMnHQ3NM+mKLqqTZHRBQYFQojRFNNomYDLSk7x0rUeVynhyrB5pf2Xao1qNcDUOLXIiPrPb7XgaIogwkbfiaKsY0W3ljqrQTnLHiD8SGQyIcpOL92cjaeJWsN0oxQHLFJmEzcL/3fX71x+qUXNI8fILfv/hZTm1vUYvvMyHc2af9ORFJELRI622S9gmzJE8dCXBthNFB0fBKRTE+iNpxI8yDvwoMRQaHbhTwtS/Xl56ME25oszVboIq5FXMMBftgvs4r1H5LWBEUcETcsXiNcEZX1AfBpjktzynAC0fVAxFpBaqX5QpmI/fmzE5subFZrXPa8ieMDyC233sH7/+vllXqjcoGm85hsqTQdpnxzMcMlhwwLKjWPRHkoBhqwzTpRrbqWS+gxvCEAJh2i/QG2LJUjHjUm+JGkslYuGT+2KTJ8ZxW8Xw/fBKRWR+sVpCKYuEKRJes3wXk0zdGy/77RnyCKrQESqgL1KGlMxebi33jyyXQGDy7aOmJALrrgbH752Y/fHCV6vg7vx7q0pGo6hAJfCKNFR6wFca3ASXCkag3VyRZEprTbsgbMMRPNKLptTBHCXG9CNm0qNbTZwCMYNbDmMxR6XchKZZXhN0mEbdUhNpg4Jits2TEsfVMWIq01kzWORUSJY4Mpk9TEJrSs+YVL/+GOSiVOjj0gr/+tl5MN2uTDztn47hYd7QvRiQZAMOBGjqxThL51nEOoWCGVCrZew5WFh+PCrhDF9wf40WiNfSIKGIttTeCNKRUoZU4CZCP8oIdRR4jzgnZts4lUYiQCX1jK/iGioTxf/royQRz//mC2DMEwWmMx1p413ayePLLVYw/IFVdcxc6TT+HUHaeeEWu/6fPDZTIXTpzD4no5OsqRqsNIHpwnEbZehzjecCuUY+rVAS+WOM3QbjucXh+tJXK23kKrNVTLUkrp3I1XXKcLrgggqS1D5gbabGCsg6I8VOKC3r1DBKwPeXoIIsrSvFEUGwqQRokqsu2k6er2k2dqxx6QP3zHWzDN8+n1Bqdq0UHdiEDDCcwRVCkGOXhHlIRStYiCEaJaNfBuN2BwjF1IWQbxuF4XimKtMoyAxBGm0cCVlWQpzaYAbjDAp+kaWS4gGG6VSrQhSAihuqp/oAMc/1PDPfIlPVWAuvGRjvo7tlTyYw/Is575VL7x7S/F1Wr8WM2XEJeWX/GggdExGhSIeGxcJnuqEFlsrbJmqsbX/FibrbGCdTQKhGr8mJEKxmBbE7goKksu65Vbk+ehf+JLsyXhtEutiZrqGqueMhFV1fBcbHydMtJz4zqXRYAq3rYSzp31bR7XOsaAXHf9DyHvxbVatIliFaN5mYOVVDcPfgTGgJScK/BIbJEkClCMMzOOucVae22T5/hOF7xfP7yA1BtorR4I3GVREMA6j3a7ZaZfOm80MCqdZexutGxQiTGoeeBxEg3P5gtZP3QIiQj1xMw8bVsf544xIHv33s89d91dK9JBTYt+SVQuM1UUHGghWKOIKRgXQ0wcIdaslUQ2RInHXBSw6qHXQ4v1HgaA2ISo2QpRH77kPXqs+pCTjEalckMw4DJP0S8wAqbs1Kh6xIwR2vgAAmpwWRhvWAfWMizyCbmsEk3O/nR1HxEg1biGxdaLPK8bl2744TGzQ/BFuCEYt3Y6JbKoHZOaj5/o2m1VSFPcYFD6FV0bO4jqDSSO1g6FBiIJ4hxFr/uAQ1L0RvhBRmxC/Wucp9g4Ck8i8k/egMu05AU7VARnDKlS275FokrlpxcajwgQg8NoYdSn1vuipG7KevcNAqXfeDB5qX6DMVKSmMvXGd+UY47Ohg68K9DOKupcGe6WiqrV0PpkiITEhVoUBusd2uvgc8/Y6KSHh/i8T5RkBD6KosZAHGF0XPGl/Hc4kG5oylKMR9Tiy76NFGW7+FgCIlraJJysRTDA2MhK2W8YH5xAcjbh8z9JfccYkHGzKFB/FN/vo1n+AKw0irATE2FWUSnbBeGGSzrC9wYhWnIwPLAK6jBxgRLY9CKCSZK19y/jFxdwuScfFqiasp0A3uWIel+oPKio8ogAKYoC770TEbfOMA8fHsAIJtbStNp187SBFLBBN8fNh2j5Dy1yXL+LKUlzWlYNTL0OlQpSRoahfxPMFu1V8AVFN2ewb5XYCBIHb2y8xcYGkyTr/HrRMkgAN3S4tMBgELUYdXifYY0fHlqWInsQXv2IAHHqsXG1H0VxXzf86DiiUANSCc4yhIhlvOL9+gmVB9eAOloZeyoRxXqH67TX+iRrtf4khmYDH7ryqBmzKoFBG9Kc0b4ubqlLJfGIDaZNVJBaBYnHvkDXngc15N0CMi0rxyFfz3xBFEV9/cCwGOU//amPqJ310pddQqW1c1CpHeq51Wjtzq5FTgbimpArqLdlpCVo4cB5JDJstKKix9Zsbcxx8IoF3KCPH44wEwkgwUQZi5lo4VbaiMsCMaJ8EC1S3FKf3u2L2Dyj0spDkRLwxhM3GsGPEG69L8EQZ0lXCqQwa0A5lzMqHKm3q1++9p/GAD9JjuiGdLp9vvzV7xft7mBJbaW0qxsOH0qlHuPH6JRqKooiJFI/rRP4UEVDJLpW0/WKLQpcv7f2dVEJfN96Fa1VymDEY8ueh4iS7TnM8K5FksiTVDIoWZUkim02Az9r3GUMWScuh9FKgfUh3/KiFOpIHX44crvzeBM/3HeMAfnmN7/La1/764Xzsou4ihKVii+zcoGoGSOxRYsyGBbweYEWRbj2PjjSjVHXMcNjLQPXUomCRdFeF81TfHnSxQtEFUxrgnFvJESLMVLE9O5ZxHT7VGseseNxN2BqAuq1EEZL6eQBEU+26nG98ZwjiDhGRUHqoyKpTexdco0H9QxHBMjTnnIW3UNXkiTNu72tezW2VISusy/qFqlHuCJMIamA5A43TNeIAevMjWMLyJjCZspet5Y2QoZDfD/0/MNMSDlV1ZwIVKByIMcbKBYLhvtH2KSgUvc4E4Z2vI2JzjgDaTZDxZcQLoeBHs9wIUdTE0jdZaI8ylKyXNpLqV060H1wXvOIAPnIx6+lvTpg4fDqbjFTK74cL1g3WIpJoDpVJSsSVAN1X7yn6A3CzTBjJ3h8oqyfKN7huj2sC2ZmnDOZagXqzbKSWyCpo39XG4Ye01KiJMyqqBd0ZhPJKTswzUlQwYgrY2aPH0QMFoch9wBiB16F4agH4u7sDPO7O+32sQfkox/9KMY0qda37lXZtE/jMY1nvYKqpqA2VyMjQdWUIa/iBgNI8xAmmhCjPVyAGBTt9WCYhpqTKY2sFcxkC2cDS7F334jevMdWCmqNESojRB3exlROPw3bbCHNCTSulJVdxahhuOgoOg4kzE5aFfLcMchzUu+vf/dX7+rNNB4cJ/GIO4ZfuvxbnHzmqxc8je8Rby2nX9fLIiqOymSEbVTICln7FTpMwy0Zf69uSCyPswiKyTJ8r896kB6+IvU6WqmTHoblu4c4IqqTKUncw5siPN/sDNWTd4RoqlZBm40Q0AA+i+nuHyJZWPMxLt8M0wEDhxuZxnV//Wun8YdfWj0+gMSRRVc/QFpEV0q0o1BixrUsU0YcUnG0NlfJsjDqHJy5Uqx2oXDrFBqjDw8kJZNduz3Uu7KCUBY+K1XIWqze2qcY5FQn+lRrgQ7rEdJKleScMzHNBnjFx4q0JlCpIBgGy0q6mIetK86iCKl19IYdMrUH2pm5tptb3vLU49DCBXjt7/wRBw52yYrou0Qzd2vZmtRyFEDV4MXRmKtiajVyFyqeAhS9AXmnt8bSeCCf8AH6e+gIbPiQsuDoRgNcOlpvIosh7zqWb1oiW1Aa1ZzG5ApYB76CqqWyYzvRqdtD08mETqNpNiCp4TOhfX8fRqY0weGV+3lKLx3ivHzvQLd2b7fv+eDVx4nkAHDw0DLbznjmfXk08XVNNpfkABP6H1KOBNSVxo4muY+wPilbqp7R4iqaFuWsnoRcWcsMUc0aifmo7k5ZNhdVhALBbfiSoi7FdbuIEyDGrzqWvnEngzsXiZOCxnSKJiM8DtQTVRMqs5MYK6jxqAHjYiSqYJoNeocLigMZVmPA422BeBj2enRVXQf7pQu3L2Wbph9cyHvUgDzp6a9hOP9ZUlf7jEvOWIUKxpfUGh3nH0p9dgI70aRwimhYn+EHfdJDi5AHWqkXWa+OEjYpGH90EbGUHY7gNWI8wVkX4fxSyRU6bdSNyBaHHPrqbvq7DhBFXWpzbUwywvgEoxafWKpbZ4Of6A2w42fzgLWobdHd00MLyCOPl+Avh5rT7nfJNL695+0VC3249JMPfgXHUY0jbJ7qsXX2VFaGj5qfqnfOs9n+xxrfRoxsoMQIYgxJtcqw10OcxxgNu01GKRInmHp9fahGQjgajElolR4pKuvNL1u+bqDAhUFNU4bgSrqsHLrybordS9SMozE7JG50sN5jfQVnDfHWKezsVCBFRHEwU5hQr3OGxR8dIrt5OexTMR6rwV8uDZdZ6nfpFrW/vvRXVz//2as3cc2eBz9zeFQ35NLf/UtqNctpMzelGk99zFd3dJ2RtT7zuNzqxWGbMfWT5shig/FK7EG9o7ewQL64isnHIzWhLerL3snR1biCUrTcoSJSYCTHUIAB72MG9zgOf/le3J3LVGopjbkhcTXHeov1MU4Uu7lFZW4KZ8NWIHpdfJHiLCARg70dutfdhxTBMiQl0S4tMla6q6Rq9q3m0d99+B9meNb500f8BEcl286+hKVexL7+6VeOkpO+kEdb1zNjxq5EUXFUpxvUt81SWEuBDbcnzxkemKe3/xA6cBiXrG3e8XK00dfYWZeO3IPxMaaIKFYci7t6LN7Ug46n0chpznYx9Q4qjkITBlGEzE1Q3RLorlLygTUd4kdDjBrckmPhqjtIlnPCqJgQ+VA+Wumt0s0cQ2c//farq7tvOez4wBduO6IneEgLzGan6mT5zVkv3fLeSXvK07RYPkUlH3c6Sx15MEJtdhIjMJpfJM5zrHd4yXGLq6y2U6qzc9RmJjGJx0tGoJod2XnRtfTfB7Pnq+R96B7o0r9vSNER4jijOtel2shD9dWHpTVpxVDdeTLJRAN8XnYCAyDioGj3sdEsy9fcjr+7jcXgpcAJxF4YpgOW+ytkGt+7VLQ+9hdPd35/R/jKXUem04c0Fv3Lz7kALSbYefJlB7udX7CRdp4p2jchuolKYDYUHmtVTBKRDsL2BAsY8dhcyVaGjFZT1EfYqIbEZo3FvMZ01AdSbkJhj3JGJISxqEVyQ7astO8dsHRnl/7+ISbz1Bue5qY+SaMNpkA1CTeyElN97Jk0zjs3rAUcDh7QUMMYJBN6t7fpXXsQyS3eKpF6IKIg59DqIZazXAda+8s3vWjxs5/8TsL7v71yxDp9yOW9A7d8HNTRGTUmtkRX/4+a2/2ySLshBAUoN/mMaZpGIV1dZXhwAZMWhBzFYxQKJwyyGLUtqpNNqtMVkkYFm4AkYd79ARTRsbMpwOXg+hmjlYLBUkG2UqBpTiyepO5JGg5bzVA7BCkwPjDbi6kpGuc9muiMUyCqwEobv/duoiIHMcGnaET/fsfCLR3MwJStJ1nb2Xiw3+Pw8v2sUP3WPb3Wq+q2ONzpFvzJFasPPyAA2YEv0lu5hYXl/rlz9T3/s8nd50ZOy4qrR/yGqjBgvCfv9ukfWkT6KeujnMGxaiakI0tWGFxksNUKUk0wlQQTWYyWddZc8alSDB3ZMMcPQQuPkYIkcSS1nKRaYBKHmrBIU8XjBFRiktnNJE96AmbrJlQM1gvkI7K9d2P73RCd+YjsgGdxV5uiH4qplXJCNbeGbtph78ICvVyWFlP51WYkV1Bt8Ft/d3Q7T47Jao2TpjPe/bGYS5695/BAW3cmZM+saDZRTlCUlNINPRABW0lIGjXE5bgsB2cCR1hyiFJs1RNXIDIeshztpriVEflSn2ypR7rYJ1/p4zojSDNir8TVgkoroz45ojoxwNaGaJLibI6Kx5ZLlk2tRrJ1lsqpW7E7diAmLvdjaVgXmGWhy6iG9IBn8ZYu9Mp6g67PivRdxsHleYZ5rsuu8Z43ffa0v3nUXI8v37zAvUd+OY7dDQG455r/yFU/+jG/8caXsvfbl79ma3X5Q7FdbHgpG0Ciaw2ptWUuClJA0WmTLi4E+qcatBykHDeazIYmvPcG9UnZMi5NmPGI8RgZhTDAx6EXQyh2hvl3iyQxyWSLZNMk1COKyBLtOA0zOR3WQIkLowSdIe7efaT39Fi5rYP2xhNZBqsWZ5RMPfNLB1jut+mY5v+az+uvq+BXVlZG/IdvHCUaHMP1TB/462/zoudsRZcGRI3n3WL8gdRTPDWWNJaSwPRAHmxwy2oFU6uQNBtIpYL34J1HfKinSlk9deIDoNZjTIGJHGIcxriwmU5yDDbMnKuUiwQUrMHUayQzm6hunSHa1MRXbDBHTvGxRSabgC1buBbJY/q7Fli+aQE/NGWaWvJ6jcPhmV89zEK/S0+aN8yntTdtqkf7t05GvOFTR78JCI5Dz27fd9/BameZ79w2jJ5z1vzvb50a/XGtOgxcfB+H0Wjc2gkes+dVJICQe4r+CNftUQwGuKKAPDS5xlHVWo6ipty9WNJwjMEZQSJBKpaoXiepNzCNGpLEZW1rTPGMUDW4WoXotJ2YpA5E5L2C1avvZnTt/ZA5nA1jDbacgcmBpfYiS6sLrEpjz6Kf/PVWlF7zm3/3HF746E9w+Z0PTX/HhXPwg8+8gqw/4AffX4ie/fTWG0/dXryrWS1mA0U/DfE9Zi2RHFef1t+ShPJ44fBphg5T/ChHsxx1DjcerlFFxIRhS2vROMFWK9hqgqnESBQWkHlYW9VnSvC8hL2mhTHYHduJpjYzvG/A4lV3kN+1jHVhOYj1ptwi53F4FlfbHOos0CfZt5xW3nD29ujyz9+sbJuO+b8+f+Ah6+64kUC++VfPZHGhyyv/+Fpu+PCzX7Hz1OT9k7Pt7UYyFIu34aRaJ2sktkDVVBRX5hTjZlb5or4EQXXtVihgTGAUrk1FbXxADX7EGV8O49iSHFfuWxRDUd1EZzli9bp9xIeHiAncTOMjYh8c3cA4DrcP02mv0qG+72AxcelbXz77hde+dw+TCbz/6u4x0dtxZeW877dPww0ifu/jX+Wbf/bqF55xevTBLVvdaZVGQWEUVUusRWnz7QaytAs7rsotJWwk1+lP3hS0XrZfF0Noe4+NnDfjGdwQJUkhDBc8q/f2SA8pJq2EZJUwluCJcEZI3YjDq4dZHPQZkdy9nCdvftOv7/zqb//5HYg6PvL9o9v887ADAvCel+1kuZ3ytrdexPdvWHza9un8o6eexNmTm6tINUNNXo4kl6PSKv+0176RhirrDdh/+jBjc7RenJTyE1rW1QwGyWPSFUdnX598f4FLATVlxTZwqsJfWnB08h7zK0v0hhkdJq7tSvOt2xuD73/h5pSKZPy37/8cLFLeKP/P7lVe8OQpfrRrxKO2Ve47tL92fbrsz3Gd/skWJY4bWFMpVzqNz2/Yv+7NWt9qnYIqY4oPa9uD1rYIPaC0sgEQU3Yts4j0sKNzZ5/27X3cYYvNKoAJ61/Hq8qN4PAcHvQ5uHKYflr4Hq1Pz49al05VRrt+cKBCwxR88OqjX+X3iAECcMUtHX7nknP40g2bedrZvf33Ha59xWWulS5m52SLw9hlijWWyErYmVjybNcVrOv+Qca7ssZ1LF37QChBFIyEeUAKKNqO4f05q3cM6N6TUSwKprAgShY5BF8u5bd4I2RpysLqIZY6y/RcvLjqGn96KK+/a6YRHXzN3z2OXZ9f5j995eBx0dVxN1kb5T0v+Ve87XOP5x/ffCt3HDaVJ+zIXzFb6f5BNeLceqTUJoR4LiLeFBM3E2wMxhblVtH1ARkJzOdydpyydWtQ1fB3wVIl73qyZUe6kpN1cnToUR8R/u4IgAfjyr9bFdjqhfcs91dY7C7Tc84PqXy7l9k/e8Nn2t/40Cu2sXUq4ePf3MuX7jl+OnpYARnLR37tPGwc8eInncb39hx41GxifnfaDF+ZaDprxGMiIa4oUUOgFWPrCVHFYGNFIh8iMEz4sx+FwaeefOTJh0o+zCkGOZoqkgnGRWVCF3Yy6lqdIHT0DTDSnPZoldXeKqtpQarRXSMXfeS+YeV/nNFMl+5ZrTBTVd78uYXjrptHBBCAP3/BHFdeu8C/f83F/NW1K/YNF80+ecLkb2xI8fyG5jOiWs5eFIhYDLaMuXwZIpd/1ghKRXvwWs7M25BZi5azhCEkNj5EV4jiREldRn8wYKXfoZcNSVXuHzr7qWXf+tjFO/zt373XUU+ESz91/P/U0SMOCMB/+uVH8aiTJ2gPPOdsa3LF/VHy1M3pkxpV+c2mFM+tUeyMyIi8X1tOoJTb38o9vWFoxq8tzh+bL9ZIa2EYJySFDucKhvmI1XTA6mhENy+K3MW7cxd/uuMrn33rzRfd9qEnXqt33HWIR+9o8Tuf7zysOnlEAdkon7r0KfRSx5mbLE/77GPl68+75Ywojl5YldELWjZ7YhWdsSaYHkGx43E0wjrxMKdRJn2E8oyX8q8kFEqeZfSzNu1sQDfXfOTi/ZmPrumrubyb8a1Xbl06+NWlLewbVWjE8M7PHd3e3X8xgAC84wVn86eXvYgPvvcqzm0Jj56r8OkfHWpsaZpzJmv2KVX6T6nFeoZI5fSKoR6TxRaPiGHMh/SuwLmMzOcMc8/ISTHKtMjzYj4Xs7ejXDc01euGQ66/5R53/3Of4PNDqwVLgxabJzxv++z+R1QHP1OAbJRXzMGnvvjv+O8f/DpTNcMvnLWdX/svX49+8eyZqa3TU6dFpDMu7509UbOn1WJJvHeoqqiqepTM4zv9fB7i26i3Dh/sFweV+v4//dSe4Ydfs4VRKiwsjZieqvKH//jQFugfS/mZBWSjvOWiiMFIufDMKQ71LTMTLTbVPJvjLpP0iHxOPVEadc9qFw63oRDI4ohRNMPhPGFfJyXKCtRYXnPx6fyHy3fx8WuPXcnjWMnPBSA/Td4MfAvYAiTAWcAB4NOP9Bs7ISfkhJyQE3JCTsgJOSEn5ISckJ8D+X8B7L1HlK7Vi1oAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjUtMDktMzBUMDI6MjE6MDgrMDA6MDAu0X64AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDI1LTA5LTMwVDAyOjIxOjA4KzAwOjAwX4zGBAAAACh0RVh0ZGF0ZTp0aW1lc3RhbXAAMjAyNS0wOS0zMFQwMjoyMToyMCswMDowMHlTrsEAAAAASUVORK5CYII="
  };

  // src/utils/friendSettingsSchema.ts
  var DEFAULT_FRIEND_SETTINGS = {
    showOnlineFriendsOnly: false,
    hideRoomFromPublicList: false,
    messageSoundEnabled: true,
    friendRequestSoundEnabled: true,
    showGarden: true,
    showInventory: true,
    showCoins: true,
    showActivityLog: true,
    showJournal: true,
    showStats: true
  };

  // src/utils/localStorage.ts
  var ARIES_STORAGE_KEY = "aries_mod";
  var ARIES_STORAGE_VERSION = 1;
  var API_KEY_STORAGE_KEY = "aries_api_key";
  var AUTH_DECLINED_STORAGE_KEY = "aries_auth_declined";
  var SEEN_ROOM_PRIVACY_NOTICE_KEY = "aries_seen_room_privacy_notice";
  var DEFAULT_ARIES_STORAGE = {
    version: ARIES_STORAGE_VERSION,
    friends: {
      settings: DEFAULT_FRIEND_SETTINGS
    },
    notifications: {
      soundEnabled: true
    }
  };
  function getHostStorage() {
    if (typeof window === "undefined") return null;
    try {
      if (typeof window.localStorage === "undefined") return null;
      return window.localStorage;
    } catch {
      return null;
    }
  }
  function parseSafe(raw) {
    try {
      return JSON.parse(raw);
    } catch {
      return raw;
    }
  }
  function mergeSection(existing, next) {
    const base = { ...existing ?? {} };
    for (const [k, v] of Object.entries(next)) {
      if (base[k] === void 0) {
        base[k] = v;
      }
    }
    return base;
  }
  function unwrapNestedSnapshot(raw) {
    let cur = raw;
    let guard = 0;
    while (guard++ < 10 && cur && typeof cur === "object" && "snapshot" in cur && typeof cur.snapshot === "object") {
      cur = cur.snapshot;
    }
    return cur ?? raw;
  }
  function coerceLegacyAggregate(raw) {
    const out = { ...DEFAULT_ARIES_STORAGE };
    if (!raw || typeof raw !== "object") return out;
    const data = raw;
    if (typeof data.version === "number") out.version = data.version;
    if (typeof data.migratedAt === "number") out.migratedAt = data.migratedAt;
    if ("stats" in data) out.stats = unwrapNestedSnapshot(data.stats);
    if ("customRooms" in data) out.room = mergeSection(out.room, { customRooms: data.customRooms });
    if ("pets" in data && typeof data.pets === "object") {
      out.pets = mergeSection(out.pets, data.pets);
    }
    if ("petsOverrides" in data) out.pets = mergeSection(out.pets, { overrides: data.petsOverrides });
    if ("petsUI" in data) out.pets = mergeSection(out.pets, { ui: data.petsUI });
    if ("petTeams" in data) out.pets = mergeSection(out.pets, { teams: data.petTeams });
    if ("petTeamSearch" in data) out.pets = mergeSection(out.pets, { teamSearch: data.petTeamSearch });
    if ("petTeamHotkeys" in data) out.pets = mergeSection(out.pets, { hotkeys: data.petTeamHotkeys });
    if ("petAlerts" in data) out.pets = mergeSection(out.pets, { alerts: data.petAlerts });
    if ("notifier" in data && typeof data.notifier === "object") {
      out.notifier = mergeSection(out.notifier, data.notifier);
    }
    if ("notifierPrefs" in data) out.notifier = mergeSection(out.notifier, { prefs: data.notifierPrefs });
    if ("notifierRules" in data) out.notifier = mergeSection(out.notifier, { rules: data.notifierRules });
    if ("weatherNotifierPrefs" in data) out.notifier = mergeSection(out.notifier, { weatherPrefs: data.weatherNotifierPrefs });
    if ("notifierLoopDefaults" in data) out.notifier = mergeSection(out.notifier, { loopDefaults: data.notifierLoopDefaults });
    if ("misc" in data && typeof data.misc === "object") {
      out.misc = mergeSection(out.misc, data.misc);
    }
    if ("ghostMode" in data) out.misc = mergeSection(out.misc, { ghostMode: data.ghostMode });
    if ("ghostDelayMs" in data) out.misc = mergeSection(out.misc, { ghostDelayMs: data.ghostDelayMs });
    if ("autoRecoEnabled" in data) out.misc = mergeSection(out.misc, { autoRecoEnabled: data.autoRecoEnabled });
    if ("autoRecoDelayMs" in data) out.misc = mergeSection(out.misc, { autoRecoDelayMs: data.autoRecoDelayMs });
    if ("locker" in data && typeof data.locker === "object") {
      out.locker = mergeSection(out.locker, data.locker);
    }
    if ("lockerRestrictions" in data) out.locker = mergeSection(out.locker, { restrictions: data.lockerRestrictions });
    if ("lockerState" in data) out.locker = mergeSection(out.locker, { state: data.lockerState });
    if ("keybinds" in data && typeof data.keybinds === "object") {
      out.keybinds = mergeSection(out.keybinds, data.keybinds);
    }
    if ("editorSavedGardens" in data) out.editor = mergeSection(out.editor, { savedGardens: data.editorSavedGardens });
    if ("editor" in data && typeof data.editor === "object") {
      out.editor = mergeSection(out.editor, data.editor);
    }
    if ("activityLog" in data && typeof data.activityLog === "object") {
      out.activityLog = mergeSection(out.activityLog, data.activityLog);
    }
    if ("activityLogHistory" in data) out.activityLog = mergeSection(out.activityLog, { history: data.activityLogHistory });
    if ("activityLogFilter" in data) out.activityLog = mergeSection(out.activityLog, { filter: data.activityLogFilter });
    if ("hud" in data && typeof data.hud === "object") {
      out.hud = mergeSection(out.hud, data.hud);
    }
    if ("menu" in data && typeof data.menu === "object") {
      out.menu = mergeSection(out.menu, data.menu);
    }
    if ("inventory" in data && typeof data.inventory === "object") {
      out.inventory = mergeSection(out.inventory, data.inventory);
    }
    if ("audio" in data && typeof data.audio === "object") {
      out.audio = mergeSection(out.audio, data.audio);
    }
    if ("audioSettings" in data) out.audio = mergeSection(out.audio, { settings: data.audioSettings });
    if ("audioLibrary" in data) out.audio = mergeSection(out.audio, { library: data.audioLibrary });
    if ("soundEffectsVolumeAtom" in data) out.audio = mergeSection(out.audio, { sfxVolumeAtom: data.soundEffectsVolumeAtom });
    if ("friends" in data && typeof data.friends === "object") {
      out.friends = {
        ...out.friends ?? {},
        ...data.friends
      };
    }
    return out;
  }
  function loadAriesStorage() {
    const storage = getHostStorage();
    if (!storage) return { ...DEFAULT_ARIES_STORAGE };
    const raw = storage.getItem(ARIES_STORAGE_KEY);
    if (raw) {
      const parsed = parseSafe(raw);
      if (parsed && typeof parsed === "object") {
        return coerceLegacyAggregate(parsed);
      }
    }
    return { ...DEFAULT_ARIES_STORAGE };
  }
  function persistAriesStorage(data) {
    const storage = getHostStorage();
    if (!storage) return;
    try {
      storage.setItem(ARIES_STORAGE_KEY, JSON.stringify(data));
    } catch {
    }
  }
  function getValueAtPath(obj, path) {
    let cur = obj;
    for (const segment of path) {
      if (!cur || typeof cur !== "object") return void 0;
      cur = cur[segment];
    }
    return cur;
  }
  function setValueAtPath(obj, path, value) {
    if (!path.length) return;
    let cur = obj;
    for (let i = 0; i < path.length - 1; i++) {
      const key2 = path[i];
      if (!cur[key2] || typeof cur[key2] !== "object") {
        cur[key2] = {};
      }
      cur = cur[key2];
    }
    const last = path[path.length - 1];
    if (value === void 0) {
      if (cur && typeof cur === "object") {
        delete cur[last];
      }
    } else {
      cur[last] = value;
    }
  }
  function getAriesStorage() {
    return loadAriesStorage();
  }
  function saveAriesStorage(data) {
    persistAriesStorage(data);
  }
  function updateAriesStorage(mutator) {
    const current = loadAriesStorage();
    mutator(current);
    current.version = ARIES_STORAGE_VERSION;
    persistAriesStorage(current);
    return current;
  }
  function readAriesPath(path, fallback) {
    const parts = path.split(".").filter(Boolean);
    const value = getValueAtPath(loadAriesStorage(), parts);
    if (value === void 0) return fallback;
    return value;
  }
  function writeAriesPath(path, value) {
    return updateAriesStorage((state3) => {
      setValueAtPath(state3, path.split(".").filter(Boolean), value);
    });
  }
  function updateAriesPath(path, updater) {
    return updateAriesStorage((state3) => {
      const parts = path.split(".").filter(Boolean);
      const currentValue = getValueAtPath(state3, parts);
      const next = updater(currentValue);
      setValueAtPath(state3, parts, next);
    });
  }
  function setApiKey(apiKey) {
    try {
      if (typeof GM_setValue === "function") {
        GM_setValue(API_KEY_STORAGE_KEY, apiKey);
        return;
      }
      getHostStorage()?.setItem(API_KEY_STORAGE_KEY, apiKey);
    } catch (e) {
      console.error("Failed to store API key:", e);
    }
  }
  function getApiKey() {
    try {
      if (typeof GM_getValue === "function") {
        return GM_getValue(API_KEY_STORAGE_KEY, null) ?? null;
      }
      return getHostStorage()?.getItem(API_KEY_STORAGE_KEY) ?? null;
    } catch (e) {
      console.error("Failed to retrieve API key:", e);
      return null;
    }
  }
  function hasApiKey() {
    const key2 = getApiKey();
    return key2 !== null && key2.length > 0;
  }
  function hasSeenRoomPrivacyNotice() {
    try {
      if (typeof GM_getValue === "function") {
        const raw = GM_getValue(SEEN_ROOM_PRIVACY_NOTICE_KEY, null);
        if (raw == null) return false;
        if (typeof raw === "boolean") return raw;
        return String(raw).trim() === "1";
      }
      return getHostStorage()?.getItem(SEEN_ROOM_PRIVACY_NOTICE_KEY) === "1";
    } catch {
      return false;
    }
  }
  function markRoomPrivacyNoticeSeen() {
    try {
      if (typeof GM_setValue === "function") {
        GM_setValue(SEEN_ROOM_PRIVACY_NOTICE_KEY, "1");
        return;
      }
      getHostStorage()?.setItem(SEEN_ROOM_PRIVACY_NOTICE_KEY, "1");
    } catch {
    }
  }
  function setDeclinedApiAuth(declined) {
    try {
      if (declined) {
        if (typeof GM_setValue === "function") {
          GM_setValue(AUTH_DECLINED_STORAGE_KEY, "1");
          return;
        }
        getHostStorage()?.setItem(AUTH_DECLINED_STORAGE_KEY, "1");
        return;
      }
      if (typeof GM_deleteValue === "function") {
        GM_deleteValue(AUTH_DECLINED_STORAGE_KEY);
        return;
      }
      getHostStorage()?.removeItem(AUTH_DECLINED_STORAGE_KEY);
    } catch {
    }
  }

  // src/services/locker.ts
  var VISUAL_MUTATIONS = /* @__PURE__ */ new Set(["Gold", "Rainbow"]);
  var LOCKER_NO_WEATHER_TAG = "NoWeatherEffect";
  var normalizeMutationTag = (value) => {
    const raw = typeof value === "string" ? value : value == null ? "" : String(value);
    const trimmed = raw.trim();
    if (!trimmed) return "";
    const collapsed = trimmed.toLowerCase().replace(/[\s_-]+/g, "");
    switch (collapsed) {
      case "gold":
        return "Gold";
      case "rainbow":
        return "Rainbow";
      case "wet":
        return "Wet";
      case "chilled":
        return "Chilled";
      case "frozen":
        return "Frozen";
      case "dawn":
      case "dawnlit":
      case "dawnlight":
        return "Dawnlit";
      case "dawnbound":
      case "dawncharged":
      case "dawnradiant":
        return "Dawnbound";
      case "amberlit":
      case "amberlight":
      case "amberglow":
      case "ambershine":
        return "Amberlit";
      case "amberbound":
      case "ambercharged":
      case "amberradiant":
        return "Amberbound";
      default:
        return trimmed;
    }
  };
  var canonicalizeWeatherTag = (value) => {
    if (value === LOCKER_NO_WEATHER_TAG) return LOCKER_NO_WEATHER_TAG;
    const normalized = normalizeMutationTag(value);
    return normalized || null;
  };
  var normalizeMutationsList = (raw) => {
    if (!Array.isArray(raw)) return [];
    const out = [];
    for (let i = 0; i < raw.length; i++) {
      const normalized = normalizeMutationTag(raw[i]);
      if (normalized) out.push(normalized);
    }
    return out;
  };
  var normalizeSpeciesKey = (value) => value.toLowerCase().replace(/['`]/g, "").replace(/\s+/g, "").replace(/-/g, "").replace(/(seed|plant|baby|fruit|crop)$/i, "");
  var MAX_SCALE_BY_SPECIES = (() => {
    const map2 = /* @__PURE__ */ new Map();
    const register = (key2, value) => {
      if (typeof key2 !== "string") return;
      const normalized = normalizeSpeciesKey(key2.trim());
      if (!normalized || map2.has(normalized)) return;
      map2.set(normalized, value);
    };
    for (const [species, entry] of Object.entries(plantCatalog)) {
      const maxScale = Number(entry?.crop?.maxScale);
      if (!Number.isFinite(maxScale) || maxScale <= 0) continue;
      register(species, maxScale);
      register(entry?.seed?.name, maxScale);
      register(entry?.plant?.name, maxScale);
      register(entry?.crop?.name, maxScale);
    }
    return map2;
  })();
  var emptySlotInfo = () => ({
    isPlant: false,
    originalIndex: null,
    orderedIndex: null,
    totalSlots: 0,
    availableSlotCount: 0,
    slot: null,
    seedKey: null,
    sizePercent: null,
    mutations: []
  });
  var now = () => typeof performance !== "undefined" && typeof performance.now === "function" ? performance.now() : Date.now();
  var shallowEqualStrings = (a, b) => {
    if (a === b) return true;
    if (!a || !b) return (a?.length ?? 0) === (b?.length ?? 0);
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  };
  var slotInfosEqual = (a, b) => a.isPlant === b.isPlant && a.originalIndex === b.originalIndex && a.orderedIndex === b.orderedIndex && a.totalSlots === b.totalSlots && a.availableSlotCount === b.availableSlotCount && a.slot === b.slot && a.seedKey === b.seedKey && a.sizePercent === b.sizePercent && shallowEqualStrings(a.mutations, b.mutations);
  var isPlantObject = (o) => !!o && o.objectType === "plant";
  var slotSignature = (slot) => {
    if (!slot) return "\u2205";
    const species = slot.species ?? "";
    const start2 = Number.isFinite(slot.startTime) ? slot.startTime : 0;
    const end = Number.isFinite(slot.endTime) ? slot.endTime : 0;
    const target = Number.isFinite(slot.targetScale) ? slot.targetScale : 0;
    const muts = Array.isArray(slot.mutations) ? slot.mutations.join(",") : "";
    return `${species}|${start2}|${end}|${target}|${muts}`;
  };
  var gardenObjectSignature = (obj) => {
    if (!obj) return "\u2205";
    if (!isPlantObject(obj)) {
      if (!obj || typeof obj !== "object") return String(obj);
      const entries = Object.keys(obj).sort().map((key2) => `${key2}:${JSON.stringify(obj[key2])}`);
      return `other|${entries.join(";")}`;
    }
    const base = `${obj.objectType}|${obj.species ?? ""}|${obj.plantedAt ?? 0}|${obj.maturedAt ?? 0}`;
    const slots = Array.isArray(obj.slots) ? obj.slots.map((slot) => slotSignature(slot)).join("||") : "";
    return `${base}|slots:${slots}`;
  };
  var arraySignature = (arr) => Array.isArray(arr) ? arr.join(",") : "\u2205";
  var defaultOrder = (n) => Array.from({ length: n }, (_, i) => i);
  var clamp = (n, min, max) => Math.max(min, Math.min(max, n));
  var extractSeedKey = (obj) => {
    if (!obj || typeof obj !== "object") return null;
    if (typeof obj.seedKey === "string") {
      return obj.seedKey;
    }
    if (typeof obj.species === "string" && obj.species) {
      return obj.species;
    }
    const asAny = obj;
    const fallbacks = ["seedSpecies", "plantSpecies", "cropSpecies", "speciesId"];
    for (const key2 of fallbacks) {
      const value = asAny[key2];
      if (typeof value === "string" && value) return value;
    }
    return null;
  };
  var clampPercent = (value, min, max) => Math.max(min, Math.min(max, value));
  var lookupMaxScale = (species) => {
    if (typeof species !== "string") return null;
    const normalized = normalizeSpeciesKey(species.trim());
    if (!normalized) return null;
    const found = MAX_SCALE_BY_SPECIES.get(normalized);
    if (typeof found === "number" && Number.isFinite(found) && found > 0) {
      return found;
    }
    return null;
  };
  var getMaxScaleForSlot = (slot) => {
    if (!slot || typeof slot !== "object") return null;
    const candidates = /* @__PURE__ */ new Set();
    const fromSeedKey = extractSeedKey(slot);
    if (fromSeedKey) candidates.add(fromSeedKey);
    const fields = [
      "species",
      "seedSpecies",
      "plantSpecies",
      "cropSpecies",
      "baseSpecies",
      "seedKey"
    ];
    for (const field of fields) {
      const value = slot[field];
      if (typeof value === "string" && value) {
        candidates.add(value);
      }
    }
    for (const cand of candidates) {
      const max = lookupMaxScale(cand);
      if (typeof max === "number" && Number.isFinite(max) && max > 0) {
        return max;
      }
    }
    return null;
  };
  var extractSizePercent = (slot) => {
    if (!slot || typeof slot !== "object") return 100;
    const direct = Number(slot.sizePercent ?? slot.sizePct ?? slot.size ?? slot.percent ?? slot.progressPercent);
    if (Number.isFinite(direct)) {
      return clampPercent(Math.round(direct), 0, 100);
    }
    const scale = Number(slot.targetScale ?? slot.scale);
    if (Number.isFinite(scale)) {
      const maxScale = getMaxScaleForSlot(slot);
      if (typeof maxScale === "number" && Number.isFinite(maxScale) && maxScale > 1) {
        const clamped = Math.max(1, Math.min(maxScale, scale));
        const pct2 = 50 + (clamped - 1) / (maxScale - 1) * 50;
        return clampPercent(Math.round(pct2), 50, 100);
      }
      if (scale > 1 && scale <= 2) {
        const pct2 = 50 + (scale - 1) / 1 * 50;
        return clampPercent(Math.round(pct2), 50, 100);
      }
      const pct = Math.round(scale * 100);
      return clampPercent(pct, 0, 100);
    }
    return 100;
  };
  function startLockerSlotWatcherViaGardenObject() {
    if (typeof window === "undefined") {
      return {
        get: () => emptySlotInfo(),
        onChange: () => () => {
        },
        stop() {
        },
        recompute() {
        }
      };
    }
    let cur = null;
    let sortedIdx = null;
    let sortedIdxSig = arraySignature(sortedIdx);
    let selectedIdx = null;
    let lastInfo = emptySlotInfo();
    let curSig = gardenObjectSignature(cur);
    const listeners5 = /* @__PURE__ */ new Set();
    const notify2 = () => {
      for (const fn of listeners5) {
        try {
          fn(lastInfo);
        } catch {
        }
      }
    };
    let scheduled = false;
    const scheduleRecomputeAndNotify = () => {
      recomputeAndNotify();
      if (scheduled) return;
      scheduled = true;
      const run = () => {
        scheduled = false;
        recomputeAndNotify();
      };
      if (typeof globalThis !== "undefined" && typeof globalThis.queueMicrotask === "function") {
        globalThis.queueMicrotask(run);
      } else if (typeof Promise !== "undefined") {
        Promise.resolve().then(run);
      } else if (typeof window !== "undefined" && typeof window.setTimeout === "function") {
        window.setTimeout(run, 0);
      } else {
        run();
      }
    };
    function getOrder(slotCount) {
      if (!slotCount) return [];
      if (Array.isArray(sortedIdx) && sortedIdx.length === slotCount) {
        return sortedIdx.slice();
      }
      return defaultOrder(slotCount);
    }
    function selectedOrderedPosition(order, slotCount) {
      if (!slotCount || !order.length) return 0;
      const raw = Number.isFinite(selectedIdx) ? selectedIdx : 0;
      const clampedRaw = clamp(raw, 0, slotCount - 1);
      const pos = order.indexOf(clampedRaw);
      return pos >= 0 ? pos : 0;
    }
    function sanitizeMutations2(raw) {
      return normalizeMutationsList(raw);
    }
    function computeSlotInfo() {
      const seedKey = extractSeedKey(cur);
      if (!isPlantObject(cur)) {
        return {
          isPlant: false,
          originalIndex: null,
          orderedIndex: null,
          totalSlots: 0,
          availableSlotCount: 0,
          slot: null,
          seedKey,
          sizePercent: null,
          mutations: []
        };
      }
      const slots = Array.isArray(cur.slots) ? cur.slots : [];
      const slotCount = slots.length;
      if (!slotCount) {
        return {
          isPlant: true,
          originalIndex: null,
          orderedIndex: null,
          totalSlots: 0,
          availableSlotCount: 0,
          slot: null,
          seedKey,
          sizePercent: null,
          mutations: []
        };
      }
      const order = getOrder(slotCount);
      const availableIndices = [];
      for (const idx of order) {
        if (Number.isInteger(idx) && idx >= 0 && idx < slotCount) {
          if (slots[idx] != null) availableIndices.push(idx);
        }
      }
      const availableCount = availableIndices.length;
      if (!availableCount) {
        return {
          isPlant: true,
          originalIndex: null,
          orderedIndex: null,
          totalSlots: slotCount,
          availableSlotCount: 0,
          slot: null,
          seedKey,
          sizePercent: null,
          mutations: []
        };
      }
      const pos = selectedOrderedPosition(order, slotCount);
      const clampedPos = clamp(pos, 0, availableCount - 1);
      const originalIndex = availableIndices[clampedPos] ?? null;
      const slot = typeof originalIndex === "number" ? slots[originalIndex] ?? null : null;
      const sizePercent = slot ? extractSizePercent(slot) : null;
      const mutations = slot ? sanitizeMutations2(slot.mutations) : [];
      return {
        isPlant: true,
        originalIndex: typeof originalIndex === "number" ? originalIndex : null,
        orderedIndex: clampedPos,
        totalSlots: slotCount,
        availableSlotCount: availableCount,
        slot: slot ?? null,
        seedKey,
        sizePercent,
        mutations
      };
    }
    function mutationsEqual(a, b) {
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) return false;
      }
      return true;
    }
    function infosEqual(a, b) {
      return a.isPlant === b.isPlant && a.originalIndex === b.originalIndex && a.orderedIndex === b.orderedIndex && a.totalSlots === b.totalSlots && a.availableSlotCount === b.availableSlotCount && a.slot === b.slot && a.seedKey === b.seedKey && a.sizePercent === b.sizePercent && mutationsEqual(a.mutations, b.mutations);
    }
    function recomputeAndNotify() {
      const next = computeSlotInfo();
      if (!infosEqual(next, lastInfo)) {
        lastInfo = next;
        notify2();
      }
    }
    (async () => {
      try {
        selectedIdx = await myCurrentGrowSlotIndex.get();
      } catch {
      }
      try {
        const v = await myCurrentSortedGrowSlotIndices.get();
        sortedIdx = Array.isArray(v) ? v.slice() : null;
        sortedIdxSig = arraySignature(sortedIdx);
      } catch {
      }
      try {
        cur = await myCurrentGardenObject.get();
        curSig = gardenObjectSignature(cur);
      } catch {
      }
      const refreshSorted = (v) => {
        const next = Array.isArray(v) ? v.slice() : null;
        const sig = arraySignature(next);
        if (sig === sortedIdxSig) return false;
        sortedIdx = next;
        sortedIdxSig = sig;
        return true;
      };
      const refreshGarden = (v) => {
        const sig = gardenObjectSignature(v ?? null);
        if (sig === curSig) return false;
        cur = v;
        curSig = sig;
        return true;
      };
      let awaitIndexBeforeRecompute = false;
      let awaitIndexTimer = null;
      const clearAwaitIndexTimer = () => {
        if (awaitIndexTimer == null) return;
        if (typeof globalThis !== "undefined") {
          const clearer = globalThis.clearTimeout;
          if (typeof clearer === "function") {
            clearer.call(globalThis, awaitIndexTimer);
          }
        }
        awaitIndexTimer = null;
      };
      const deferUntilIndexChanges = () => {
        awaitIndexBeforeRecompute = true;
        if (awaitIndexTimer != null) return;
        const run = () => {
          awaitIndexTimer = null;
          if (!awaitIndexBeforeRecompute) return;
          awaitIndexBeforeRecompute = false;
          scheduleRecomputeAndNotify();
        };
        if (typeof globalThis !== "undefined") {
          const setter = globalThis.setTimeout;
          if (typeof setter === "function") {
            awaitIndexTimer = setter.call(globalThis, run, 0);
            return;
          }
        }
        run();
      };
      myCurrentSortedGrowSlotIndices.onChange((v) => {
        const changed = refreshSorted(v);
        if (!changed) return;
        deferUntilIndexChanges();
      });
      myCurrentGardenObject.onChange((v) => {
        const changed = refreshGarden(v);
        if (!changed) return;
        deferUntilIndexChanges();
      });
      myCurrentGrowSlotIndex.onChange((idx) => {
        selectedIdx = Number.isFinite(idx) ? idx : 0;
        void (async () => {
          try {
            refreshSorted(await myCurrentSortedGrowSlotIndices.get());
          } catch {
          }
          try {
            refreshGarden(await myCurrentGardenObject.get());
          } catch {
          }
          if (awaitIndexBeforeRecompute) {
            awaitIndexBeforeRecompute = false;
            clearAwaitIndexTimer();
          }
          scheduleRecomputeAndNotify();
        })();
      });
      recomputeAndNotify();
    })();
    return {
      get() {
        return lastInfo;
      },
      onChange(cb) {
        listeners5.add(cb);
        return () => listeners5.delete(cb);
      },
      stop() {
        listeners5.clear();
      },
      recompute() {
        recomputeAndNotify();
      }
    };
  }
  function defaultSettings() {
    return {
      minScalePct: 50,
      maxScalePct: 100,
      scaleLockMode: "RANGE",
      lockMode: "LOCK",
      minInventory: 91,
      avoidNormal: false,
      includeNormal: true,
      visualMutations: [],
      weatherMode: "ANY",
      weatherSelected: [],
      weatherRecipes: []
    };
  }
  function defaultState() {
    return {
      enabled: false,
      settings: defaultSettings(),
      overrides: {}
    };
  }
  var ARIES_LOCKER_STATE_PATH = "locker.state";
  var clampNumber = (value, min, max) => Math.max(min, Math.min(max, value));
  function sanitizeSettings(raw) {
    const base = defaultSettings();
    base.lockMode = raw?.lockMode === "ALLOW" ? "ALLOW" : "LOCK";
    const rawMode = raw?.scaleLockMode;
    const scaleMode = rawMode === "MINIMUM" ? "MINIMUM" : rawMode === "MAXIMUM" ? "MAXIMUM" : rawMode === "NONE" ? "NONE" : "RANGE";
    base.scaleLockMode = scaleMode;
    const minScaleRaw = Number(raw?.minScalePct);
    let minScale = Number.isFinite(minScaleRaw) ? clampNumber(Math.round(minScaleRaw), 50, 100) : 50;
    const maxScaleRaw = Number(raw?.maxScalePct);
    let maxScale = Number.isFinite(maxScaleRaw) ? clampNumber(Math.round(maxScaleRaw), 50, 100) : 100;
    if (scaleMode === "RANGE") {
      maxScale = clampNumber(maxScale, 51, 100);
      if (maxScale <= minScale) {
        if (minScale >= 99) {
          minScale = 99;
          maxScale = 100;
        } else {
          maxScale = clampNumber(minScale + 1, 51, 100);
        }
      }
    } else if (scaleMode === "MAXIMUM") {
      maxScale = clampNumber(maxScale, 50, 100);
    } else if (scaleMode === "MINIMUM") {
      minScale = clampNumber(minScale, 50, 100);
    }
    base.minScalePct = minScale;
    base.maxScalePct = maxScale;
    const minInv = Number(raw?.minInventory);
    base.minInventory = Number.isFinite(minInv) ? clampNumber(Math.round(minInv), 0, 999) : 91;
    if (typeof raw?.avoidNormal === "boolean") {
      base.avoidNormal = raw.avoidNormal;
    } else {
      base.avoidNormal = raw?.includeNormal === false;
    }
    base.includeNormal = !base.avoidNormal;
    base.visualMutations = Array.isArray(raw?.visualMutations) ? Array.from(new Set(raw.visualMutations.filter((m) => VISUAL_MUTATIONS.has(m)))) : [];
    const mode = raw?.weatherMode;
    base.weatherMode = mode === "ALL" || mode === "RECIPES" ? mode : "ANY";
    base.weatherSelected = Array.isArray(raw?.weatherSelected) ? Array.from(new Set(raw.weatherSelected.map((m) => String(m || "")).filter(Boolean))) : [];
    base.weatherRecipes = Array.isArray(raw?.weatherRecipes) ? raw.weatherRecipes.map(
      (recipe) => Array.isArray(recipe) ? Array.from(new Set(recipe.map((m) => String(m || "")).filter(Boolean))) : []
    ).filter((arr) => arr.length > 0) : [];
    return base;
  }
  function sanitizeState(raw) {
    const state3 = defaultState();
    if (!raw || typeof raw !== "object") return state3;
    state3.enabled = raw.enabled === true;
    state3.settings = sanitizeSettings(raw.settings);
    state3.overrides = {};
    if (raw.overrides && typeof raw.overrides === "object") {
      for (const [key2, value] of Object.entries(raw.overrides)) {
        if (!key2) continue;
        state3.overrides[key2] = {
          enabled: value?.enabled === true,
          settings: sanitizeSettings(value?.settings)
        };
      }
    }
    return state3;
  }
  function cloneSettings(settings) {
    return {
      minScalePct: settings.minScalePct,
      maxScalePct: settings.maxScalePct,
      scaleLockMode: settings.scaleLockMode,
      lockMode: settings.lockMode === "ALLOW" ? "ALLOW" : "LOCK",
      minInventory: settings.minInventory,
      avoidNormal: settings.avoidNormal,
      includeNormal: settings.includeNormal,
      visualMutations: settings.visualMutations.slice(),
      weatherMode: settings.weatherMode,
      weatherSelected: settings.weatherSelected.slice(),
      weatherRecipes: settings.weatherRecipes.map((recipe) => recipe.slice())
    };
  }
  function cloneState(state3) {
    const overrides = {};
    for (const [key2, value] of Object.entries(state3.overrides)) {
      overrides[key2] = { enabled: value.enabled, settings: cloneSettings(value.settings) };
    }
    return {
      enabled: state3.enabled,
      settings: cloneSettings(state3.settings),
      overrides
    };
  }
  function cloneSlotInfo(info) {
    return {
      isPlant: info.isPlant,
      originalIndex: info.originalIndex,
      orderedIndex: info.orderedIndex,
      totalSlots: info.totalSlots,
      availableSlotCount: info.availableSlotCount,
      slot: info.slot,
      seedKey: info.seedKey,
      sizePercent: info.sizePercent,
      mutations: info.mutations.slice()
    };
  }
  function mutationsToArrays(raw) {
    const normalized = normalizeMutationsList(raw);
    let hasGold = false;
    let hasRainbow = false;
    const weather2 = [];
    for (let i = 0; i < normalized.length; i++) {
      const tag = String(normalized[i] || "");
      if (!tag) continue;
      if (tag === "Gold") {
        hasGold = true;
      } else if (tag === "Rainbow") {
        hasRainbow = true;
      } else {
        weather2.push(tag);
      }
    }
    return { hasGold, hasRainbow, weather: weather2 };
  }
  var LockerService = class {
    constructor() {
      __publicField(this, "state", defaultState());
      __publicField(this, "listeners", /* @__PURE__ */ new Set());
      __publicField(this, "slotInfoListeners", /* @__PURE__ */ new Set());
      __publicField(this, "slotWatcher", null);
      __publicField(this, "slotWatcherUnsub", null);
      __publicField(this, "currentSlotInfo", emptySlotInfo());
      __publicField(this, "currentSlotHarvestAllowed", null);
      __publicField(this, "lastSlotChangeDetectedAt", null);
      this.load();
      this.updateSlotWatcher();
    }
    load() {
      if (typeof window === "undefined") {
        this.state = defaultState();
        return;
      }
      try {
        const parsed = readAriesPath(ARIES_LOCKER_STATE_PATH);
        this.state = sanitizeState(parsed);
      } catch {
        this.state = defaultState();
      }
    }
    save() {
      if (typeof window === "undefined") return;
      try {
        writeAriesPath(ARIES_LOCKER_STATE_PATH, this.state);
      } catch {
      }
    }
    emit() {
      if (!this.listeners.size) return;
      const snapshot = this.getState();
      const event = { type: "locker-state-changed", state: snapshot };
      for (const listener of this.listeners) {
        try {
          listener(event);
        } catch {
        }
      }
    }
    setState(next) {
      this.state = next;
      this.updateSlotWatcher();
      this.save();
      this.emit();
      this.requestSlotWatcherRecompute();
      this.reapplyCurrentSlotInfo();
    }
    updateSlotWatcher() {
      const shouldWatch = this.state.enabled;
      if (shouldWatch) {
        if (!this.slotWatcher) {
          this.slotWatcher = startLockerSlotWatcherViaGardenObject();
        }
        if (this.slotWatcher && !this.slotWatcherUnsub) {
          try {
            this.slotWatcherUnsub = this.slotWatcher.onChange((info) => this.handleSlotInfo(info));
          } catch {
            this.slotWatcherUnsub = null;
          }
        }
        try {
          const info = this.slotWatcher ? this.slotWatcher.get() : emptySlotInfo();
          this.handleSlotInfo(info, { silent: true });
        } catch {
          this.handleSlotInfo(emptySlotInfo(), { silent: true });
        }
        return;
      }
      this.detachSlotWatcher();
    }
    getState() {
      return cloneState(this.state);
    }
    setGlobalState(next) {
      const current = this.state;
      const sanitized = sanitizeSettings(next.settings);
      const updated = {
        enabled: !!next.enabled,
        settings: sanitized,
        overrides: { ...current.overrides }
      };
      this.setState(updated);
    }
    setOverride(seedKey, override) {
      if (!seedKey) return;
      const sanitized = {
        enabled: !!override?.enabled,
        settings: sanitizeSettings(override?.settings)
      };
      const overrides = { ...this.state.overrides, [seedKey]: sanitized };
      this.setState({ ...this.state, overrides });
    }
    removeOverride(seedKey) {
      if (!seedKey) return;
      if (!(seedKey in this.state.overrides)) return;
      const overrides = { ...this.state.overrides };
      delete overrides[seedKey];
      this.setState({ ...this.state, overrides });
    }
    subscribe(listener) {
      this.listeners.add(listener);
      return () => this.listeners.delete(listener);
    }
    onSlotInfoChange(listener) {
      this.slotInfoListeners.add(listener);
      return () => this.slotInfoListeners.delete(listener);
    }
    getCurrentSlotSnapshot() {
      return {
        info: cloneSlotInfo(this.currentSlotInfo),
        harvestAllowed: this.currentSlotHarvestAllowed,
        detectedAt: this.lastSlotChangeDetectedAt
      };
    }
    requestSlotWatcherRecompute() {
      if (!this.slotWatcher) return;
      try {
        this.slotWatcher.recompute();
      } catch {
      }
    }
    detachSlotWatcher() {
      if (this.slotWatcherUnsub) {
        try {
          this.slotWatcherUnsub();
        } catch {
        }
        this.slotWatcherUnsub = null;
      }
      if (this.slotWatcher) {
        try {
          this.slotWatcher.stop();
        } catch {
        }
        this.slotWatcher = null;
      }
      this.handleSlotInfo(emptySlotInfo(), { silent: true });
    }
    handleSlotInfo(info, opts = {}) {
      const { silent = false } = opts;
      const prevInfo = this.currentSlotInfo;
      const prevHarvestAllowed = this.currentSlotHarvestAllowed;
      const normalizedMutations = normalizeMutationsList(info.mutations);
      const nextInfo = { ...info, mutations: normalizedMutations };
      let computedSizePercent = null;
      let harvestAllowed = null;
      let displaySizePercent = null;
      if (nextInfo.isPlant && nextInfo.slot) {
        if (typeof nextInfo.sizePercent === "number" && Number.isFinite(nextInfo.sizePercent)) {
          computedSizePercent = nextInfo.sizePercent;
        } else {
          computedSizePercent = extractSizePercent(nextInfo.slot);
        }
        try {
          const assessment = this.assessHarvest({
            seedKey: nextInfo.seedKey ?? null,
            sizePercent: computedSizePercent ?? 0,
            mutations: normalizedMutations
          });
          harvestAllowed = assessment.allowed;
        } catch {
          harvestAllowed = null;
        }
      } else {
        computedSizePercent = typeof nextInfo.sizePercent === "number" && Number.isFinite(nextInfo.sizePercent) ? nextInfo.sizePercent : null;
        harvestAllowed = null;
      }
      if (typeof computedSizePercent === "number") {
        displaySizePercent = Math.max(50, Math.min(100, computedSizePercent));
      }
      this.currentSlotInfo = nextInfo;
      this.currentSlotHarvestAllowed = harvestAllowed;
      if (!silent) {
        if (nextInfo.isPlant) {
          if (nextInfo.slot) {
            console.log("[Locker] Slot selection", {
              seedKey: nextInfo.seedKey ?? null,
              slotIndex: nextInfo.originalIndex,
              orderedIndex: nextInfo.orderedIndex,
              sizePercent: computedSizePercent,
              displaySizePercent,
              harvestAllowed,
              mutations: normalizedMutations,
              slot: nextInfo.slot
            });
          } else {
            console.log("[Locker] Slot selection", {
              isPlant: true,
              slotIndex: nextInfo.originalIndex,
              orderedIndex: nextInfo.orderedIndex,
              totalSlots: nextInfo.totalSlots,
              availableSlotCount: nextInfo.availableSlotCount,
              seedKey: nextInfo.seedKey ?? null,
              displaySizePercent,
              slot: nextInfo.slot
            });
          }
        } else {
          console.log("[Locker] Slot selection", { isPlant: false, slot: nextInfo.slot });
        }
        const infoChanged = !slotInfosEqual(prevInfo, nextInfo) || (prevHarvestAllowed ?? null) !== (harvestAllowed ?? null);
        if (infoChanged) {
          this.lastSlotChangeDetectedAt = now();
        }
      }
      this.emitSlotInfoChange();
    }
    reapplyCurrentSlotInfo() {
      try {
        const info = this.slotWatcher ? this.slotWatcher.get() : emptySlotInfo();
        this.handleSlotInfo(info, { silent: true });
      } catch {
        this.handleSlotInfo(emptySlotInfo(), { silent: true });
      }
    }
    recomputeCurrentSlot() {
      this.requestSlotWatcherRecompute();
      this.reapplyCurrentSlotInfo();
    }
    effectiveSettings(seedKey) {
      if (!this.state.enabled) {
        return { enabled: false, settings: this.state.settings };
      }
      if (seedKey) {
        const override = this.state.overrides[seedKey];
        if (override?.enabled) {
          return { enabled: true, settings: override.settings };
        }
      }
      return { enabled: true, settings: this.state.settings };
    }
    assessHarvest(args) {
      const effective = this.effectiveSettings(args.seedKey);
      const filters = this.evaluateLockFilters(effective.settings, args);
      const lockMode = effective.settings.lockMode === "ALLOW" ? "ALLOW" : "LOCK";
      if (!effective.enabled) {
        return { effective, filters, lockMode, allowed: true };
      }
      const blocked = lockMode === "ALLOW" ? filters.size.hasCriteria && !filters.size.matched || filters.color.hasCriteria && !filters.color.matched || filters.weather.hasCriteria && !filters.weather.matched : filters.matchAny;
      return { effective, filters, lockMode, allowed: !blocked };
    }
    evaluateLockFilters(settings, args) {
      const size = { hasCriteria: false, matched: false };
      const color = { hasCriteria: false, matched: false };
      const weatherInfo = { hasCriteria: false, matched: false };
      const scaleMode = settings.scaleLockMode === "MAXIMUM" ? "MAXIMUM" : settings.scaleLockMode === "MINIMUM" ? "MINIMUM" : settings.scaleLockMode === "NONE" ? "NONE" : "RANGE";
      const minScale = clampNumber(Math.round(settings.minScalePct ?? 50), 50, 100);
      const maxScaleBase = clampNumber(Math.round(settings.maxScalePct ?? 100), 50, 100);
      const epsilon = 1e-4;
      let sizeMin = null;
      let sizeMax = null;
      if (scaleMode === "RANGE") {
        size.hasCriteria = true;
        const maxScaleRaw = clampNumber(maxScaleBase, 51, 100);
        const maxScale = maxScaleRaw <= minScale ? Math.min(100, Math.max(51, minScale + 1)) : maxScaleRaw;
        sizeMin = minScale;
        sizeMax = maxScale;
        const inRange = args.sizePercent + epsilon >= minScale && args.sizePercent - epsilon <= maxScale;
        size.matched = inRange;
      } else if (scaleMode === "MINIMUM") {
        size.hasCriteria = true;
        sizeMin = minScale;
        size.matched = args.sizePercent + epsilon >= minScale;
      } else if (scaleMode === "MAXIMUM") {
        size.hasCriteria = true;
        const maxScale = clampNumber(maxScaleBase, 50, 100);
        sizeMax = maxScale;
        size.matched = args.sizePercent - epsilon <= maxScale;
      }
      const { hasGold, hasRainbow, weather: weather2 } = mutationsToArrays(args.mutations);
      const isNormal = !hasGold && !hasRainbow;
      const avoidGold = settings.visualMutations.includes("Gold");
      const avoidRainbow = settings.visualMutations.includes("Rainbow");
      const colorFilters = [
        settings.avoidNormal ? "normal" : null,
        avoidGold ? "gold" : null,
        avoidRainbow ? "rainbow" : null
      ].filter(Boolean);
      if (colorFilters.length) {
        color.hasCriteria = true;
        const matches = settings.avoidNormal && isNormal || avoidGold && hasGold || avoidRainbow && hasRainbow;
        color.matched = matches;
      }
      const selected = settings.weatherSelected ?? [];
      const mode = settings.weatherMode ?? "ANY";
      if (mode === "RECIPES") {
        const recipes = settings.weatherRecipes ?? [];
        if (recipes.length) {
          weatherInfo.hasCriteria = true;
          let recipeMatch = false;
          for (const recipe of recipes) {
            if (!Array.isArray(recipe) || recipe.length === 0) continue;
            let matches = true;
            for (let j = 0; j < recipe.length; j++) {
              const rawTag = recipe[j];
              const normalizedRequired = canonicalizeWeatherTag(rawTag);
              if (!normalizedRequired) {
                matches = false;
                break;
              }
              if (normalizedRequired === LOCKER_NO_WEATHER_TAG) {
                if (weather2.length !== 0) {
                  matches = false;
                  break;
                }
                continue;
              }
              if (!weather2.includes(normalizedRequired)) {
                matches = false;
                break;
              }
            }
            if (matches) {
              recipeMatch = true;
              break;
            }
          }
          weatherInfo.matched = recipeMatch;
        }
        const matchAny2 = size.matched || color.matched || weatherInfo.matched;
        return { size, color, weather: weatherInfo, matchAny: matchAny2, sizeMin, sizeMax, scaleMode };
      }
      if (selected.length) {
        weatherInfo.hasCriteria = true;
        if (mode === "ALL") {
          let allMatch = true;
          for (let i = 0; i < selected.length; i++) {
            const requiredRaw = selected[i];
            const normalizedRequired = canonicalizeWeatherTag(requiredRaw);
            if (!normalizedRequired) {
              allMatch = false;
              break;
            }
            if (normalizedRequired === LOCKER_NO_WEATHER_TAG) {
              if (weather2.length !== 0) {
                allMatch = false;
                break;
              }
              continue;
            }
            if (!weather2.includes(normalizedRequired)) {
              allMatch = false;
              break;
            }
          }
          weatherInfo.matched = allMatch;
        } else {
          let anyMatch = false;
          for (let i = 0; i < selected.length; i++) {
            const requiredRaw = selected[i];
            const normalizedRequired = canonicalizeWeatherTag(requiredRaw);
            if (!normalizedRequired) {
              continue;
            }
            if (normalizedRequired === LOCKER_NO_WEATHER_TAG) {
              if (weather2.length === 0) {
                anyMatch = true;
                break;
              }
              continue;
            }
            if (weather2.includes(normalizedRequired)) {
              anyMatch = true;
              break;
            }
          }
          weatherInfo.matched = anyMatch;
        }
      }
      const matchAny = size.matched || color.matched || weatherInfo.matched;
      return { size, color, weather: weatherInfo, matchAny, sizeMin, sizeMax, scaleMode };
    }
    emitSlotInfoChange() {
      if (!this.slotInfoListeners.size) {
        return;
      }
      const snapshot = {
        type: "locker-slot-info-changed",
        info: cloneSlotInfo(this.currentSlotInfo),
        harvestAllowed: this.currentSlotHarvestAllowed,
        detectedAt: this.lastSlotChangeDetectedAt
      };
      for (const listener of this.slotInfoListeners) {
        try {
          listener(snapshot);
        } catch {
        }
      }
    }
    allowsHarvest(args) {
      return this.assessHarvest(args).allowed;
    }
  };
  var lockerService = new LockerService();

  // src/services/stats.ts
  var GARDEN_INT_KEYS = {
    totalPlanted: true,
    totalHarvested: true,
    totalDestroyed: true,
    watercanUsed: true,
    waterTimeSavedMs: true
  };
  var SHOP_INT_KEYS = {
    seedsBought: true,
    decorBought: true,
    eggsBought: true,
    toolsBought: true,
    cropsSoldCount: true,
    cropsSoldValue: false,
    petsSoldCount: true,
    petsSoldValue: false
  };
  var ABILITY_INT_KEYS = {
    triggers: true,
    totalValue: false
  };
  var WEATHER_INT_KEYS = {
    triggers: true
  };
  var memoryStore = null;
  var listeners = /* @__PURE__ */ new Set();
  var isRecord = (value) => typeof value === "object" && value !== null;
  var toNumber = (value, fallback = 0) => {
    const num = Number(value);
    if (!Number.isFinite(num)) return fallback;
    return num;
  };
  var toPositiveNumber = (value, fallback = 0) => {
    const num = toNumber(value, fallback);
    return Math.max(0, num);
  };
  var toPositiveInt = (value, fallback = 0) => {
    const num = toPositiveNumber(value, fallback);
    return Math.floor(num);
  };
  var toPositiveTimestamp = (value, fallback) => {
    const num = Number(value);
    if (!Number.isFinite(num) || num <= 0) return fallback;
    return Math.floor(num);
  };
  var cloneStats = (stats) => ({
    createdAt: stats.createdAt,
    garden: { ...stats.garden },
    shops: { ...stats.shops },
    pets: {
      hatchedByType: Object.fromEntries(
        Object.entries(stats.pets.hatchedByType).map(([key2, counts]) => [key2, { ...counts }])
      )
    },
    abilities: Object.fromEntries(
      Object.entries(stats.abilities).map(([key2, value]) => [key2, { ...value }])
    ),
    weather: Object.fromEntries(
      Object.entries(stats.weather).map(([key2, value]) => [key2, { ...value }])
    )
  });
  var unwrapMaybeNestedSnapshot = (raw) => {
    let cur = raw;
    let guard = 0;
    while (guard++ < 10 && isRecord(cur) && "snapshot" in cur && isRecord(cur.snapshot)) {
      cur = cur.snapshot;
    }
    return cur;
  };
  function createDefaultStats(createdAt = Date.now()) {
    const hatchedByType = {};
    for (const species of Object.keys(petCatalog)) {
      hatchedByType[species.toLowerCase()] = { normal: 0, gold: 0, rainbow: 0 };
    }
    const abilities = {};
    for (const abilityId of Object.keys(petAbilities)) {
      abilities[abilityId] = { triggers: 0, totalValue: 0 };
    }
    const weather2 = {};
    for (const key2 of Object.keys(weatherCatalog)) {
      weather2[key2.toLowerCase()] = { triggers: 0 };
    }
    return {
      createdAt,
      garden: {
        totalPlanted: 0,
        totalHarvested: 0,
        totalDestroyed: 0,
        watercanUsed: 0,
        waterTimeSavedMs: 0
      },
      shops: {
        seedsBought: 0,
        decorBought: 0,
        eggsBought: 0,
        toolsBought: 0,
        cropsSoldCount: 0,
        cropsSoldValue: 0,
        petsSoldCount: 0,
        petsSoldValue: 0
      },
      pets: { hatchedByType },
      abilities,
      weather: weather2
    };
  }
  function normalizeHatchedCounts(value, fallback) {
    if (!isRecord(value)) return { ...fallback };
    return {
      normal: toPositiveInt(value.normal, fallback.normal),
      gold: toPositiveInt(value.gold, fallback.gold),
      rainbow: toPositiveInt(value.rainbow, fallback.rainbow)
    };
  }
  function normalizeStats(raw) {
    const fallbackCreatedAt = Date.now();
    const base = createDefaultStats(fallbackCreatedAt);
    if (!isRecord(raw)) return base;
    if (Object.prototype.hasOwnProperty.call(raw, "createdAt")) {
      base.createdAt = toPositiveTimestamp(raw.createdAt, fallbackCreatedAt);
    }
    if (isRecord(raw.garden)) {
      base.garden = {
        totalPlanted: toPositiveInt(raw.garden.totalPlanted, base.garden.totalPlanted),
        totalHarvested: toPositiveInt(raw.garden.totalHarvested, base.garden.totalHarvested),
        totalDestroyed: toPositiveInt(raw.garden.totalDestroyed, base.garden.totalDestroyed),
        watercanUsed: toPositiveInt(raw.garden.watercanUsed, base.garden.watercanUsed),
        waterTimeSavedMs: toPositiveInt(raw.garden.waterTimeSavedMs, base.garden.waterTimeSavedMs)
      };
    }
    if (isRecord(raw.shops)) {
      base.shops = {
        seedsBought: toPositiveInt(raw.shops.seedsBought, base.shops.seedsBought),
        decorBought: toPositiveInt(raw.shops.decorBought, base.shops.decorBought),
        eggsBought: toPositiveInt(raw.shops.eggsBought, base.shops.eggsBought),
        toolsBought: toPositiveInt(raw.shops.toolsBought, base.shops.toolsBought),
        cropsSoldCount: toPositiveInt(raw.shops.cropsSoldCount, base.shops.cropsSoldCount),
        cropsSoldValue: toPositiveNumber(raw.shops.cropsSoldValue, base.shops.cropsSoldValue),
        petsSoldCount: toPositiveInt(raw.shops.petsSoldCount, base.shops.petsSoldCount),
        petsSoldValue: toPositiveNumber(raw.shops.petsSoldValue, base.shops.petsSoldValue)
      };
    }
    if (isRecord(raw.pets) && isRecord(raw.pets.hatchedByType)) {
      for (const [key2, counts] of Object.entries(raw.pets.hatchedByType)) {
        if (typeof key2 !== "string") continue;
        const normalizedKey = key2.toLowerCase();
        const fallback = base.pets.hatchedByType[normalizedKey] ?? { normal: 0, gold: 0, rainbow: 0 };
        base.pets.hatchedByType[normalizedKey] = normalizeHatchedCounts(counts, fallback);
      }
    }
    if (isRecord(raw.abilities)) {
      for (const [key2, value] of Object.entries(raw.abilities)) {
        if (typeof key2 !== "string" || !isRecord(value)) continue;
        base.abilities[key2] = {
          triggers: toPositiveInt(value.triggers, base.abilities[key2]?.triggers ?? 0),
          totalValue: toPositiveNumber(value.totalValue, base.abilities[key2]?.totalValue ?? 0)
        };
      }
    }
    if (isRecord(raw.weather)) {
      for (const [key2, value] of Object.entries(raw.weather)) {
        if (typeof key2 !== "string" || !isRecord(value)) continue;
        const normalizedKey = key2.toLowerCase();
        const fallback = base.weather[normalizedKey] ?? { triggers: 0 };
        base.weather[normalizedKey] = {
          triggers: toPositiveInt(value.triggers, fallback.triggers)
        };
      }
    }
    return base;
  }
  function readFromStorage() {
    if (memoryStore) return cloneStats(memoryStore);
    const rawWrapped = readAriesPath("stats");
    const raw = unwrapMaybeNestedSnapshot(rawWrapped);
    if (!raw) {
      const fresh = createDefaultStats();
      memoryStore = cloneStats(fresh);
      writeAriesPath("stats", memoryStore);
      return fresh;
    }
    const normalized = normalizeStats(raw);
    memoryStore = cloneStats(normalized);
    if (rawWrapped !== raw) {
      writeAriesPath("stats", memoryStore);
    }
    return normalized;
  }
  function emitUpdate(stats) {
    const snapshot = cloneStats(stats);
    for (const listener of listeners) {
      try {
        listener(snapshot);
      } catch (error) {
        console.error("[StatsService] Listener error", error);
      }
    }
  }
  function writeToStorage(stats) {
    const snapshot = cloneStats(stats);
    memoryStore = snapshot;
    writeAriesPath("stats", snapshot);
    return snapshot;
  }
  function adjustValue(current, delta, integer) {
    const a = Number(current);
    const b = Number(delta);
    const sum = Number.isFinite(a) ? a : 0;
    const next = sum + (Number.isFinite(b) ? b : 0);
    const clamped = Math.max(0, next);
    return integer ? Math.floor(clamped) : clamped;
  }
  function updateStats(mutator) {
    const current = readFromStorage();
    const before = JSON.stringify(current);
    const draft = cloneStats(current);
    mutator(draft);
    const after = JSON.stringify(draft);
    if (before === after) return current;
    const stored = writeToStorage(draft);
    emitUpdate(stored);
    return stored;
  }
  function requireAbilityEntry(stats, abilityId) {
    if (!stats.abilities[abilityId]) {
      stats.abilities[abilityId] = { triggers: 0, totalValue: 0 };
    }
    return stats.abilities[abilityId];
  }
  function requireWeatherEntry(stats, weatherId) {
    const key2 = weatherId.toLowerCase();
    if (!stats.weather[key2]) {
      stats.weather[key2] = { triggers: 0 };
    }
    return stats.weather[key2];
  }
  function requirePetEntry(stats, species) {
    const key2 = species.toLowerCase();
    if (!stats.pets.hatchedByType[key2]) {
      stats.pets.hatchedByType[key2] = { normal: 0, gold: 0, rainbow: 0 };
    }
    return stats.pets.hatchedByType[key2];
  }
  var StatsService = {
    storageKey: "stats",
    getSnapshot() {
      return readFromStorage();
    },
    setSnapshot(snapshot) {
      const normalized = normalizeStats(unwrapMaybeNestedSnapshot(snapshot));
      const stored = writeToStorage(normalized);
      emitUpdate(stored);
      return stored;
    },
    reset() {
      const fresh = createDefaultStats();
      const stored = writeToStorage(fresh);
      emitUpdate(stored);
      return stored;
    },
    update(mutator) {
      return updateStats(mutator);
    },
    incrementGardenStat(key2, amount = 1) {
      return updateStats((draft) => {
        draft.garden[key2] = adjustValue(draft.garden[key2], amount, GARDEN_INT_KEYS[key2]);
      });
    },
    incrementShopStat(key2, amount = 1) {
      return updateStats((draft) => {
        draft.shops[key2] = adjustValue(draft.shops[key2], amount, SHOP_INT_KEYS[key2]);
      });
    },
    incrementPetHatched(species, rarityKey = "normal", amount = 1) {
      return updateStats((draft) => {
        const entry = requirePetEntry(draft, species);
        entry[rarityKey] = adjustValue(entry[rarityKey], amount, true);
      });
    },
    incrementAbilityStat(abilityId, key2, amount = 1) {
      return updateStats((draft) => {
        const entry = requireAbilityEntry(draft, abilityId);
        entry[key2] = adjustValue(entry[key2], amount, ABILITY_INT_KEYS[key2]);
      });
    },
    incrementWeatherStat(weatherId, key2 = "triggers", amount = 1) {
      return updateStats((draft) => {
        const entry = requireWeatherEntry(draft, weatherId);
        entry[key2] = adjustValue(entry[key2], amount, WEATHER_INT_KEYS[key2]);
      });
    },
    subscribe(listener) {
      listeners.add(listener);
      return () => {
        listeners.delete(listener);
      };
    }
  };
  var StatsDefaults = {
    rarityOrder: [
      rarity.Common,
      rarity.Uncommon,
      rarity.Rare,
      rarity.Legendary,
      rarity.Mythic,
      rarity.Divine,
      rarity.Celestial
    ],
    createEmpty() {
      return createDefaultStats();
    }
  };

  // src/services/lockerRestrictions.ts
  var ARIES_LOCKER_RESTRICTIONS_PATH = "locker.restrictions";
  var clampPercent2 = (value) => Math.max(0, Math.min(50, Math.round(value)));
  var roundToStep = (value, step) => Math.round(value / step) * step;
  var DEFAULT_SELL_ALL_PETS_RULES = {
    enabled: true,
    protectGold: true,
    protectRainbow: true,
    protectMaxStr: true,
    maxStrThreshold: 95
  };
  var DEFAULT_STATE = {
    minRequiredPlayers: 1,
    eggLocks: {},
    decorPickupLocked: false,
    sellAllPets: { ...DEFAULT_SELL_ALL_PETS_RULES }
  };
  var FRIEND_BONUS_STEP = 10;
  var FRIEND_BONUS_MAX = 50;
  var sanitizePercent = (value) => {
    const clamped = clampPercent2(value);
    return Math.max(0, Math.min(FRIEND_BONUS_MAX, roundToStep(clamped, FRIEND_BONUS_STEP)));
  };
  var sanitizePlayers = (value) => {
    if (!Number.isFinite(value)) return 1;
    return Math.max(1, Math.min(6, Math.round(value)));
  };
  var sanitizeEggLocks = (raw) => {
    const out = {};
    if (!raw || typeof raw !== "object") return out;
    for (const [key2, value] of Object.entries(raw)) {
      if (!key2) continue;
      out[key2] = value === true;
    }
    return out;
  };
  var sanitizeSellAllPetsRules = (raw) => {
    if (!raw || typeof raw !== "object") return { ...DEFAULT_SELL_ALL_PETS_RULES };
    const maxStrRaw = Number(raw.maxStrThreshold);
    const maxStrThreshold = Number.isFinite(maxStrRaw) ? Math.max(0, Math.min(100, Math.round(maxStrRaw))) : DEFAULT_SELL_ALL_PETS_RULES.maxStrThreshold;
    return {
      enabled: raw.enabled !== false,
      protectGold: raw.protectGold !== false,
      protectRainbow: raw.protectRainbow !== false,
      protectMaxStr: raw.protectMaxStr !== false,
      maxStrThreshold
    };
  };
  function friendBonusPercentFromMultiplier(raw) {
    const n = Number(raw);
    if (!Number.isFinite(n)) return null;
    if (n <= 0) return 0;
    if (n > 0 && n <= 2) {
      return clampPercent2(Math.round((n - 1) * 100));
    }
    const clamped = Math.max(1, Math.min(6, Math.round(n)));
    return clampPercent2((clamped - 1) * 10);
  }
  function friendBonusPercentFromPlayers(raw) {
    const n = Number(raw);
    if (!Number.isFinite(n)) return null;
    const clamped = Math.max(1, Math.min(6, Math.round(n)));
    return clampPercent2((clamped - 1) * 10);
  }
  function percentToRequiredFriendCount(percent) {
    const pct = sanitizePercent(percent);
    return Math.max(1, Math.min(6, Math.round(pct / 10) + 1));
  }
  var requiredPercentFromPlayers = (players) => sanitizePercent((sanitizePlayers(players) - 1) * 10);
  var LockerRestrictionsService = class {
    constructor() {
      __publicField(this, "state", { ...DEFAULT_STATE });
      __publicField(this, "listeners", /* @__PURE__ */ new Set());
      this.load();
    }
    load() {
      if (typeof window === "undefined") {
        this.state = { ...DEFAULT_STATE };
        return;
      }
      try {
        const parsed = readAriesPath(ARIES_LOCKER_RESTRICTIONS_PATH) ?? {};
        const players = sanitizePlayers(Number(parsed?.minRequiredPlayers ?? parsed?.minFriendBonusPct));
        const eggLocks = sanitizeEggLocks(parsed?.eggLocks);
        const decorPickupLocked = parsed?.decorPickupLocked === true;
        const sellAllPets = sanitizeSellAllPetsRules(parsed?.sellAllPets);
        this.state = { minRequiredPlayers: players, eggLocks, decorPickupLocked, sellAllPets };
      } catch {
        this.state = { ...DEFAULT_STATE };
      }
    }
    save() {
      if (typeof window === "undefined") return;
      try {
        writeAriesPath(ARIES_LOCKER_RESTRICTIONS_PATH, this.state);
      } catch {
      }
    }
    emit() {
      for (const listener of this.listeners) {
        try {
          listener(this.getState());
        } catch {
        }
      }
    }
    getState() {
      return { ...this.state };
    }
    getSellAllPetsRules() {
      return { ...this.state.sellAllPets ?? DEFAULT_SELL_ALL_PETS_RULES };
    }
    setSellAllPetsRules(next) {
      const current = this.getSellAllPetsRules();
      const merged = { ...current, ...next };
      const sanitized = sanitizeSellAllPetsRules(merged);
      const prev = this.state.sellAllPets;
      const same = prev?.enabled === sanitized.enabled && prev?.protectGold === sanitized.protectGold && prev?.protectRainbow === sanitized.protectRainbow && prev?.protectMaxStr === sanitized.protectMaxStr && prev?.maxStrThreshold === sanitized.maxStrThreshold;
      if (same) return;
      this.state = { ...this.state, sellAllPets: sanitized };
      this.save();
      this.emit();
    }
    setMinRequiredPlayers(value) {
      const players = sanitizePlayers(value);
      if (players === this.state.minRequiredPlayers) return;
      this.state = { ...this.state, minRequiredPlayers: players };
      this.save();
      this.emit();
    }
    setEggLock(eggId, locked) {
      if (!eggId) return;
      const nextLocks = { ...this.state.eggLocks, [eggId]: !!locked };
      this.state = { ...this.state, eggLocks: nextLocks };
      this.save();
      this.emit();
    }
    setDecorPickupLocked(locked) {
      if (!!locked === this.state.decorPickupLocked) return;
      this.state = { ...this.state, decorPickupLocked: !!locked };
      this.save();
      this.emit();
    }
    isEggLocked(eggId) {
      if (!eggId) return false;
      return this.state.eggLocks?.[eggId] === true;
    }
    allowsCropSale(currentFriendBonusPercent) {
      const required = requiredPercentFromPlayers(this.state.minRequiredPlayers);
      if (required <= 0) return true;
      if (!Number.isFinite(currentFriendBonusPercent)) return false;
      const current = clampPercent2(Number(currentFriendBonusPercent));
      return current + 1e-4 >= required;
    }
    getRequiredPercent() {
      return requiredPercentFromPlayers(this.state.minRequiredPlayers);
    }
    isDecorPickupLocked() {
      return this.state.decorPickupLocked === true;
    }
    subscribe(listener) {
      this.listeners.add(listener);
      return () => this.listeners.delete(listener);
    }
  };
  var lockerRestrictionsService = new LockerRestrictionsService();

  // src/ui/toast.ts
  init_jotai();
  async function sendToast(toast2) {
    const sendAtom = getAtomByLabel("sendQuinoaToastAtom");
    if (sendAtom) {
      await jSet(sendAtom, toast2);
      return;
    }
    const listAtom = getAtomByLabel("quinoaToastsAtom");
    if (!listAtom) throw new Error("Aucun atom de toast trouv\xE9");
    const prev = await jGet(listAtom).catch(() => []);
    const t = { isClosable: true, duration: 1e4, ...toast2 };
    if ("toastType" in t && t.toastType === "board") {
      t.id = t.id ?? (t.isStackable ? `quinoa-stackable-${Date.now()}-${Math.random()}` : "quinoa-game-toast");
    } else {
      t.id = t.id ?? "quinoa-game-toast";
    }
    await jSet(listAtom, [...prev, t]);
  }
  async function toastSimple(title, description, variant = "info", duration = 3500) {
    await sendToast({ title, description, variant, duration });
  }

  // src/hooks/ws-hook.ts
  init_jotai();

  // src/utils/api.ts
  function detectEnvironment() {
    const isInIframe = (() => {
      try {
        return window.top !== window.self;
      } catch {
        return true;
      }
    })();
    const refHost = safeHost(document.referrer);
    const parentLooksDiscord = isInIframe && !!refHost && /(^|\.)discord(app)?\.com$/i.test(refHost);
    const host = location.hostname;
    const surface = parentLooksDiscord ? "discord" : "web";
    const platform = /Android|iPhone|iPad|Mobile/i.test(navigator.userAgent) ? "mobile" : "desktop";
    return {
      surface,
      host,
      origin: location.origin,
      isInIframe,
      platform
    };
  }
  function isDiscordSurface() {
    return detectEnvironment().surface === "discord";
  }
  function safeHost(url) {
    if (!url) return null;
    try {
      return new URL(url).hostname;
    } catch {
      return null;
    }
  }

  // src/core/webSocketBridge.ts
  function postAllToWorkers(msg) {
    if (Workers.forEach) Workers.forEach((w) => {
      try {
        w.postMessage(msg);
      } catch {
      }
    });
    else for (const w of Workers._a) {
      try {
        w.postMessage(msg);
      } catch {
      }
    }
  }
  function getPageWS() {
    if (quinoaWS && quinoaWS.readyState === NativeWS.OPEN) return quinoaWS;
    let any = null;
    if (sockets.find) any = sockets.find((s) => s.readyState === NativeWS.OPEN) || null;
    if (!any) {
      for (let i = 0; i < sockets.length; i++) if (sockets[i].readyState === NativeWS.OPEN) {
        any = sockets[i];
        break;
      }
    }
    if (any) {
      setQWS(any, "getPageWS");
      return any;
    }
    throw new Error("No page WebSocket open");
  }
  function sendToGame(payloadObj) {
    const msg = { scopePath: ["Room", "Quinoa"], ...payloadObj };
    try {
      const ws = getPageWS();
      ws.send(JSON.stringify(msg));
      return true;
    } catch {
      postAllToWorkers({ __QWS_CMD: "send", payload: JSON.stringify(msg) });
      return true;
    }
  }

  // src/services/player.ts
  init_atoms();
  function slotSig2(o) {
    if (!o) return "\u2205";
    return [
      o.objectType ?? o.type ?? "",
      o.species ?? o.seedSpecies ?? o.plantSpecies ?? o.eggId ?? o.decorId ?? "",
      o.plantedAt ?? o.startTime ?? 0,
      o.maturedAt ?? o.endTime ?? 0
    ].join("|");
  }
  function diffGarden(prev, next) {
    const p = prev?.tileObjects ?? {};
    const n = next?.tileObjects ?? {};
    const added = [];
    const updated = [];
    const removed = [];
    const changes = [];
    const seen = /* @__PURE__ */ new Set();
    for (const k of Object.keys(n)) {
      seen.add(k);
      if (!(k in p)) {
        added.push(+k);
        changes.push({ kind: "added", slot: +k, next: n[k] });
      } else if (slotSig2(p[k]) !== slotSig2(n[k])) {
        updated.push(+k);
        changes.push({ kind: "updated", slot: +k, prev: p[k], next: n[k] });
      }
    }
    for (const k of Object.keys(p)) {
      if (!seen.has(k)) {
        removed.push(+k);
        changes.push({ kind: "removed", slot: +k, prev: p[k] });
      }
    }
    return { added, updated, removed, changes };
  }
  function petSig(p) {
    const s = p?.slot ?? {};
    const muts = Array.isArray(s.mutations) ? s.mutations.slice().sort().join(",") : "";
    const ab = Array.isArray(s.abilities) ? s.abilities.slice().sort().join(",") : "";
    const name = s.name ?? "";
    const species = s.petSpecies ?? "";
    const xp = Number.isFinite(s.xp) ? Math.round(s.xp) : 0;
    const hunger = Number.isFinite(s.hunger) ? Math.round(s.hunger * 1e3) : 0;
    const scale = Number.isFinite(s.targetScale) ? Math.round(s.targetScale * 1e3) : 0;
    const x = Number.isFinite(p?.position?.x) ? Math.round(p.position.x) : 0;
    const y = Number.isFinite(p?.position?.y) ? Math.round(p.position.y) : 0;
    return `${species}|${name}|xp:${xp}|hg:${hunger}|sc:${scale}|m:${muts}|a:${ab}|pos:${x},${y}`;
  }
  function snapshotPets(state3) {
    const snap = /* @__PURE__ */ new Map();
    const arr = Array.isArray(state3) ? state3 : [];
    for (const it of arr) {
      const id = String(it?.slot?.id ?? "");
      if (!id) continue;
      snap.set(id, petSig(it));
    }
    return snap;
  }
  function diffPetsSnapshot(prev, next) {
    const added = [];
    const updated = [];
    const removed = [];
    const changes = [];
    for (const [id, sig] of next) {
      if (!prev.has(id)) {
        added.push(id);
        changes.push({ kind: "added", id });
      } else if (prev.get(id) !== sig) {
        updated.push(id);
        changes.push({ kind: "updated", id });
      }
    }
    for (const id of prev.keys()) {
      if (!next.has(id)) {
        removed.push(id);
        changes.push({ kind: "removed", id });
      }
    }
    return { added, updated, removed, changes };
  }
  function cropSig(it) {
    const muts = Array.isArray(it.mutations) ? it.mutations.slice().sort().join(",") : "";
    const scale = Number.isFinite(it.scale) ? Math.round(it.scale * 1e3) : 0;
    return `${it.species ?? ""}|${it.itemType ?? ""}|${scale}|${muts}`;
  }
  function snapshotInventory(inv) {
    const snap = /* @__PURE__ */ new Map();
    const arr = Array.isArray(inv) ? inv : [];
    for (const it of arr) {
      const id = String(it?.id ?? "");
      if (!id) continue;
      snap.set(id, cropSig(it));
    }
    return snap;
  }
  function diffCropInventorySnapshot(prev, next) {
    const added = [];
    const updated = [];
    const removed = [];
    const changes = [];
    for (const [id, sig] of next) {
      if (!prev.has(id)) {
        added.push(id);
        changes.push({ kind: "added", key: id });
      } else if (prev.get(id) !== sig) {
        updated.push(id);
        changes.push({ kind: "updated", key: id });
      }
    }
    for (const id of prev.keys()) {
      if (!next.has(id)) {
        removed.push(id);
        changes.push({ kind: "removed", key: id });
      }
    }
    return { added, updated, removed, changes };
  }
  var PlayerService = {
    /* ------------------------- Position / Dplacement ------------------------- */
    getPosition() {
      return Atoms.player.position.get();
    },
    onPosition(cb) {
      return Atoms.player.position.onChange(cb);
    },
    onPositionNow(cb) {
      return Atoms.player.position.onChangeNow(cb);
    },
    async setPosition(x, y) {
      await Atoms.player.position.set({ x, y });
    },
    async teleport(x, y) {
      try {
        await this.setPosition(x, y);
      } catch (err) {
      }
      try {
        sendToGame({ type: "Teleport", position: { x, y } });
      } catch (err) {
      }
    },
    async move(x, y) {
      try {
        await this.setPosition(x, y);
      } catch (err) {
      }
      try {
        sendToGame({ type: "PlayerPosition", position: { x, y } });
      } catch (err) {
      }
    },
    /* ------------------------------ Actions jeu ------------------------------ */
    async plantSeed(slot, species) {
      try {
        sendToGame({ type: "PlantSeed", slot, species });
      } catch (err) {
      }
    },
    async logItems() {
      try {
        sendToGame({ type: "LogItems" });
      } catch (err) {
      }
    },
    async sellAllCrops() {
      try {
        sendToGame({ type: "SellAllCrops" });
      } catch (err) {
      }
    },
    async sellPet(itemId) {
      try {
        sendToGame({ type: "SellPet", itemId });
      } catch (err) {
      }
    },
    async removeGardenObject(slot, slotType) {
      try {
        sendToGame({ type: "RemoveGardenObject", slot, slotType });
      } catch (err) {
      }
    },
    async waterPlant(slot) {
      try {
        sendToGame({ type: "WaterPlant", slot });
      } catch (err) {
      }
    },
    async setSelectedItem(itemIndex) {
      try {
        sendToGame({ type: "SetSelectedItem", itemIndex });
      } catch (err) {
      }
    },
    async pickupObject() {
      try {
        sendToGame({ type: "PickupObject" });
      } catch (err) {
      }
    },
    async dropObject() {
      try {
        sendToGame({ type: "DropObject" });
      } catch (err) {
      }
    },
    async harvestCrop(slot, slotsIndex) {
      try {
        sendToGame({ type: "HarvestCrop", slot, slotsIndex });
      } catch (err) {
      }
    },
    async feedPet(petItemId, cropItemId) {
      try {
        sendToGame({ type: "FeedPet", petItemId, cropItemId });
      } catch (err) {
      }
    },
    async hatchEgg(slot) {
      try {
        sendToGame({ type: "HatchEgg", slot });
      } catch (err) {
      }
    },
    async placeDecor(tileType, localTileIndex, decorId, rotation) {
      try {
        sendToGame({ type: "PlaceDecor", tileType, localTileIndex, decorId, rotation });
      } catch (err) {
      }
    },
    async swapPet(petSlotId, petInventoryId) {
      try {
        sendToGame({ type: "SwapPet", petSlotId, petInventoryId });
      } catch (err) {
      }
    },
    async placePet(itemId, position2, tileType, localTileIndex) {
      try {
        sendToGame({ type: "PlacePet", itemId, position: position2, tileType, localTileIndex });
      } catch (err) {
      }
    },
    async retrieveItemFromStorage(itemId, storageId) {
      try {
        sendToGame({ type: "RetrieveItemFromStorage", itemId, storageId });
      } catch (err) {
      }
    },
    async putItemInStorage(itemId, storageId) {
      try {
        sendToGame({ type: "PutItemInStorage", itemId, storageId });
      } catch (err) {
      }
    },
    async petPositions(petPositions) {
      const entries = Object.entries(petPositions ?? {});
      if (!entries.length) {
        return;
      }
      const sanitized = {};
      for (const [id, pos] of entries) {
        const x = Number(pos?.x);
        const y = Number(pos?.y);
        if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
        sanitized[String(id)] = { x, y };
      }
      const validCount = Object.keys(sanitized).length;
      if (!validCount) {
        return;
      }
      try {
        sendToGame({ type: "PetPositions", petPositions: sanitized });
      } catch (err) {
      }
    },
    async storePet(itemId) {
      try {
        sendToGame({ type: "StorePet", itemId });
      } catch (err) {
      }
    },
    async wish(itemId) {
      try {
        sendToGame({ type: "Wish", itemId });
      } catch (err) {
      }
    },
    async purchaseSeed(species) {
      try {
        sendToGame({ type: "PurchaseSeed", species });
      } catch (err) {
      }
    },
    async purchaseDecor(decorId) {
      try {
        sendToGame({ type: "PurchaseDecor", decorId });
      } catch (err) {
      }
    },
    async purchaseEgg(eggId) {
      try {
        sendToGame({ type: "PurchaseEgg", eggId });
      } catch (err) {
      }
    },
    async purchaseTool(toolId) {
      try {
        sendToGame({ type: "PurchaseTool", toolId });
      } catch (err) {
      }
    },
    async triggerAnimation(playerId2, animation) {
      Atoms.player.avatarTriggerAnimationAtom.set({ playerId: playerId2, animation });
    },
    /* -------------------------------- Favorites ------------------------------ */
    async toggleFavoriteItem(itemId) {
      try {
        sendToGame({ type: "ToggleFavoriteItem", itemId });
      } catch (err) {
      }
    },
    async getFavoriteIds() {
      const ids = await Atoms.inventory.favoriteIds.get();
      return Array.isArray(ids) ? ids.slice() : [];
    },
    async getFavoriteIdSet() {
      return getFavoriteIdSet();
    },
    async isFavoriteItem(itemId) {
      const set3 = await getFavoriteIdSet();
      return set3.has(itemId);
    },
    async ensureFavoriteItem(itemId, shouldBeFavorite) {
      const cur = await this.isFavoriteItem(itemId);
      if (cur !== shouldBeFavorite) {
        await this.toggleFavoriteItem(itemId);
        return shouldBeFavorite;
      }
      return cur;
    },
    async ensureFavorites(items, shouldBeFavorite) {
      const set3 = await getFavoriteIdSet();
      for (const id of items) {
        const cur = set3.has(id);
        if (cur !== shouldBeFavorite) {
          try {
            await this.toggleFavoriteItem(id);
          } catch {
          }
        }
      }
    },
    onFavoriteIdsChange(cb) {
      return onFavoriteIds((ids) => cb(Array.isArray(ids) ? ids : []));
    },
    async onFavoriteIdsChangeNow(cb) {
      return onFavoriteIdsNow((ids) => cb(Array.isArray(ids) ? ids : []));
    },
    onFavoriteSetChange(cb) {
      return onFavoriteIds((ids) => cb(new Set(Array.isArray(ids) ? ids : [])));
    },
    async onFavoriteSetChangeNow(cb) {
      const cur = await getFavoriteIdSet();
      cb(cur);
      return onFavoriteIds((ids) => cb(new Set(Array.isArray(ids) ? ids : [])));
    },
    /* --------------------------------- Garden -------------------------------- */
    async getGardenState() {
      return await Atoms.data.garden.get() ?? null;
    },
    onGardenChange(cb) {
      return Atoms.data.garden.onChange(cb);
    },
    onGardenChangeNow(cb) {
      return Atoms.data.garden.onChangeNow(cb);
    },
    onGardenDiff(cb) {
      let prev = null;
      return Atoms.data.garden.onChange((g) => {
        const d = diffGarden(prev, g);
        if (d.added.length || d.updated.length || d.removed.length || g !== prev) {
          prev = g;
          cb(g, d);
        }
      });
    },
    async onGardenDiffNow(cb) {
      let prev = await Atoms.data.garden.get() ?? null;
      cb(prev, diffGarden(null, prev));
      return Atoms.data.garden.onChange((next) => {
        const d = diffGarden(prev, next);
        if (d.added.length || d.updated.length || d.removed.length) {
          prev = next;
          cb(next, d);
        }
      });
    },
    /* ------------------------------------ Pets ------------------------------------ */
    async getPets() {
      const arr = await Atoms.pets.myPetInfos.get();
      return Array.isArray(arr) ? arr : null;
    },
    onPetsChange(cb) {
      let prev = null;
      return Atoms.pets.myPetInfos.onChange((next) => {
        if (next !== prev) {
          prev = next;
          cb(prev);
        }
      });
    },
    async onPetsChangeNow(cb) {
      let prev = await this.getPets();
      cb(prev);
      return Atoms.pets.myPetInfos.onChange((next) => {
        if (next !== prev) {
          prev = next;
          cb(prev);
        }
      });
    },
    onPetsDiff(cb) {
      let prevSnap = snapshotPets(null);
      return Atoms.pets.myPetInfos.onChange((state3) => {
        const nextSnap = snapshotPets(state3);
        const d = diffPetsSnapshot(prevSnap, nextSnap);
        if (d.added.length || d.updated.length || d.removed.length) {
          cb(state3, d);
          prevSnap = nextSnap;
        }
      });
    },
    async onPetsDiffNow(cb) {
      let cur = await this.getPets();
      let prevSnap = snapshotPets(null);
      let nextSnap = snapshotPets(cur);
      const first = diffPetsSnapshot(prevSnap, nextSnap);
      cb(cur, first);
      prevSnap = nextSnap;
      return Atoms.pets.myPetInfos.onChange((state3) => {
        nextSnap = snapshotPets(state3);
        const d = diffPetsSnapshot(prevSnap, nextSnap);
        if (d.added.length || d.updated.length || d.removed.length) {
          cb(state3, d);
          prevSnap = nextSnap;
        }
      });
    },
    /* ------------------------- Crop Inventory (crops) ------------------------- */
    async getCropInventoryState() {
      return Atoms.inventory.myCropInventory.get();
    },
    onCropInventoryChange(cb) {
      let prev = null;
      return Atoms.inventory.myCropInventory.onChange((inv) => {
        if (inv !== prev) {
          prev = inv;
          cb(inv);
        }
      });
    },
    async onCropInventoryChangeNow(cb) {
      let prev = await Atoms.inventory.myCropInventory.get();
      cb(prev);
      return Atoms.inventory.myCropInventory.onChange((inv) => {
        if (inv !== prev) {
          prev = inv;
          cb(inv);
        }
      });
    },
    onCropInventoryDiff(cb) {
      let prevSnap = snapshotInventory(null);
      return Atoms.inventory.myCropInventory.onChange((inv) => {
        const nextSnap = snapshotInventory(inv);
        const d = diffCropInventorySnapshot(prevSnap, nextSnap);
        if (d.added.length || d.updated.length || d.removed.length) {
          cb(inv, d);
          prevSnap = nextSnap;
        }
      });
    },
    async onCropInventoryDiffNow(cb) {
      let cur = await Atoms.inventory.myCropInventory.get();
      let prevSnap = snapshotInventory(null);
      let nextSnap = snapshotInventory(cur);
      const firstDiff = diffCropInventorySnapshot(prevSnap, nextSnap);
      cb(cur, firstDiff);
      prevSnap = nextSnap;
      return Atoms.inventory.myCropInventory.onChange((inv) => {
        nextSnap = snapshotInventory(inv);
        const d = diffCropInventorySnapshot(prevSnap, nextSnap);
        if (d.added.length || d.updated.length || d.removed.length) {
          cb(inv, d);
          prevSnap = nextSnap;
        }
      });
    },
    /* --------------------------- Players in room --------------------------- */
    async getNumPlayers() {
      const n = await Atoms.server.numPlayers.get();
      return typeof n === "number" ? n : 0;
    },
    onNumPlayersChange(cb) {
      let prev = void 0;
      return Atoms.server.numPlayers.onChange((n) => {
        if (n !== prev) {
          prev = n;
          cb(n);
        }
      });
    },
    async onNumPlayersChangeNow(cb) {
      let prev = await this.getNumPlayers();
      cb(prev);
      return Atoms.server.numPlayers.onChange((n) => {
        if (n !== prev) {
          prev = n;
          cb(n);
        }
      });
    }
  };

  // src/services/misc.ts
  init_atoms();
  init_fakeModal();
  var PATH_GHOST_MODE = "misc.ghostMode";
  var PATH_GHOST_DELAY = "misc.ghostDelayMs";
  var DEFAULT_DELAY_MS = 50;
  var PATH_AUTO_RECO_ENABLED = "misc.autoRecoEnabled";
  var PATH_AUTO_RECO_DELAY = "misc.autoRecoDelayMs";
  var AUTO_RECO_MIN_MS = 0;
  var AUTO_RECO_MAX_MS = 5 * 6e4;
  var AUTO_RECO_DEFAULT_MS = 6e4;
  var PATH_KEEP_INVENTORY_SLOT_FREE = "misc.keepInventorySlotFree";
  var PATH_AUTO_STORE_SEED_SILO_ENABLED = "misc.autoStoreSeedSiloEnabled";
  var PATH_AUTO_STORE_DECOR_SHED_ENABLED = "misc.autoStoreDecorShedEnabled";
  var readGhostEnabled = (def = false) => {
    try {
      const stored = readAriesPath(PATH_GHOST_MODE);
      if (typeof stored === "boolean") return stored;
      if (stored === "1" || stored === 1) return true;
      if (stored === "0" || stored === 0) return false;
      return !!stored;
    } catch {
      return def;
    }
  };
  var writeGhostEnabled = (v) => {
    try {
      writeAriesPath(PATH_GHOST_MODE, !!v);
    } catch (err) {
    }
  };
  var getGhostDelayMs = () => {
    try {
      const stored = readAriesPath(PATH_GHOST_DELAY);
      const n = Math.floor(Number(stored || DEFAULT_DELAY_MS));
      return Math.max(5, n);
    } catch {
      return DEFAULT_DELAY_MS;
    }
  };
  var setGhostDelayMs = (n) => {
    const v = Math.max(5, Math.floor(n || DEFAULT_DELAY_MS));
    try {
      writeAriesPath(PATH_GHOST_DELAY, v);
    } catch (err) {
    }
  };
  var clampAutoRecoDelay = (ms) => {
    const safeMs = Number.isFinite(ms) ? Math.floor(ms) : AUTO_RECO_DEFAULT_MS;
    return Math.min(AUTO_RECO_MAX_MS, Math.max(AUTO_RECO_MIN_MS, safeMs));
  };
  var readAutoRecoEnabled = (def = false) => {
    try {
      const stored = readAriesPath(PATH_AUTO_RECO_ENABLED);
      if (typeof stored === "boolean") return stored;
      if (stored === "1" || stored === 1) return true;
      if (stored === "0" || stored === 0) return false;
      return !!stored;
    } catch {
      return def;
    }
  };
  var writeAutoRecoEnabled = (on) => {
    try {
      writeAriesPath(PATH_AUTO_RECO_ENABLED, !!on);
    } catch {
    }
  };
  var getAutoRecoDelayMs = () => {
    try {
      const raw = Number(readAriesPath(PATH_AUTO_RECO_DELAY));
      if (Number.isFinite(raw)) return clampAutoRecoDelay(raw);
    } catch {
    }
    return AUTO_RECO_DEFAULT_MS;
  };
  var setAutoRecoDelayMs = (ms) => {
    const v = clampAutoRecoDelay(ms);
    try {
      writeAriesPath(PATH_AUTO_RECO_DELAY, v);
    } catch {
    }
  };
  var readInventorySlotReserveEnabled = (def = false) => {
    try {
      const stored = readAriesPath(PATH_KEEP_INVENTORY_SLOT_FREE);
      if (typeof stored === "boolean") return stored;
      if (stored === "1" || stored === 1) return true;
      if (stored === "0" || stored === 0) return false;
      return !!stored;
    } catch {
      return def;
    }
  };
  var writeInventorySlotReserveEnabled = (on) => {
    try {
      writeAriesPath(PATH_KEEP_INVENTORY_SLOT_FREE, !!on);
    } catch {
    }
  };
  var readAutoStoreSeedSiloEnabled = (def = false) => {
    try {
      const stored = readAriesPath(PATH_AUTO_STORE_SEED_SILO_ENABLED);
      if (typeof stored === "boolean") return stored;
      if (stored === "1" || stored === 1) return true;
      if (stored === "0" || stored === 0) return false;
      return !!stored;
    } catch {
      return def;
    }
  };
  var readAutoStoreDecorShedEnabled = (def = false) => {
    try {
      const stored = readAriesPath(PATH_AUTO_STORE_DECOR_SHED_ENABLED);
      if (typeof stored === "boolean") return stored;
      if (stored === "1" || stored === 1) return true;
      if (stored === "0" || stored === 0) return false;
      return !!stored;
    } catch {
      return def;
    }
  };
  function createGhostController() {
    let DELAY_MS = getGhostDelayMs();
    const KEYS = /* @__PURE__ */ new Set();
    const onKeyDownCapture = (e) => {
      const k = e.key.toLowerCase();
      const isMove = k === "z" || k === "q" || k === "s" || k === "d" || k === "w" || k === "a" || e.key === "ArrowUp" || e.key === "ArrowDown" || e.key === "ArrowLeft" || e.key === "ArrowRight";
      if (!isMove) return;
      e.preventDefault();
      e.stopImmediatePropagation();
      if (e.repeat) return;
      KEYS.add(k);
    };
    const onKeyUpCapture = (e) => {
      const k = e.key.toLowerCase();
      const isMove = k === "z" || k === "q" || k === "s" || k === "d" || k === "w" || k === "a" || e.key === "ArrowUp" || e.key === "ArrowDown" || e.key === "ArrowLeft" || e.key === "ArrowRight";
      if (!isMove) return;
      e.preventDefault();
      e.stopImmediatePropagation();
      KEYS.delete(k);
    };
    const onBlur = () => {
      KEYS.clear();
    };
    const onVisibility = () => {
      if (document.hidden) KEYS.clear();
    };
    function getDir() {
      let dx = 0, dy = 0;
      if (KEYS.has("z") || KEYS.has("w") || KEYS.has("arrowup")) dy -= 1;
      if (KEYS.has("s") || KEYS.has("arrowdown")) dy += 1;
      if (KEYS.has("q") || KEYS.has("a") || KEYS.has("arrowleft")) dx -= 1;
      if (KEYS.has("d") || KEYS.has("arrowright")) dx += 1;
      if (dx) dx = dx > 0 ? 1 : -1;
      if (dy) dy = dy > 0 ? 1 : -1;
      return { dx, dy };
    }
    let rafId = null;
    let lastTs = 0, accMs = 0, inMove = false;
    async function step(dx, dy) {
      let cur;
      try {
        cur = await PlayerService.getPosition();
      } catch (err) {
      }
      const cx = Math.round(cur?.x ?? 0), cy = Math.round(cur?.y ?? 0);
      try {
        await PlayerService.move(cx + dx, cy + dy);
      } catch (err) {
      }
    }
    const CAPTURE = { capture: true };
    function frame(ts) {
      if (!lastTs) lastTs = ts;
      const dt = ts - lastTs;
      lastTs = ts;
      const { dx, dy } = getDir();
      accMs += dt;
      if (dx === 0 && dy === 0) {
        accMs = Math.min(accMs, DELAY_MS * 4);
        rafId = requestAnimationFrame(frame);
        return;
      }
      if (accMs >= DELAY_MS && !inMove) {
        accMs -= DELAY_MS;
        inMove = true;
        (async () => {
          try {
            await step(dx, dy);
          } finally {
            inMove = false;
          }
        })();
      }
      accMs = Math.min(accMs, DELAY_MS * 4);
      rafId = requestAnimationFrame(frame);
    }
    return {
      start() {
        if (rafId !== null) return;
        lastTs = 0;
        accMs = 0;
        inMove = false;
        window.addEventListener("keydown", onKeyDownCapture, CAPTURE);
        window.addEventListener("keyup", onKeyUpCapture, CAPTURE);
        window.addEventListener("blur", onBlur);
        document.addEventListener("visibilitychange", onVisibility);
        rafId = requestAnimationFrame(frame);
      },
      stop() {
        if (rafId !== null) {
          cancelAnimationFrame(rafId);
          rafId = null;
        }
        KEYS.clear();
        window.removeEventListener("keydown", onKeyDownCapture, CAPTURE);
        window.removeEventListener("keyup", onKeyUpCapture, CAPTURE);
        window.removeEventListener("blur", onBlur);
        document.removeEventListener("visibilitychange", onVisibility);
      },
      setSpeed(n) {
        const v = Math.max(5, Math.floor(n || DEFAULT_DELAY_MS));
        DELAY_MS = v;
        setGhostDelayMs(v);
      },
      getSpeed() {
        return DELAY_MS;
      }
    };
  }
  var normalizeStorageKey = (value) => typeof value === "string" ? value.trim() : "";
  var normalizeStorageQty = (value) => {
    const n = Number(value);
    return Number.isFinite(n) ? Math.max(0, Math.floor(n)) : 0;
  };
  var buildQtyMap = (raw, getKey) => {
    const map2 = /* @__PURE__ */ new Map();
    const list = Array.isArray(raw) ? raw : [];
    for (const item of list) {
      const key2 = getKey(item);
      if (!key2) continue;
      const qty = normalizeStorageQty(item?.quantity);
      if (qty <= 0) continue;
      map2.set(key2, (map2.get(key2) ?? 0) + qty);
    }
    return map2;
  };
  var buildKeySet = (raw, getKey) => {
    const set3 = /* @__PURE__ */ new Set();
    const list = Array.isArray(raw) ? raw : [];
    for (const item of list) {
      const key2 = getKey(item);
      if (!key2) continue;
      const qty = normalizeStorageQty(item?.quantity);
      if (qty <= 0) continue;
      set3.add(key2);
    }
    return set3;
  };
  var diffIncreases = (prev, next) => {
    const out = [];
    for (const [key2, qty] of next) {
      const before = prev.get(key2) ?? 0;
      if (qty > before) out.push(key2);
    }
    return out;
  };
  var seedKeyFromItem = (item) => normalizeStorageKey(item?.species);
  var decorKeyFromItem = (item) => normalizeStorageKey(item?.decorId);
  var autoSeedSiloEnabled = readAutoStoreSeedSiloEnabled(false);
  var autoDecorShedEnabled = readAutoStoreDecorShedEnabled(false);
  var seedSiloItems = /* @__PURE__ */ new Set();
  var seedInventoryQty = /* @__PURE__ */ new Map();
  var seedSiloQueue = /* @__PURE__ */ new Set();
  var seedSiloBusy = false;
  var seedInvUnsub = null;
  var seedSiloUnsub = null;
  var decorShedItems = /* @__PURE__ */ new Set();
  var decorInventoryQty = /* @__PURE__ */ new Map();
  var decorShedQueue = /* @__PURE__ */ new Set();
  var decorShedBusy = false;
  var decorInvUnsub = null;
  var decorShedUnsub = null;
  function queueSeedSiloStore(keys) {
    for (const key2 of keys) if (key2) seedSiloQueue.add(key2);
    void flushSeedSiloQueue();
  }
  async function flushSeedSiloQueue() {
    if (seedSiloBusy || !autoSeedSiloEnabled) return;
    seedSiloBusy = true;
    try {
      while (seedSiloQueue.size && autoSeedSiloEnabled) {
        const batch = Array.from(seedSiloQueue);
        seedSiloQueue.clear();
        for (const species of batch) {
          if (!autoSeedSiloEnabled) return;
          if (!seedSiloItems.has(species)) continue;
          try {
            await PlayerService.putItemInStorage(species, "SeedSilo");
          } catch {
          }
        }
      }
    } finally {
      seedSiloBusy = false;
    }
  }
  async function startSeedSiloAutoStore() {
    if (seedInvUnsub || seedSiloUnsub) return;
    if (typeof window === "undefined") return;
    try {
      seedSiloItems = buildKeySet(await mySeedSiloItems.get(), seedKeyFromItem);
    } catch {
    }
    try {
      seedInventoryQty = buildQtyMap(await Atoms.inventory.mySeedInventory.get(), seedKeyFromItem);
    } catch {
    }
    try {
      seedSiloUnsub = await mySeedSiloItems.onChange((next) => {
        seedSiloItems = buildKeySet(next, seedKeyFromItem);
      });
    } catch {
      seedSiloUnsub = null;
    }
    try {
      seedInvUnsub = await Atoms.inventory.mySeedInventory.onChange((next) => {
        if (!autoSeedSiloEnabled) return;
        const nextMap = buildQtyMap(next, seedKeyFromItem);
        const increased = diffIncreases(seedInventoryQty, nextMap);
        seedInventoryQty = nextMap;
        if (increased.length) queueSeedSiloStore(increased);
      });
    } catch {
      seedInvUnsub = null;
    }
  }
  function stopSeedSiloAutoStore() {
    try {
      seedInvUnsub?.();
    } catch {
    }
    try {
      seedSiloUnsub?.();
    } catch {
    }
    seedInvUnsub = null;
    seedSiloUnsub = null;
    seedSiloQueue.clear();
    seedSiloBusy = false;
    seedSiloItems.clear();
    seedInventoryQty.clear();
  }
  function queueDecorShedStore(keys) {
    for (const key2 of keys) if (key2) decorShedQueue.add(key2);
    void flushDecorShedQueue();
  }
  async function flushDecorShedQueue() {
    if (decorShedBusy || !autoDecorShedEnabled) return;
    decorShedBusy = true;
    try {
      while (decorShedQueue.size && autoDecorShedEnabled) {
        const batch = Array.from(decorShedQueue);
        decorShedQueue.clear();
        for (const decorId of batch) {
          if (!autoDecorShedEnabled) return;
          if (!decorShedItems.has(decorId)) continue;
          try {
            await PlayerService.putItemInStorage(decorId, "DecorShed");
          } catch {
          }
        }
      }
    } finally {
      decorShedBusy = false;
    }
  }
  async function startDecorShedAutoStore() {
    if (decorInvUnsub || decorShedUnsub) return;
    if (typeof window === "undefined") return;
    try {
      decorShedItems = buildKeySet(await myDecorShedItems.get(), decorKeyFromItem);
    } catch {
    }
    try {
      decorInventoryQty = buildQtyMap(await Atoms.inventory.myDecorInventory.get(), decorKeyFromItem);
    } catch {
    }
    try {
      decorShedUnsub = await myDecorShedItems.onChange((next) => {
        decorShedItems = buildKeySet(next, decorKeyFromItem);
      });
    } catch {
      decorShedUnsub = null;
    }
    try {
      decorInvUnsub = await Atoms.inventory.myDecorInventory.onChange((next) => {
        if (!autoDecorShedEnabled) return;
        const nextMap = buildQtyMap(next, decorKeyFromItem);
        const increased = diffIncreases(decorInventoryQty, nextMap);
        decorInventoryQty = nextMap;
        if (increased.length) queueDecorShedStore(increased);
      });
    } catch {
      decorInvUnsub = null;
    }
  }
  function stopDecorShedAutoStore() {
    try {
      decorInvUnsub?.();
    } catch {
    }
    try {
      decorShedUnsub?.();
    } catch {
    }
    decorInvUnsub = null;
    decorShedUnsub = null;
    decorShedQueue.clear();
    decorShedBusy = false;
    decorShedItems.clear();
    decorInventoryQty.clear();
  }
  function setAutoStoreSeedSiloEnabled(on) {
    const next = !!on;
    autoSeedSiloEnabled = next;
    try {
      writeAriesPath(PATH_AUTO_STORE_SEED_SILO_ENABLED, next);
    } catch {
    }
    if (next) {
      void (async () => {
        await startSeedSiloAutoStore();
        const keys = Array.from(seedInventoryQty.keys()).filter((k) => seedSiloItems.has(k));
        if (keys.length) queueSeedSiloStore(keys);
      })();
    } else {
      stopSeedSiloAutoStore();
    }
  }
  function setAutoStoreDecorShedEnabled(on) {
    const next = !!on;
    autoDecorShedEnabled = next;
    try {
      writeAriesPath(PATH_AUTO_STORE_DECOR_SHED_ENABLED, next);
    } catch {
    }
    if (next) {
      void (async () => {
        await startDecorShedAutoStore();
        const keys = Array.from(decorInventoryQty.keys()).filter((k) => decorShedItems.has(k));
        if (keys.length) queueDecorShedStore(keys);
      })();
    } else {
      stopDecorShedAutoStore();
    }
  }
  if (autoSeedSiloEnabled) {
    void startSeedSiloAutoStore();
  }
  if (autoDecorShedEnabled) {
    void startDecorShedAutoStore();
  }
  var selectedMap = /* @__PURE__ */ new Map();
  var seedStockByName = /* @__PURE__ */ new Map();
  var seedSourceCache = [];
  var selectedDecorMap = /* @__PURE__ */ new Map();
  var decorStockByName = /* @__PURE__ */ new Map();
  var decorSourceCache = [];
  var _decorDeleteAbort = null;
  var _decorDeleteBusy = false;
  var _decorDeletePaused = false;
  var _decorDeletePauseResolver = null;
  var NF_US = new Intl.NumberFormat("en-US");
  var formatNum = (n) => NF_US.format(Math.max(0, Math.floor(n || 0)));
  async function clearUiSelectionAtoms() {
    try {
      await Atoms.inventory.mySelectedItemName.set(null);
    } catch {
    }
    try {
      await Atoms.inventory.myValidatedSelectedItemIndex.set(null);
    } catch {
    }
    try {
      await Atoms.inventory.myPossiblyNoLongerValidSelectedItemIndex.set(null);
    } catch {
    }
  }
  var OVERLAY_ID = "qws-seeddeleter-overlay";
  var LIST_ID = "qws-seeddeleter-list";
  var SUMMARY_ID = "qws-seeddeleter-summary";
  var OVERLAY_DECOR_ID = "qws-decordeleter-overlay";
  var LIST_DECOR_ID = "qws-decordeleter-list";
  var SUMMARY_DECOR_ID = "qws-decordeleter-summary";
  function sleep2(ms) {
    return new Promise((r) => setTimeout(r, ms));
  }
  function buildDisplayNameToSpeciesFromCatalog() {
    const map2 = /* @__PURE__ */ new Map();
    try {
      const cat = plantCatalog;
      for (const species of Object.keys(cat || {})) {
        const seedName = cat?.[species]?.seed?.name && String(cat?.[species]?.seed?.name) || `${species} Seed`;
        const arr = map2.get(seedName) ?? [];
        arr.push(species);
        map2.set(seedName, arr);
      }
    } catch {
    }
    return map2;
  }
  async function buildSpeciesStockFromInventory() {
    const inv = await getMySeedInventory();
    const stock = /* @__PURE__ */ new Map();
    for (const it of inv) {
      const q = Math.max(0, Math.floor(it.quantity || 0));
      if (q > 0) stock.set(it.species, (stock.get(it.species) ?? 0) + q);
    }
    return stock;
  }
  function allocateForRequestedName(requested, nameToSpecies, speciesStock) {
    let remaining = Math.max(0, Math.floor(requested.qty || 0));
    let candidates = nameToSpecies.get(requested.name) ?? [];
    if (!candidates.length && / seed$/i.test(requested.name)) {
      const fallbackSpecies = requested.name.replace(/\s+seed$/i, "");
      if (plantCatalog?.[fallbackSpecies]) candidates = [fallbackSpecies];
    }
    if (!candidates.length || remaining <= 0) return [];
    const ranked = candidates.map((sp) => ({ sp, available: speciesStock.get(sp) ?? 0 })).filter((x) => x.available > 0).sort((a, b) => b.available - a.available);
    const out = [];
    for (const { sp, available } of ranked) {
      if (remaining <= 0) break;
      const take = Math.min(available, remaining);
      if (take > 0) {
        out.push({ species: sp, qty: take });
        remaining -= take;
      }
    }
    return out;
  }
  var _seedDeleteAbort = null;
  var _seedDeleteBusy = false;
  var _seedDeletePaused = false;
  var _seedDeletePauseResolver = null;
  var DEFAULT_SEED_DELETE_DELAY_MS = 35;
  async function waitSeedPause() {
    while (_seedDeletePaused) {
      await new Promise((resolve2) => {
        _seedDeletePauseResolver = resolve2;
      });
      _seedDeletePauseResolver = null;
    }
  }
  async function deleteSelectedSeeds(opts = {}) {
    if (_seedDeleteBusy) {
      await toastSimple("Seed deleter", "Deletion already in progress.", "info");
      return;
    }
    const delayMs = Math.max(0, Math.floor(opts.delayMs ?? DEFAULT_SEED_DELETE_DELAY_MS));
    const selection = (opts.selection && Array.isArray(opts.selection) ? opts.selection : Array.from(selectedMap.values())).map((s) => ({ name: s.name, qty: Math.max(0, Math.floor(s.qty || 0)) })).filter((s) => s.qty > 0);
    if (selection.length === 0) {
      await toastSimple("Seed deleter", "No seeds selected.", "info");
      return;
    }
    const nameToSpecies = buildDisplayNameToSpeciesFromCatalog();
    const speciesStock = await buildSpeciesStockFromInventory();
    const allocatedBySpecies = /* @__PURE__ */ new Map();
    let requestedTotal = 0, cappedTotal = 0;
    for (const req of selection) {
      requestedTotal += req.qty;
      const chunks = allocateForRequestedName(req, nameToSpecies, speciesStock);
      const okForThis = chunks.reduce((a, c) => a + c.qty, 0);
      cappedTotal += okForThis;
      for (const c of chunks) {
        allocatedBySpecies.set(c.species, (allocatedBySpecies.get(c.species) ?? 0) + c.qty);
      }
    }
    if (cappedTotal <= 0) {
      await toastSimple("Seed deleter", "Nothing to delete (not in inventory).", "info");
      return;
    }
    if (cappedTotal < requestedTotal) {
      await toastSimple(
        "Seed deleter",
        `Requested ${formatNum(requestedTotal)} but only ${formatNum(cappedTotal)} available. Proceeding.`,
        "info"
      );
    }
    const tasks = Array.from(allocatedBySpecies.entries()).map(([species, qty]) => ({ species, qty: Math.max(0, Math.floor(qty || 0)) })).filter((t) => t.qty > 0);
    const total = tasks.reduce((acc, t) => acc + t.qty, 0);
    if (total <= 0) {
      await toastSimple("Seed deleter", "Nothing to delete.", "info");
      return;
    }
    _seedDeleteBusy = true;
    const abort = new AbortController();
    _seedDeleteAbort = abort;
    try {
      await toastSimple("Seed deleter", `Deleting ${formatNum(total)} seeds across ${tasks.length} species...`, "info");
      let done = 0;
      let successfulDeletes = 0;
      for (const t of tasks) {
        let remaining = t.qty;
        while (remaining > 0) {
          if (abort.signal.aborted) throw new Error("Deletion cancelled.");
          await waitDecorPause();
          await waitSeedPause();
          let attemptSucceeded = false;
          try {
            await PlayerService.wish(t.species);
            attemptSucceeded = true;
          } catch (err) {
          }
          if (attemptSucceeded) successfulDeletes += 1;
          done += 1;
          remaining -= 1;
          try {
            opts.onProgress?.({ done, total, species: t.species, remainingForSpecies: remaining });
            window.dispatchEvent(new CustomEvent("qws:seeddeleter:progress", {
              detail: { done, total, species: t.species, remainingForSpecies: remaining }
            }));
          } catch {
          }
          if (delayMs > 0 && remaining > 0) await sleep2(delayMs);
        }
      }
      if (!opts.keepSelection) selectedMap.clear();
      try {
        window.dispatchEvent(new CustomEvent("qws:seeddeleter:done", { detail: { total, speciesCount: tasks.length } }));
      } catch {
      }
      if (successfulDeletes > 0) {
        await toastSimple("Seed deleter", `Deleted ${formatNum(successfulDeletes)} seeds (${tasks.length} species).`, "success");
      } else {
        await toastSimple("Seed deleter", "No seeds were deleted (requests failed).", "info");
      }
    } catch (e) {
      const msg = e?.message || "Deletion failed.";
      try {
        window.dispatchEvent(new CustomEvent("qws:seeddeleter:error", { detail: { message: msg } }));
      } catch {
      }
      await toastSimple("Seed deleter", msg, "error");
    } finally {
      _seedDeleteBusy = false;
      _seedDeletePaused = false;
      _seedDeleteAbort = null;
      _seedDeletePauseResolver?.();
      _seedDeletePauseResolver = null;
    }
  }
  function cancelSeedDeletion() {
    try {
      _seedDeletePaused = false;
      _seedDeletePauseResolver?.();
      _seedDeletePauseResolver = null;
      _seedDeleteAbort?.abort();
    } catch (err) {
    }
  }
  function isSeedDeletionRunning() {
    return _seedDeleteBusy;
  }
  function pauseSeedDeletion() {
    if (!_seedDeleteBusy || _seedDeletePaused) return;
    _seedDeletePaused = true;
    try {
      window.dispatchEvent(new CustomEvent("qws:seeddeleter:paused"));
    } catch {
    }
  }
  function resumeSeedDeletion() {
    if (!_seedDeletePaused) return;
    _seedDeletePaused = false;
    _seedDeletePauseResolver?.();
    _seedDeletePauseResolver = null;
    try {
      window.dispatchEvent(new CustomEvent("qws:seeddeleter:resumed"));
    } catch {
    }
  }
  function isSeedDeletionPaused() {
    return _seedDeletePaused;
  }
  try {
    window.addEventListener("qws:seeddeleter:apply", async (e) => {
      try {
        const selection = Array.isArray(e?.detail?.selection) ? e.detail.selection : void 0;
        await deleteSelectedSeeds({ selection, delayMs: 35, keepSelection: false });
      } catch {
      }
    });
  } catch {
  }
  function seedDisplayNameFromSpecies(species) {
    try {
      const node = plantCatalog?.[species];
      const n = node?.seed?.name;
      if (typeof n === "string" && n) return n;
    } catch {
    }
    return `${species} Seed`;
  }
  function normalizeSeedItem(x, _idx) {
    if (!x || typeof x !== "object") return null;
    const species = typeof x.species === "string" ? x.species.trim() : "";
    const itemType = x.itemType === "Seed" ? "Seed" : null;
    const quantity = Number.isFinite(x.quantity) ? Math.max(0, Math.floor(x.quantity)) : 0;
    if (!species || itemType !== "Seed" || quantity <= 0) return null;
    return { species, itemType: "Seed", quantity, id: `seed:${species}` };
  }
  async function getMySeedInventory() {
    try {
      const raw = await Atoms.inventory.mySeedInventory.get();
      if (!Array.isArray(raw)) return [];
      const out = [];
      raw.forEach((x, i) => {
        const s = normalizeSeedItem(x, i);
        if (s) out.push(s);
      });
      return out;
    } catch {
      return [];
    }
  }
  function buildInventoryShapeFrom(items) {
    return { items, favoritedItemIds: [] };
  }
  function decorDisplayNameFromId(decorId) {
    try {
      const node = decorCatalog?.[decorId];
      const n = node?.name;
      if (typeof n === "string" && n) return n;
    } catch {
    }
    return decorId || "Decor";
  }
  function normalizeDecorItem(x) {
    if (!x || typeof x !== "object") return null;
    const decorId = typeof x.decorId === "string" ? x.decorId.trim() : "";
    const itemType = x.itemType === "Decor" ? "Decor" : null;
    const quantity = Number.isFinite(x.quantity) ? Math.max(0, Math.floor(x.quantity)) : 0;
    if (!decorId || itemType !== "Decor" || quantity <= 0) return null;
    return { decorId, itemType: "Decor", quantity, id: `decor:${decorId}` };
  }
  async function getMyDecorInventory() {
    try {
      const raw = await Atoms.inventory.myDecorInventory.get();
      if (!Array.isArray(raw)) return [];
      const out = [];
      raw.forEach((x) => {
        const s = normalizeDecorItem(x);
        if (s) out.push(s);
      });
      return out;
    } catch {
      return [];
    }
  }
  function buildDecorInventoryShapeFrom(items) {
    return { items, favoritedItemIds: [] };
  }
  function setStyles(el2, styles) {
    Object.assign(el2.style, styles);
  }
  function styleOverlayBox(div, id) {
    div.id = id;
    setStyles(div, {
      position: "fixed",
      left: "12px",
      top: "12px",
      zIndex: "999999",
      display: "grid",
      gridTemplateRows: "auto auto 1px 1fr auto",
      gap: "6px",
      minWidth: "320px",
      maxWidth: "420px",
      maxHeight: "52vh",
      padding: "8px",
      border: "1px solid #39424c",
      borderRadius: "10px",
      background: "rgba(22,27,34,0.92)",
      boxShadow: "0 10px 30px rgba(0,0,0,0.35)",
      backdropFilter: "blur(2px)",
      userSelect: "none",
      fontFamily: "ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial",
      fontSize: "12px",
      lineHeight: "1.25"
    });
    div.dataset["qwsSeedDeleter"] = "1";
  }
  function makeDraggable(root, handle) {
    let dragging = false;
    let ox = 0, oy = 0;
    const onDown = (e) => {
      dragging = true;
      const r = root.getBoundingClientRect();
      ox = e.clientX - r.left;
      oy = e.clientY - r.top;
      document.addEventListener("mousemove", onMove);
      document.addEventListener("mouseup", onUp, { once: true });
    };
    const onMove = (e) => {
      if (!dragging) return;
      const nx = Math.max(4, e.clientX - ox);
      const ny = Math.max(4, e.clientY - oy);
      root.style.left = `${nx}px`;
      root.style.top = `${ny}px`;
    };
    const onUp = () => {
      dragging = false;
      document.removeEventListener("mousemove", onMove);
    };
    handle.addEventListener("mousedown", onDown);
  }
  function createButton(label2, styleOverride) {
    const b = document.createElement("button");
    b.textContent = label2;
    setStyles(b, {
      padding: "4px 8px",
      borderRadius: "8px",
      border: "1px solid #4446",
      background: "#161b22",
      color: "#E7EEF7",
      cursor: "pointer",
      fontWeight: "600",
      fontSize: "12px",
      ...styleOverride
    });
    b.onmouseenter = () => b.style.borderColor = "#6aa1";
    b.onmouseleave = () => b.style.borderColor = "#4446";
    return b;
  }
  var overlayKeyGuardsOn = false;
  function isInsideOverlay(el2) {
    return !!(el2 && (el2.closest?.(`#${OVERLAY_ID}`) || el2.closest?.(`#${OVERLAY_DECOR_ID}`)));
  }
  function keyGuardCapture(e) {
    const ae = document.activeElement;
    if (!isInsideOverlay(ae)) return;
    const tag = (ae?.tagName || "").toLowerCase();
    const isEditable = tag === "input" || tag === "textarea" || ae && ae.isContentEditable;
    if (!isEditable) return;
    if (/^[0-9]$/.test(e.key)) {
      e.stopImmediatePropagation();
    }
  }
  function installOverlayKeyGuards() {
    if (overlayKeyGuardsOn) return;
    window.addEventListener("keydown", keyGuardCapture, { capture: true });
    overlayKeyGuardsOn = true;
  }
  function removeOverlayKeyGuards() {
    if (!overlayKeyGuardsOn) return;
    window.removeEventListener("keydown", keyGuardCapture, { capture: true });
    overlayKeyGuardsOn = false;
  }
  async function closeSeedInventoryPanel() {
    try {
      await fakeInventoryHide();
    } catch {
      try {
        document.dispatchEvent(new KeyboardEvent("keydown", { key: "Escape" }));
      } catch {
      }
    }
  }
  function createSeedOverlay() {
    const box = document.createElement("div");
    styleOverlayBox(box, OVERLAY_ID);
    const header = document.createElement("div");
    setStyles(header, { display: "flex", alignItems: "center", gap: "4px", cursor: "move" });
    const title = document.createElement("div");
    title.textContent = "\u{1F3AF} Selection mode";
    setStyles(title, { fontWeight: "700", fontSize: "13px" });
    const hint = document.createElement("div");
    hint.textContent = "Click seeds in inventory to toggle selection.";
    setStyles(hint, { opacity: "0.8", fontSize: "11px" });
    const hr = document.createElement("div");
    setStyles(hr, { height: "1px", background: "#2d333b" });
    const list = document.createElement("div");
    list.id = LIST_ID;
    setStyles(list, {
      minHeight: "44px",
      maxHeight: "26vh",
      overflow: "auto",
      padding: "4px",
      border: "1px dashed #39424c",
      borderRadius: "8px",
      background: "rgba(15,19,24,0.84)",
      userSelect: "text"
    });
    const actions = document.createElement("div");
    setStyles(actions, { display: "flex", justifyContent: "space-between", alignItems: "center", gap: "8px" });
    const summary = document.createElement("div");
    summary.id = SUMMARY_ID;
    setStyles(summary, { fontWeight: "600" });
    summary.textContent = "Selected: 0 species \xB7 0 seeds";
    const btnClear = createButton("Clear");
    btnClear.title = "Clear selection";
    btnClear.onclick = async () => {
      selectedMap.clear();
      refreshList();
      updateSummary();
      await clearUiSelectionAtoms();
      await repatchFakeSeedInventoryWithSelection();
    };
    _btnConfirm = createButton("Confirm", { background: "#1F2328CC" });
    _btnConfirm.disabled = true;
    _btnConfirm.onclick = async () => {
      await closeSeedInventoryPanel();
    };
    header.append(title);
    actions.append(summary, btnClear, _btnConfirm);
    box.append(header, hint, hr, list, actions);
    makeDraggable(box, header);
    return box;
  }
  function showSeedOverlay() {
    if (document.getElementById(OVERLAY_ID)) return;
    const el2 = createSeedOverlay();
    document.body.appendChild(el2);
    installOverlayKeyGuards();
    refreshList();
    updateSummary();
  }
  function hideSeedOverlay() {
    const el2 = document.getElementById(OVERLAY_ID);
    if (el2) el2.remove();
    if (!document.getElementById(OVERLAY_DECOR_ID)) removeOverlayKeyGuards();
  }
  var _btnConfirm = null;
  var unsubSelectedName = null;
  var unsubDecorSelectedName = null;
  function renderListRow(item) {
    const row = document.createElement("div");
    setStyles(row, {
      display: "grid",
      gridTemplateColumns: "1fr auto",
      alignItems: "center",
      gap: "6px",
      padding: "4px 6px",
      borderBottom: "1px dashed #2d333b"
    });
    const name = document.createElement("div");
    name.textContent = item.name;
    setStyles(name, {
      fontSize: "12px",
      fontWeight: "600",
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    });
    const controls = document.createElement("div");
    setStyles(controls, { display: "flex", alignItems: "center", gap: "6px" });
    const qty = document.createElement("input");
    qty.type = "number";
    qty.min = "1";
    qty.max = String(Math.max(1, item.maxQty));
    qty.step = "1";
    qty.value = String(item.qty);
    qty.className = "qmm-input";
    setStyles(qty, {
      width: "68px",
      height: "28px",
      border: "1px solid #4446",
      borderRadius: "8px",
      background: "rgba(15,19,24,0.90)",
      padding: "0 8px",
      fontSize: "12px"
    });
    const swallowDigits = (e) => {
      if (/^[0-9]$/.test(e.key)) {
        e.stopPropagation();
        e.stopImmediatePropagation();
      }
    };
    qty.addEventListener("keydown", swallowDigits);
    const updateQty = async () => {
      const v = Math.min(item.maxQty, Math.max(1, Math.floor(Number(qty.value) || 1)));
      qty.value = String(v);
      const cur = selectedMap.get(item.name);
      if (!cur) return;
      cur.qty = v;
      selectedMap.set(item.name, cur);
      updateSummary();
      await repatchFakeSeedInventoryWithSelection();
    };
    qty.onchange = () => {
      void updateQty();
    };
    qty.oninput = () => {
      void updateQty();
    };
    const remove = createButton("Remove", { background: "transparent" });
    remove.onclick = async () => {
      selectedMap.delete(item.name);
      refreshList();
      updateSummary();
      await repatchFakeSeedInventoryWithSelection();
    };
    controls.append(qty, remove);
    row.append(name, controls);
    return row;
  }
  function refreshList() {
    const list = document.getElementById(LIST_ID);
    if (!list) return;
    list.innerHTML = "";
    const entries = Array.from(selectedMap.values()).sort((a, b) => a.name.localeCompare(b.name));
    if (entries.length === 0) {
      const empty = document.createElement("div");
      empty.textContent = "No seeds selected.";
      empty.style.opacity = "0.8";
      list.appendChild(empty);
      return;
    }
    for (const it of entries) list.appendChild(renderListRow(it));
  }
  function totalSelected() {
    let species = 0, qty = 0;
    for (const it of selectedMap.values()) {
      species += 1;
      qty += it.qty;
    }
    return { species, qty };
  }
  function updateSummary() {
    const { species, qty } = totalSelected();
    const el2 = document.getElementById(SUMMARY_ID);
    if (el2) el2.textContent = `Selected: ${species} species \xB7 ${formatNum(qty)} seeds`;
    if (_btnConfirm) {
      _btnConfirm.textContent = "Confirm";
      _btnConfirm.disabled = qty <= 0;
      _btnConfirm.style.opacity = qty <= 0 ? "0.6" : "1";
      _btnConfirm.style.cursor = qty <= 0 ? "not-allowed" : "pointer";
    }
  }
  async function repatchFakeSeedInventoryWithSelection() {
    const src = Array.isArray(seedSourceCache) ? seedSourceCache : [];
    const remainingByName = /* @__PURE__ */ new Map();
    for (const s of src) {
      const disp = seedDisplayNameFromSpecies(s.species);
      const qty = Math.max(0, Math.floor(s.quantity || 0));
      remainingByName.set(disp, (remainingByName.get(disp) ?? 0) + qty);
    }
    for (const sel of selectedMap.values()) {
      const cur = remainingByName.get(sel.name) ?? 0;
      const picked = Math.max(0, Math.floor(sel.qty || 0));
      remainingByName.set(sel.name, Math.max(0, cur - picked));
    }
    const patched = [];
    for (const s of src) {
      const disp = seedDisplayNameFromSpecies(s.species);
      const remaining = remainingByName.get(disp) ?? 0;
      if (remaining <= 0) continue;
      const take = Math.min(remaining, Math.max(0, Math.floor(s.quantity || 0)));
      if (take <= 0) continue;
      patched.push({ ...s, quantity: take });
      remainingByName.set(disp, remaining - take);
    }
    try {
      await fakeInventoryShow({ items: patched, favoritedItemIds: [] }, { open: false });
    } catch {
    }
  }
  async function beginSelectedNameListener() {
    if (unsubSelectedName) return;
    const unsub = await Atoms.inventory.mySelectedItemName.onChange(async (name) => {
      const n = (name || "").trim();
      if (!n) return;
      const max = Math.max(1, seedStockByName.get(n) ?? 1);
      const existing = selectedMap.get(n);
      if (existing) {
        existing.qty = max;
        existing.maxQty = max;
        selectedMap.set(n, existing);
      } else {
        selectedMap.set(n, { name: n, qty: max, maxQty: max });
      }
      refreshList();
      updateSummary();
      await clearUiSelectionAtoms();
      await repatchFakeSeedInventoryWithSelection();
    });
    unsubSelectedName = typeof unsub === "function" ? unsub : null;
  }
  async function endSelectedNameListener() {
    const fn = unsubSelectedName;
    unsubSelectedName = null;
    try {
      await fn?.();
    } catch {
    }
  }
  async function openSeedInventoryPreview() {
    try {
      const src = await getMySeedInventory();
      if (!src.length) {
        await toastSimple("Seed inventory", "No seeds to display.", "info");
        return;
      }
      await fakeInventoryShow(buildInventoryShapeFrom(src), { open: true });
    } catch (e) {
      await toastSimple("Seed inventory", e?.message || "Failed to open seed inventory.", "error");
    }
  }
  async function openSeedSelectorFlow(setWindowVisible) {
    try {
      setWindowVisible?.(false);
      seedSourceCache = await getMySeedInventory();
      seedStockByName = /* @__PURE__ */ new Map();
      for (const s of seedSourceCache) {
        const display = seedDisplayNameFromSpecies(s.species);
        seedStockByName.set(display, Math.max(1, Math.floor(s.quantity || 0)));
      }
      selectedMap.clear();
      showSeedOverlay();
      await beginSelectedNameListener();
      await fakeInventoryShow(buildInventoryShapeFrom(seedSourceCache), { open: true });
      if (await isInventoryPanelOpen()) {
        await waitInventoryPanelClosed();
      }
    } catch (e) {
      await toastSimple("Seed inventory", e?.message || "Failed to open seed selector.", "error");
    } finally {
      await endSelectedNameListener();
      hideSeedOverlay();
      seedSourceCache = [];
      seedStockByName.clear();
      setWindowVisible?.(true);
    }
  }
  function createDecorOverlay() {
    const box = document.createElement("div");
    styleOverlayBox(box, OVERLAY_DECOR_ID);
    const header = document.createElement("div");
    setStyles(header, { display: "flex", alignItems: "center", gap: "4px", cursor: "move" });
    const title = document.createElement("div");
    title.textContent = "Decor selection";
    setStyles(title, { fontWeight: "700", fontSize: "13px" });
    const hint = document.createElement("div");
    hint.textContent = "Click decor in inventory to toggle selection.";
    setStyles(hint, { opacity: "0.8", fontSize: "11px" });
    const hr = document.createElement("div");
    setStyles(hr, { height: "1px", background: "#2d333b" });
    const list = document.createElement("div");
    list.id = LIST_DECOR_ID;
    setStyles(list, {
      minHeight: "44px",
      maxHeight: "26vh",
      overflow: "auto",
      padding: "4px",
      border: "1px dashed #39424c",
      borderRadius: "8px",
      background: "rgba(15,19,24,0.84)",
      userSelect: "text"
    });
    const actions = document.createElement("div");
    setStyles(actions, { display: "flex", justifyContent: "space-between", alignItems: "center", gap: "8px" });
    const summary = document.createElement("div");
    summary.id = SUMMARY_DECOR_ID;
    setStyles(summary, { fontWeight: "600" });
    summary.textContent = "Selected: 0 decor \xB7 0 items";
    const btnClear = createButton("Clear");
    btnClear.title = "Clear selection";
    btnClear.onclick = async () => {
      selectedDecorMap.clear();
      refreshDecorList();
      updateDecorSummary();
      await clearUiSelectionAtoms();
      await repatchFakeDecorInventoryWithSelection();
    };
    const btnConfirm = createButton("Confirm", { background: "#1F2328CC" });
    btnConfirm.disabled = true;
    btnConfirm.onclick = async () => {
      await closeSeedInventoryPanel();
    };
    header.append(title);
    actions.append(summary, btnClear, btnConfirm);
    box.append(header, hint, hr, list, actions);
    makeDraggable(box, header);
    box.__btnConfirm = btnConfirm;
    return box;
  }
  function showDecorOverlay() {
    if (document.getElementById(OVERLAY_DECOR_ID)) return;
    const el2 = createDecorOverlay();
    document.body.appendChild(el2);
    installOverlayKeyGuards();
    refreshDecorList();
    updateDecorSummary();
  }
  function hideDecorOverlay() {
    const el2 = document.getElementById(OVERLAY_DECOR_ID);
    if (el2) el2.remove();
    if (!document.getElementById(OVERLAY_ID)) removeOverlayKeyGuards();
  }
  function renderDecorListRow(item) {
    const row = document.createElement("div");
    setStyles(row, {
      display: "grid",
      gridTemplateColumns: "1fr auto",
      alignItems: "center",
      gap: "6px",
      padding: "4px 6px",
      borderBottom: "1px dashed #2d333b"
    });
    const name = document.createElement("div");
    name.textContent = item.name;
    setStyles(name, {
      fontSize: "12px",
      fontWeight: "600",
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    });
    const controls = document.createElement("div");
    setStyles(controls, { display: "flex", alignItems: "center", gap: "6px" });
    const qty = document.createElement("input");
    qty.type = "number";
    qty.min = "1";
    qty.max = String(Math.max(1, item.maxQty));
    qty.step = "1";
    qty.value = String(item.qty);
    qty.className = "qmm-input";
    setStyles(qty, {
      width: "68px",
      height: "28px",
      border: "1px solid #4446",
      borderRadius: "8px",
      background: "rgba(15,19,24,0.90)",
      padding: "0 8px",
      fontSize: "12px"
    });
    const swallowDigits = (e) => {
      if (/^[0-9]$/.test(e.key)) {
        e.stopPropagation();
        e.stopImmediatePropagation();
      }
    };
    qty.addEventListener("keydown", swallowDigits);
    const updateQty = async () => {
      const v = Math.min(item.maxQty, Math.max(1, Math.floor(Number(qty.value) || 1)));
      qty.value = String(v);
      const cur = selectedDecorMap.get(item.name);
      if (!cur) return;
      cur.qty = v;
      cur.maxQty = Math.max(cur.maxQty, v);
      selectedDecorMap.set(item.name, cur);
      updateDecorSummary();
      await repatchFakeDecorInventoryWithSelection();
    };
    qty.onchange = () => {
      void updateQty();
    };
    qty.oninput = () => {
      void updateQty();
    };
    const remove = createButton("Remove", { background: "transparent" });
    remove.onclick = async () => {
      selectedDecorMap.delete(item.name);
      refreshDecorList();
      updateDecorSummary();
      await repatchFakeDecorInventoryWithSelection();
    };
    controls.append(qty, remove);
    row.append(name, controls);
    return row;
  }
  function refreshDecorList() {
    const list = document.getElementById(LIST_DECOR_ID);
    if (!list) return;
    list.innerHTML = "";
    const entries = Array.from(selectedDecorMap.values()).sort((a, b) => a.name.localeCompare(b.name));
    if (entries.length === 0) {
      const empty = document.createElement("div");
      empty.textContent = "No decor selected.";
      empty.style.opacity = "0.8";
      list.appendChild(empty);
      return;
    }
    for (const it of entries) list.appendChild(renderDecorListRow(it));
  }
  function totalDecorSelected() {
    let kinds = 0, qty = 0;
    for (const it of selectedDecorMap.values()) {
      kinds += 1;
      qty += it.qty;
    }
    return { kinds, qty };
  }
  function updateDecorSummary() {
    const { kinds, qty } = totalDecorSelected();
    const el2 = document.getElementById(SUMMARY_DECOR_ID);
    if (el2) el2.textContent = `Selected: ${kinds} decor \xB7 ${formatNum(qty)} items`;
    const overlay = document.getElementById(OVERLAY_DECOR_ID);
    const btn = overlay?.__btnConfirm;
    if (btn) {
      btn.textContent = "Confirm";
      btn.disabled = qty <= 0;
      btn.style.opacity = qty <= 0 ? "0.6" : "1";
      btn.style.cursor = qty <= 0 ? "not-allowed" : "pointer";
    }
  }
  async function repatchFakeDecorInventoryWithSelection() {
    const src = Array.isArray(decorSourceCache) ? decorSourceCache : [];
    const remainingByName = /* @__PURE__ */ new Map();
    for (const s of src) {
      const disp = decorDisplayNameFromId(s.decorId);
      const qty = Math.max(0, Math.floor(s.quantity || 0));
      remainingByName.set(disp, (remainingByName.get(disp) ?? 0) + qty);
    }
    for (const sel of selectedDecorMap.values()) {
      const cur = remainingByName.get(sel.name) ?? 0;
      const picked = Math.max(0, Math.floor(sel.qty || 0));
      remainingByName.set(sel.name, Math.max(0, cur - picked));
    }
    const patched = [];
    for (const s of src) {
      const disp = decorDisplayNameFromId(s.decorId);
      const remaining = remainingByName.get(disp) ?? 0;
      if (remaining <= 0) continue;
      const take = Math.min(remaining, Math.max(0, Math.floor(s.quantity || 0)));
      if (take <= 0) continue;
      patched.push({ ...s, quantity: take });
      remainingByName.set(disp, remaining - take);
    }
    try {
      await fakeInventoryShow({ items: patched, favoritedItemIds: [] }, { open: false });
    } catch {
    }
  }
  async function beginSelectedDecorNameListener() {
    if (unsubDecorSelectedName) return;
    const unsub = await Atoms.inventory.mySelectedItemName.onChange(async (name) => {
      const n = (name || "").trim();
      if (!n) return;
      const max = Math.max(1, decorStockByName.get(n) ?? 1);
      const decorId = Array.from(decorSourceCache || []).find((d) => decorDisplayNameFromId(d.decorId) === n)?.decorId || n;
      const existing = selectedDecorMap.get(n);
      if (existing) {
        existing.qty = max;
        existing.maxQty = max;
        selectedDecorMap.set(n, existing);
      } else {
        selectedDecorMap.set(n, { name: n, qty: max, maxQty: max, decorId });
      }
      refreshDecorList();
      updateDecorSummary();
      await clearUiSelectionAtoms();
      await repatchFakeDecorInventoryWithSelection();
    });
    unsubDecorSelectedName = typeof unsub === "function" ? unsub : null;
  }
  async function endSelectedDecorNameListener() {
    const fn = unsubDecorSelectedName;
    unsubDecorSelectedName = null;
    try {
      await fn?.();
    } catch {
    }
  }
  async function findFirstEmptySlot() {
    const state3 = await PlayerService.getGardenState();
    const dirt = state3?.tileObjects || {};
    const boardwalk = state3?.boardwalkTileObjects || {};
    for (let i = 0; i < 200; i++) {
      const key2 = String(i);
      const has = Object.prototype.hasOwnProperty.call(dirt, key2) && dirt[key2] != null;
      if (!has) return { tileType: "Dirt", index: i };
    }
    for (let i = 0; i < 76; i++) {
      const key2 = String(i);
      const has = Object.prototype.hasOwnProperty.call(boardwalk, key2) && boardwalk[key2] != null;
      if (!has) return { tileType: "Boardwalk", index: i };
    }
    return null;
  }
  var DEFAULT_DECOR_DELETE_DELAY_MS = 35;
  async function waitDecorPause() {
    while (_decorDeletePaused) {
      await new Promise((resolve2) => {
        _decorDeletePauseResolver = resolve2;
      });
      _decorDeletePauseResolver = null;
    }
  }
  async function deleteSelectedDecor(opts = {}) {
    if (_decorDeleteBusy) {
      await toastSimple("Decor deleter", "Deletion already in progress.", "info");
      return;
    }
    const delayMs = Math.max(0, Math.floor(opts.delayMs ?? DEFAULT_DECOR_DELETE_DELAY_MS));
    const selection = (opts.selection && Array.isArray(opts.selection) ? opts.selection : Array.from(selectedDecorMap.values())).map((s) => ({ name: s.name, decorId: s.decorId, qty: Math.max(0, Math.floor(s.qty || 0)) })).filter((s) => s.qty > 0);
    if (!selection.length) {
      await toastSimple("Decor deleter", "No decor selected.", "info");
      return;
    }
    const stock = /* @__PURE__ */ new Map();
    (await getMyDecorInventory()).forEach((d) => {
      stock.set(d.decorId, (stock.get(d.decorId) ?? 0) + Math.max(0, Math.floor(d.quantity || 0)));
    });
    const tasks = selection.map((s) => {
      const available = stock.get(s.decorId) ?? 0;
      const qty = Math.min(s.qty, available);
      return { decorId: s.decorId, qty, name: s.name };
    }).filter((t) => t.qty > 0);
    const total = tasks.reduce((acc, t) => acc + t.qty, 0);
    if (total <= 0) {
      await toastSimple("Decor deleter", "Nothing to delete (not in inventory).", "info");
      return;
    }
    const emptySlot = await findFirstEmptySlot();
    if (!emptySlot) {
      await toastSimple("Decor deleter", "No empty slot available to delete decor (dirt 0-199, boardwalk 0-75).", "error");
      return;
    }
    _decorDeleteBusy = true;
    const abort = new AbortController();
    _decorDeleteAbort = abort;
    try {
      await toastSimple("Decor deleter", `Deleting ${formatNum(total)} decor items across ${tasks.length} types...`, "info");
      let done = 0;
      for (const t of tasks) {
        let remaining = t.qty;
        while (remaining > 0) {
          if (abort.signal.aborted) throw new Error("Deletion cancelled.");
          try {
            await PlayerService.placeDecor(emptySlot.tileType, emptySlot.index, t.decorId, 0);
          } catch {
          }
          if (delayMs > 0) await sleep2(delayMs);
          try {
            await PlayerService.removeGardenObject(emptySlot.index, emptySlot.tileType);
          } catch {
          }
          if (delayMs > 0) await sleep2(delayMs);
          done += 1;
          remaining -= 1;
          try {
            opts.onProgress?.({ done, total, decorId: t.decorId, remainingForDecor: remaining });
            window.dispatchEvent(new CustomEvent("qws:decordeleter:progress", {
              detail: { done, total, decorId: t.decorId, remainingForDecor: remaining }
            }));
          } catch {
          }
        }
      }
      if (!opts.keepSelection) selectedDecorMap.clear();
      try {
        window.dispatchEvent(new CustomEvent("qws:decordeleter:done", { detail: { total, decorCount: tasks.length } }));
      } catch {
      }
      await toastSimple("Decor deleter", `Deleted ${formatNum(total)} decor items (${tasks.length} types).`, "success");
    } catch (e) {
      const msg = e?.message || "Deletion failed.";
      try {
        window.dispatchEvent(new CustomEvent("qws:decordeleter:error", { detail: { message: msg } }));
      } catch {
      }
      await toastSimple("Decor deleter", msg, "error");
    } finally {
      _decorDeleteBusy = false;
      _decorDeletePaused = false;
      _decorDeleteAbort = null;
      _decorDeletePauseResolver?.();
      _decorDeletePauseResolver = null;
    }
  }
  function cancelDecorDeletion() {
    try {
      _decorDeletePaused = false;
      _decorDeletePauseResolver?.();
      _decorDeletePauseResolver = null;
      _decorDeleteAbort?.abort();
    } catch {
    }
  }
  function isDecorDeletionRunning() {
    return _decorDeleteBusy;
  }
  function pauseDecorDeletion() {
    if (!_decorDeleteBusy || _decorDeletePaused) return;
    _decorDeletePaused = true;
    try {
      window.dispatchEvent(new CustomEvent("qws:decordeleter:paused"));
    } catch {
    }
  }
  function resumeDecorDeletion() {
    if (!_decorDeletePaused) return;
    _decorDeletePaused = false;
    _decorDeletePauseResolver?.();
    _decorDeletePauseResolver = null;
    try {
      window.dispatchEvent(new CustomEvent("qws:decordeleter:resumed"));
    } catch {
    }
  }
  function isDecorDeletionPaused() {
    return _decorDeletePaused;
  }
  async function openDecorSelectorFlow(setWindowVisible) {
    try {
      setWindowVisible?.(false);
      decorSourceCache = await getMyDecorInventory();
      decorStockByName = /* @__PURE__ */ new Map();
      for (const d of decorSourceCache) {
        const display = decorDisplayNameFromId(d.decorId);
        decorStockByName.set(display, Math.max(1, Math.floor(d.quantity || 0)));
      }
      selectedDecorMap.clear();
      showDecorOverlay();
      await beginSelectedDecorNameListener();
      await fakeInventoryShow(buildDecorInventoryShapeFrom(decorSourceCache), { open: true });
      if (await isInventoryPanelOpen()) {
        await waitInventoryPanelClosed();
      }
    } catch (e) {
      await toastSimple("Decor inventory", e?.message || "Failed to open decor selector.", "error");
    } finally {
      await endSelectedDecorNameListener();
      hideDecorOverlay();
      decorSourceCache = [];
      decorStockByName.clear();
      setWindowVisible?.(true);
    }
  }
  var MiscService = {
    // ghost
    readGhostEnabled,
    writeGhostEnabled,
    getGhostDelayMs,
    setGhostDelayMs,
    createGhostController,
    readAutoRecoEnabled,
    writeAutoRecoEnabled,
    getAutoRecoDelayMs,
    setAutoRecoDelayMs,
    readInventorySlotReserveEnabled,
    writeInventorySlotReserveEnabled,
    readAutoStoreSeedSiloEnabled,
    setAutoStoreSeedSiloEnabled,
    readAutoStoreDecorShedEnabled,
    setAutoStoreDecorShedEnabled,
    // seeds
    getMySeedInventory,
    openSeedInventoryPreview,
    openSeedSelectorFlow,
    //delete
    deleteSelectedSeeds,
    cancelSeedDeletion,
    isSeedDeletionRunning,
    pauseSeedDeletion,
    resumeSeedDeletion,
    isSeedDeletionPaused,
    getCurrentSeedSelection() {
      return Array.from(selectedMap.values());
    },
    clearSeedSelection() {
      selectedMap.clear();
    },
    // decor
    getMyDecorInventory,
    openDecorSelectorFlow,
    deleteSelectedDecor,
    cancelDecorDeletion,
    isDecorDeletionRunning,
    pauseDecorDeletion,
    resumeDecorDeletion,
    isDecorDeletionPaused,
    getCurrentDecorSelection() {
      return Array.from(selectedDecorMap.values());
    },
    clearDecorSelection() {
      selectedDecorMap.clear();
    }
  };

  // src/services/editor.ts
  init_atoms();
  init_jotai();
  init_page_context();

  // src/core/ingameHotkeys.ts
  init_page_context();
  var resolveContext = (context) => {
    if (context) return context;
    const win = pageWindow ?? window;
    const doc = win.document ?? document;
    return { window: win, document: doc };
  };
  var KEYCODE_TABLE = {
    KeyA: 65,
    KeyB: 66,
    KeyC: 67,
    KeyD: 68,
    KeyE: 69,
    KeyF: 70,
    KeyG: 71,
    KeyH: 72,
    KeyI: 73,
    KeyJ: 74,
    KeyK: 75,
    KeyL: 76,
    KeyM: 77,
    KeyN: 78,
    KeyO: 79,
    KeyP: 80,
    KeyQ: 81,
    KeyR: 82,
    KeyS: 83,
    KeyT: 84,
    KeyU: 85,
    KeyV: 86,
    KeyW: 87,
    KeyX: 88,
    KeyY: 89,
    KeyZ: 90,
    Digit0: 48,
    Digit1: 49,
    Digit2: 50,
    Digit3: 51,
    Digit4: 52,
    Digit5: 53,
    Digit6: 54,
    Digit7: 55,
    Digit8: 56,
    Digit9: 57,
    Space: 32,
    Enter: 13,
    Escape: 27,
    Tab: 9,
    Backspace: 8,
    Delete: 46,
    Insert: 45,
    ArrowLeft: 37,
    ArrowUp: 38,
    ArrowRight: 39,
    ArrowDown: 40
  };
  var codeToKey = (code, shift = false) => {
    if (!code) return "";
    if (/^Key[A-Z]$/.test(code)) return shift ? code.slice(3).toUpperCase() : code.slice(3).toLowerCase();
    if (/^Digit[0-9]$/.test(code)) return code.slice(5);
    if (code === "Space") return " ";
    return code;
  };
  var isEditableTarget = (t) => {
    const el2 = t;
    if (!el2 || !el2.tagName) return false;
    const tag = el2.tagName.toLowerCase();
    if (tag === "input" || tag === "textarea") return true;
    const ce = el2.getAttribute && el2.getAttribute("contenteditable");
    return !!(ce && ce !== "false");
  };
  var normalizeCombo = (c) => {
    const parts = String(c).split("+").map((s) => s.trim()).filter(Boolean);
    const mods = [];
    let code = "";
    for (const p of parts) {
      const P = p.toLowerCase();
      if (P === "ctrl" || P === "control") mods.push("ctrl");
      else if (P === "shift") mods.push("shift");
      else if (P === "alt") mods.push("alt");
      else if (P === "meta" || P === "cmd" || P === "command" || P === "win") mods.push("meta");
      else code = p;
    }
    mods.sort((a, b) => ["ctrl", "shift", "alt", "meta"].indexOf(a) - ["ctrl", "shift", "alt", "meta"].indexOf(b));
    return (mods.length ? mods.join("+") + "+" : "") + code;
  };
  var parseCombo = (c) => {
    const parts = String(c).split("+").map((s) => s.trim()).filter(Boolean);
    const spec = {};
    for (const p of parts) {
      const P = p.toLowerCase();
      if (P === "ctrl" || P === "control") spec.ctrl = true;
      else if (P === "shift") spec.shift = true;
      else if (P === "alt") spec.alt = true;
      else if (P === "meta" || P === "cmd" || P === "command" || P === "win") spec.meta = true;
      else spec.code = p;
    }
    if (spec.code && spec.key === void 0) spec.key = codeToKey(spec.code, !!spec.shift);
    return spec;
  };
  var evToCombo = (e) => {
    const mods = [];
    if (e.ctrlKey) mods.push("ctrl");
    if (e.shiftKey) mods.push("shift");
    if (e.altKey) mods.push("alt");
    if (e.metaKey) mods.push("meta");
    mods.sort((a, b) => ["ctrl", "shift", "alt", "meta"].indexOf(a) - ["ctrl", "shift", "alt", "meta"].indexOf(b));
    return (mods.length ? mods.join("+") + "+" : "") + (e.code || "");
  };
  var REMAP_FLAG = "__inGameHotkeysRemapped__";
  var RAPID_SYN_FLAG = "__inGameHotkeysRapidSynthetic__";
  var InGameHotkeys = class {
    constructor(autoAttach = true, context) {
      __publicField(this, "win");
      __publicField(this, "doc");
      // remapper
      __publicField(this, "enabled", true);
      __publicField(this, "map", /* @__PURE__ */ new Map());
      // combo normalis -> spec destination
      __publicField(this, "blockedSet", /* @__PURE__ */ new Set());
      // combos bloqus
      __publicField(this, "eventBlockers", /* @__PURE__ */ new Set());
      __publicField(this, "attachedDocs", /* @__PURE__ */ new WeakSet());
      // docs dj hooks
      __publicField(this, "observers", []);
      __publicField(this, "handlers", /* @__PURE__ */ new Map());
      __publicField(this, "passthrough", /* @__PURE__ */ new Set(["F5", "F12"]));
      // rapid-fire manager
      __publicField(this, "sessions", /* @__PURE__ */ new Map());
      const ctx2 = resolveContext(context);
      this.win = ctx2.window;
      this.doc = ctx2.document;
      if (autoAttach) {
        this.attachDoc(this.doc);
        this.attachAllFrames();
        if (this.win.MutationObserver) {
          const mo = new this.win.MutationObserver(() => this.attachAllFrames());
          mo.observe(this.doc.documentElement || this.doc, { childList: true, subtree: true });
          this.observers.push(mo);
        }
      }
    }
    /* --------- on/off remapper --------- */
    enable(flag = true) {
      this.enabled = !!flag;
    }
    disable() {
      this.enabled = false;
    }
    isEnabled() {
      return this.enabled;
    }
    /* --------- remaps --------- */
    setMap(m) {
      this.map.clear();
      for (const [from, to] of Object.entries(m || {})) this.map.set(normalizeCombo(from), parseCombo(to));
    }
    add(from, to) {
      this.map.set(normalizeCombo(from), parseCombo(to));
    }
    remove(from) {
      this.map.delete(normalizeCombo(from));
    }
    clear() {
      this.map.clear();
    }
    current() {
      const out = {};
      for (const [k, v] of this.map.entries()) {
        const mods = [];
        if (v.ctrl) mods.push("Ctrl");
        if (v.shift) mods.push("Shift");
        if (v.alt) mods.push("Alt");
        if (v.meta) mods.push("Meta");
        out[k] = (mods.length ? mods.join("+") + "+" : "") + (v.code || "");
      }
      return out;
    }
    /* --------- blocages --------- */
    block(combo) {
      this.blockedSet.add(normalizeCombo(combo));
    }
    unblock(combo) {
      this.blockedSet.delete(normalizeCombo(combo));
    }
    blocked() {
      return Array.from(this.blockedSet);
    }
    addEventBlocker(blocker) {
      if (typeof blocker !== "function") {
        return () => {
        };
      }
      this.eventBlockers.add(blocker);
      return () => {
        this.eventBlockers.delete(blocker);
      };
    }
    /* --------- helpers de binding --------- */
    /** Dplace laction binde sur oldBase vers newPhysical et dsactive oldBase. */
    replace(oldBase, newPhysical) {
      const oldN = normalizeCombo(oldBase);
      const newN = normalizeCombo(newPhysical);
      this.blockedSet.add(oldN);
      this.map.set(newN, parseCombo(oldN));
    }
    /** change rciproquement deux touches (ne bloque pas). */
    swap(a, b) {
      const an = normalizeCombo(a), bn = normalizeCombo(b);
      this.map.set(an, parseCombo(bn));
      this.map.set(bn, parseCombo(an));
    }
    /* --------- frames & cleanup --------- */
    attachAllFrames() {
      this.doc.querySelectorAll("iframe").forEach((f) => {
        try {
          const d = f.contentDocument;
          const origin = d?.location?.origin;
          if (d && origin && origin === this.win.location.origin) this.attachDoc(d);
        } catch {
        }
      });
    }
    destroy() {
      for (const [doc, handler] of this.handlers.entries()) {
        try {
          const win = doc.defaultView || this.win;
          win.removeEventListener("keydown", handler, true);
          win.removeEventListener("keypress", handler, true);
          win.removeEventListener("keyup", handler, true);
        } catch {
        }
      }
      this.handlers.clear();
      this.attachedDocs = /* @__PURE__ */ new WeakSet();
      for (const mo of this.observers) mo.disconnect();
      this.observers = [];
      this.stopAllRapidFires();
      this.eventBlockers.clear();
    }
    /* --------- rapid-fire (API) --------- */
    startRapidFire(opts) {
      const trigger = normalizeCombo(opts.trigger);
      const emit = normalizeCombo(opts.emit ?? opts.trigger);
      const rateMs = 1e3 / Math.max(1, opts.rateHz ?? 12);
      const mode = opts.mode ?? "tap";
      const keyupDelayMs = opts.keyupDelayMs ?? 20;
      this.sessions.set(trigger, {
        trigger: parseRapid(trigger),
        emit: parseRapid(emit),
        rateMs,
        mode,
        keyupDelayMs,
        pressed: false,
        lastTarget: null,
        tickTimer: null,
        upTimer: null
      });
    }
    stopRapidFire(trigger) {
      if (!trigger) {
        this.stopAllRapidFires();
        return;
      }
      const key2 = normalizeCombo(trigger);
      const s = this.sessions.get(key2);
      if (!s) return;
      this.endSession(s);
      this.sessions.delete(key2);
    }
    stopAllRapidFires() {
      for (const s of this.sessions.values()) this.endSession(s);
      this.sessions.clear();
    }
    isRapidFireActive(trigger) {
      const s = this.sessions.get(normalizeCombo(trigger));
      return !!(s && s.pressed);
    }
    setRapidFireRate(trigger, hz) {
      const s = this.sessions.get(normalizeCombo(trigger));
      if (!s) return;
      s.rateMs = 1e3 / Math.max(1, hz);
      if (s.pressed) this.restartLoop(s);
    }
    setRapidFireMode(trigger, mode) {
      const s = this.sessions.get(normalizeCombo(trigger));
      if (!s) return;
      s.mode = mode;
    }
    listRapidFires() {
      const out = [];
      for (const [key2, s] of this.sessions.entries()) {
        out.push({
          trigger: key2,
          emit: joinRapid(s.emit),
          rateHz: Math.round(1e3 / s.rateMs),
          mode: s.mode
        });
      }
      return out;
    }
    /* ================= internes ================= */
    attachDoc(doc) {
      if (!doc || this.attachedDocs.has(doc)) return;
      const handler = this.makeHandler(doc);
      const win = doc.defaultView || this.win;
      win.addEventListener("keydown", handler, true);
      win.addEventListener("keypress", handler, true);
      win.addEventListener("keyup", handler, true);
      this.handlers.set(doc, handler);
      this.attachedDocs.add(doc);
    }
    makeHandler(doc) {
      return (evt) => {
        const e = evt;
        if (e[REMAP_FLAG]) return;
        const isRapidSynthetic = !!e[RAPID_SYN_FLAG];
        if (!isRapidSynthetic) this.handleRapidFireInput(doc, e);
        if (!isRapidSynthetic && this.eventBlockers.size) {
          for (const blocker of Array.from(this.eventBlockers)) {
            let shouldBlock = false;
            try {
              shouldBlock = blocker(e);
            } catch {
              shouldBlock = false;
            }
            if (shouldBlock) {
              e.stopImmediatePropagation();
              e.preventDefault();
              return;
            }
          }
        }
        if (!this.enabled) return;
        if (isEditableTarget(e.target)) return;
        if (this.passthrough.has(e.code)) return;
        const combo = evToCombo(e);
        if (this.blockedSet.has(combo)) {
          e.stopImmediatePropagation();
          e.preventDefault();
          return;
        }
        const spec = this.map.get(combo);
        if (!spec) return;
        e.stopImmediatePropagation();
        e.preventDefault();
        const code = spec.code || "";
        const key2 = spec.key !== void 0 ? spec.key : codeToKey(code, e.shiftKey);
        const ctrl = spec.ctrl ?? e.ctrlKey;
        const shift = spec.shift ?? e.shiftKey;
        const alt = spec.alt ?? e.altKey;
        const meta = spec.meta ?? e.metaKey;
        const kc = KEYCODE_TABLE[code] ?? (key2 && key2.length === 1 ? key2.toUpperCase().charCodeAt(0) : 0);
        const eventWindow = doc.defaultView || this.win;
        const ne = new eventWindow.KeyboardEvent(e.type, {
          bubbles: true,
          cancelable: true,
          composed: true,
          key: key2,
          code,
          ctrlKey: ctrl,
          shiftKey: shift,
          altKey: alt,
          metaKey: meta,
          repeat: e.repeat,
          location: e.location
        });
        Object.defineProperties(ne, {
          keyCode: { get: () => kc },
          which: { get: () => kc },
          charCode: { get: () => kc },
          [REMAP_FLAG]: { value: true }
        });
        const target = e.target || doc;
        target.dispatchEvent(ne);
      };
    }
    /* ---------- Rapid-fire internes ---------- */
    handleRapidFireInput(doc, e) {
      if (isEditableTarget(e.target)) return;
      if (e.type === "keydown" && !e.repeat) {
        for (const s of this.sessions.values()) {
          if (this.matches(e, s.trigger)) {
            s.pressed = true;
            s.lastTarget = e.target || doc;
            this.startLoop(doc, s);
          }
        }
      } else if (e.type === "keyup") {
        for (const s of this.sessions.values()) {
          if (this.matches(e, s.trigger)) {
            s.pressed = false;
            this.stopLoop(doc, s);
          }
        }
      }
    }
    matches(e, c) {
      return e.code === c.code && !!e.ctrlKey === !!c.ctrl && !!e.shiftKey === !!c.shift && !!e.altKey === !!c.alt && !!e.metaKey === !!c.meta;
    }
    startLoop(doc, s) {
      this.stopLoop(doc, s);
      const tick = () => {
        if (!s.pressed) return;
        this.dispatchKey(doc, s.lastTarget || doc, "keydown", s.emit, true);
        if (s.mode === "tap") {
          if (s.upTimer) this.win.clearTimeout(s.upTimer);
          s.upTimer = this.win.setTimeout(() => {
            this.dispatchKey(doc, s.lastTarget || doc, "keyup", s.emit, false);
          }, s.keyupDelayMs);
        }
      };
      tick();
      s.tickTimer = this.win.setInterval(tick, s.rateMs);
    }
    stopLoop(doc, s) {
      if (s.tickTimer) {
        this.win.clearInterval(s.tickTimer);
        s.tickTimer = null;
      }
      if (s.upTimer) {
        this.win.clearTimeout(s.upTimer);
        s.upTimer = null;
      }
      if (s.mode === "hold" && s.lastTarget) {
        this.dispatchKey(doc, s.lastTarget, "keyup", s.emit, false);
      }
    }
    restartLoop(s) {
      if (!s.pressed) return;
      const anyDoc = this.doc;
      this.startLoop(anyDoc, s);
    }
    endSession(s) {
      this.stopLoop(this.doc, s);
      s.pressed = false;
      s.lastTarget = null;
    }
    dispatchKey(doc, target, type, c, repeat) {
      const code = c.code;
      const key2 = codeToKey(code, c.shift);
      const kc = KEYCODE_TABLE[code] ?? (key2 && key2.length === 1 ? key2.toUpperCase().charCodeAt(0) : 0);
      const eventWindow = doc.defaultView || this.win;
      const ev = new eventWindow.KeyboardEvent(type, {
        bubbles: true,
        cancelable: true,
        composed: true,
        key: key2,
        code,
        ctrlKey: c.ctrl,
        shiftKey: c.shift,
        altKey: c.alt,
        metaKey: c.meta,
        repeat
      });
      Object.defineProperties(ev, {
        keyCode: { get: () => kc },
        which: { get: () => kc },
        charCode: { get: () => kc },
        [RAPID_SYN_FLAG]: { value: true }
      });
      try {
        target.dispatchEvent(ev);
      } catch {
        doc.dispatchEvent(ev);
      }
    }
  };
  function parseRapid(c) {
    const parts = String(c).split("+").map((s) => s.trim()).filter(Boolean);
    let code = "";
    let ctrl = false, shift = false, alt = false, meta = false;
    for (const p of parts) {
      const P = p.toLowerCase();
      if (P === "ctrl" || P === "control") ctrl = true;
      else if (P === "shift") shift = true;
      else if (P === "alt") alt = true;
      else if (P === "meta" || P === "cmd" || P === "command" || P === "win") meta = true;
      else code = p;
    }
    return { code, ctrl, shift, alt, meta };
  }
  function joinRapid(c) {
    const mods = [];
    if (c.ctrl) mods.push("Ctrl");
    if (c.shift) mods.push("Shift");
    if (c.alt) mods.push("Alt");
    if (c.meta) mods.push("Meta");
    mods.push(c.code);
    return mods.join("+");
  }
  var defaultContext = resolveContext();
  var inGameHotkeys = new InGameHotkeys(true, defaultContext);
  shareGlobal("inGameHotkeys", inGameHotkeys);
  try {
    window.inGameHotkeys = inGameHotkeys;
  } catch {
  }

  // src/ui/menu.ts
  var Menu = class {
    constructor(opts = {}) {
      this.opts = opts;
      // NOTE: je rends root public pour pouvoir faire ui.root.appendChild(...) ct menus
      __publicField(this, "root");
      __publicField(this, "tabBar");
      __publicField(this, "views");
      __publicField(this, "tabs", /* @__PURE__ */ new Map());
      __publicField(this, "events", /* @__PURE__ */ new Map());
      __publicField(this, "currentId", null);
      __publicField(this, "lsKeyActive");
      __publicField(this, "menuId");
      __publicField(this, "_altDown", false);
      __publicField(this, "_insertDown", false);
      __publicField(this, "_hovering", false);
      __publicField(this, "_onKey", (e) => {
        if (e.code === "Insert" || e.key === "Insert") {
          this._insertDown = e.type === "keydown";
        }
        const alt = e.altKey || this._insertDown;
        if (alt !== this._altDown) {
          this._altDown = alt;
          this._updateAltCursor();
        }
      });
      __publicField(this, "_onBlur", () => {
        this._altDown = false;
        this._insertDown = false;
        this._updateAltCursor();
      });
      __publicField(this, "_onEnter", () => {
        this._hovering = true;
        this._updateAltCursor();
      });
      __publicField(this, "_onLeave", () => {
        this._hovering = false;
        this._updateAltCursor();
      });
      this.menuId = this.opts.id || "default";
      this.lsKeyActive = `menu:${this.menuId}:activeTab`;
    }
    /** Monte le menu dans un conteneur */
    mount(container) {
      this.ensureStyles();
      container.innerHTML = "";
      this.root = el("div", `qmm ${this.opts.classes || ""} ${this.opts.compact ? "qmm-compact" : ""}`);
      if (this.opts.startHidden) this.root.style.display = "none";
      this.tabBar = el("div", "qmm-tabs");
      this.views = el("div", "qmm-views");
      this.root.appendChild(this.tabBar);
      this.root.appendChild(this.views);
      container.appendChild(this.root);
      if (this.tabs.size) {
        for (const [id, def] of this.tabs) this.createTabView(id, def);
        this.restoreActive();
      }
      this.updateTabsBarVisibility();
      this.root.addEventListener("pointerenter", this._onEnter);
      this.root.addEventListener("pointerleave", this._onLeave);
      window.addEventListener("keydown", this._onKey, true);
      window.addEventListener("keyup", this._onKey, true);
      window.addEventListener("blur", this._onBlur);
      document.addEventListener("visibilitychange", this._onBlur);
      if (this.opts.startWindowHidden) this.setWindowVisible(false);
      this.emit("mounted");
    }
    /** Dmonte le menu (optionnel) */
    unmount() {
      this.root?.removeEventListener("pointerenter", this._onEnter);
      this.root?.removeEventListener("pointerleave", this._onLeave);
      window.removeEventListener("keydown", this._onKey, true);
      window.removeEventListener("keyup", this._onKey, true);
      window.removeEventListener("blur", this._onBlur);
      document.removeEventListener("visibilitychange", this._onBlur);
      if (this.root?.parentElement) this.root.parentElement.removeChild(this.root);
      this.emit("unmounted");
    }
    /** Retourne l'lment fentre englobant (barre  / ) */
    getWindowEl() {
      if (!this.root) return null;
      const sel = this.opts.windowSelector || ".qws-win";
      return this.root.closest(sel);
    }
    /** Affiche/masque la FENTRE (barre incluse) */
    setWindowVisible(visible) {
      const win = this.getWindowEl();
      if (!win) return;
      win.classList.toggle("is-hidden", !visible);
      this.emit(visible ? "window:show" : "window:hide");
    }
    /** Bascule ltat de la fentre. Retourne true si maintenant visible. */
    toggleWindow() {
      const win = this.getWindowEl();
      if (!win) return false;
      const willShow = win.classList.contains("is-hidden");
      this.setWindowVisible(willShow);
      return willShow;
    }
    /** Donne ltat courant de la fentre (true = visible) */
    isWindowVisible() {
      const win = this.getWindowEl();
      if (!win) return true;
      return !win.classList.contains("is-hidden") && getComputedStyle(win).display !== "none";
    }
    /** Affiche/masque le root */
    setVisible(visible) {
      if (!this.root) return;
      this.root.style.display = visible ? "" : "none";
      this.emit(visible ? "show" : "hide");
    }
    toggle() {
      if (!this.root) return false;
      const v = this.root.style.display === "none";
      this.setVisible(v);
      return v;
    }
    /** Ajoute un onglet (peut tre appel avant ou aprs mount) */
    addTab(id, title, render2) {
      this.tabs.set(id, { title, render: render2, badge: null });
      if (this.root) {
        this.createTabView(id, this.tabs.get(id));
        this.updateTabsBarVisibility();
      }
      return this;
    }
    /** Ajoute plusieurs onglets en une fois */
    addTabs(defs) {
      defs.forEach((d) => this.addTab(d.id, d.title, d.render));
      return this;
    }
    /** Met  jour le titre de longlet (ex: compteur, libell) */
    setTabTitle(id, title) {
      const def = this.tabs.get(id);
      if (!def) return;
      def.title = title;
      if (def.btn) {
        const label2 = def.btn.querySelector(".label");
        if (label2) label2.textContent = title;
      }
    }
    /** Ajoute/retire un badge  droite du titre (ex: 3, NEW, !) */
    setTabBadge(id, text) {
      const def = this.tabs.get(id);
      if (!def || !def.btn) return;
      if (!def.badge) {
        def.badge = document.createElement("span");
        def.badge.className = "badge";
        def.btn.appendChild(def.badge);
      }
      if (text == null || text === "") {
        def.badge.style.display = "none";
      } else {
        def.badge.textContent = text;
        def.badge.style.display = "";
      }
    }
    /** Force le re-render dun onglet (r-excute son render) */
    refreshTab(id) {
      const def = this.tabs.get(id);
      if (!def?.view) return;
      const scroller = this.findScrollableAncestor(def.view);
      const st = scroller ? scroller.scrollTop : null;
      const sl = scroller ? scroller.scrollLeft : null;
      const activeId = document.activeElement?.id || null;
      def.view.innerHTML = "";
      try {
        def.render(def.view, this);
      } catch (e) {
        def.view.textContent = String(e);
      }
      if (this.currentId === id) this.switchTo(id);
      this.emit("tab:render", id);
      if (scroller && st != null) {
        requestAnimationFrame(() => {
          try {
            scroller.scrollTop = st;
            scroller.scrollLeft = sl ?? 0;
          } catch {
          }
          if (activeId) {
            const n = document.getElementById(activeId);
            if (n && n.focus) try {
              n.focus();
            } catch {
            }
          }
        });
      }
    }
    findScrollableAncestor(start2) {
      function isScrollable(el3) {
        const s = getComputedStyle(el3);
        const oy = s.overflowY || s.overflow;
        return /(auto|scroll)/.test(oy) && el3.scrollHeight > el3.clientHeight;
      }
      let el2 = start2;
      while (el2) {
        if (isScrollable(el2)) return el2;
        el2 = el2.parentElement;
      }
      return document.querySelector(".qws-win");
    }
    firstTabId() {
      const it = this.tabs.keys().next();
      return it.done ? null : it.value ?? null;
    }
    _updateAltCursor() {
      if (!this.root) return;
      this.root.classList.toggle("qmm-alt-drag", this._altDown && this._hovering);
    }
    /** Rcupre la vue DOM dun onglet (pratique pour updates cibles) */
    getTabView(id) {
      return this.tabs.get(id)?.view ?? null;
    }
    /** Retire un onglet */
    removeTab(id) {
      const def = this.tabs.get(id);
      if (!def) return;
      this.tabs.delete(id);
      const btn = this.tabBar?.querySelector(`button[data-id="${cssq(id)}"]`);
      if (btn && btn.parentElement) btn.parentElement.removeChild(btn);
      if (def.view && def.view.parentElement) def.view.parentElement.removeChild(def.view);
      if (this.currentId === id) {
        const first = this.tabs.keys().next().value || null;
        this.switchTo(first);
      }
      this.updateTabsBarVisibility();
    }
    /** Active un onglet (id=null => affiche toutes les vues) */
    switchTo(id) {
      this.currentId = id;
      [...this.tabBar.children].forEach((ch) => ch.classList.toggle("active", ch.dataset.id === id || id === null));
      [...this.views.children].forEach((ch) => ch.classList.toggle("active", ch.dataset.id === id || id === null));
      this.persistActive();
      this.emit("tab:change", id);
    }
    /** vnements */
    on(event, handler) {
      if (!this.events.has(event)) this.events.set(event, /* @__PURE__ */ new Set());
      this.events.get(event).add(handler);
      return () => this.off(event, handler);
    }
    off(event, handler) {
      this.events.get(event)?.delete(handler);
    }
    emit(event, ...args) {
      this.events.get(event)?.forEach((h) => {
        try {
          h(...args);
        } catch {
        }
      });
    }
    // ---------- Helpers UI publics (rutilisables dans tes tabs) ----------
    btn(label2, onClickOrOpts) {
      const opts = typeof onClickOrOpts === "function" ? { onClick: onClickOrOpts } : { ...onClickOrOpts || {} };
      const b = el("button", "qmm-btn");
      b.type = "button";
      let iconEl = null;
      if (opts.icon) {
        iconEl = typeof opts.icon === "string" ? document.createElement("span") : opts.icon;
        if (typeof opts.icon === "string" && iconEl) {
          iconEl.textContent = opts.icon;
        }
        if (iconEl) {
          iconEl.classList.add("qmm-btn__icon");
        }
      }
      const trimmedLabel = (label2 ?? "").trim();
      const shouldRenderLabel = !iconEl || trimmedLabel.length > 0;
      const labelSpan = shouldRenderLabel ? document.createElement("span") : null;
      if (labelSpan) {
        labelSpan.className = "label";
        labelSpan.textContent = label2;
      }
      if (iconEl) {
        if (trimmedLabel.length === 0) {
          b.classList.add("qmm-btn--icon");
        }
        if (opts.iconPosition === "right") {
          iconEl.classList.add("is-right");
          if (labelSpan) b.append(labelSpan);
          b.append(iconEl);
        } else {
          iconEl.classList.add("is-left");
          b.append(iconEl);
          if (labelSpan) b.append(labelSpan);
        }
      } else {
        if (labelSpan) b.append(labelSpan);
      }
      const variant = opts.variant && opts.variant !== "default" ? opts.variant : null;
      if (variant) b.classList.add(`qmm-btn--${variant}`);
      if (opts.fullWidth) b.classList.add("qmm-btn--full");
      if (opts.size === "sm") b.classList.add("qmm-btn--sm");
      if (opts.active) b.classList.add("active");
      if (opts.tooltip || opts.title) b.title = opts.tooltip || opts.title || "";
      if (opts.ariaLabel) b.setAttribute("aria-label", opts.ariaLabel);
      if (opts.onClick) b.addEventListener("click", opts.onClick);
      if (opts.disabled) this.setButtonEnabled(b, false);
      b.setEnabled = (enabled) => this.setButtonEnabled(b, enabled);
      b.setActive = (active) => b.classList.toggle("active", !!active);
      return b;
    }
    setButtonEnabled(button, enabled) {
      button.disabled = !enabled;
      button.classList.toggle("is-disabled", !enabled);
      button.setAttribute("aria-disabled", (!enabled).toString());
    }
    flexRow(opts = {}) {
      const row = document.createElement("div");
      row.className = ["qmm-flex", opts.className || ""].filter(Boolean).join(" ").trim();
      row.style.display = "flex";
      row.style.alignItems = this.mapAlign(opts.align ?? "center");
      row.style.justifyContent = this.mapJustify(opts.justify ?? "start");
      row.style.gap = `${opts.gap ?? 8}px`;
      row.style.flexWrap = opts.wrap === false ? "nowrap" : "wrap";
      if (opts.fullWidth) row.style.width = "100%";
      return row;
    }
    formGrid(opts = {}) {
      const grid = document.createElement("div");
      grid.className = "qmm-form-grid";
      grid.style.display = "grid";
      grid.style.gridTemplateColumns = opts.columns || "max-content 1fr";
      grid.style.columnGap = `${opts.columnGap ?? 8}px`;
      grid.style.rowGap = `${opts.rowGap ?? 8}px`;
      grid.style.alignItems = opts.align ? opts.align : "center";
      return grid;
    }
    formRow(labelText, control, opts = {}) {
      const wrap = document.createElement("div");
      wrap.className = "qmm-form-row";
      wrap.style.display = "grid";
      wrap.style.gridTemplateColumns = `${opts.labelWidth || "160px"} 1fr`;
      wrap.style.columnGap = `${opts.gap ?? 10}px`;
      wrap.style.alignItems = opts.alignTop ? "start" : "center";
      if (opts.wrap) wrap.classList.add("is-wrap");
      const lab = this.label(labelText);
      lab.classList.add("qmm-form-row__label");
      lab.style.margin = "0";
      lab.style.justifySelf = "start";
      if (opts.alignTop) lab.style.alignSelf = "start";
      wrap.append(lab, control);
      return { root: wrap, label: lab };
    }
    card(title, opts = {}) {
      const root = document.createElement("div");
      root.className = "qmm-card";
      root.dataset.tone = opts.tone || "default";
      if (opts.align === "center") root.classList.add("is-center");
      if (opts.align === "stretch") root.classList.add("is-stretch");
      if (opts.padding) root.style.padding = opts.padding;
      if (opts.gap != null) root.style.gap = `${opts.gap}px`;
      if (opts.maxWidth) {
        const max = typeof opts.maxWidth === "number" ? `${opts.maxWidth}px` : opts.maxWidth;
        root.style.width = `min(${max}, 100%)`;
      }
      const header = document.createElement("div");
      header.className = "qmm-card__header";
      if (opts.compactHeader) header.classList.add("is-compact");
      const titleWrap = document.createElement("div");
      titleWrap.className = "qmm-card__title";
      titleWrap.textContent = title;
      if (opts.icon) {
        const icon = typeof opts.icon === "string" ? document.createElement("span") : opts.icon;
        if (typeof opts.icon === "string" && icon) icon.textContent = opts.icon;
        if (icon) {
          icon.classList.add("qmm-card__icon");
          header.appendChild(icon);
        }
      }
      header.appendChild(titleWrap);
      if (opts.subtitle || opts.description) {
        const sub = document.createElement("div");
        sub.className = "qmm-card__subtitle";
        sub.textContent = opts.subtitle || opts.description || "";
        header.appendChild(sub);
      }
      if (opts.actions?.length) {
        const actions = document.createElement("div");
        actions.className = "qmm-card__actions";
        opts.actions.forEach((a) => actions.appendChild(a));
        header.appendChild(actions);
      }
      const body = document.createElement("div");
      body.className = "qmm-card__body";
      root.append(header, body);
      return {
        root,
        header,
        body,
        setTitle(next) {
          titleWrap.textContent = next;
        }
      };
    }
    toggleChip(labelText, opts = {}) {
      const wrap = document.createElement("label");
      wrap.className = "qmm-chip-toggle";
      if (opts.tooltip) wrap.title = opts.tooltip;
      const input = document.createElement("input");
      input.type = opts.type || "checkbox";
      if (opts.name) input.name = opts.name;
      if (opts.value) input.value = opts.value;
      input.checked = !!opts.checked;
      const face = document.createElement("div");
      face.className = "qmm-chip-toggle__face";
      if (opts.icon) {
        const icon = typeof opts.icon === "string" ? document.createElement("span") : opts.icon;
        if (typeof opts.icon === "string" && icon) icon.textContent = opts.icon;
        if (icon) {
          icon.classList.add("qmm-chip-toggle__icon");
          face.appendChild(icon);
        }
      }
      const labelEl = document.createElement("span");
      labelEl.className = "qmm-chip-toggle__label";
      labelEl.textContent = labelText;
      face.appendChild(labelEl);
      if (opts.description) {
        const desc = document.createElement("span");
        desc.className = "qmm-chip-toggle__desc";
        desc.textContent = opts.description;
        face.appendChild(desc);
      }
      if (opts.badge) {
        const badge = document.createElement("span");
        badge.className = "qmm-chip-toggle__badge";
        badge.textContent = opts.badge;
        face.appendChild(badge);
      }
      wrap.append(input, face);
      return { root: wrap, input, label: labelEl };
    }
    select(opts = {}) {
      const sel = document.createElement("select");
      sel.className = "qmm-input qmm-select";
      if (opts.id) sel.id = opts.id;
      if (opts.width) sel.style.minWidth = opts.width;
      if (opts.placeholder) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = opts.placeholder;
        opt.disabled = true;
        opt.selected = true;
        sel.appendChild(opt);
      }
      return sel;
    }
    errorBar() {
      const el2 = document.createElement("div");
      el2.className = "qmm-error";
      el2.style.display = "none";
      return {
        el: el2,
        show(message) {
          el2.textContent = message;
          el2.style.display = "block";
        },
        clear() {
          el2.textContent = "";
          el2.style.display = "none";
        }
      };
    }
    mapAlign(al) {
      if (al === "start") return "flex-start";
      if (al === "end") return "flex-end";
      if (al === "stretch") return "stretch";
      return "center";
    }
    mapJustify(j) {
      if (j === "center") return "center";
      if (j === "end") return "flex-end";
      if (j === "between") return "space-between";
      if (j === "around") return "space-around";
      return "flex-start";
    }
    label(text) {
      const l = el("label", "qmm-label");
      l.textContent = text;
      return l;
    }
    row(...children) {
      const r = el("div", "qmm-row");
      children.forEach((c) => r.appendChild(c));
      return r;
    }
    section(title) {
      const s = el("div", "qmm-section");
      s.appendChild(el("div", "qmm-section-title", escapeHtml(title)));
      return s;
    }
    inputNumber(min = 0, max = 9999, step = 1, value = 0) {
      const wrap = el("div", "qmm-input-number");
      const i = el("input", "qmm-input qmm-input-number-input");
      i.type = "number";
      i.min = String(min);
      i.max = String(max);
      i.step = String(step);
      i.value = String(value);
      i.inputMode = "numeric";
      const spin = el("div", "qmm-spin");
      const up = el("button", "qmm-step qmm-step--up", "\u25B2");
      const down = el("button", "qmm-step qmm-step--down", "\u25BC");
      up.type = down.type = "button";
      const clamp4 = () => {
        const n = Number(i.value);
        if (Number.isFinite(n)) {
          const lo = Number(i.min), hi = Number(i.max);
          const clamped = Math.max(lo, Math.min(hi, n));
          if (clamped !== n) i.value = String(clamped);
        }
      };
      const bump = (dir) => {
        if (dir < 0) i.stepDown();
        else i.stepUp();
        clamp4();
        i.dispatchEvent(new Event("input", { bubbles: true }));
        i.dispatchEvent(new Event("change", { bubbles: true }));
      };
      const addSpin = (btn, dir) => {
        let pressTimer = null;
        let repeatTimer = null;
        let suppressNextClick = false;
        const start2 = (ev) => {
          suppressNextClick = false;
          pressTimer = window.setTimeout(() => {
            suppressNextClick = true;
            bump(dir);
            repeatTimer = window.setInterval(() => bump(dir), 60);
          }, 300);
          btn.setPointerCapture?.(ev.pointerId);
        };
        const stop2 = () => {
          if (pressTimer != null) {
            clearTimeout(pressTimer);
            pressTimer = null;
          }
          if (repeatTimer != null) {
            clearInterval(repeatTimer);
            repeatTimer = null;
          }
        };
        btn.addEventListener("pointerdown", start2);
        ["pointerup", "pointercancel", "pointerleave", "blur"].forEach(
          (ev) => btn.addEventListener(ev, stop2)
        );
        btn.addEventListener("click", (e) => {
          if (suppressNextClick) {
            e.preventDefault();
            e.stopPropagation();
            suppressNextClick = false;
            return;
          }
          bump(dir);
        });
      };
      addSpin(up, 1);
      addSpin(down, -1);
      i.addEventListener("change", clamp4);
      spin.append(up, down);
      wrap.append(i, spin);
      i.wrap = wrap;
      return i;
    }
    inputText(placeholder = "", value = "") {
      const i = el("input", "qmm-input");
      i.type = "text";
      i.placeholder = placeholder;
      i.value = value;
      return i;
    }
    checkbox(checked = false) {
      const i = el("input", "qmm-check");
      i.type = "checkbox";
      i.checked = checked;
      return i;
    }
    radio(name, value, checked = false) {
      const i = el("input", "qmm-radio");
      i.type = "radio";
      i.name = name;
      i.value = value;
      i.checked = checked;
      return i;
    }
    slider(min = 0, max = 100, step = 1, value = 0) {
      const i = el("input", "qmm-range");
      i.type = "range";
      i.min = String(min);
      i.max = String(max);
      i.step = String(step);
      i.value = String(value);
      return i;
    }
    rangeDual(min = 0, max = 100, step = 1, valueMin = min, valueMax = max) {
      const wrap = el("div", "qmm-range-dual");
      const track = el("div", "qmm-range-dual-track");
      const fill = el("div", "qmm-range-dual-fill");
      track.appendChild(fill);
      wrap.appendChild(track);
      const createHandle = (value, extraClass) => {
        const input = this.slider(min, max, step, value);
        input.classList.add("qmm-range-dual-input", extraClass);
        wrap.appendChild(input);
        return input;
      };
      const minInput = createHandle(valueMin, "qmm-range-dual-input--min");
      const maxInput = createHandle(valueMax, "qmm-range-dual-input--max");
      const updateFill = () => {
        const minValue = Number(minInput.value);
        const maxValue = Number(maxInput.value);
        const total = max - min;
        if (!Number.isFinite(total) || total <= 0) {
          fill.style.left = "0%";
          fill.style.right = "100%";
          return;
        }
        const clampPercent4 = (value) => Math.max(0, Math.min(100, value));
        const start2 = (Math.min(minValue, maxValue) - min) / total * 100;
        const end = (Math.max(minValue, maxValue) - min) / total * 100;
        fill.style.left = `${clampPercent4(start2)}%`;
        fill.style.right = `${clampPercent4(100 - end)}%`;
      };
      minInput.addEventListener("input", updateFill);
      maxInput.addEventListener("input", updateFill);
      const handle = {
        root: wrap,
        min: minInput,
        max: maxInput,
        setValues(minValue, maxValue) {
          minInput.value = String(minValue);
          maxInput.value = String(maxValue);
          updateFill();
        },
        refresh: updateFill
      };
      handle.refresh();
      return handle;
    }
    switch(checked = false) {
      const i = this.checkbox(checked);
      i.classList.add("qmm-switch");
      return i;
    }
    // Helpers tableau simple pour lister les items
    table(headers, opts) {
      const wrap = document.createElement("div");
      wrap.className = "qmm-table-wrap";
      if (opts?.minimal) wrap.classList.add("qmm-table-wrap--minimal");
      const scroller = document.createElement("div");
      scroller.className = "qmm-table-scroll";
      if (opts?.maxHeight) scroller.style.maxHeight = opts.maxHeight;
      wrap.appendChild(scroller);
      const t = document.createElement("table");
      t.className = "qmm-table";
      if (opts?.minimal) t.classList.add("qmm-table--minimal");
      if (opts?.compact) t.classList.add("qmm-table--compact");
      if (opts?.fixed) t.style.tableLayout = "fixed";
      const thead = document.createElement("thead");
      const trh = document.createElement("tr");
      headers.forEach((h) => {
        const th = document.createElement("th");
        if (typeof h === "string") {
          th.textContent = h;
        } else {
          th.textContent = h.label ?? "";
          if (h.align) th.classList.add(`is-${h.align}`);
          if (h.width) th.style.width = h.width;
        }
        trh.appendChild(th);
      });
      thead.appendChild(trh);
      const tbody = document.createElement("tbody");
      t.append(thead, tbody);
      scroller.appendChild(t);
      return { root: wrap, tbody };
    }
    segmented(items, selected, onChange, opts) {
      const root = document.createElement("div");
      root.className = "qmm-seg";
      if (opts?.fullWidth) root.classList.add("qmm-seg--full");
      if (opts?.id) root.id = opts.id;
      root.setAttribute("role", "radiogroup");
      if (opts?.ariaLabel) root.setAttribute("aria-label", opts.ariaLabel);
      const rail = document.createElement("div");
      rail.className = "qmm-seg__indicator";
      root.appendChild(rail);
      const reduceMotionQuery = typeof window !== "undefined" && "matchMedia" in window ? window.matchMedia("(prefers-reduced-motion: reduce)") : null;
      const canAnimateIndicator = typeof rail.animate === "function";
      if (canAnimateIndicator) {
        rail.style.transition = "none";
      }
      let indicatorMetrics = null;
      let indicatorAnimation = null;
      const applyIndicatorStyles = (left, width) => {
        rail.style.transform = `translate3d(${left}px,0,0)`;
        rail.style.width = `${width}px`;
      };
      const cancelIndicatorAnimation = () => {
        if (!indicatorAnimation) return;
        indicatorAnimation.cancel();
        indicatorAnimation = null;
      };
      let value = selected;
      const btns = [];
      const setSelected = (v, focus = false) => {
        if (v === value) {
          if (focus) {
            const alreadyActive = btns.find((b) => b.dataset.value === v);
            alreadyActive?.focus();
          }
          onChange?.(value);
          return;
        }
        value = v;
        for (const b of btns) {
          const active = b.dataset.value === v;
          b.setAttribute("aria-checked", active ? "true" : "false");
          b.tabIndex = active ? 0 : -1;
          b.classList.toggle("active", active);
          if (active && focus) b.focus();
        }
        moveIndicator(true);
        onChange?.(value);
      };
      const moveIndicator = (animate = false) => {
        const active = btns.find((b) => b.dataset.value === value);
        if (!active) return;
        const i = btns.indexOf(active);
        const n = btns.length;
        const cs = getComputedStyle(root);
        const gap = parseFloat(cs.gap || cs.columnGap || "0") || 0;
        const bL = parseFloat(cs.borderLeftWidth || "0") || 0;
        const bR = parseFloat(cs.borderRightWidth || "0") || 0;
        const rRoot = root.getBoundingClientRect();
        const rBtn = active.getBoundingClientRect();
        let left = rBtn.left - rRoot.left - bL;
        let width = rBtn.width;
        const padW = rRoot.width - bL - bR;
        if (n === 1) {
          left = 0;
          width = padW;
        } else if (i === 0) {
          const rightEdge = left + width + gap / 2;
          left = 0;
          width = rightEdge - left;
        } else if (i === n - 1) {
          left = left - gap / 2;
          width = padW - left;
        } else {
          left = left - gap / 2;
          width = width + gap;
        }
        const dpr = window.devicePixelRatio || 1;
        const snap = (x) => Math.round(x * dpr) / dpr;
        const targetLeft = snap(left);
        const targetWidth = snap(width);
        const previous = indicatorMetrics;
        indicatorMetrics = { left: targetLeft, width: targetWidth };
        const applyFinal = () => applyIndicatorStyles(targetLeft, targetWidth);
        const shouldAnimate = animate && canAnimateIndicator && !reduceMotionQuery?.matches && previous != null && previous.width > 0 && Number.isFinite(previous.width) && targetWidth > 0 && Number.isFinite(targetWidth);
        if (!shouldAnimate) {
          cancelIndicatorAnimation();
          applyFinal();
          return;
        }
        cancelIndicatorAnimation();
        applyIndicatorStyles(previous.left, previous.width);
        indicatorAnimation = rail.animate(
          [
            {
              transform: `translate3d(${previous.left}px,0,0)`,
              width: `${previous.width}px`,
              opacity: 0.92,
              offset: 0
            },
            {
              transform: `translate3d(${targetLeft}px,0,0)`,
              width: `${targetWidth}px`,
              opacity: 1,
              offset: 1
            }
          ],
          {
            duration: 260,
            easing: "cubic-bezier(.22,.7,.28,1)",
            fill: "forwards"
          }
        );
        const finalize = () => {
          applyFinal();
          indicatorAnimation = null;
        };
        indicatorAnimation.addEventListener("finish", finalize, { once: true });
        indicatorAnimation.addEventListener("cancel", finalize, { once: true });
      };
      items.forEach(({ value: v, label: label2, disabled }) => {
        const b = document.createElement("button");
        b.type = "button";
        b.className = "qmm-seg__btn";
        b.dataset.value = String(v);
        b.setAttribute("role", "radio");
        b.setAttribute("aria-checked", v === selected ? "true" : "false");
        b.tabIndex = v === selected ? 0 : -1;
        b.disabled = !!disabled;
        const labelSpan = document.createElement("span");
        labelSpan.className = "qmm-seg__btn-label";
        labelSpan.textContent = label2;
        b.appendChild(labelSpan);
        b.addEventListener("click", () => {
          if (!b.disabled) setSelected(v, false);
        });
        b.addEventListener("keydown", (e) => {
          if (!["ArrowRight", "ArrowLeft", "Home", "End"].includes(e.key)) return;
          e.preventDefault();
          const idx = items.findIndex((it) => it.value === value);
          if (e.key === "Home") {
            setSelected(items[0].value, true);
            return;
          }
          if (e.key === "End") {
            setSelected(items[items.length - 1].value, true);
            return;
          }
          const dir = e.key === "ArrowRight" ? 1 : -1;
          let j = idx;
          for (let k = 0; k < items.length; k++) {
            j = (j + dir + items.length) % items.length;
            if (!items[j].disabled) {
              setSelected(items[j].value, true);
              break;
            }
          }
        });
        btns.push(b);
        root.appendChild(b);
      });
      const ro = window.ResizeObserver ? new ResizeObserver(() => moveIndicator(false)) : null;
      if (ro) ro.observe(root);
      window.addEventListener("resize", () => moveIndicator(false));
      queueMicrotask(() => moveIndicator(false));
      root.get = () => value;
      root.set = (v) => setSelected(v, false);
      return root;
    }
    radioGroup(name, options, selected, onChange) {
      const wrap = el("div", "qmm-radio-group");
      for (const { value, label: label2 } of options) {
        const r = this.radio(name, value, selected === value);
        const lab = document.createElement("label");
        lab.className = "qmm-radio-label";
        lab.appendChild(r);
        lab.appendChild(document.createTextNode(label2));
        r.onchange = () => {
          if (r.checked) onChange(value);
        };
        wrap.appendChild(lab);
      }
      return wrap;
    }
    /** Bind LS: sauvegarde automatique via toStr/parse */
    bindLS(key2, read, write, parse2, toStr) {
      try {
        const raw = localStorage.getItem(key2);
        if (raw != null) write(parse2(raw));
      } catch {
      }
      return { save: () => {
        try {
          localStorage.setItem(key2, toStr(read()));
        } catch {
        }
      } };
    }
    /* -------------------------- split2 helper -------------------------- */
    /** Cre un layout 2 colonnes (gauche/droite) en CSS Grid.
     *  leftWidth: ex "200px" | "18rem" | "minmax(160px, 30%)" */
    split2(leftWidth = "260px") {
      const root = el("div", "qmm-split");
      root.style.gridTemplateColumns = "minmax(160px, max-content) 1fr";
      const left = el("div", "qmm-split-left");
      const right = el("div", "qmm-split-right");
      root.appendChild(left);
      root.appendChild(right);
      return { root, left, right };
    }
    /* -------------------------- VTabs factory -------------------------- */
    /** Cre des tabs verticaux gnriques (liste slectionnable + filtre). */
    vtabs(options = {}) {
      return new VTabs(this, options);
    }
    hotkeyButton(initial, onChange, opts) {
      const emptyLabel = opts?.emptyLabel ?? "None";
      const listeningLabel = opts?.listeningLabel ?? "Press a key\u2026";
      const clearable = opts?.clearable ?? true;
      let hk = initial ?? null;
      let recording = false;
      if (opts?.storageKey) {
        try {
          hk = stringToHotkey(localStorage.getItem(opts.storageKey) || "") ?? initial ?? null;
        } catch {
        }
      }
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "qmm-hotkey";
      btn.setAttribute("aria-live", "polite");
      const render2 = () => {
        btn.classList.toggle("is-recording", recording);
        btn.classList.toggle("is-empty", !hk);
        btn.classList.toggle("is-assigned", !recording && !!hk);
        if (recording) {
          btn.textContent = listeningLabel;
          btn.title = "Listening\u2026 press a key (Esc to cancel, Backspace to clear)";
        } else if (!hk) {
          btn.textContent = emptyLabel;
          btn.title = "No key assigned";
        } else {
          btn.textContent = hotkeyToPretty(hk);
          btn.title = "Click to rebind \u2022 Right-click to clear";
        }
      };
      const applyHotkey = (value, skipRender = false) => {
        hk = value ? { ...value } : null;
        if (!skipRender) render2();
      };
      btn.refreshHotkey = (value) => {
        applyHotkey(value);
      };
      const stopRecording = (commit2) => {
        recording = false;
        if (!commit2) {
          render2();
          return;
        }
        render2();
      };
      const save = () => {
        if (opts?.storageKey) {
          const str = hotkeyToString(hk);
          try {
            if (str) localStorage.setItem(opts.storageKey, str);
            else localStorage.removeItem(opts.storageKey);
          } catch {
          }
        }
        onChange?.(hk, opts?.storageKey ? hotkeyToString(hk) : void 0);
      };
      const handleKeyDown = (e) => {
        if (!recording) return;
        e.preventDefault();
        e.stopPropagation();
        if (e.key === "Escape") {
          stopRecording(false);
          window.removeEventListener("keydown", handleKeyDown, true);
          return;
        }
        if ((e.key === "Backspace" || e.key === "Delete") && clearable) {
          applyHotkey(null, true);
          save();
          stopRecording(true);
          window.removeEventListener("keydown", handleKeyDown, true);
          return;
        }
        const next = eventToHotkey(e, opts?.allowModifierOnly ?? false);
        if (!next) {
          return;
        }
        applyHotkey(next, true);
        save();
        stopRecording(true);
        window.removeEventListener("keydown", handleKeyDown, true);
      };
      btn.addEventListener("click", (e) => {
        e.preventDefault();
        if (!recording) {
          recording = true;
          render2();
          window.addEventListener("keydown", handleKeyDown, true);
          btn.focus();
        }
      });
      if (clearable) {
        btn.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          if (hk) {
            applyHotkey(null, true);
            save();
            render2();
          }
        });
      }
      render2();
      return btn;
    }
    // ---------- internes ----------
    createTabView(id, def) {
      const b = document.createElement("button");
      b.className = "qmm-tab";
      b.dataset.id = id;
      b.innerHTML = `<span class="label">${escapeHtml(def.title)}</span><span class="badge" style="display:none"></span>`;
      const badgeEl = b.querySelector(".badge");
      def.btn = b;
      def.badge = badgeEl;
      b.onclick = () => this.switchTo(id);
      this.tabBar.appendChild(b);
      const view = el("div", "qmm-view");
      view.dataset.id = id;
      def.view = view;
      this.views.appendChild(view);
      try {
        def.render(view, this);
      } catch (e) {
        view.textContent = String(e);
      }
      if (!this.currentId) this.switchTo(id);
    }
    persistActive() {
      if (!this.currentId) return;
      try {
        writeAriesPath(`menu.activeTabs.${this.menuId}`, this.currentId);
        try {
          localStorage.removeItem(this.lsKeyActive);
        } catch {
        }
      } catch {
      }
    }
    restoreActive() {
      let id = null;
      try {
        const stored = readAriesPath(`menu.activeTabs.${this.menuId}`);
        if (typeof stored === "string" && stored) id = stored;
      } catch {
      }
      try {
        id = localStorage.getItem(this.lsKeyActive);
      } catch {
      }
      if (id && this.tabs.has(id)) this.switchTo(id);
      else if (this.tabs.size) this.switchTo(this.firstTabId());
    }
    updateTabsBarVisibility() {
      if (!this.tabBar || !this.root) return;
      const hasTabs = this.tabs.size > 0;
      if (hasTabs) {
        if (!this.tabBar.parentElement) {
          this.root.insertBefore(this.tabBar, this.views);
        }
        this.tabBar.style.display = "flex";
        this.root.classList.remove("qmm-no-tabs");
      } else {
        if (this.tabBar.parentElement) {
          this.tabBar.parentElement.removeChild(this.tabBar);
        }
        this.root.classList.add("qmm-no-tabs");
      }
    }
    ensureStyles() {
      if (document.getElementById("__qmm_css__")) return;
      const css3 = `
    /* ================= Modern UI for qmm ================= */
.qmm{
  --qmm-bg:        #0a0e14;
  --qmm-bg-soft:   #080c12;
  --qmm-panel:     rgba(10,14,20,0.96);
  --qmm-border:    rgba(255,255,255,0.14);
  --qmm-border-2:  rgba(255,255,255,0.08);
  --qmm-accent:    #5eead4;
  --qmm-accent-2:  #2dd4bf;
  --qmm-text:      #e7eef7;
  --qmm-text-dim:  #b9c3cf;
  --qmm-shadow:    0 18px 44px rgba(0,0,0,.45);
  --qmm-blur:      10px;

  display:flex; flex-direction:column; gap:10px; color:var(--qmm-text);
}
.qmm-compact{ gap:6px }

/* ---------- Tabs (pill nav) ---------- */
.qmm-tabs{
  display:flex; gap:4px; flex-wrap:wrap; align-items:center;
  padding:8px 10px; position:relative; isolation:isolate;
  border-bottom:1px solid rgba(255,255,255,0.08);
  background:linear-gradient(120deg, rgba(22,28,40,0.9), rgba(12,17,26,0.92));
  border-top-left-radius:18px; border-top-right-radius:18px;
}
.qmm-no-tabs .qmm-views{ margin-top:0; border-radius:18px; }

.qmm-tab{
  flex:1 1 0; min-width:0; cursor:pointer;
  display:inline-flex; justify-content:center; align-items:center; gap:8px;
  padding:8px 12px; color:#c9d4e6;
  background:transparent; border:1px solid transparent;
  border-radius:12px;
  position:relative; margin:0;
  font-size:12px;
  transition:background 120ms ease, color 120ms ease, border-color 120ms ease;
}
.qmm-compact .qmm-tab{ padding:6px 10px }
.qmm-tab:hover{ background:rgba(94,234,212,0.08); color:#e7eef7; }
.qmm-tab:active{ transform:translateY(1px) }
.qmm-tab:focus-visible{ outline:2px solid var(--qmm-accent); outline-offset:2px; border-radius:12px }

.qmm-tab .badge{
  font-size:11px; line-height:1; padding:2px 6px; border-radius:999px;
  background:rgba(94,234,212,0.12); border:1px solid rgba(94,234,212,0.25);
  color:#5eead4;
}

.qmm-tab.active{
  background:rgba(94,234,212,0.18);
  border-color:rgba(94,234,212,0.35);
  color:#ecfdf5;
}

/* ---------- Views panel ---------- */
.qmm-views{
  border:1px solid rgba(255,255,255,0.14); border-radius:18px; padding:14px;
  background:linear-gradient(160deg, rgba(15,20,30,0.95) 0%, rgba(10,14,20,0.95) 60%, rgba(8,12,18,0.96) 100%);
  backdrop-filter:blur(10px);
  display:flex; flex-direction:column;
  min-width:0; min-height:0; overflow:auto; box-shadow:0 18px 44px rgba(0,0,0,.45);
  scrollbar-width:thin;
  scrollbar-color:rgba(94,234,212,0.20) rgba(255,255,255,0.03);
}
.qmm-views::-webkit-scrollbar{ width:8px; }
.qmm-views::-webkit-scrollbar-track{ background:rgba(255,255,255,0.03); border-radius:4px; }
.qmm-views::-webkit-scrollbar-thumb{ background:rgba(94,234,212,0.20); border-radius:4px; }
.qmm-views::-webkit-scrollbar-thumb:hover{ background:rgba(94,234,212,0.35); }
.qmm-compact .qmm-views{ padding:8px }
.qmm-tabs + .qmm-views{ margin-top:0; border-top:none; border-top-left-radius:0; border-top-right-radius:0; }

.qmm-view{ display:none; min-width:0; min-height:0; }
.qmm-view.active{ display:block; }

/* ---------- Basic controls ---------- */
.qmm-row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin:6px 0 }
.qmm-section{ margin-top:8px }
.qmm-section-title{ font-weight:650; margin:2px 0 8px 0; color:var(--qmm-text) }

.qmm-label{ opacity:.9 }
.qmm-val{ min-width:24px; text-align:center }

/* Buttons */
.qmm-btn{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:8px;
  padding:8px 14px;
  border-radius:10px;
  border:1px solid var(--qmm-border);
  background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.02));
  color:var(--qmm-text);
  font-weight:600;
  font-size:13px;
  line-height:1.2;
  cursor:pointer;
  user-select:none;
  transition:background 120ms ease, border-color 120ms ease, transform 100ms ease, box-shadow 120ms ease, color 120ms ease;
}
.qmm-compact .qmm-btn{ padding:6px 10px }
.qmm-btn:hover{ background:linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.04)); border-color:rgba(255,255,255,0.24) }
.qmm-btn:active{ transform:translateY(1px) }
.qmm-btn:focus-visible{ outline:2px solid var(--qmm-accent); outline-offset:2px; }
.qmm-btn:disabled,
.qmm-btn.is-disabled{
  opacity:.55;
  cursor:not-allowed;
  filter:saturate(.6);
  box-shadow:none;
}
.qmm-btn--full{ width:100%; justify-content:center; }
.qmm-btn--sm{ padding:6px 10px; font-size:12px; border-radius:8px; }
.qmm-btn--icon{ padding:6px; width:34px; height:34px; border-radius:50%; gap:0; }
.qmm-btn__icon{ display:inline-flex; align-items:center; justify-content:center; font-size:1.1em; }
.qmm-btn__icon.is-right{ order:2; }
.qmm-btn__icon.is-left{ order:0; }

/* Button variants */
.qmm-btn--primary,
.qmm-btn.qmm-primary{
  background:linear-gradient(180deg, rgba(94,234,212,.32), rgba(45,212,191,.14));
  border-color:rgba(94,234,212,0.45);
  box-shadow:0 4px 14px rgba(94,234,212,.18);
}
.qmm-btn--primary:hover,
.qmm-btn.qmm-primary:hover{ border-color:rgba(94,234,212,0.65); background:linear-gradient(180deg, rgba(94,234,212,.42), rgba(45,212,191,.22)); }
.qmm-btn--secondary{
  background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.01));
}
.qmm-btn--danger,
.qmm-btn.qmm-danger{
  background:linear-gradient(180deg, rgba(255,86,86,.32), rgba(255,86,86,.14));
  border-color:#ff6a6a55;
  box-shadow:0 4px 14px rgba(255,86,86,.25);
}
.qmm-btn--ghost{ background:transparent; border-color:transparent; }
.qmm-btn--ghost:hover{ background:rgba(255,255,255,.06); border-color:#ffffff2a; }
.qmm-btn.active{
  background:rgba(94,234,212,0.14);
  border-color:rgba(94,234,212,0.40);
  box-shadow:inset 0 0 0 1px rgba(94,234,212,0.20);
}

.qmm-flex{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; }

.qmm-form-grid{ width:100%; }

.qmm-form-row{ width:100%; }
.qmm-form-row.is-wrap{ grid-template-columns:1fr; }
.qmm-form-row__label{ font-weight:600; opacity:.9; }

.qmm-card{
  display:grid;
  gap:12px;
  border:1px solid rgba(255,255,255,0.12);
  border-radius:14px;
  padding:14px;
  background:linear-gradient(160deg, rgba(18,24,34,0.95), rgba(12,17,26,0.96));
  backdrop-filter:blur(10px);
  box-shadow:0 8px 24px rgba(0,0,0,.35);
  width:100%;
  transition:border-color 120ms ease, box-shadow 120ms ease;
}
.qmm-card.is-center{ text-align:center; align-items:center; }
.qmm-card.is-stretch{ align-items:stretch; }
.qmm-card__header{
  display:flex;
  align-items:center;
  gap:10px;
  flex-wrap:wrap;
  justify-content:space-between;
}
.qmm-card__header.is-compact{ gap:6px; }
.qmm-card__icon{ font-size:18px; }
.qmm-card__title{ font-weight:700; font-size:14px; letter-spacing:.01em; }
.qmm-card__subtitle{ font-size:12px; opacity:.75; flex-basis:100%; }
.qmm-card__actions{ display:flex; gap:6px; margin-left:auto; }
.qmm-card__body{ display:grid; gap:10px; }
.qmm-card[data-tone="muted"]{
  background:rgba(10,14,20,.92);
  border-color:rgba(255,255,255,0.08);
  box-shadow:none;
}
.qmm-card[data-tone="accent"]{
  border-color:rgba(94,234,212,0.45);
  box-shadow:0 10px 26px rgba(94,234,212,.15);
}

.qmm .stats-collapse-toggle{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:8px;
  padding:6px 12px;
  min-height:32px;
  border-radius:999px;
  border:1px solid rgba(94,234,212,.40);
  background:linear-gradient(135deg, rgba(94,234,212,.14), rgba(15,30,30,.18));
  color:rgba(220,240,236,.92);
  font-size:12px;
  font-weight:600;
  letter-spacing:.01em;
  text-transform:uppercase;
  box-shadow:inset 0 1px 0 rgba(255,255,255,.12), 0 10px 24px rgba(9,13,27,.28);
  transition:background .26s ease, border-color .26s ease, box-shadow .26s ease, color .26s ease, transform .16s ease;
}
.qmm .stats-collapse-toggle:hover{
  background:linear-gradient(135deg, rgba(94,234,212,.22), rgba(20,100,90,.22));
  border-color:rgba(94,234,212,.55);
  color:#fff;
  box-shadow:0 14px 30px rgba(45,212,191,.25), inset 0 1px 0 rgba(255,255,255,.18);
}
.qmm .stats-collapse-toggle:active{
  transform:translateY(1px) scale(.99);
}
.qmm-card--collapsible[data-collapsed="true"] .stats-collapse-toggle{
  background:linear-gradient(135deg, rgba(94,234,212,.08), rgba(8,30,28,.12));
  border-color:rgba(94,234,212,.25);
  color:rgba(196,240,236,.85);
  box-shadow:inset 0 1px 0 rgba(255,255,255,.1), 0 6px 18px rgba(9,13,27,.22);
}
.qmm-card--collapsible[data-collapsed="false"] .stats-collapse-toggle{
  background:linear-gradient(135deg, rgba(94,234,212,.30), rgba(45,212,191,.25));
  border-color:rgba(94,234,212,.72);
  color:#fff;
  box-shadow:0 16px 32px rgba(45,212,191,.28), inset 0 1px 0 rgba(255,255,255,.22);
}
.qmm .stats-collapse-toggle__icon{
  width:16px;
  height:16px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  position:relative;
  color:inherit;
  transition:transform .24s ease;
}
.qmm .stats-collapse-toggle__icon::before{
  content:"";
  position:absolute;
  width:8px;
  height:8px;
  border-right:2px solid currentColor;
  border-bottom:2px solid currentColor;
  transform:rotate(45deg);
  transition:transform .24s ease;
}
.qmm .stats-collapse-toggle__label{
  color:inherit;
  font-size:11px;
  letter-spacing:.08em;
  font-weight:700;
}
.qmm-card--collapsible[data-collapsed="false"] .stats-collapse-toggle__icon::before{
  transform:rotate(-135deg);
}
.qmm-card--collapsible[data-collapsed="true"] .stats-collapse-toggle__icon::before{
  transform:rotate(45deg);
}

.qmm-chip-toggle{
  display:inline-flex;
  align-items:stretch;
  border-radius:999px;
  border:1px solid #ffffff1f;
  background:rgba(255,255,255,.05);
  cursor:pointer;
  transition:border-color .18s ease, background .18s ease, box-shadow .18s ease, transform .1s ease;
}
.qmm-chip-toggle input{ display:none; }
.qmm-chip-toggle__face{
  display:flex;
  align-items:center;
  gap:8px;
  padding:6px 12px;
  border-radius:999px;
}
.qmm-chip-toggle__icon{ font-size:14px; }
.qmm-chip-toggle__label{ font-weight:600; }
.qmm-chip-toggle__desc{ font-size:12px; opacity:.75; }
.qmm-chip-toggle__badge{ font-size:11px; padding:2px 6px; border-radius:999px; background:#ffffff1a; border:1px solid #ffffff22; }
.qmm-chip-toggle:hover{ border-color:rgba(94,234,212,0.30); background:rgba(94,234,212,0.09); }
.qmm-chip-toggle input:checked + .qmm-chip-toggle__face{
  background:linear-gradient(180deg, rgba(94,234,212,.22), rgba(94,234,212,.08));
  box-shadow:0 0 0 1px rgba(94,234,212,0.35) inset, 0 6px 18px rgba(94,234,212,.15);
}

.qmm .stats-metric-grid{
  display:grid;
  gap:10px;
  grid-template-columns:repeat(auto-fit, minmax(160px, 1fr));
}
.qmm .stats-metric{
  border-radius:12px;
  padding:12px 14px;
  background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
  border:1px solid rgba(255,255,255,.08);
  box-shadow:inset 0 1px 0 rgba(255,255,255,.08);
  display:flex;
  flex-direction:column;
  gap:6px;
  transition:border-color .18s ease, background .18s ease, transform .14s ease;
}
.qmm .stats-metric:hover{
  border-color:rgba(94,234,212,0.30);
  background:linear-gradient(180deg, rgba(94,234,212,.14), rgba(94,234,212,.06));
  transform:translateY(-1px);
}
.qmm .stats-metric__label{
  font-size:12px;
  letter-spacing:.02em;
  text-transform:uppercase;
  color:var(--qmm-text-dim);
}
.qmm .stats-metric__value{
  font-size:20px;
  font-weight:700;
  color:#fff;
}

.qmm .stats-list{
  display:flex;
  flex-direction:column;
  gap:6px;
}
.qmm .stats-list__row{
  display:grid;
  align-items:center;
  gap:10px;
  padding:10px 12px;
  border-radius:10px;
  background:rgba(255,255,255,.035);
  border:1px solid rgba(255,255,255,.08);
  transition:border-color .18s ease, background .18s ease;
}
.qmm .stats-list__row:not(.stats-list__row--header):hover{
  background:rgba(94,234,212,0.09);
  border-color:rgba(94,234,212,0.28);
}
.qmm .stats-list__row--header{
  background:transparent;
  border:none;
  padding:0 6px 2px 6px;
  font-size:11px;
  letter-spacing:.05em;
  text-transform:uppercase;
  color:var(--qmm-text-dim);
}
.qmm .stats-list__row--header .stats-list__cell{
  font-weight:600;
}
.qmm .stats-list__header-label--gold,
.qmm .stats-list__header-label--rainbow{
  display:inline-block;
}
.qmm .stats-list__header-label--gold{
  color:#f7d774;
  background:linear-gradient(135deg,#fff5c0 0%,#f3c76a 55%,#f5b84f 100%);
  background-clip:text;
  -webkit-background-clip:text;
  -webkit-text-fill-color:transparent;
  text-shadow:0 1px 4px rgba(0,0,0,.35);
}
.qmm .stats-list__header-label--rainbow{
  color:#ffd6ff;
  background:linear-gradient(90deg,#ff6b6b 0%,#ffd86f 25%,#6bff8f 50%,#6bc7ff 75%,#b86bff 100%);
  background-clip:text;
  -webkit-background-clip:text;
  -webkit-text-fill-color:transparent;
  text-shadow:0 1px 4px rgba(0,0,0,.35);
}
.qmm .stats-list__cell{
  min-width:0;
  font-size:13px;
}
.qmm .stats-pet__species{
  display:inline-flex;
  align-items:center;
  gap:8px;
  min-width:0;
}
.qmm .stats-pet__label{
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}
.qmm .stats-pet__total-label{
  font-weight:700;
}
.qmm .stats-pet__total-value{
  font-weight:700;
}
.qmm .stats-weather__name{
  display:inline-flex;
  align-items:center;
  gap:8px;
  min-width:0;
}
.qmm .stats-weather__icon{
  width:32px;
  height:32px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  border-radius:6px;
  background:rgba(255,255,255,.08);
  overflow:hidden;
  flex-shrink:0;
}
.qmm .stats-weather__icon img{
  width:100%;
  height:100%;
  object-fit:contain;
  image-rendering:pixelated;
}
.qmm .stats-weather__label{
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}
.qmm .stats-list__cell--align-right{ text-align:right; }
.qmm .stats-list__cell--align-center{ text-align:center; }

.qmm .stats-pet-group{
  border:1px solid var(--stats-pet-group-border-color, rgba(255,255,255,.09));
  border-radius:12px;
  padding:10px 12px;
  background:rgba(255,255,255,.05);
  transition:border-color .18s ease, background .18s ease;
  display:flex;
  flex-direction:column;
  align-items:stretch;
  width:100%;
}
.qmm .stats-pet-group + .stats-pet-group{
  margin-top:8px;
}
.qmm .stats-pet-group__summary{
  display:flex;
  align-items:center;
  gap:6px;
  font-weight:650;
  font-size:13px;
  color:var(--qmm-text);
  margin:0;
  user-select:none;
  justify-content:center;
  text-align:center;
}
.qmm .stats-pet-group__content{
  margin-top:8px;
  display:flex;
  flex-direction:column;
  align-items:stretch;
  gap:8px;
}

.qmm-error{
  border:1px solid #ff6a6a55;
  background:rgba(120,20,20,.35);
  border-radius:10px;
  color:#ffdada;
  padding:10px;
  font-size:13px;
  line-height:1.4;
}

.qmm-select{
  background-image:linear-gradient(45deg, transparent 50%, #ffffff80 50%), linear-gradient(135deg, #ffffff80 50%, transparent 50%), linear-gradient(90deg, transparent 50%, rgba(255,255,255,.1) 50%);
  background-position:calc(100% - 18px) 50%, calc(100% - 13px) 50%, 100% 0;
  background-size:5px 5px, 5px 5px, 2.5rem 2.5rem;
  background-repeat:no-repeat;
  padding-right:34px;
}

.qmm-vlist-wrap{ display:flex; flex-direction:column; width:100%; }

/* Inputs */
.qmm-input{
  min-width:90px; background:rgba(255,255,255,0.04); color:#fff;
  border:1px solid rgba(255,255,255,0.12); border-radius:10px;
  padding:8px 10px; box-shadow:inset 0 1px 0 rgba(255,255,255,.06);
  transition:border-color 150ms ease, background 150ms ease, box-shadow 150ms ease;
}
.qmm-input::placeholder{ color:#cbd6e780 }
.qmm-input:focus{ outline:none; border-color:var(--qmm-accent); background:rgba(8,12,20,0.9); box-shadow:0 0 0 2px rgba(94,234,212,0.20) }

/* Number input + spinner (unchanged API) */
.qmm-input-number{ display:inline-flex; align-items:center; gap:6px }
.qmm-input-number-input{ width:70px; text-align:center; padding-right:8px }
.qmm-spin{ display:inline-flex; flex-direction:column; gap:2px }
.qmm-step{
  width:22px; height:16px; font-size:11px; line-height:1;
  display:inline-flex; align-items:center; justify-content:center;
  border-radius:6px; border:1px solid var(--qmm-border);
  background:rgba(255,255,255,.08); color:#fff; cursor:pointer; user-select:none;
  transition:background .18s ease, border-color .18s ease, transform .08s ease;
}
.qmm-step:hover{ background:#ffffff18; border-color:#ffffff40 }
.qmm-step:active{ transform:translateY(1px) }

/* Switch (checkbox) */
.qmm-switch{
  appearance:none; width:42px; height:24px; background:#6c7488aa; border-radius:999px;
  position:relative; outline:none; cursor:pointer; transition:background .18s ease, box-shadow .18s ease;
  box-shadow:inset 0 1px 0 rgba(255,255,255,.12);
}
.qmm-switch::before{
  content:""; position:absolute; top:2px; left:2px; width:20px; height:20px;
  background:#fff; border-radius:50%; transition:transform .2s ease;
  box-shadow:0 2px 8px rgba(0,0,0,.35);
}
.qmm-switch:checked{ background:linear-gradient(180deg, rgba(94,234,212,.90), rgba(45,212,191,.65)) }
.qmm-switch:checked::before{ transform:translateX(18px) }
.qmm-switch:focus-visible{ outline:2px solid var(--qmm-accent); outline-offset:2px }

/* Checkbox & radio (native inputs skinned lightly) */
.qmm-check, .qmm-radio{ transform:scale(1.1); accent-color: var(--qmm-accent) }

/* Slider */
.qmm-range{
  width:180px; appearance:none; background:transparent; height:22px;
}
.qmm-range:focus{ outline:none }
.qmm-range::-webkit-slider-runnable-track{
  height:6px; background:linear-gradient(90deg, var(--qmm-accent), rgba(94,234,212,0.25));
  border-radius:999px; box-shadow:inset 0 1px 0 rgba(255,255,255,.14);
}
.qmm-range::-moz-range-track{
  height:6px; background:linear-gradient(90deg, var(--qmm-accent), rgba(94,234,212,0.25));
  border-radius:999px; box-shadow:inset 0 1px 0 rgba(255,255,255,.14);
}
.qmm-range::-webkit-slider-thumb{
  appearance:none; width:16px; height:16px; border-radius:50%; margin-top:-5px;
  background:#fff; box-shadow:0 2px 10px rgba(0,0,0,.35), 0 0 0 2px #ffffff66 inset;
  transition:transform .1s ease;
}
.qmm-range:active::-webkit-slider-thumb{ transform:scale(1.04) }
.qmm-range::-moz-range-thumb{
  width:16px; height:16px; border-radius:50%; background:#fff; border:none;
  box-shadow:0 2px 10px rgba(0,0,0,.35), 0 0 0 2px #ffffff66 inset;
}

.qmm-range-dual{
  position:relative;
  width:100%;
  padding:18px 0 10px;
}
.qmm-range-dual-track{
  position:absolute;
  left:0;
  right:0;
  top:50%;
  transform:translateY(-50%);
  height:8px;
  border-radius:999px;
  background:linear-gradient(90deg, rgba(8,19,33,.8), rgba(27,43,68,.9));
  box-shadow:inset 0 1px 0 rgba(255,255,255,.08), inset 0 0 0 1px rgba(94,234,212,.08);
}
.qmm-range-dual-fill{
  position:absolute;
  top:50%;
  transform:translateY(-50%);
  height:8px;
  border-radius:999px;
  background:linear-gradient(90deg, var(--qmm-accent), rgba(94,234,212,0.55));
  box-shadow:0 4px 14px rgba(94,234,212,.22);
  transition:left .12s ease, right .12s ease;
}
.qmm-range-dual-input{
  position:absolute;
  left:0;
  right:0;
  top:50%;
  transform:translateY(-50%);
  width:100%;
  height:28px;
  margin:0;
  background:transparent;
  pointer-events:none;
}
.qmm-range-dual-input::-webkit-slider-runnable-track{ background:none; }
.qmm-range-dual-input::-moz-range-track{ background:none; }
.qmm-range-dual-input::-webkit-slider-thumb{
  pointer-events:auto;
  width:18px;
  height:18px;
  border-radius:50%;
  background:linear-gradient(145deg, #fff, #d6f5ef);
  border:2px solid rgba(94,234,212,.65);
  box-shadow:0 4px 12px rgba(0,0,0,.35);
  transition:transform .12s ease, box-shadow .12s ease;
}
.qmm-range-dual-input:active::-webkit-slider-thumb,
.qmm-range-dual-input:focus-visible::-webkit-slider-thumb{
  transform:scale(1.05);
  box-shadow:0 6px 16px rgba(0,0,0,.4);
}
.qmm-range-dual-input::-moz-range-thumb{
  pointer-events:auto;
  width:18px;
  height:18px;
  border-radius:50%;
  background:linear-gradient(145deg, #fff, #d6f5ef);
  border:2px solid rgba(94,234,212,.65);
  box-shadow:0 4px 12px rgba(0,0,0,.35);
  transition:transform .12s ease, box-shadow .12s ease;
}
.qmm-range-dual-input:active::-moz-range-thumb,
.qmm-range-dual-input:focus-visible::-moz-range-thumb{
  transform:scale(1.05);
  box-shadow:0 6px 16px rgba(0,0,0,.4);
}
.qmm-range-dual-input--min{ z-index:2; }
.qmm-range-dual-input--max{ z-index:3; }
.qmm-range-dual-bubble{
  position:absolute;
  top:14px;
  transform:translate(-50%, -100%);
  padding:4px 8px;
  border-radius:6px;
  font-size:11px;
  line-height:1;
  font-weight:600;
  color:#d6f5ef;
  background:rgba(17,28,46,.9);
  box-shadow:0 4px 14px rgba(0,0,0,.35);
  pointer-events:none;
  transition:opacity .12s ease, transform .12s ease;
  opacity:.85;
}
.qmm-range-dual-bubble::after{
  content:"";
  position:absolute;
  left:50%;
  bottom:-4px;
  width:8px;
  height:8px;
  background:inherit;
  transform:translateX(-50%) rotate(45deg);
  border-radius:2px;
  box-shadow:0 4px 14px rgba(0,0,0,.35);
}
.qmm-range-dual-input--min:focus-visible + .qmm-range-dual-bubble--min,
.qmm-range-dual-input--max:focus-visible + .qmm-range-dual-bubble--max,
.qmm-range-dual-input--min:active + .qmm-range-dual-bubble--min,
.qmm-range-dual-input--max:active + .qmm-range-dual-bubble--max{
  opacity:1;
  transform:translate(-50%, -110%) scale(1.02);
}

/* ---------- Minimal table ---------- */
/* container */
.qmm-table-wrap--minimal{
  border:1px solid #263040; border-radius:8px; background:#0b0f14; box-shadow:none;
}
/* scroller (height cap) */
.qmm-table-scroll{
  overflow:auto; max-height:44vh; /* override via opts.maxHeight */
}

/* base */
.qmm-table--minimal{
  width:100%;
  border-collapse:collapse;
  background:transparent;
  font-size:13px; line-height:1.35; color:var(--qmm-text, #cdd6e3);
}

/* header */
.qmm-table--minimal thead th{
  position:sticky; top:0; z-index:1;
  text-align:left; font-weight:600;
  padding:8px 10px;
  color:#cbd5e1; background:#0f1318;
  border-bottom:1px solid #263040;
  text-transform:none; letter-spacing:0;
}
.qmm-table--minimal thead th.is-center { text-align: center; }
.qmm-table--minimal thead th.is-left   { text-align: left; }   /* d\xE9j\xE0 pr\xE9sent, ok */
.qmm-table--minimal thead th.is-right  { text-align: right; }
.qmm-table--minimal thead th,
.qmm-table--minimal td { vertical-align: middle; }

/* cells */
.qmm-table--minimal td{
  padding:8px 10px; border-bottom:1px solid #1f2937; vertical-align:middle;
}
.qmm-table--minimal tbody tr:hover{ background:#0f1824; }

/* compact variant */
.qmm-table--compact thead th,
.qmm-table--compact td{ padding:6px 8px; font-size:12px }

/* utils */
.qmm-table--minimal td.is-num{ text-align:right; font-variant-numeric:tabular-nums }
.qmm-table--minimal td.is-center{ text-align:center }
.qmm-ellipsis{ overflow:hidden; text-overflow:ellipsis; white-space:nowrap }
.qmm-prewrap{ white-space:pre-wrap; word-break:break-word }


/* ---------- Split panels ---------- */
.qmm-split{
  display:grid; gap:12px;
  grid-template-columns:minmax(180px,260px) minmax(0,1fr);
  align-items:start;
}
.qmm-split-left{ display:flex; flex-direction:column; gap:10px }
.qmm-split-right{
  border:1px solid rgba(255,255,255,0.12); border-radius:14px; padding:12px;
  display:flex; flex-direction:column; gap:12px;
  background:linear-gradient(160deg, rgba(15,20,30,0.95), rgba(10,14,20,0.95));
  backdrop-filter:blur(10px);
  box-shadow:0 8px 24px rgba(0,0,0,.35);
}

/* ---------- VTabs (vertical list + filter) ---------- */
.qmm-vtabs{ display:flex; flex-direction:column; gap:8px; min-width:0 }
.qmm-vtabs .filter{ display:block }
.qmm-vtabs .filter input{ width:100% }

.qmm-vlist{
  flex:0 0 auto; overflow:visible;
  border:1px solid var(--qmm-border); border-radius:12px; padding:6px;
  background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
  box-shadow:inset 0 1px 0 rgba(255,255,255,.04);
}

.qmm-vtab{
  width:100%; text-align:left; cursor:pointer;
  display:grid; grid-template-columns:28px 1fr auto; align-items:center; gap:10px;
  padding:8px 10px; border-radius:10px; border:1px solid #ffffff18;
  background:rgba(255,255,255,.03); color:inherit;
  transition:background .18s ease, border-color .18s ease, transform .08s ease;
}
.qmm-vtab:hover{ background:rgba(255,255,255,.07); border-color:#ffffff34 }
.qmm-vtab:active{ transform:translateY(1px) }
.qmm-vtab.active{
  background:linear-gradient(180deg, rgba(94,234,212,.16), rgba(94,234,212,.07));
  border-color:rgba(94,234,212,0.35);
  box-shadow:0 1px 14px rgba(94,234,212,.14) inset;
}

.qmm-dot{ width:10px; height:10px; border-radius:50%; justify-self:center; box-shadow:0 0 0 1px #0006 inset }
.qmm-chip{ display:flex; align-items:center; gap:8px; min-width:0 }
.qmm-chip img{
  width:20px; height:20px; border-radius:50%; object-fit:cover; border:1px solid #4446;
  box-shadow:0 1px 0 rgba(255,255,255,.08) inset;
}
.qmm-chip .t{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis }
.qmm-tag{
  font-size:11px; line-height:1; padding:3px 7px; border-radius:999px;
  background:#ffffff14; border:1px solid #ffffff26;
}

/* ---------- Small helpers (optional) ---------- */
  .qmm .qmm-help{ font-size:12px; color:var(--qmm-text-dim) }
  .qmm .qmm-sep{ height:1px; background:linear-gradient(90deg, transparent, rgba(255,255,255,0.12), transparent); width:100%; border:none; }

/* drag handle */
.qmm-grab {
  margin-left:auto; opacity:.8; cursor:grab; user-select:none;
  display:grid; grid-template-columns:repeat(2, 3px); grid-template-rows:repeat(3, 3px);
  gap:2px; padding:4px 3px; align-content:center; justify-content:center;
}
.qmm-grab:active { cursor:grabbing; }
.qmm-grab-dot {
  width:3px; height:3px; border-radius:999px;
  background:rgba(255,255,255,.82); box-shadow:0 0 0 1px #0005 inset;
}
.qmm-dragging { opacity:.6; }

/* items animables */
.qmm-team-item {
  will-change: transform;
  transition: transform 160ms ease;
}
.qmm-team-item.drag-ghost {
  opacity: .4;
}

.qmm.qmm-alt-drag { cursor: grab; }
.qmm.qmm-alt-drag:active { cursor: grabbing; }

.qws-win.is-hidden { display: none !important; }

.qmm-hotkey{
  cursor:pointer; user-select:none;
  border:1px solid var(--qmm-border); border-radius:10px;
  padding:8px 12px;
  background:linear-gradient(180deg, #ffffff10, #ffffff06);
  color:var(--qmm-text);
  box-shadow:0 1px 0 #000 inset, 0 1px 16px rgba(0,0,0,.18);
  transition:
    background .18s ease,
    border-color .18s ease,
    box-shadow .18s ease,
    transform .08s ease,
    color .18s ease;
}
.qmm-hotkey{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  white-space:nowrap;
  width: var(--qmm-hotkey-w, 180px); 
}
.qmm-hotkey:hover{ background:linear-gradient(180deg, #ffffff16, #ffffff08); border-color:#ffffff40 }
.qmm-hotkey:active{ transform:translateY(1px) }

.qmm-hotkey:focus-visible{ outline:none }

.qmm-hotkey.is-empty{
  color:var(--qmm-text-dim);
  font-style:italic;
}

.qmm-hotkey.is-assigned{
  border-color:rgba(94,234,212,0.40);
  box-shadow:0 1px 0 #000 inset, 0 1px 16px rgba(0,0,0,.18), 0 0 0 2px rgba(94,234,212,0.20);
}

.qmm-hotkey.is-recording{
  outline:2px solid var(--qmm-accent);
  outline-offset:2px;
  border-color:var(--qmm-accent);
  background:linear-gradient(180deg, rgba(94,234,212,.22), rgba(94,234,212,.08));
  animation:qmm-hotkey-breathe 1.2s ease-in-out infinite;
}

@keyframes qmm-hotkey-breathe{
  0%   { box-shadow: 0 0 0 0 rgba(94,234,212,.50), 0 1px 16px rgba(0,0,0,.25); }
  60%  { box-shadow: 0 0 0 12px rgba(94,234,212,0), 0 1px 16px rgba(0,0,0,.25); }
  100% { box-shadow: 0 0 0 0 rgba(94,234,212,0),  0 1px 16px rgba(0,0,0,.25); }
}

/* ---------- Segmented (minimal, modern) ---------- */
.qmm-seg{
  --seg-pad: 8px;
  --seg-radius: 999px;
  --seg-stroke: 1.2px;      /* \xE9paisseur du trait */
  --seg-nudge-x: 0px;       /* micro-ajustements optionnels */
  --seg-nudge-w: 0px;
  --seg-fill: rgba(94,234,212,.07);
  --seg-stroke-color: rgba(94,234,212,.55);

  position: relative;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: var(--seg-pad);
  border-radius: var(--seg-radius);
  background: var(--qmm-bg-soft);
  border: 1px solid var(--qmm-border-2);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
  overflow: hidden;
  background-clip: padding-box; /* important pour que le fond ne passe pas sous la bordure */
}

.qmm-seg--full{ display:flex; width:100% }

.qmm-seg__btn{
  position: relative;
  z-index: 1;
  appearance: none; background: transparent; border: 0; cursor: pointer;
  padding: 8px 14px;
  border-radius: 999px;
  color: var(--qmm-text-dim);
  font: inherit; line-height: 1; white-space: nowrap;
  transition: color .15s ease, transform .06s ease;
}
.qmm-seg__btn-label{
  display: inline-flex;
  align-items: center;
  justify-content: center;
  white-space: inherit;
}
.qmm-compact .qmm-seg__btn{ padding: 6px 10px }
.qmm-seg__btn:hover{ color: var(--qmm-text); }
.qmm-seg__btn.active{ color:#fff; font-weight:600; }
.qmm-seg__btn:active{ transform: translateY(1px); }
.qmm-seg__btn[disabled]{ opacity:.5; cursor:not-allowed; }

.qmm-seg__indicator{
  position: absolute;
  top: 0; left: 0;
  height: 100%;
  width: 40px;                      /* maj en JS */
  border-radius: inherit;
  background: var(--seg-fill);              /* \u2B05\uFE0F applique la couleur */
  outline: var(--seg-stroke,1.2px) solid var(--seg-stroke-color);
  outline-offset: calc(-1 * var(--seg-stroke));

  box-shadow: 0 1px 4px rgba(94,234,212,.08);
  transform-origin: left center;
  will-change: transform, width, opacity;
  transition: transform .18s cubic-bezier(.2,.8,.2,1),
              width .18s cubic-bezier(.2,.8,.2,1),
              opacity .18s ease-out;
  pointer-events: none;
}

/* Accessibilit\xE9 */
@media (prefers-reduced-motion: reduce){
  .qmm-seg__indicator, .qmm-seg__btn { transition: none; }
}

/* ---------- Card bounce utility ---------- */
@keyframes qmm-card-bounce{
  0%   { transform:translateY(0); }
  30%  { transform:translateY(-4px); }
  60%  { transform:translateY(1px); }
  100% { transform:translateY(0); }
}
.qmm-card.is-bouncing{ animation:qmm-card-bounce 320ms ease; }

    `;
      const st = document.createElement("style");
      st.id = "__qmm_css__";
      st.textContent = css3;
      (document.documentElement || document.body).appendChild(st);
    }
  };
  var VTabs = class {
    constructor(api, opts = {}) {
      this.api = api;
      this.opts = opts;
      __publicField(this, "root");
      __publicField(this, "filterWrap", null);
      __publicField(this, "filterInput", null);
      __publicField(this, "list");
      __publicField(this, "listWrap", null);
      __publicField(this, "items", []);
      __publicField(this, "selectedId", null);
      __publicField(this, "onSelectCb");
      __publicField(this, "renderItemCustom");
      __publicField(this, "emptyText");
      this.root = el("div", "qmm-vtabs");
      this.root.style.minWidth = "0";
      this.emptyText = opts.emptyText || "Aucun \xE9l\xE9ment.";
      this.renderItemCustom = opts.renderItem;
      if (opts.filterPlaceholder) {
        this.filterWrap = el("div", "filter");
        this.filterInput = document.createElement("input");
        this.filterInput.type = "search";
        this.filterInput.placeholder = opts.filterPlaceholder;
        this.filterInput.className = "qmm-input";
        this.filterInput.oninput = () => this.renderList();
        this.filterWrap.appendChild(this.filterInput);
        this.root.appendChild(this.filterWrap);
      }
      this.list = el("div", "qmm-vlist");
      this.list.style.minWidth = "0";
      if (opts.maxHeightPx) {
        this.list.style.maxHeight = `${opts.maxHeightPx}px`;
        this.list.style.overflow = "auto";
        this.list.style.flex = "1 1 auto";
      }
      if (opts.fillAvailableHeight) {
        this.listWrap = document.createElement("div");
        this.listWrap.className = "qmm-vlist-wrap";
        Object.assign(this.listWrap.style, {
          flex: "1 1 auto",
          minHeight: "0",
          display: "flex",
          flexDirection: "column"
        });
        this.list.style.flex = "1 1 auto";
        if (!opts.maxHeightPx) this.list.style.overflow = "auto";
        this.listWrap.appendChild(this.list);
        this.root.appendChild(this.listWrap);
      } else {
        this.root.appendChild(this.list);
      }
      this.selectedId = opts.initialId ?? null;
      this.onSelectCb = opts.onSelect;
    }
    setItems(items) {
      this.items = Array.isArray(items) ? items.slice() : [];
      if (this.selectedId && !this.items.some((i) => i.id === this.selectedId)) {
        this.selectedId = this.items[0]?.id ?? null;
      }
      this.renderList();
    }
    getSelected() {
      return this.items.find((i) => i.id === this.selectedId) ?? null;
    }
    select(id) {
      this.selectedId = id;
      this.renderList();
      this.onSelectCb?.(this.selectedId, this.getSelected());
    }
    onSelect(cb) {
      this.onSelectCb = cb;
    }
    setBadge(id, text) {
      const btn = this.list.querySelector(`button[data-id="${cssq(id)}"]`);
      if (!btn) return;
      let tag = btn.querySelector(".qmm-tag");
      if (!tag && text != null) {
        tag = el("span", "qmm-tag");
        btn.appendChild(tag);
      }
      if (!tag) return;
      if (text == null || text === "") tag.style.display = "none";
      else {
        tag.textContent = text;
        tag.style.display = "";
      }
    }
    getFilter() {
      return (this.filterInput?.value || "").trim().toLowerCase();
    }
    renderList() {
      const keepScroll = this.list.scrollTop;
      this.list.innerHTML = "";
      const q = this.getFilter();
      const filtered = q ? this.items.filter((it) => (it.title || "").toLowerCase().includes(q) || (it.subtitle || "").toLowerCase().includes(q)) : this.items;
      if (!filtered.length) {
        const empty = document.createElement("div");
        empty.style.opacity = "0.75";
        empty.textContent = this.emptyText;
        this.list.appendChild(empty);
        return;
      }
      const ul = document.createElement("ul");
      ul.style.listStyle = "none";
      ul.style.margin = "0";
      ul.style.padding = "0";
      ul.style.display = "flex";
      ul.style.flexDirection = "column";
      ul.style.gap = "4px";
      for (const it of filtered) {
        const li = document.createElement("li");
        const btn = document.createElement("button");
        btn.className = "qmm-vtab";
        btn.dataset.id = it.id;
        btn.disabled = !!it.disabled;
        if (this.renderItemCustom) {
          this.renderItemCustom(it, btn);
        } else {
          const dot = el("div", "qmm-dot");
          dot.style.background = it.statusColor || "#999a";
          const chip = el("div", "qmm-chip");
          const img = document.createElement("img");
          img.src = it.avatarUrl || "";
          img.alt = it.title;
          const wrap = document.createElement("div");
          wrap.style.display = "flex";
          wrap.style.flexDirection = "column";
          wrap.style.gap = "2px";
          const t = el("div", "t");
          t.textContent = it.title;
          const sub = document.createElement("div");
          sub.textContent = it.subtitle || "";
          sub.style.opacity = "0.7";
          sub.style.fontSize = "12px";
          if (!it.subtitle) sub.style.display = "none";
          wrap.appendChild(t);
          wrap.appendChild(sub);
          chip.appendChild(img);
          chip.appendChild(wrap);
          btn.appendChild(dot);
          btn.appendChild(chip);
          if (it.badge != null) {
            const tag = el("span", "qmm-tag", escapeHtml(String(it.badge)));
            btn.appendChild(tag);
          } else {
            const spacer = document.createElement("div");
            spacer.style.width = "0";
            btn.appendChild(spacer);
          }
        }
        btn.classList.toggle("active", it.id === this.selectedId);
        btn.onclick = () => this.select(it.id);
        li.appendChild(btn);
        ul.appendChild(li);
      }
      this.list.appendChild(ul);
      this.list.scrollTop = keepScroll;
    }
  };
  function el(tag, cls, html) {
    const e = document.createElement(tag);
    if (cls) e.className = cls;
    if (html != null) e.innerHTML = html;
    return e;
  }
  function cssq(s) {
    return s.replace(/"/g, '\\"');
  }
  function escapeHtml(s) {
    return s.replace(/[&<>"']/g, (m) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" })[m]);
  }
  var _MOD_CODES = /* @__PURE__ */ new Set([
    "ShiftLeft",
    "ShiftRight",
    "ControlLeft",
    "ControlRight",
    "AltLeft",
    "AltRight",
    "MetaLeft",
    "MetaRight"
  ]);
  function codesMatch(expected, actual) {
    if (expected === actual) return true;
    const altCodes = expected === "AltLeft" || expected === "AltRight";
    const ctrlCodes = expected === "ControlLeft" || expected === "ControlRight";
    const shiftCodes = expected === "ShiftLeft" || expected === "ShiftRight";
    const metaCodes = expected === "MetaLeft" || expected === "MetaRight";
    if (altCodes && (actual === "AltLeft" || actual === "AltRight")) return true;
    if (ctrlCodes && (actual === "ControlLeft" || actual === "ControlRight")) return true;
    if (shiftCodes && (actual === "ShiftLeft" || actual === "ShiftRight")) return true;
    if (metaCodes && (actual === "MetaLeft" || actual === "MetaRight")) return true;
    return false;
  }
  function isMac() {
    return navigator.platform?.toLowerCase().includes("mac") || /mac|iphone|ipad|ipod/i.test(navigator.userAgent);
  }
  function eventToHotkey(e, allowModifierOnly = false) {
    const isModifier = _MOD_CODES.has(e.code) || e.key === "Shift" || e.key === "Control" || e.key === "Alt" || e.key === "Meta";
    if (isModifier && !allowModifierOnly) {
      return null;
    }
    return {
      code: e.code,
      ctrl: e.ctrlKey,
      alt: e.altKey,
      shift: e.shiftKey,
      meta: e.metaKey
    };
  }
  function matchHotkey(e, h) {
    if (!h) return false;
    if (!!h.ctrl !== e.ctrlKey) return false;
    if (!!h.shift !== e.shiftKey) return false;
    if (!!h.alt !== e.altKey) return false;
    if (!!h.meta !== e.metaKey) return false;
    return codesMatch(h.code, e.code);
  }
  function hotkeyToString(hk) {
    if (!hk) return "";
    const parts = [];
    if (hk.ctrl) parts.push("Ctrl");
    if (hk.shift) parts.push("Shift");
    if (hk.alt) parts.push("Alt");
    if (hk.meta) parts.push("Meta");
    if (hk.code) parts.push(hk.code);
    return parts.join("+");
  }
  function stringToHotkey(s) {
    if (!s) return null;
    const parts = s.split("+").map((p) => p.trim()).filter(Boolean);
    if (!parts.length) return null;
    const code = canonicalizeCode(parts.pop() || "");
    const hk = { code };
    for (const p of parts) {
      const P = p.toLowerCase();
      if (P === "ctrl" || P === "control") hk.ctrl = true;
      else if (P === "shift") hk.shift = true;
      else if (P === "alt") hk.alt = true;
      else if (P === "meta" || P === "cmd" || P === "command") hk.meta = true;
    }
    return hk.code ? hk : null;
  }
  var CANONICAL_CODES = {
    space: "Space",
    enter: "Enter",
    escape: "Escape",
    tab: "Tab",
    backspace: "Backspace",
    delete: "Delete",
    insert: "Insert",
    home: "Home",
    end: "End",
    pageup: "PageUp",
    pagedown: "PageDown",
    arrowup: "ArrowUp",
    arrowdown: "ArrowDown",
    arrowleft: "ArrowLeft",
    arrowright: "ArrowRight",
    bracketleft: "BracketLeft",
    bracketright: "BracketRight",
    backslash: "Backslash",
    slash: "Slash",
    minus: "Minus",
    equal: "Equal",
    semicolon: "Semicolon",
    quote: "Quote",
    backquote: "Backquote",
    comma: "Comma",
    period: "Period",
    dot: "Period",
    capslock: "CapsLock",
    numlock: "NumLock",
    scrolllock: "ScrollLock",
    pause: "Pause",
    contextmenu: "ContextMenu",
    printscreen: "PrintScreen",
    metaleft: "MetaLeft",
    metaright: "MetaRight",
    altleft: "AltLeft",
    altright: "AltRight",
    controlleft: "ControlLeft",
    controlright: "ControlRight",
    shiftleft: "ShiftLeft",
    shiftright: "ShiftRight"
  };
  function canonicalizeCode(rawCode) {
    const trimmed = rawCode.trim();
    if (!trimmed) return "";
    const lower = trimmed.toLowerCase();
    const keyMatch = lower.match(/^key([a-z])$/);
    if (keyMatch) return `Key${keyMatch[1].toUpperCase()}`;
    const digitMatch = lower.match(/^digit([0-9])$/);
    if (digitMatch) return `Digit${digitMatch[1]}`;
    const numpadDigitMatch = lower.match(/^numpad([0-9])$/);
    if (numpadDigitMatch) return `Numpad${numpadDigitMatch[1]}`;
    if (lower.startsWith("numpad")) {
      const suffix = lower.slice(6);
      if (!suffix) return "Numpad";
      const mappedSuffix = CANONICAL_CODES[suffix] ?? capitalizeWord(suffix);
      return `Numpad${mappedSuffix}`;
    }
    const fMatch = lower.match(/^f([0-9]{1,2})$/);
    if (fMatch) return `F${fMatch[1]}`;
    const arrowMatch = lower.match(/^arrow([a-z]+)$/);
    if (arrowMatch) {
      const suffix = arrowMatch[1];
      const mappedSuffix = CANONICAL_CODES[suffix] ?? capitalizeWord(suffix);
      return `Arrow${mappedSuffix}`;
    }
    if (CANONICAL_CODES[lower]) {
      return CANONICAL_CODES[lower];
    }
    return trimmed[0].toUpperCase() + trimmed.slice(1);
  }
  function capitalizeWord(word) {
    if (!word) return "";
    return word[0].toUpperCase() + word.slice(1);
  }
  function prettyCode(code) {
    if (code === "AltLeft" || code === "AltRight") return "Alt";
    if (code === "ControlLeft" || code === "ControlRight") return "Ctrl";
    if (code === "ShiftLeft" || code === "ShiftRight") return "Shift";
    if (code === "MetaLeft" || code === "MetaRight") return isMac() ? "\u2318" : "Meta";
    if (code.startsWith("Key")) return code.slice(3);
    if (code.startsWith("Digit")) return code.slice(5);
    if (code.startsWith("Numpad")) return "Numpad " + code.slice(6);
    const arrows = { ArrowUp: "\u2191", ArrowDown: "\u2193", ArrowLeft: "\u2190", ArrowRight: "\u2192" };
    if (arrows[code]) return arrows[code];
    return code;
  }
  function hotkeyToPretty(h) {
    if (!h) return "\u2014";
    const mac = isMac();
    const mods = [];
    if (mac) {
      if (h.ctrl) mods.push("\u2303");
      if (h.alt) mods.push("\u2325");
      if (h.shift) mods.push("\u21E7");
      if (h.meta) mods.push("\u2318");
    } else {
      if (h.ctrl) mods.push("Ctrl");
      if (h.alt) mods.push("Alt");
      if (h.shift) mods.push("Shift");
      if (h.meta) mods.push("Meta");
    }
    const modifierCode = h.alt && (h.code === "AltLeft" || h.code === "AltRight") || h.ctrl && (h.code === "ControlLeft" || h.code === "ControlRight") || h.shift && (h.code === "ShiftLeft" || h.code === "ShiftRight") || h.meta && (h.code === "MetaLeft" || h.code === "MetaRight");
    const parts = mods.slice();
    const codePretty = prettyCode(h.code);
    if (!modifierCode || parts.length === 0) {
      parts.push(codePretty);
    }
    if (!parts.length) return codePretty;
    return parts.join(mac ? "" : " + ");
  }

  // src/services/keybinds.ts
  var SECTION_CONFIG = [
    {
      id: "gui",
      title: "GUI",
      icon: "\u{1F5A5}\uFE0F",
      description: "Choose how you open and move the overlay.",
      actions: [
        {
          id: "gui.toggle",
          label: "\u{1F441}\uFE0F Toggle menu visibility",
          hint: "Opens or closes the Arie's Mod overlay.",
          defaultHotkey: { alt: true, code: "KeyX" }
        },
        {
          id: "gui.drag",
          label: "\u270B Drag HUD",
          hint: "Hold to drag menus interfaces around the screen.",
          defaultHotkey: { alt: true, code: "AltLeft" },
          allowModifierOnly: true
        }
      ]
    },
    {
      id: "shops",
      title: "Shops",
      icon: "\u{1F6D2}",
      description: "Quick shortcuts to every shop tab.",
      actions: [
        {
          id: "shops.seeds",
          label: "\u{1F330} Seeds shop",
          defaultHotkey: { alt: true, code: "KeyS" }
        },
        {
          id: "shops.eggs",
          label: "\u{1F95A} Eggs shop",
          defaultHotkey: { alt: true, code: "KeyE" }
        },
        {
          id: "shops.decors",
          label: "\u{1FA91} Decors shop",
          defaultHotkey: { alt: true, code: "KeyD" }
        },
        {
          id: "shops.tools",
          label: "\u{1F9FA} Tools shop",
          defaultHotkey: { alt: true, code: "KeyT" }
        }
      ]
    },
    {
      id: "game",
      title: "Game",
      icon: "\u{1F3AE}",
      description: "Remap the in-game actions",
      actions: [
        {
          id: "game.action",
          label: "\u26A1 Action",
          defaultHotkey: { code: "Space" },
          holdDetection: {
            label: "Hold to repeat",
            defaultEnabled: false
          }
        },
        {
          id: "game.inventory",
          label: "\u{1F392} Inventory",
          defaultHotkey: { code: "KeyE" }
        },
        {
          id: "game.pet-hutch",
          label: "\u{1F3E0} Pet hutch",
          defaultHotkey: null,
          allowClear: true
        },
        {
          id: "game.decor-shed",
          label: "\u{1F9F4} Decor shed",
          defaultHotkey: null,
          allowClear: true
        },
        {
          id: "game.seed-silo",
          label: "\u{1F33E} Seed Silo",
          defaultHotkey: null,
          allowClear: true
        },
        {
          id: "game.journal",
          label: "\u{1F4D4} Journal",
          defaultHotkey: null,
          allowClear: true
        },
        {
          id: "game.move-up",
          label: "\u2B06 Move up",
          defaultHotkey: { code: "KeyW" }
        },
        {
          id: "game.move-down",
          label: "\u2B07 Move down",
          defaultHotkey: { code: "KeyS" }
        },
        {
          id: "game.move-left",
          label: "\u2B05 Move left",
          defaultHotkey: { code: "KeyA" }
        },
        {
          id: "game.move-right",
          label: "\u27A1 Move right",
          defaultHotkey: { code: "KeyD" }
        }
      ]
    },
    {
      id: "sell",
      title: "Sell",
      icon: "\u{1F4B0}",
      description: "Streamline selling actions.",
      actions: [
        {
          id: "sell.sell-all",
          label: "\u{1F33E} All crops",
          hint: "Trigger the sell-all flow for harvested crops.",
          defaultHotkey: null
        },
        {
          id: "sell.sell-all-pets",
          label: "\u{1F43E} All pets",
          hint: "Sell every non-favorited pet in your inventory.",
          defaultHotkey: null
        }
      ]
    },
    {
      id: "editor",
      title: "Editor",
      icon: "\u{1F4DD}",
      description: "Shortcuts for placing/removing items and toggling editor overlays.",
      actions: [
        {
          id: "editor.place-remove",
          label: "Place / Remove item",
          hint: "Place selected item on empty tile, or remove the item under your feet.",
          defaultHotkey: { code: "Space" }
        },
        {
          id: "editor.toggle-overlays",
          label: "Toggle editor overlays",
          hint: "Show or hide the editor panels.",
          defaultHotkey: { code: "KeyU" }
        },
        {
          id: "editor.delete-inventory",
          label: "Remove selected item from inventory",
          hint: "Remove the currently selected inventory item.",
          defaultHotkey: { code: "Delete" }
        }
      ]
    }
  ];
  var KEYBINDS_BINDINGS_PATH = "keybinds.bindings";
  var KEYBINDS_HOLD_PATH = "keybinds.hold";
  var ARIES_ROOT_KEY = "aries_mod";
  var STORED_NONE = "__none__";
  var actionMap = /* @__PURE__ */ new Map();
  var defaultMap = /* @__PURE__ */ new Map();
  var cache = /* @__PURE__ */ new Map();
  var listeners2 = /* @__PURE__ */ new Map();
  var holdDefaultMap = /* @__PURE__ */ new Map();
  var holdCache = /* @__PURE__ */ new Map();
  var holdListeners = /* @__PURE__ */ new Map();
  var keybindSections = SECTION_CONFIG.map((section) => {
    const actions = section.actions.map((action2) => {
      const normalized = {
        id: action2.id,
        sectionId: section.id,
        label: action2.label,
        hint: action2.hint,
        allowModifierOnly: action2.allowModifierOnly,
        allowClear: action2.allowClear,
        defaultHotkey: cloneHotkey(action2.defaultHotkey),
        holdDetection: action2.holdDetection ? {
          label: action2.holdDetection.label,
          description: action2.holdDetection.description,
          defaultEnabled: action2.holdDetection.defaultEnabled
        } : void 0
      };
      actionMap.set(normalized.id, normalized);
      defaultMap.set(normalized.id, cloneHotkey(action2.defaultHotkey));
      if (action2.holdDetection) {
        holdDefaultMap.set(normalized.id, !!action2.holdDetection.defaultEnabled);
      }
      return normalized;
    });
    return {
      id: section.id,
      title: section.title,
      description: section.description,
      icon: section.icon,
      actions
    };
  });
  var PET_SECTION_ID = "pets";
  var PET_TEAM_ACTION_PREFIX = "pets.team.";
  var PET_TEAM_NEXT_ID = "pets.team.next";
  var PET_TEAM_PREV_ID = "pets.team.prev";
  var petSection = {
    id: PET_SECTION_ID,
    title: "Pets",
    icon: "\u{1F437}",
    description: "Assign shortcuts to your pet teams and cycle through them instantly.",
    actions: []
  };
  keybindSections.push(petSection);
  var petActionIds = /* @__PURE__ */ new Set();
  function getPetTeamActionId(teamId) {
    return `${PET_TEAM_ACTION_PREFIX}${teamId}`;
  }
  function disposePetAction(id) {
    actionMap.delete(id);
    defaultMap.delete(id);
    cache.delete(id);
    listeners2.delete(id);
    holdDefaultMap.delete(id);
    holdCache.delete(id);
    holdListeners.delete(id);
  }
  function registerPetAction(action2, defaultHotkey) {
    const normalized = {
      id: action2.id,
      sectionId: PET_SECTION_ID,
      label: action2.label,
      hint: action2.hint,
      allowModifierOnly: action2.allowModifierOnly,
      defaultHotkey: cloneHotkey(defaultHotkey),
      holdDetection: action2.holdDetection ? {
        label: action2.holdDetection.label,
        description: action2.holdDetection.description,
        defaultEnabled: action2.holdDetection.defaultEnabled
      } : void 0
    };
    actionMap.set(normalized.id, normalized);
    defaultMap.set(normalized.id, cloneHotkey(defaultHotkey));
    petActionIds.add(normalized.id);
    petSection.actions.push(normalized);
  }
  function updatePetKeybinds(teams) {
    for (const id of petActionIds) {
      disposePetAction(id);
    }
    petActionIds.clear();
    petSection.actions = [];
    registerPetAction(
      {
        id: PET_TEAM_PREV_ID,
        sectionId: PET_SECTION_ID,
        label: "\u25C0\uFE0F Previous team",
        defaultHotkey: null
      },
      null
    );
    registerPetAction(
      {
        id: PET_TEAM_NEXT_ID,
        sectionId: PET_SECTION_ID,
        label: "\u25B6\uFE0F Next team",
        defaultHotkey: null
      },
      null
    );
    teams.forEach((team, index) => {
      const name = String(team?.name || "").trim();
      const labelName = name.length ? name : `Team ${index + 1}`;
      registerPetAction(
        {
          id: getPetTeamActionId(team.id),
          sectionId: PET_SECTION_ID,
          label: `Use team \u2014 ${labelName}`,
          defaultHotkey: null
        },
        null
      );
    });
  }
  updatePetKeybinds([]);
  var GAME_KEYBIND_TARGETS = {
    "game.action": "Space",
    "game.inventory": "KeyE",
    "game.move-up": "KeyW",
    // Z (AZERTY) == KeyW
    "game.move-down": "KeyS",
    // S
    "game.move-left": "KeyA",
    // Q (AZERTY) == KeyA
    "game.move-right": "KeyD"
    // D
  };
  var GAME_KEYBIND_IDS = [
    "game.action",
    "game.inventory",
    "game.move-up",
    "game.move-down",
    "game.move-left",
    "game.move-right"
  ];
  var gameActiveStates = /* @__PURE__ */ new Map();
  var gameKeybindsInstalled = false;
  var GAME_ACTION_ID = "game.action";
  var gameActionBlockers = /* @__PURE__ */ new Set();
  var gameActionBlockedCombos = /* @__PURE__ */ new Set();
  function getCombosForGameAction() {
    const state3 = gameActiveStates.get(GAME_ACTION_ID);
    if (!state3) return [];
    const combo = state3.combo;
    return typeof combo === "string" && combo.length ? [combo] : [];
  }
  function applyGameActionBlockers() {
    const shouldBlock = gameActionBlockers.size > 0;
    const desired = /* @__PURE__ */ new Set();
    if (shouldBlock) {
      for (const combo of getCombosForGameAction()) {
        if (combo) desired.add(combo);
      }
    }
    for (const combo of gameActionBlockedCombos) {
      if (!desired.has(combo)) {
        try {
          inGameHotkeys.unblock(combo);
        } catch {
        }
      }
    }
    if (shouldBlock) {
      for (const combo of desired) {
        if (!gameActionBlockedCombos.has(combo)) {
          try {
            inGameHotkeys.block(combo);
          } catch {
          }
        }
      }
    }
    gameActionBlockedCombos.clear();
    if (shouldBlock) {
      for (const combo of desired) gameActionBlockedCombos.add(combo);
    }
  }
  function hotkeyToCombo(hk) {
    if (!hk) return null;
    const combo = hotkeyToString(hk);
    return combo.length ? combo : null;
  }
  function purgeTargetBindings(emitCombo) {
    try {
      inGameHotkeys.unblock(emitCombo);
    } catch {
    }
    try {
      const curr = inGameHotkeys.current();
      for (const [from, to] of Object.entries(curr)) {
        const toCode = String(to).split("+").pop();
        if (toCode === emitCombo) {
          try {
            inGameHotkeys.remove(from);
          } catch {
          }
        }
      }
    } catch {
    }
  }
  function isMac2() {
    return typeof navigator !== "undefined" && /Mac|iPhone|iPad|iPod/.test(navigator.platform || "");
  }
  function codeToDisplay(code) {
    if (!code) return "";
    const mKey = code.match(/^Key([A-Z])$/);
    if (mKey) return mKey[1];
    const mDigit = code.match(/^Digit([0-9])$/);
    if (mDigit) return mDigit[1];
    if (code === "ControlLeft" || code === "ControlRight") return "Ctrl";
    if (code === "AltLeft" || code === "AltRight") return "Alt";
    if (code === "ShiftLeft" || code === "ShiftRight") return "Shift";
    if (code === "MetaLeft" || code === "MetaRight") return isMac2() ? "\xE2\u0152\u02DC" : "Win";
    if (code === "Space") return "Space";
    if (code === "Enter") return "Enter";
    if (code === "Escape") return "Esc";
    if (code === "Tab") return "Tab";
    if (code === "Backspace") return "Backspace";
    if (code === "Delete") return "Del";
    if (code === "Insert") return "Ins";
    if (code === "ArrowUp") return "\xE2\u2020\u2018";
    if (code === "ArrowDown") return "\xE2\u2020\u201C";
    if (code === "ArrowLeft") return "\xE2\u2020\x90";
    if (code === "ArrowRight") return "\xE2\u2020\u2019";
    return code;
  }
  function prettyHotkey(hk) {
    if (!hk) return "\xE2\u20AC\u201D";
    const mods = [];
    if (hk.ctrl) mods.push("Ctrl");
    if (hk.shift) mods.push("Shift");
    if (hk.alt) mods.push("Alt");
    if (hk.meta) mods.push(isMac2() ? "\xE2\u0152\u02DC" : "Win");
    let base = "";
    const k = hk.key;
    if (typeof k === "string" && k.length === 1) {
      base = k.toUpperCase();
    } else {
      base = codeToDisplay(hk.code);
    }
    const baseIsModifier = base && ["Ctrl", "Shift", "Alt", "\xE2\u0152\u02DC", "Win"].includes(base);
    const parts = baseIsModifier ? mods : mods.concat(base ? [base] : []);
    return parts.join(" + ");
  }
  function syncGameKeybind(id) {
    if (typeof window === "undefined") return;
    const emitCombo = GAME_KEYBIND_TARGETS[id];
    purgeTargetBindings(emitCombo);
    const prev = gameActiveStates.get(id);
    if (prev) {
      if (prev.rapidFire) {
        try {
          inGameHotkeys.stopRapidFire(prev.combo);
        } catch {
        }
      }
      gameActiveStates.delete(id);
    }
    const combo = hotkeyToCombo(getKeybind(id));
    if (!combo) {
      if (id === GAME_ACTION_ID) {
        applyGameActionBlockers();
      }
      return;
    }
    const holdEnabled = getKeybindHoldDetection(id);
    let replaced = false;
    if (combo !== emitCombo) {
      try {
        inGameHotkeys.replace(emitCombo, combo);
        replaced = true;
      } catch {
      }
    }
    let rapidFire = false;
    if (holdEnabled) {
      try {
        inGameHotkeys.startRapidFire({
          trigger: combo,
          // on tient la touche choisie
          emit: combo,
          // remapper convertira en emitCombo si replace() actif
          mode: "tap",
          rateHz: 10
        });
        rapidFire = true;
      } catch {
      }
    }
    gameActiveStates.set(id, { combo, replaced, rapidFire });
    if (id === GAME_ACTION_ID) {
      applyGameActionBlockers();
    }
  }
  function cloneHotkey(hk) {
    return hk ? { ...hk } : null;
  }
  function hotkeysEqual(a, b) {
    if (!a && !b) return true;
    if (!a || !b) return false;
    return hotkeyToString(a) === hotkeyToString(b);
  }
  function readStored(id) {
    if (typeof window === "undefined") return void 0;
    const map2 = readAriesPath(KEYBINDS_BINDINGS_PATH);
    const raw = map2?.[id];
    if (raw == null) return void 0;
    if (raw === STORED_NONE) return null;
    if (typeof raw !== "string") return null;
    const parsed = stringToHotkey(raw);
    return parsed ?? null;
  }
  function writeStored(id, hk) {
    if (typeof window === "undefined") return;
    updateAriesPath(KEYBINDS_BINDINGS_PATH, (current) => {
      const base = current && typeof current === "object" ? { ...current } : {};
      if (hk) {
        base[id] = hotkeyToString(hk);
      } else {
        base[id] = STORED_NONE;
      }
      return base;
    });
  }
  function removeStored(id) {
    if (typeof window === "undefined") return;
    updateAriesPath(KEYBINDS_BINDINGS_PATH, (current) => {
      const base = current && typeof current === "object" ? { ...current } : {};
      delete base[id];
      return base;
    });
  }
  function readHoldStored(id) {
    if (typeof window === "undefined") return void 0;
    const map2 = readAriesPath(KEYBINDS_HOLD_PATH);
    const raw = map2?.[id];
    if (raw == null) return void 0;
    if (typeof raw === "string") return raw === "1";
    if (typeof raw === "number") return raw === 1;
    if (typeof raw === "boolean") return raw;
    return void 0;
  }
  function writeHoldStored(id, enabled) {
    if (typeof window === "undefined") return;
    updateAriesPath(KEYBINDS_HOLD_PATH, (current) => {
      const base = current && typeof current === "object" ? { ...current } : {};
      base[id] = !!enabled;
      return base;
    });
  }
  function emitHoldChange(id) {
    const set3 = holdListeners.get(id);
    if (!set3 || set3.size === 0) return;
    const current = getKeybindHoldDetection(id);
    for (const cb of set3) cb(current);
  }
  function emitChange(id) {
    const set3 = listeners2.get(id);
    if (!set3 || set3.size === 0) return;
    const current = cloneHotkey(getKeybind(id));
    for (const cb of set3) cb(current);
  }
  function ensureCache(id) {
    if (cache.has(id)) {
      return cloneHotkey(cache.get(id) ?? null);
    }
    const stored = readStored(id);
    const resolved = stored === void 0 ? cloneHotkey(defaultMap.get(id) ?? null) : cloneHotkey(stored);
    cache.set(id, resolved);
    return cloneHotkey(resolved);
  }
  function ensureHoldCache(id) {
    if (!holdDefaultMap.has(id)) return false;
    if (holdCache.has(id)) {
      return holdCache.get(id) ?? false;
    }
    const stored = readHoldStored(id);
    const resolved = stored === void 0 ? !!holdDefaultMap.get(id) : stored;
    holdCache.set(id, resolved);
    return resolved;
  }
  function getKeybind(id) {
    return ensureCache(id);
  }
  function getDefaultKeybind(id) {
    return cloneHotkey(defaultMap.get(id) ?? null);
  }
  function setKeybind(id, hk) {
    const current = getKeybind(id);
    if (hotkeysEqual(current, hk)) return;
    const next = cloneHotkey(hk);
    if (next) {
      const asString = hotkeyToString(next);
      for (const otherId of actionMap.keys()) {
        if (otherId === id) continue;
        const other = getKeybind(otherId);
        if (!other) continue;
        if (hotkeyToString(other) !== asString) continue;
        cache.set(otherId, null);
        writeStored(otherId, null);
        emitChange(otherId);
      }
    }
    cache.set(id, next);
    writeStored(id, next);
    emitChange(id);
  }
  function resetKeybind(id) {
    cache.delete(id);
    removeStored(id);
    emitChange(id);
  }
  function getKeybindHoldDetection(id) {
    return ensureHoldCache(id);
  }
  function setKeybindHoldDetection(id, enabled) {
    if (!holdDefaultMap.has(id)) return;
    const current = ensureHoldCache(id);
    if (current === enabled) return;
    holdCache.set(id, enabled);
    writeHoldStored(id, enabled);
    emitHoldChange(id);
  }
  function onKeybindHoldDetectionChange(id, cb) {
    if (!holdDefaultMap.has(id)) {
      return () => {
      };
    }
    const set3 = holdListeners.get(id) ?? /* @__PURE__ */ new Set();
    if (!holdListeners.has(id)) holdListeners.set(id, set3);
    set3.add(cb);
    return () => {
      set3.delete(cb);
      if (set3.size === 0) holdListeners.delete(id);
    };
  }
  function onKeybindChange(id, cb) {
    const set3 = listeners2.get(id) ?? /* @__PURE__ */ new Set();
    if (!listeners2.has(id)) listeners2.set(id, set3);
    set3.add(cb);
    return () => {
      set3.delete(cb);
      if (set3.size === 0) listeners2.delete(id);
    };
  }
  function eventMatchesKeybind(id, e) {
    return matchHotkey(e, getKeybind(id));
  }
  function installGameKeybindsOnce() {
    if (gameKeybindsInstalled || typeof window === "undefined") return;
    gameKeybindsInstalled = true;
    for (const id of GAME_KEYBIND_IDS) {
      syncGameKeybind(id);
      onKeybindChange(id, () => syncGameKeybind(id));
      onKeybindHoldDetectionChange(id, () => syncGameKeybind(id));
    }
  }
  function getKeybindLabel(id) {
    return prettyHotkey(getKeybind(id));
  }
  function getKeybindSections() {
    return keybindSections.map((section) => ({
      ...section,
      actions: section.actions.map((action2) => ({
        ...action2,
        defaultHotkey: cloneHotkey(action2.defaultHotkey),
        holdDetection: action2.holdDetection ? {
          label: action2.holdDetection.label,
          description: action2.holdDetection.description,
          defaultEnabled: action2.holdDetection.defaultEnabled
        } : void 0
      }))
    }));
  }
  if (typeof window !== "undefined") {
    window.addEventListener("storage", (event) => {
      if (event.key !== ARIES_ROOT_KEY) return;
      cache.clear();
      holdCache.clear();
      for (const id of actionMap.keys()) emitChange(id);
      for (const id of holdDefaultMap.keys()) emitHoldChange(id);
    });
  }

  // src/utils/keyboard.ts
  function shouldIgnoreKeydown(e) {
    const el2 = e.target;
    if (!el2) return false;
    return el2.isContentEditable || el2.tagName === "INPUT" || el2.tagName === "TEXTAREA" || el2.tagName === "SELECT";
  }

  // src/core/audioPlayer.ts
  var AudioPlayer = class {
    constructor(opts = {}) {
      __publicField(this, "found", /* @__PURE__ */ new Set());
      __publicField(this, "meta", /* @__PURE__ */ new Map());
      __publicField(this, "groupsMap", /* @__PURE__ */ new Map());
      // config volume
      __publicField(this, "atomKey");
      __publicField(this, "min");
      __publicField(this, "max");
      __publicField(this, "gainFactor");
      // Howler cache local
      __publicField(this, "howler", null);
      // options
      __publicField(this, "minVariantsPerAutoGroup");
      this.atomKey = opts.atomKey ?? "soundEffectsVolumeAtom";
      this.min = opts.min ?? 1e-3;
      this.max = opts.max ?? 0.2000000000000001;
      this.gainFactor = opts.gainFactor ?? 1;
      this.minVariantsPerAutoGroup = opts.minVariantsPerAutoGroup ?? 2;
      if (opts.autoScan) void this.init();
    }
    /** Lance un scan initial et reconstruit les groupes auto. */
    async init() {
      await this.scanAll();
    }
    // ----------------- Utils -----------------
    abs(u) {
      try {
        return new URL(u, location.href).href;
      } catch {
        return u;
      }
    }
    isMP3(u) {
      return /\.mp3(?:[\?#][^\s'"]*)?$/i.test(u);
    }
    fileName(u) {
      try {
        return new URL(u, location.href).pathname.split("/").pop() || u;
      } catch {
        return String(u);
      }
    }
    logicalName(fileName) {
      return fileName.replace(/-[A-Za-z0-9_=-]{6,}(?=\.mp3$)/i, "");
    }
    clamp(x, a, b) {
      return Math.max(a, Math.min(b, x));
    }
    choose(arr) {
      return arr && arr.length ? arr[Math.random() * arr.length | 0] : void 0;
    }
    toKey(name) {
      return String(name || "").trim().toLowerCase();
    }
    add(u, sourceTag) {
      if (!u || !this.isMP3(u)) return;
      const url = this.abs(u);
      if (!this.found.has(url)) {
        this.found.add(url);
        const name = this.fileName(url);
        this.meta.set(url, { from: /* @__PURE__ */ new Set([sourceTag]), name, logicalName: this.logicalName(name) });
      } else {
        this.meta.get(url)?.from.add(sourceTag);
      }
    }
    refreshHowler() {
      this.howler = window.Howler && Array.isArray(window.Howler._howls) ? window.Howler : null;
      return this.howler;
    }
    sameAsset(a, b) {
      try {
        const A = new URL(a, location.href).href;
        const B = new URL(b, location.href).href;
        if (A === B) return true;
        const fn = (p) => new URL(p, location.href).pathname.split("/").pop();
        const la = this.logicalName(fn(A));
        const lb = this.logicalName(fn(B));
        return la === lb;
      } catch {
        return a === b;
      }
    }
    readAtomRaw() {
      const raw = localStorage.getItem(this.atomKey);
      if (raw == null) return null;
      try {
        const val = JSON.parse(raw);
        if (typeof val === "number") return val;
        const m = JSON.stringify(val).match(/-?\d+(?:\.\d+)?/);
        return m ? parseFloat(m[0]) : null;
      } catch {
        const m = String(raw).match(/-?\d+(?:\.\d+)?/);
        return m ? parseFloat(m[0]) : null;
      }
    }
    howlerMaster() {
      try {
        return window.Howler && typeof window.Howler.volume === "function" ? window.Howler.volume() : 1;
      } catch {
        return 1;
      }
    }
    // 0.001 est considr comme un vrai mute ( 0)
    finalVolumeObj() {
      let raw = this.readAtomRaw();
      if (raw == null) raw = this.max;
      const clamped = this.clamp(raw, this.min, this.max);
      const nearMute = Math.abs(clamped - this.min) < 1e-6 ? 0 : clamped;
      const vol = nearMute * this.howlerMaster() * this.gainFactor;
      return { raw, clamped, vol };
    }
    // ----------------- Scanners -----------------
    async scanPerformance() {
      performance.getEntriesByType("resource").map((e) => e.name).filter(Boolean).forEach((u) => this.add(u, "perf"));
    }
    async scanHowler() {
      this.refreshHowler();
      if (!this.howler) return;
      this.howler._howls.forEach((h) => {
        const src = h && (h._src || h._urls && h._urls[0]);
        if (src) this.add(src, "howler");
      });
    }
    async scanCaches() {
      if (!("caches" in window)) return;
      try {
        const keys = await caches.keys();
        for (const k of keys) {
          const c = await caches.open(k);
          const reqs = await c.keys();
          for (const r of reqs) {
            const u = r.url;
            if (this.isMP3(u)) this.add(u, `cache:${k}`);
          }
        }
      } catch {
      }
    }
    async fetchText(u) {
      try {
        const res = await fetch(u, { mode: "same-origin", credentials: "same-origin" });
        if (!res.ok) return "";
        const ct = res.headers.get("content-type") || "";
        if (!/javascript|ecmascript|css|html/i.test(ct)) return "";
        return await res.text();
      } catch {
        return "";
      }
    }
    extractMp3s(text) {
      if (!text) return [];
      const re = /["'`](\/?[^"'`)\s]+?\.mp3(?:\?[^"'`\s]*)?)["'`]/ig;
      const out = [];
      let m;
      while (m = re.exec(text)) out.push(m[1]);
      return out;
    }
    async scanResourcesForRefs() {
      const urls = /* @__PURE__ */ new Set();
      document.querySelectorAll('script[src],link[rel="stylesheet"][href]').forEach((el2) => {
        const u = el2.src || el2.href;
        try {
          const url = new URL(u, location.href);
          if (url.origin === location.origin) urls.add(url.href);
        } catch {
        }
      });
      urls.add(location.href);
      const texts = await Promise.all([...urls].map((u) => this.fetchText(u)));
      texts.forEach((t, i) => {
        for (const match of this.extractMp3s(t)) this.add(match, `ref:${[...urls][i]}`);
      });
    }
    async scanDOM() {
      document.querySelectorAll("audio[src]").forEach((a) => this.add(a.getAttribute("src") || "", "dom"));
      document.querySelectorAll("source[src]").forEach((s) => this.add(s.getAttribute("src") || "", "dom"));
      const html = document.documentElement?.outerHTML || "";
      for (const m of this.extractMp3s(html)) this.add(m, "html");
    }
    async scanAll() {
      this.found.clear();
      this.meta.clear();
      await Promise.all([
        this.scanPerformance(),
        this.scanHowler(),
        this.scanCaches(),
        this.scanDOM()
      ]);
      await this.scanResourcesForRefs();
      this.autoGroups({ overwrite: true });
      return this.urls();
    }
    // ----------------- Groupes -----------------
    inferGroupKey(logicalName) {
      const base = String(logicalName || "").replace(/\.mp3$/i, "");
      let m = base.match(/^([A-Za-z]+)[_\-]/);
      if (m) return m[1].toLowerCase();
      m = base.match(/^([A-Za-z]+)\d+$/);
      if (m) return m[1].toLowerCase();
      m = base.match(/^([A-Za-z]+)/);
      return m ? m[1].toLowerCase() : base.toLowerCase();
    }
    defineGroup(name, matcher) {
      const key2 = this.toKey(name);
      const set3 = /* @__PURE__ */ new Set();
      const items = this.urls().map((u) => [u, this.meta.get(u)]);
      const test = (url, meta) => {
        if (!matcher) return false;
        if (typeof matcher === "function") return !!matcher(url, meta);
        const ln = meta?.logicalName || meta?.name || url;
        if (matcher instanceof RegExp) return matcher.test(ln) || matcher.test(url);
        const txt = String(matcher).toLowerCase();
        return ln.toLowerCase().startsWith(txt) || url.toLowerCase().includes("/" + txt);
      };
      for (const [url, meta] of items)
        if (test(url, meta && { name: meta.name, logicalName: meta.logicalName })) set3.add(url);
      this.groupsMap.set(key2, set3);
      return [...set3];
    }
    undefineGroup(name) {
      this.groupsMap.delete(this.toKey(name));
    }
    // --- Unique implmentation publique ---
    autoGroups({ overwrite = false, minVariants = this.minVariantsPerAutoGroup } = {}) {
      this.rebuildAutoGroups(overwrite, minVariants);
      return this.groups();
    }
    // Helper priv appel par autoGroups()
    rebuildAutoGroups(overwrite, minVariants) {
      const tmp = /* @__PURE__ */ new Map();
      for (const [url, m] of this.meta.entries()) {
        const grp = this.inferGroupKey(m?.logicalName || m?.name || url);
        if (!tmp.has(grp)) tmp.set(grp, /* @__PURE__ */ new Set());
        tmp.get(grp).add(url);
      }
      for (const [grp, set3] of tmp.entries()) {
        if (set3.size < minVariants) continue;
        if (overwrite || !this.groupsMap.has(grp)) this.groupsMap.set(grp, set3);
      }
    }
    groups() {
      const out = {};
      for (const [k, set3] of this.groupsMap.entries()) out[k] = [...set3];
      return out;
    }
    getGroup(name) {
      const set3 = this.groupsMap.get(this.toKey(name));
      return set3 ? [...set3] : [];
    }
    pick(name) {
      const g = this.getGroup(name);
      return this.choose(g);
    }
    // ----------------- Lecture -----------------
    findExistingHowlByUrl(url) {
      this.refreshHowler();
      if (!this.howler) return null;
      for (const h of this.howler._howls) {
        const src = h && (h._src || h._urls && h._urls[0]);
        if (src && this.sameAsset(src, url)) return h;
      }
      return null;
    }
    /** Volume calcul selon config + atom du jeu. */
    getGameSfxVolume() {
      return this.finalVolumeObj();
    }
    /** Ajoute un offset global (sans toucher  latom du jeu). */
    setGainFactor(g = 1) {
      this.gainFactor = +g || 1;
    }
    /** Permet dadapter la cl et la plage de latom si a change ct jeu. */
    setAtomConfig(key2 = "soundEffectsVolumeAtom", min = 1e-3, max = 0.2000000000000001) {
      this.atomKey = key2;
      this.min = min;
      this.max = max;
    }
    /** Joue une URL en respectant le volume du jeu et Howler si dispo. */
    playUrl(url) {
      const { vol } = this.finalVolumeObj();
      const existing = this.findExistingHowlByUrl(url);
      if (existing) {
        try {
          existing.play();
          return existing;
        } catch {
        }
      }
      const Howl = window.Howl && window.Howler ? window.Howl : null;
      if (Howl) {
        try {
          const h = new Howl({ src: [url], volume: vol });
          h.play();
          return h;
        } catch {
        }
      }
      try {
        const a = new Audio(url);
        a.volume = Math.max(0, Math.min(1, vol));
        void a.play().catch(() => {
        });
        return a;
      } catch {
        return null;
      }
    }
    /** Joue par motif (RegExp ou texte partiel). */
    playBy(matcher) {
      const list = this.urls();
      const re = matcher instanceof RegExp ? matcher : new RegExp(String(matcher).replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "i");
      const hit = list.find((u) => re.test(u));
      return hit ? this.playUrl(hit) : null;
    }
    /** Joue par nom logique exact si possible, sinon via motif. */
    play(nameOrRegex) {
      if (typeof nameOrRegex === "string") {
        const m = this.map();
        if (m[nameOrRegex]?.[0]) return this.playUrl(m[nameOrRegex][0]);
      }
      return this.playBy(nameOrRegex);
    }
    /** Joue une entre dun groupe (index fixe, ou alatoire). */
    playGroup(name, opts = {}) {
      const { index, random = true, filter } = opts;
      let list = this.getGroup(name);
      if (!list.length) return null;
      if (typeof filter === "function") {
        list = list.filter((u) => {
          const m = this.meta.get(u);
          return filter(u, m && { name: m.name, logicalName: m.logicalName });
        });
        if (!list.length) return null;
      }
      const url = typeof index === "number" ? list[(index % list.length + list.length) % list.length] : random ? this.choose(list) : list[0];
      return this.playUrl(url);
    }
    /** Alias pratique pour jouer une variation alatoire dun groupe (ex: "harvest"). */
    playRandom(name) {
      return this.playGroup(name, { random: true });
    }
    // ----------------- Tables & export -----------------
    urls() {
      return [...this.found];
    }
    map() {
      const map2 = {};
      for (const [url, m] of this.meta.entries()) {
        const key2 = m.logicalName || m.name;
        (map2[key2] || (map2[key2] = [])).push(url);
      }
      return map2;
    }
    info() {
      return this.urls().map((u) => {
        const m = this.meta.get(u);
        return { url: u, name: m?.name, logicalName: m?.logicalName, sources: [...m?.from || []].join(",") };
      });
    }
    /** Exporte JSON (URLs + groupes). Retourne la string. */
    exportJSON() {
      return JSON.stringify({ urls: this.info(), groups: this.groups() }, null, 2);
    }
    /** Scan public de commodit. */
    async scan() {
      return this.scanAll();
    }
    /* Helpers */
    playHarvest() {
      return this.playGroup("harvest");
    }
    playPlantSeed() {
      return this.playGroup("plantseed");
    }
    playWaterPlant() {
      return this.playBy("water");
    }
    playDestroyPlant() {
      return this.playBy("Break_Dirt");
    }
    playDestroyStone() {
      return this.playBy("Break_Stone");
    }
    /** Joue une URL  un volume fixe (0-1), indpendamment du volume SFX du jeu. */
    playAt(url, volume) {
      const clampedVol = Math.max(0, Math.min(1, volume));
      try {
        const a = new Audio(url);
        a.volume = clampedVol;
        void a.play().catch(() => {
        });
      } catch {
      }
    }
    playSellNotification() {
      return this.playBy("Score_PlusOne");
    }
    playInfoNotification() {
      return this.playBy("Keyboard_Enter_01");
    }
    playBuy() {
      return this.playGroup("coinbuy");
    }
  };
  var audioPlayer = new AudioPlayer({ autoScan: true });

  // src/utils/tileObjectSystemApi.ts
  var state2 = {
    engine: null,
    tos: null,
    origBind: Function.prototype.bind,
    bindPatched: false
  };
  function looksLikeEngine(o) {
    return !!(o && typeof o === "object" && typeof o.start === "function" && typeof o.destroy === "function" && o.app && o.app.stage && o.app.renderer && o.systems && typeof o.systems.values === "function");
  }
  function findTileObjectSystem(engine) {
    try {
      for (const e of engine.systems.values()) {
        const s = e?.system;
        if (s?.name === "tileObject") return s;
      }
    } catch {
    }
    return null;
  }
  function tryCaptureFromKnownGlobals() {
    const w = window;
    if (!state2.engine && w.__QUINOA_ENGINE__) state2.engine = w.__QUINOA_ENGINE__;
    if (!state2.tos && w.__TILE_OBJECT_SYSTEM__) state2.tos = w.__TILE_OBJECT_SYSTEM__;
    if (state2.engine && !state2.tos) state2.tos = findTileObjectSystem(state2.engine);
  }
  function armCapture() {
    if (state2.engine && state2.tos) return;
    if (state2.bindPatched) return;
    state2.bindPatched = true;
    Function.prototype.bind = function(thisArg, ...args) {
      const bound = state2.origBind.call(this, thisArg, ...args);
      try {
        if (!state2.engine && looksLikeEngine(thisArg)) {
          state2.engine = thisArg;
          state2.tos = findTileObjectSystem(thisArg);
          Function.prototype.bind = state2.origBind;
          state2.bindPatched = false;
        }
      } catch {
      }
      return bound;
    };
  }
  function deepClone(v) {
    try {
      if (typeof structuredClone === "function") return structuredClone(v);
    } catch {
    }
    try {
      return JSON.parse(JSON.stringify(v));
    } catch {
    }
    return v;
  }
  function globalIndexFromXY(tx, ty) {
    const cols = state2.tos?.map?.cols;
    if (!Number.isFinite(cols) || cols <= 0) return null;
    return ty * cols + tx | 0;
  }
  function getTileViewAt(tx, ty, ensureView) {
    const gidx = globalIndexFromXY(tx, ty);
    if (!state2.tos || gidx == null) return { gidx: null, tv: null };
    let tv = state2.tos.tileViews?.get?.(gidx) ?? null;
    if (!tv && ensureView && typeof state2.tos.getOrCreateTileView === "function") {
      try {
        tv = state2.tos.getOrCreateTileView(gidx);
      } catch {
      }
    }
    return { gidx, tv };
  }
  function assertReady() {
    if (!state2.engine || !state2.tos) {
      throw new Error("Quinoa engine/TOS not captured. Call tos.init() early (main entry) and ensure it runs before engine initializes.");
    }
  }
  function applyTileObject(tx, ty, nextObj, opts = {}) {
    assertReady();
    const ensureView = opts.ensureView !== false;
    const forceUpdate = opts.forceUpdate !== false;
    const { gidx, tv } = getTileViewAt(tx, ty, ensureView);
    if (gidx == null) throw new Error("TOS/map cols not available");
    if (!tv) throw new Error("TileView not available");
    const before = tv.tileObject;
    tv.onDataChanged(nextObj);
    if (forceUpdate && state2.engine?.reusableContext) {
      try {
        tv.update(state2.engine.reusableContext);
      } catch {
      }
    }
    return { tx, ty, gidx, ok: true, before, after: tv.tileObject };
  }
  function assertType(obj, type) {
    if (!obj) throw new Error("No tileObject on this tile");
    if (obj.objectType !== type) throw new Error(`Wrong objectType: expected "${type}", got "${obj.objectType}"`);
  }
  function patchPlantSlot(slot, slotPatch) {
    const p = slotPatch || {};
    if ("startTime" in p) slot.startTime = Number(p.startTime);
    if ("endTime" in p) slot.endTime = Number(p.endTime);
    if ("targetScale" in p) slot.targetScale = Number(p.targetScale);
    if ("mutations" in p) {
      if (!Array.isArray(p.mutations)) throw new Error("mutations must be an array of strings");
      if (!p.mutations.every((x) => typeof x === "string")) throw new Error("mutations must contain only strings");
      slot.mutations = p.mutations.slice();
    }
  }
  var tos = {
    /**  appeler une fois dans le main, le plus tt possible */
    init() {
      tryCaptureFromKnownGlobals();
      armCapture();
      tryCaptureFromKnownGlobals();
      return { ok: !!(state2.engine && state2.tos), engine: state2.engine, tos: state2.tos };
    },
    isReady() {
      return !!(state2.engine && state2.tos);
    },
    getStatus() {
      return { ok: !!(state2.engine && state2.tos), engine: state2.engine, tos: state2.tos };
    },
    getTileObject(tx, ty, opts = {}) {
      assertReady();
      const ensureView = opts.ensureView !== false;
      const { gidx, tv } = getTileViewAt(Number(tx), Number(ty), ensureView);
      if (gidx == null) throw new Error("TOS/map cols not available");
      return {
        tx: Number(tx),
        ty: Number(ty),
        gidx,
        tileView: tv,
        tileObject: tv?.tileObject
      };
    },
    /** Met la tile  vide (tileObject = null) */
    setTileEmpty(tx, ty, opts = {}) {
      return applyTileObject(Number(tx), Number(ty), null, opts);
    },
    setTilePlant(tx, ty, patch2, opts = {}) {
      const info = this.getTileObject(tx, ty, opts);
      const cur = info.tileObject;
      assertType(cur, "plant");
      const next = deepClone(cur);
      if (!Array.isArray(next.slots)) next.slots = [];
      const p = patch2 || {};
      if ("plantedAt" in p) next.plantedAt = Number(p.plantedAt);
      if ("maturedAt" in p) next.maturedAt = Number(p.maturedAt);
      if ("species" in p) next.species = String(p.species);
      if ("slotIdx" in p && "slotPatch" in p) {
        const i = Number(p.slotIdx) | 0;
        if (!next.slots[i]) throw new Error(`Plant slot ${i} does not exist`);
        patchPlantSlot(next.slots[i], p.slotPatch);
        return applyTileObject(Number(tx), Number(ty), next, opts);
      }
      if ("slots" in p) {
        const s = p.slots;
        if (Array.isArray(s)) {
          for (let i = 0; i < s.length; i++) {
            if (s[i] == null) continue;
            if (!next.slots[i]) throw new Error(`Plant slot ${i} does not exist`);
            patchPlantSlot(next.slots[i], s[i]);
          }
        } else if (s && typeof s === "object") {
          for (const k of Object.keys(s)) {
            const i = Number(k) | 0;
            if (!Number.isFinite(i)) continue;
            if (!next.slots[i]) throw new Error(`Plant slot ${i} does not exist`);
            patchPlantSlot(next.slots[i], s[k]);
          }
        } else {
          throw new Error("patch.slots must be an array or object map");
        }
        return applyTileObject(Number(tx), Number(ty), next, opts);
      }
      return applyTileObject(Number(tx), Number(ty), next, opts);
    },
    setTileDecor(tx, ty, patch2, opts = {}) {
      const info = this.getTileObject(tx, ty, opts);
      const cur = info.tileObject;
      assertType(cur, "decor");
      const next = deepClone(cur);
      const p = patch2 || {};
      if ("rotation" in p) next.rotation = Number(p.rotation);
      return applyTileObject(Number(tx), Number(ty), next, opts);
    },
    setTileEgg(tx, ty, patch2, opts = {}) {
      const info = this.getTileObject(tx, ty, opts);
      const cur = info.tileObject;
      assertType(cur, "egg");
      const next = deepClone(cur);
      const p = patch2 || {};
      if ("plantedAt" in p) next.plantedAt = Number(p.plantedAt);
      if ("maturedAt" in p) next.maturedAt = Number(p.maturedAt);
      return applyTileObject(Number(tx), Number(ty), next, opts);
    }
  };

  // src/services/editor.ts
  var ARIES_SAVED_GARDENS_PATH = "editor.savedGardens";
  var FIXED_SLOT_START = 1760866288723;
  var FIXED_SLOT_END = 1760867858782;
  var mutationColorMap = {
    Gold: "rgba(200, 170, 0, 1)",
    Rainbow: "linear-gradient(135deg, #ff0000, #ff7a00, #ffeb3b, #00c853, #40c4ff, #8e24aa)",
    Wet: "rgb(30, 140, 230)",
    Chilled: "rgb(100, 190, 200)",
    Frozen: "rgb(100, 120, 255)",
    Thunderstruck: "rgb(16, 141, 163)",
    Dawnlit: "rgba(120, 100, 180, 1)",
    Ambershine: "rgba(160, 70, 50, 1)",
    // <- important : Ambershine, pas Amberlit
    Dawncharged: "rgba(160, 140, 220, 1)",
    Ambercharged: "rgba(240, 110, 80, 1)"
  };
  function buildSpriteCandidates(rawId, label2) {
    const set3 = /* @__PURE__ */ new Set();
    const add = (value) => {
      if (!value) return;
      const trimmed = String(value).trim();
      if (!trimmed) return;
      set3.add(trimmed);
      set3.add(trimmed.replace(/\s+/g, ""));
      const last = trimmed.split(/[./]/).pop();
      if (last && last !== trimmed) {
        set3.add(last);
        set3.add(last.replace(/\s+/g, ""));
      }
    };
    add(rawId);
    add(label2);
    return Array.from(set3).filter(Boolean);
  }
  var overlayEl = null;
  var currentEnabled = false;
  var listeners3 = /* @__PURE__ */ new Set();
  var savedGardensListeners = /* @__PURE__ */ new Set();
  var sideOverlayEl = null;
  var sideListWrap = null;
  var sideSelect = null;
  var sideRightWrap = null;
  var currentSideMode = "plants";
  var selectedPlantId = null;
  var selectedDecorId = null;
  var currentItemOverlayEl = null;
  var currentItemUnsub = null;
  var currentItemApplyAll = false;
  var currentItemSlotModes = {};
  var editorKeybindsInstalled = false;
  var overlaysVisible = true;
  var EDITOR_PLACE_REMOVE_FIRST_DELAY_MS = 200;
  var EDITOR_PLACE_REMOVE_REPEAT_MS = 100;
  var lastEditorPlaceRemoveTs = 0;
  var lastEditorPressStartTs = 0;
  var lastEditorFirstFired = false;
  var lastEditorTileKey = null;
  var lastEditorTileType;
  var lastEditorFirstActionTs = 0;
  var editorActionHeld = false;
  async function triggerEditorAnimation(animation) {
    try {
      const playerId2 = await getPlayerId();
      if (!playerId2) return;
      await Atoms.player.avatarTriggerAnimationAtom.set({ playerId: playerId2, animation });
      if (animation === "dig") {
        void audioPlayer.playBy("Break_Dirt_01");
      } else if (animation === "dropObject") {
        void (audioPlayer.playGroup("plant") || audioPlayer.playGroup("hit_dirt") || audioPlayer.playGroup("hit") || audioPlayer.playBy(/Hit_Dirt/i));
      }
    } catch {
    }
  }
  var stateFrozenValue = null;
  var statePatch = null;
  var stateOriginalValue = null;
  var friendGardenPreviewActive = false;
  var friendGardenBackup = null;
  function createSelectionIcon(kind, label2, size = 32, rawId) {
    const wrap = document.createElement("span");
    Object.assign(wrap.style, {
      width: `${size}px`,
      height: `${size}px`,
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      fontSize: `${Math.max(14, size - 10)}px`,
      lineHeight: "1"
    });
    const fallback = label2?.trim().charAt(0).toUpperCase() || (kind === "decor" ? "D" : "P");
    wrap.textContent = "";
    wrap.setAttribute("aria-hidden", "true");
    const applyFallback = () => {
      if (!wrap.querySelector("img")) {
        wrap.textContent = fallback;
      }
    };
    const candidates = buildSpriteCandidates(rawId, label2);
    let categories = kind === "decor" ? ["decor"] : ["plant"];
    if (kind !== "decor" && /bamboo|cactus/i.test(String(rawId ?? label2 ?? ""))) {
      categories = ["tallplant", "tallPlant", "plant"];
    }
    if (candidates.length) {
      attachSpriteIcon(wrap, categories, candidates, size, "editor", {
        onNoSpriteFound: applyFallback
      });
    } else {
      applyFallback();
    }
    return wrap;
  }
  function persist(enabled) {
  }
  function ensureOverlay() {
    if (overlayEl && document.contains(overlayEl)) return overlayEl;
    const el2 = document.createElement("div");
    el2.id = "qws-editor-overlay";
    el2.textContent = "Editor mode";
    Object.assign(el2.style, {
      position: "fixed",
      top: "7%",
      left: "50%",
      transform: "translateX(-50%)",
      zIndex: "1000001",
      padding: "8px 12px",
      borderRadius: "999px",
      border: "1px solid #ffffff33",
      background: "linear-gradient(180deg, rgba(17,24,31,0.95), rgba(12,18,26,0.92))",
      color: "#e7eef7",
      font: "600 13px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif",
      letterSpacing: "0.3px",
      boxShadow: "0 10px 30px rgba(0,0,0,.35)",
      pointerEvents: "none"
    });
    (document.body || document.documentElement || document).appendChild(el2);
    overlayEl = el2;
    return el2;
  }
  function showOverlay() {
    ensureOverlay();
  }
  function hideOverlay() {
    if (overlayEl) {
      overlayEl.remove();
      overlayEl = null;
    }
  }
  function notifySavedGardensChanged() {
    if (!savedGardensListeners.size) return;
    for (const listener of savedGardensListeners) {
      try {
        listener();
      } catch (error) {
        console.error("[EditorService] saved gardens listener failed", error);
      }
    }
  }
  function getSelectedId() {
    return currentSideMode === "decor" ? selectedDecorId : selectedPlantId;
  }
  function setSelectedId(next) {
    if (currentSideMode === "decor") {
      selectedDecorId = next;
    } else {
      selectedPlantId = next;
    }
  }
  function getSideEntries() {
    if (currentSideMode === "decor") {
      return Object.entries(decorCatalog || {}).map(([decorId, val]) => ({
        id: decorId,
        label: String(val?.name || decorId)
      }));
    }
    return Object.entries(plantCatalog || {}).map(([species, val]) => ({
      id: species,
      label: String(val?.crop?.name || val?.seed?.name || species)
    }));
  }
  function getSideEntry(id) {
    if (!id) return null;
    return currentSideMode === "decor" ? decorCatalog?.[id] : plantCatalog?.[id];
  }
  function getSideEntryLabel(id, entry) {
    if (currentSideMode === "decor") return entry?.name || id;
    return entry?.crop?.name || entry?.seed?.name || id;
  }
  function getSideSpriteKind() {
    return currentSideMode === "decor" ? "Decor" : "Crop";
  }
  function ensureSideOverlay() {
    if (sideOverlayEl && document.contains(sideOverlayEl)) return sideOverlayEl;
    const root = document.createElement("div");
    root.id = "qws-editor-side";
    Object.assign(root.style, {
      position: "fixed",
      top: "12%",
      left: "12px",
      zIndex: "1000001",
      width: "560px",
      minHeight: "420px",
      maxHeight: "86vh",
      height: "min(720px, 86vh)",
      display: "grid",
      gridTemplateRows: "auto 1fr",
      // <- header + contenu
      gap: "10px",
      padding: "10px",
      borderRadius: "12px",
      border: "1px solid #ffffff22",
      background: "linear-gradient(180deg, rgba(14,18,25,0.95), rgba(10,14,20,0.92))",
      color: "#e7eef7",
      boxShadow: "0 10px 30px rgba(0,0,0,0.35)",
      pointerEvents: "auto"
    });
    const header = document.createElement("div");
    header.textContent = "Item picker";
    header.style.fontWeight = "700";
    header.style.fontSize = "13px";
    header.style.letterSpacing = "0.08em";
    header.style.textTransform = "uppercase";
    header.style.opacity = "0.85";
    header.style.textAlign = "center";
    const content = document.createElement("div");
    content.style.display = "grid";
    content.style.gridTemplateColumns = "260px 1fr";
    content.style.gap = "10px";
    content.style.minHeight = "0";
    const left = document.createElement("div");
    left.style.display = "grid";
    left.style.gridTemplateRows = "auto 1fr";
    left.style.gap = "8px";
    left.style.minHeight = "0";
    const select2 = document.createElement("select");
    select2.id = "qws-editor-side-select";
    select2.style.width = "100%";
    select2.style.padding = "8px";
    select2.style.borderRadius = "10px";
    select2.style.border = "1px solid #33404e";
    select2.style.background = "rgba(20,25,33,0.9)";
    select2.style.color = "#e7eef7";
    select2.style.fontWeight = "600";
    select2.style.cursor = "pointer";
    const optPlants = document.createElement("option");
    optPlants.value = "plants";
    optPlants.textContent = "Plants";
    const optDecor = document.createElement("option");
    optDecor.value = "decor";
    optDecor.textContent = "Decor";
    select2.append(optPlants, optDecor);
    select2.value = currentSideMode;
    select2.onchange = () => {
      currentSideMode = select2.value === "decor" ? "decor" : "plants";
      renderSideList();
    };
    sideSelect = select2;
    const listWrap = document.createElement("div");
    listWrap.id = "qws-editor-side-list";
    Object.assign(listWrap.style, {
      border: "1px solid #2c3643",
      borderRadius: "10px",
      background: "rgba(16,21,28,0.9)",
      overflow: "auto",
      padding: "6px",
      maxHeight: "72vh"
    });
    sideListWrap = listWrap;
    left.append(select2, listWrap);
    const right = document.createElement("div");
    right.id = "qws-editor-side-details";
    right.style.display = "grid";
    right.style.gridTemplateRows = "1fr auto";
    right.style.gap = "8px";
    right.style.border = "1px solid #2c3643";
    right.style.borderRadius = "10px";
    right.style.background = "rgba(16,21,28,0.9)";
    right.style.padding = "10px";
    right.style.minHeight = "0";
    right.style.overflow = "hidden";
    sideRightWrap = right;
    content.append(left, right);
    root.append(header, content);
    (document.body || document.documentElement || document).appendChild(root);
    sideOverlayEl = root;
    renderSideList();
    renderSideDetails();
    return root;
  }
  function showSideOverlay() {
    ensureSideOverlay();
  }
  function hideSideOverlay() {
    if (sideOverlayEl) {
      sideOverlayEl.remove();
      sideOverlayEl = null;
      sideListWrap = null;
      sideSelect = null;
      sideRightWrap = null;
    }
  }
  function ensureCurrentItemOverlay() {
    if (currentItemOverlayEl && document.contains(currentItemOverlayEl)) return currentItemOverlayEl;
    const root = document.createElement("div");
    root.id = "qws-editor-current-item";
    Object.assign(root.style, {
      position: "fixed",
      top: "12%",
      right: "12px",
      zIndex: "1000001",
      width: "420px",
      minHeight: "200px",
      maxHeight: "86vh",
      display: "grid",
      gridTemplateRows: "auto 1fr",
      gap: "10px",
      padding: "10px",
      borderRadius: "12px",
      border: "1px solid #ffffff22",
      background: "linear-gradient(180deg, rgba(14,18,25,0.95), rgba(10,14,20,0.92))",
      color: "#e7eef7",
      boxShadow: "0 10px 30px rgba(0,0,0,0.35)",
      pointerEvents: "auto"
    });
    const header = document.createElement("div");
    header.textContent = "Current item";
    header.style.fontWeight = "700";
    header.style.fontSize = "13px";
    header.style.letterSpacing = "0.08em";
    header.style.textTransform = "uppercase";
    header.style.opacity = "0.85";
    header.style.textAlign = "center";
    const content = document.createElement("div");
    content.id = "qws-editor-current-item-content";
    content.style.display = "grid";
    content.style.gap = "10px";
    content.style.minHeight = "0";
    content.style.overflow = "auto";
    root.append(header, content);
    (document.body || document.documentElement || document).appendChild(root);
    currentItemOverlayEl = root;
    attachCurrentItemListener();
    renderCurrentItemOverlay();
    return root;
  }
  function showCurrentItemOverlay() {
    ensureCurrentItemOverlay();
  }
  function hideCurrentItemOverlay() {
    if (currentItemUnsub) {
      try {
        currentItemUnsub();
      } catch {
      }
      currentItemUnsub = null;
    }
    if (currentItemOverlayEl) {
      currentItemOverlayEl.remove();
      currentItemOverlayEl = null;
    }
  }
  function attachCurrentItemListener() {
    if (currentItemUnsub) {
      try {
        currentItemUnsub();
      } catch {
      }
      currentItemUnsub = null;
    }
    void (async () => {
      try {
        const atom = getAtomByLabel("myCurrentGardenObjectAtom");
        const selectedIdxAtom = getAtomByLabel("myValidatedSelectedItemIndexAtom");
        const store = await ensureStore().catch(() => null);
        if (!atom || !store) return;
        const unsubA = store.sub(atom, () => {
          renderCurrentItemOverlay();
        });
        const unsubB = selectedIdxAtom ? store.sub(selectedIdxAtom, () => renderCurrentItemOverlay()) : null;
        currentItemUnsub = () => {
          try {
            unsubA();
          } catch {
          }
          if (unsubB) {
            try {
              unsubB();
            } catch {
            }
          }
        };
      } catch {
      }
    })();
  }
  async function readCurrentTileContext() {
    try {
      const store = await ensureStore().catch(() => null);
      if (!store) return { tileType: void 0, tileKey: null, tileObject: null };
      const tileAtom = getAtomByLabel("myCurrentGardenTileAtom");
      if (!tileAtom) return { tileType: void 0, tileKey: null, tileObject: null };
      const tileVal = store.get(tileAtom);
      if (!tileVal) return { tileType: void 0, tileKey: null, tileObject: null };
      const tileType = tileVal.tileType;
      const localTileIndex = tileVal.localTileIndex;
      const userSlotIdxRaw = tileVal.userSlotIdx;
      const userSlotIdx = typeof userSlotIdxRaw === "number" && Number.isFinite(userSlotIdxRaw) ? userSlotIdxRaw : 0;
      if (localTileIndex == null || !Number.isFinite(localTileIndex)) {
        return { tileType, tileKey: null, tileObject: null };
      }
      const cur = stateFrozenValue ?? await Atoms.root.state.get();
      const garden2 = Array.isArray(cur?.child?.data?.userSlots) ? cur?.child?.data?.userSlots?.[userSlotIdx]?.data?.garden : cur?.child?.data?.userSlots?.[String(userSlotIdx)]?.data?.garden;
      const safeGarden = garden2 && typeof garden2 === "object" ? garden2 : makeEmptyGarden();
      const key2 = String(localTileIndex);
      const targetMap = tileType === "Dirt" ? safeGarden.tileObjects || {} : safeGarden.boardwalkTileObjects || {};
      return { tileType, tileKey: key2, tileObject: targetMap[key2] };
    } catch {
      return { tileType: void 0, tileKey: null, tileObject: null };
    }
  }
  function getGardenObjectLabel(obj) {
    if (!obj || typeof obj !== "object") return "Unknown";
    if (obj.objectType === "plant") {
      const entry = plantCatalog[obj.species];
      return entry?.crop?.name || entry?.seed?.name || obj.species || "Plant";
    }
    if (obj.objectType === "decor") {
      const entry = decorCatalog[obj.decorId];
      return entry?.name || obj.decorId || "Decor";
    }
    return String(obj.objectType || "Item");
  }
  function getInventoryItemLabel(item) {
    if (!item || typeof item !== "object") return "Item";
    if (item.itemType === "Plant") {
      const entry = plantCatalog[item.species];
      return entry?.crop?.name || entry?.seed?.name || item.species || "Plant";
    }
    if (item.itemType === "Decor") {
      const entry = decorCatalog[item.decorId];
      return entry?.name || item.decorId || "Decor";
    }
    return String(item.itemType || "Item");
  }
  function renderCurrentItemOverlay() {
    if (!currentItemOverlayEl) return;
    const content = currentItemOverlayEl.querySelector("#qws-editor-current-item-content");
    if (!content) return;
    void (async () => {
      content.innerHTML = "";
      const { tileType, tileKey, tileObject } = await readCurrentTileContext();
      if (!tileObject) {
        const empty = document.createElement("div");
        empty.textContent = "Look at a plant or decor to edit it.";
        empty.style.opacity = "0.7";
        empty.style.textAlign = "center";
        content.appendChild(empty);
        try {
          const inv = await Atoms.inventory.myInventory.get();
          const idx = await Atoms.inventory.myValidatedSelectedItemIndex.get();
          const items = Array.isArray(inv?.items) ? inv.items : [];
          const selected = typeof idx === "number" ? items[idx] : null;
          if (selected) {
            const infoRow = document.createElement("div");
            infoRow.style.display = "flex";
            infoRow.style.flexDirection = "column";
            infoRow.style.alignItems = "center";
            infoRow.style.gap = "6px";
            const nameEl2 = document.createElement("div");
            nameEl2.textContent = getInventoryItemLabel(selected);
            nameEl2.style.fontWeight = "700";
            nameEl2.style.fontSize = "14px";
            nameEl2.style.overflow = "hidden";
            nameEl2.style.textOverflow = "ellipsis";
            nameEl2.style.whiteSpace = "nowrap";
            nameEl2.style.textAlign = "center";
            const icon2 = createSelectionIcon(
              selected.itemType === "Decor" ? "decor" : "plants",
              getInventoryItemLabel(selected),
              40,
              selected.itemType === "Decor" ? selected?.decorId : selected?.species
            );
            infoRow.append(icon2, nameEl2);
            content.appendChild(infoRow);
            if (selected.itemType === "Plant") {
              const slotsArr = Array.isArray(selected.slots) ? selected.slots : [];
              const mutSet = /* @__PURE__ */ new Set();
              for (const s of slotsArr) {
                const muts = Array.isArray(s?.mutations) ? s.mutations : [];
                muts.forEach((m) => mutSet.add(m));
              }
              const mutList = Array.from(mutSet);
              const mutRow = document.createElement("div");
              mutRow.style.display = "flex";
              mutRow.style.flexWrap = "wrap";
              mutRow.style.gap = "6px";
              mutRow.style.justifyContent = "center";
              if (mutList.length) {
                for (const mutId of mutList) {
                  const tag = document.createElement("span");
                  tag.textContent = mutationCatalog[mutId]?.name?.charAt(0)?.toUpperCase() || mutId.charAt(0)?.toUpperCase() || "?";
                  tag.style.fontWeight = "900";
                  tag.style.fontSize = "12px";
                  tag.style.padding = "4px 8px";
                  tag.style.borderRadius = "999px";
                  tag.style.border = "1px solid #2c3643";
                  tag.style.background = "rgba(10,14,20,0.9)";
                  const color = mutationColorMap[mutId];
                  if (color) {
                    if (color.startsWith("linear-gradient")) {
                      tag.style.backgroundImage = color;
                      tag.style.backgroundClip = "text";
                      tag.style.webkitBackgroundClip = "text";
                      tag.style.color = "transparent";
                      tag.style.webkitTextFillColor = "transparent";
                    } else {
                      tag.style.color = color;
                    }
                  }
                  mutRow.appendChild(tag);
                }
              } else {
                const none = document.createElement("div");
                none.textContent = "No mutations";
                none.style.opacity = "0.7";
                none.style.fontSize = "11px";
                mutRow.appendChild(none);
              }
              content.append(mutRow);
            }
            const placeBtn = document.createElement("button");
            placeBtn.type = "button";
            placeBtn.textContent = "Place";
            Object.assign(placeBtn.style, {
              width: "100%",
              padding: "8px 10px",
              borderRadius: "8px",
              border: "1px solid #2b3441",
              background: "linear-gradient(180deg, rgba(42,154,255,0.12), rgba(30,91,181,0.35))",
              color: "#e7eef7",
              fontWeight: "700",
              cursor: "pointer"
            });
            placeBtn.onclick = () => {
              void placeSelectedItemInGardenAtCurrentTile();
            };
            content.appendChild(placeBtn);
          }
        } catch {
        }
        return;
      }
      const name = getGardenObjectLabel(tileObject);
      const header = document.createElement("div");
      header.style.display = "flex";
      header.style.flexDirection = "column";
      header.style.alignItems = "center";
      header.style.gap = "6px";
      const nameEl = document.createElement("div");
      nameEl.textContent = name;
      nameEl.style.fontWeight = "700";
      nameEl.style.fontSize = "15px";
      nameEl.style.overflow = "hidden";
      nameEl.style.textOverflow = "ellipsis";
      nameEl.style.whiteSpace = "nowrap";
      nameEl.style.textAlign = "center";
      const icon = createSelectionIcon(
        tileObject.objectType === "decor" ? "decor" : "plants",
        name,
        48,
        tileObject.objectType === "decor" ? tileObject.decorId || tileKey || name : tileObject.species || tileKey || name
      );
      header.append(icon, nameEl);
      content.appendChild(header);
      if (tileObject.objectType === "plant") {
        renderCurrentPlantEditor(content, tileObject, tileKey || "");
      }
      const addBtn = document.createElement("button");
      addBtn.type = "button";
      addBtn.textContent = "Copy to inventory";
      Object.assign(addBtn.style, {
        width: "100%",
        padding: "8px 10px",
        borderRadius: "8px",
        border: "1px solid #2b3441",
        background: "linear-gradient(180deg, rgba(42,154,255,0.12), rgba(30,91,181,0.35))",
        color: "#e7eef7",
        fontWeight: "700",
        cursor: "pointer"
      });
      addBtn.onclick = () => {
        void addTileObjectToInventory(tileObject);
      };
      content.appendChild(addBtn);
      const removeBtn = document.createElement("button");
      removeBtn.type = "button";
      removeBtn.textContent = "Remove";
      Object.assign(removeBtn.style, {
        width: "100%",
        padding: "8px 10px",
        borderRadius: "8px",
        border: "1px solid #2b3441",
        background: "linear-gradient(180deg, rgba(220,80,80,0.18), rgba(160,40,40,0.25))",
        color: "#e7eef7",
        fontWeight: "700",
        cursor: "pointer"
      });
      removeBtn.onclick = () => {
        if (tileObject.objectType === "plant") void removeItemFromGardenAtCurrentTile();
        else void removeDecorFromGardenAtCurrentTile();
      };
      content.appendChild(removeBtn);
    })();
  }
  function renderCurrentPlantEditor(content, tileObject, tileKey) {
    const species = tileObject?.species;
    const slots = Array.isArray(tileObject?.slots) ? tileObject.slots : [];
    const modeKey = tileKey || "default";
    const slotModeMap = currentItemSlotModes[modeKey] || {};
    let applyAll = currentItemApplyAll;
    const slotsList = document.createElement("div");
    slotsList.style.display = "grid";
    slotsList.style.gap = "8px";
    const maxSlots = getMaxSlotsForSpecies(species);
    const applyAllRow = document.createElement("label");
    applyAllRow.style.display = "flex";
    applyAllRow.style.alignItems = "center";
    applyAllRow.style.gap = "6px";
    applyAllRow.style.fontSize = "12px";
    applyAllRow.style.opacity = "0.9";
    const applyToggle = document.createElement("input");
    applyToggle.type = "checkbox";
    applyToggle.checked = applyAll;
    applyToggle.onchange = () => {
      applyAll = !!applyToggle.checked;
      currentItemApplyAll = applyAll;
      if (applyAll) syncApplyAllControls();
    };
    const applyLabel = document.createElement("span");
    applyLabel.textContent = "Edit all slots together";
    applyAllRow.append(applyToggle, applyLabel);
    const syncApplyAllControls = () => {
      if (!applyAll) return;
      slotsList.querySelectorAll("input[data-slot-idx]").forEach((s) => {
        s.value = String(s._currentPct || s.value);
        const mode = s._currentMode || "percent";
        s.disabled = mode === "custom";
        s.style.opacity = mode === "custom" ? "0.45" : "1";
      });
      slotsList.querySelectorAll("input[data-scale-input-slot]").forEach((s) => {
        s.value = String(s._currentScale || s.value);
      });
      slotsList.querySelectorAll("[data-size-label]").forEach((lab) => {
        const curPct = lab._currentPct;
        if (curPct != null) lab.textContent = `${curPct}%`;
      });
      slotsList.querySelectorAll("input[data-scale-mode-slot]").forEach((chk) => {
        const mode = chk._currentMode || "percent";
        chk.checked = mode === "custom";
      });
      slotsList.querySelectorAll("[data-custom-row-slot]").forEach((row) => {
        const mode = row._currentMode || "percent";
        row.style.display = mode === "custom" ? "flex" : "none";
      });
      slotsList.querySelectorAll("[data-slider-row-slot]").forEach((row) => {
        const mode = row._currentMode || "percent";
        row.style.display = mode === "custom" ? "none" : "";
      });
    };
    slots.forEach((slot, idx) => {
      const box = document.createElement("div");
      Object.assign(box.style, {
        border: "1px solid #2c3643",
        borderRadius: "8px",
        padding: "8px",
        background: "rgba(10,14,20,0.9)",
        display: "grid",
        gap: "6px"
      });
      const rawScale = Number(slot?.targetScale);
      const fallbackScale = computeTargetScaleFromPercent(species, 100);
      const initialScale = Number.isFinite(rawScale) ? rawScale : fallbackScale;
      const { minScale, maxScale } = getScaleBoundsForSpecies(species);
      const computePercentLoose = (scale) => {
        const { minScale: minScale2, maxScale: maxScale2 } = getScaleBoundsForSpecies(species);
        if (!maxScale2 || maxScale2 <= minScale2) return 100;
        const pct2 = 50 + (scale - minScale2) / (maxScale2 - minScale2) * 50;
        return clampSizePercent(pct2);
      };
      const pct = computePercentLoose(initialScale);
      let currentPct = pct;
      let currentScale = initialScale;
      const outOfBounds = initialScale < minScale || initialScale > maxScale;
      let currentMode = slotModeMap[idx] === "custom" ? "custom" : outOfBounds ? "custom" : "percent";
      if (!slotModeMap[idx] && outOfBounds) {
        currentItemSlotModes[modeKey] = { ...currentItemSlotModes[modeKey] || {}, [idx]: "custom" };
      }
      const sizeRow = document.createElement("div");
      sizeRow.style.display = "flex";
      sizeRow.style.justifyContent = "space-between";
      sizeRow.style.alignItems = "center";
      sizeRow.style.fontSize = "11px";
      sizeRow.style.opacity = "0.85";
      const sizeName = document.createElement("span");
      sizeName.textContent = "Size";
      const sizeValue = document.createElement("span");
      sizeValue.textContent = `${currentPct}%`;
      sizeValue.dataset.sizeLabel = String(idx);
      sizeValue._currentPct = currentPct;
      sizeRow.append(sizeName, sizeValue);
      const slider = document.createElement("input");
      slider.type = "range";
      slider.min = "50";
      slider.max = "100";
      slider.step = "1";
      slider.value = String(currentPct);
      slider.dataset.slotIdx = String(idx);
      slider._currentPct = currentPct;
      slider._currentMode = currentMode;
      Object.assign(slider.style, { width: "100%", cursor: "pointer" });
      const sliderRow = document.createElement("div");
      sliderRow.dataset.sliderRowSlot = String(idx);
      sliderRow.appendChild(slider);
      const customRow = document.createElement("div");
      customRow.style.display = "flex";
      customRow.style.alignItems = "center";
      customRow.style.gap = "6px";
      customRow.style.fontSize = "11px";
      customRow.style.opacity = "0.9";
      const customLabel = document.createElement("span");
      customLabel.textContent = "Custom scale";
      const customInput = document.createElement("input");
      customInput.type = "text";
      customInput.inputMode = "decimal";
      customInput.autocomplete = "off";
      customInput.value = String(currentScale);
      customInput.dataset.scaleInputSlot = String(idx);
      customInput._currentScale = currentScale;
      Object.assign(customInput.style, {
        width: "90px",
        padding: "4px 6px",
        borderRadius: "6px",
        border: "1px solid #2c3643",
        background: "rgba(10,14,20,0.9)",
        color: "#e7eef7"
      });
      let pendingPatch = null;
      let debounceTimer = null;
      const flushPatch = () => {
        if (!pendingPatch) return;
        const patch2 = pendingPatch;
        pendingPatch = null;
        void updateGardenObjectAtCurrentTile((obj) => {
          if (obj?.objectType !== "plant") return obj;
          const nextSlots = Array.isArray(obj.slots) ? obj.slots.slice() : [];
          if (applyAll) {
            for (let i = 0; i < nextSlots.length; i++) {
              nextSlots[i] = { ...nextSlots[i] || {}, ...patch2 };
            }
          } else {
            nextSlots[idx] = { ...nextSlots[idx] || {}, ...patch2 };
          }
          return { ...obj, slots: nextSlots };
        });
      };
      const queuePatch = (patch2) => {
        pendingPatch = { ...pendingPatch || {}, ...patch2 };
        if (debounceTimer != null) window.clearTimeout(debounceTimer);
        debounceTimer = window.setTimeout(() => {
          flushPatch();
        }, 150);
      };
      const updatePercent = (nextPct) => {
        const pctVal = clampSizePercent(nextPct);
        currentPct = pctVal;
        slider._currentPct = pctVal;
        sizeValue._currentPct = pctVal;
        sizeValue.textContent = `${pctVal}%`;
        slider.value = String(pctVal);
        currentScale = computeTargetScaleFromPercent(species, pctVal);
        if (currentMode !== "custom") customInput.value = currentScale.toFixed(4);
        customInput._currentScale = currentScale;
        queuePatch({ targetScale: currentScale });
        if (applyAll) {
          slotsList.querySelectorAll("input[data-slot-idx]").forEach((s) => {
            if (s === slider) return;
            s.value = String(pctVal);
            s._currentPct = pctVal;
            s._currentMode = "percent";
            s.disabled = false;
            s.style.opacity = "1";
          });
          slotsList.querySelectorAll("input[data-scale-input-slot]").forEach((s) => {
            if (s === customInput) return;
            s.value = currentScale.toFixed(4);
            s._currentScale = currentScale;
          });
          slotsList.querySelectorAll("[data-size-label]").forEach((lab) => {
            lab.textContent = `${pctVal}%`;
            lab._currentPct = pctVal;
          });
          applyModeToAll("percent", currentScale, currentPct);
        }
      };
      const updateCustomScale = (raw) => {
        const normalized = raw.replace(",", ".").replace(/\s+/g, "");
        const n = Number(normalized);
        if (!Number.isFinite(n)) return;
        currentScale = n;
        customInput.value = normalized;
        customInput._currentScale = n;
        const pctVal = computePercentFromScale(species, n);
        currentPct = pctVal;
        slider.value = String(pctVal);
        sizeValue.textContent = `${pctVal}%`;
        queuePatch({ targetScale: n });
        if (applyAll) {
          slotsList.querySelectorAll("input[data-slot-idx]").forEach((s) => {
            if (s === slider) return;
            s.value = String(pctVal);
            s._currentPct = pctVal;
            s._currentMode = "custom";
            s.disabled = true;
            s.style.opacity = "0.45";
          });
          slotsList.querySelectorAll("input[data-scale-input-slot]").forEach((s) => {
            if (s === customInput) return;
            s.value = String(n);
            s._currentScale = n;
          });
          slotsList.querySelectorAll("[data-size-label]").forEach((lab) => {
            lab.textContent = `${pctVal}%`;
            lab._currentPct = pctVal;
          });
          applyModeToAll("custom", n, currentPct);
        }
      };
      slider.oninput = () => updatePercent(Number(slider.value));
      const commitCustomInput = () => updateCustomScale(customInput.value);
      customInput.onblur = commitCustomInput;
      customInput.onkeydown = (ev) => {
        if (ev.key === "Enter") {
          ev.preventDefault();
          commitCustomInput();
        }
      };
      customRow.append(customLabel, customInput);
      const modeRow = document.createElement("label");
      modeRow.style.display = "flex";
      modeRow.style.alignItems = "center";
      modeRow.style.gap = "6px";
      modeRow.style.fontSize = "11px";
      modeRow.style.opacity = "0.9";
      const modeToggle = document.createElement("input");
      modeToggle.type = "checkbox";
      modeToggle.dataset.scaleModeSlot = String(idx);
      modeToggle._currentMode = currentMode;
      modeToggle.checked = currentMode === "custom";
      const modeText = document.createElement("span");
      modeText.textContent = "Use custom scale";
      const syncValueLabel = () => {
        sizeValue.textContent = currentMode === "custom" ? `${currentScale.toFixed(2)}x` : `${currentPct}%`;
        sizeValue._currentPct = currentPct;
      };
      const syncControlState = () => {
        const showPercent = currentMode !== "custom";
        modeToggle._currentMode = currentMode;
        slider._currentMode = currentMode;
        slider.disabled = !showPercent;
        sliderRow.style.display = showPercent ? "" : "none";
        customRow.style.display = showPercent ? "none" : "flex";
      };
      modeToggle.onchange = () => {
        currentMode = modeToggle.checked ? "custom" : "percent";
        currentItemSlotModes[modeKey] = {
          ...currentItemSlotModes[modeKey] || {},
          [idx]: currentMode
        };
        if (currentMode === "custom") {
          queuePatch({ targetScale: currentScale });
        } else {
          const clamped = clampCustomScale(species, currentScale);
          currentScale = clamped;
          customInput._currentScale = clamped;
          customInput.value = String(clamped);
          const pctVal = computePercentFromScale(species, clamped);
          currentPct = pctVal;
          slider._currentPct = pctVal;
          slider.value = String(pctVal);
          queuePatch({ targetScale: clamped });
        }
        syncControlState();
        syncValueLabel();
        if (applyAll) syncApplyAllControls();
        if (applyAll) {
          applyModeToAll(currentMode, currentScale, currentPct);
        }
      };
      const installGameKeyBlocker = (inp) => {
        const stop2 = (ev) => {
          ev.stopImmediatePropagation?.();
          ev.stopPropagation();
        };
        const attach = () => {
          window.addEventListener("keydown", stop2, true);
          window.addEventListener("keyup", stop2, true);
        };
        const detach = () => {
          window.removeEventListener("keydown", stop2, true);
          window.removeEventListener("keyup", stop2, true);
        };
        inp.addEventListener("focus", attach);
        inp.addEventListener("blur", detach);
        inp.addEventListener("keydown", stop2);
      };
      const installCharGuard = (inp) => {
        const allowed = /* @__PURE__ */ new Set(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "-", "."]);
        inp.addEventListener("keydown", (ev) => {
          if (ev.ctrlKey || ev.metaKey || ev.altKey) return;
          const k = ev.key;
          if (["Backspace", "Delete", "Tab", "Enter", "ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"].includes(k)) {
            return;
          }
          if (k.length === 1 && !allowed.has(k)) {
            ev.preventDefault();
          }
        });
        inp.addEventListener("input", () => {
          const cleaned = inp.value.replace(/[^0-9.-]/g, "");
          if (cleaned !== inp.value) inp.value = cleaned;
        });
      };
      installGameKeyBlocker(customInput);
      installCharGuard(customInput);
      modeRow.append(modeToggle, modeText);
      slider.disabled = currentMode === "custom";
      sliderRow.style.display = currentMode === "custom" ? "none" : "";
      customRow.style.display = currentMode === "custom" ? "flex" : "none";
      syncControlState();
      syncValueLabel();
      const mutWrap = document.createElement("div");
      mutWrap.style.display = "grid";
      mutWrap.style.gap = "6px";
      const mutTitle = document.createElement("div");
      mutTitle.textContent = "Mutations";
      mutTitle.style.fontSize = "11px";
      mutTitle.style.opacity = "0.85";
      const mutRow = document.createElement("div");
      mutRow.style.display = "flex";
      mutRow.style.flexWrap = "wrap";
      mutRow.style.gap = "6px";
      mutRow.style.alignItems = "center";
      const mutations = Array.isArray(slot?.mutations) ? slot.mutations.slice() : [];
      const mutationKeys = Object.keys(mutationCatalog || {});
      const applyMutationsPatch = (nextMutations) => {
        const copy2 = nextMutations.slice();
        mutations.length = 0;
        mutations.push(...copy2);
        void updateGardenObjectAtCurrentTile((obj) => {
          if (obj?.objectType !== "plant") return obj;
          const nextSlots = Array.isArray(obj.slots) ? obj.slots.slice() : [];
          if (applyAll) {
            for (let i = 0; i < nextSlots.length; i++) {
              nextSlots[i] = { ...nextSlots[i] || {}, mutations: copy2.slice() };
            }
          } else {
            nextSlots[idx] = { ...nextSlots[idx] || {}, mutations: copy2.slice() };
          }
          return { ...obj, slots: nextSlots };
        }).then(() => {
          renderMutations();
        });
      };
      const styleLetter = (target, mutId) => {
        const color = mutationColorMap[mutId];
        if (!color) return;
        if (color.startsWith("linear-gradient")) {
          target.style.backgroundImage = color;
          target.style.backgroundClip = "text";
          target.style.webkitBackgroundClip = "text";
          target.style.color = "transparent";
          target.style.webkitTextFillColor = "transparent";
        } else {
          target.style.color = color;
        }
      };
      const getLetter = (mutId) => {
        const def = mutationCatalog[mutId] || {};
        const src = def.name || mutId || "?";
        return String(src).charAt(0).toUpperCase();
      };
      const renderMutations = () => {
        mutRow.innerHTML = "";
        for (const mutId of mutations) {
          const tag = document.createElement("span");
          Object.assign(tag.style, {
            borderRadius: "999px",
            padding: "3px 8px",
            fontSize: "11px",
            fontWeight: "700",
            border: "1px solid #2c3643",
            background: "rgba(10,14,20,0.9)",
            cursor: "pointer"
          });
          const letterSpan = document.createElement("span");
          letterSpan.textContent = getLetter(mutId);
          letterSpan.style.fontWeight = "900";
          styleLetter(letterSpan, mutId);
          tag.title = "Remove mutation";
          tag.onclick = () => {
            const next = mutations.filter((m) => m !== mutId);
            applyMutationsPatch(next);
          };
          tag.appendChild(letterSpan);
          mutRow.appendChild(tag);
        }
        if (mutations.length < mutationKeys.length) {
          const toggleBtn2 = document.createElement("button");
          toggleBtn2.type = "button";
          toggleBtn2.textContent = "+";
          Object.assign(toggleBtn2.style, {
            width: "28px",
            height: "28px",
            borderRadius: "50%",
            border: "1px solid #2c3643",
            background: "rgba(10,14,20,0.9)",
            color: "#e7eef7",
            fontWeight: "900",
            fontSize: "16px",
            cursor: "pointer",
            display: "inline-flex",
            alignItems: "center",
            justifyContent: "center"
          });
          toggleBtn2.onclick = () => {
            const isOpen = dropdown.style.display !== "none";
            dropdown.style.display = isOpen ? "none" : "grid";
            toggleBtn2.style.background = isOpen ? "rgba(10,14,20,0.9)" : "rgba(32,42,56,0.8)";
          };
          mutRow.appendChild(toggleBtn2);
        }
      };
      const dropdown = document.createElement("div");
      dropdown.style.display = "none";
      dropdown.style.gridTemplateColumns = "repeat(auto-fill, minmax(90px, 1fr))";
      dropdown.style.gap = "6px";
      dropdown.style.padding = "6px";
      dropdown.style.border = "1px solid #2c3643";
      dropdown.style.borderRadius = "8px";
      dropdown.style.background = "rgba(8,12,18,0.9)";
      for (const mutKey of mutationKeys) {
        const def = mutationCatalog[mutKey] || {};
        const storedId = mutKey === "Amberlit" ? "Ambershine" : mutKey;
        const isActive = Array.isArray(slot.mutations) && slot.mutations.includes(storedId);
        if (isActive) continue;
        const btn = document.createElement("button");
        btn.type = "button";
        btn.textContent = def.name || mutKey || "?";
        Object.assign(btn.style, {
          padding: "6px 8px",
          borderRadius: "8px",
          border: isActive ? "1px solid #55d38a" : "1px solid #2c3643",
          background: isActive ? "rgba(85,211,138,0.22)" : "rgba(10,14,20,0.9)",
          color: "#e7eef7",
          fontSize: "11px",
          fontWeight: "700",
          cursor: "pointer",
          textAlign: "left"
        });
        const color = mutationColorMap[storedId];
        if (color) {
          btn.style.color = color.startsWith("linear-gradient") ? "#e7eef7" : color;
          if (color.startsWith("linear-gradient")) {
            btn.style.backgroundImage = color;
            btn.style.backgroundClip = "text";
            btn.style.webkitBackgroundClip = "text";
            btn.style.color = "transparent";
            btn.style.webkitTextFillColor = "transparent";
          }
        }
        btn.onclick = () => {
          const has = Array.isArray(slot.mutations) && slot.mutations.includes(storedId);
          const next = has ? (slot.mutations || []).filter((x) => x !== storedId) : [...slot.mutations || [], storedId];
          applyMutationsPatch(next);
        };
        dropdown.appendChild(btn);
      }
      mutWrap.append(mutTitle, mutRow, dropdown);
      renderMutations();
      box.append(sizeRow, modeRow, sliderRow, customRow, mutWrap);
      slotsList.appendChild(box);
    });
    const showSlotControls = maxSlots > 1;
    if (showSlotControls) {
      const slotHeader = document.createElement("div");
      slotHeader.style.display = "flex";
      slotHeader.style.alignItems = "center";
      slotHeader.style.justifyContent = "space-between";
      slotHeader.style.fontSize = "12px";
      slotHeader.style.opacity = "0.9";
      slotHeader.style.gap = "8px";
      const slotCount = document.createElement("span");
      slotCount.textContent = `Slots ${slots.length}/${maxSlots}`;
      const slotBtnWrap = document.createElement("div");
      slotBtnWrap.style.display = "flex";
      slotBtnWrap.style.gap = "6px";
      slotBtnWrap.style.alignItems = "center";
      const makeCircleBtn = (text) => {
        const b = document.createElement("button");
        b.type = "button";
        b.textContent = text;
        Object.assign(b.style, {
          width: "28px",
          height: "28px",
          borderRadius: "50%",
          border: "1px solid #2b3441",
          background: "rgba(16,21,28,0.9)",
          color: "#e7eef7",
          cursor: "pointer",
          fontSize: "14px",
          fontWeight: "600",
          display: "inline-flex",
          alignItems: "center",
          justifyContent: "center"
        });
        return b;
      };
      const btnAdd = makeCircleBtn("+");
      const btnRemove = makeCircleBtn("-");
      const updateSlotHeaderState = () => {
        slotCount.textContent = `Slots ${slots.length}/${maxSlots}`;
        btnAdd.disabled = slots.length >= maxSlots;
        btnRemove.disabled = slots.length <= 1;
        btnAdd.style.opacity = btnAdd.disabled ? "0.4" : "1";
        btnRemove.style.opacity = btnRemove.disabled ? "0.4" : "1";
      };
      updateSlotHeaderState();
      const makeDefaultSlot = () => ({
        species,
        startTime: FIXED_SLOT_START,
        endTime: FIXED_SLOT_END,
        targetScale: computeTargetScaleFromPercent(species, 100),
        mutations: []
      });
      btnAdd.onclick = () => {
        if (slots.length >= maxSlots) return;
        void updateGardenObjectAtCurrentTile((obj) => {
          if (obj?.objectType !== "plant") return obj;
          const nextSlots = Array.isArray(obj.slots) ? obj.slots.slice() : [];
          if (nextSlots.length >= maxSlots) return obj;
          nextSlots.push(makeDefaultSlot());
          return { ...obj, slots: nextSlots };
        }).then((ok) => {
          if (ok) renderCurrentItemOverlay();
        });
      };
      btnRemove.onclick = () => {
        if (slots.length <= 1) return;
        void updateGardenObjectAtCurrentTile((obj) => {
          if (obj?.objectType !== "plant") return obj;
          const nextSlots = Array.isArray(obj.slots) ? obj.slots.slice(0, Math.max(1, obj.slots.length - 1)) : [];
          return { ...obj, slots: nextSlots };
        }).then((ok) => {
          if (ok) renderCurrentItemOverlay();
        });
      };
      slotBtnWrap.append(btnRemove, btnAdd);
      slotHeader.append(slotCount, slotBtnWrap);
      content.appendChild(slotHeader);
      content.appendChild(applyAllRow);
    }
    content.appendChild(slotsList);
    const applyModeToAll = (mode, refScale, refPct) => {
      slotsList.querySelectorAll("input[data-scale-mode-slot]").forEach((chk) => {
        chk.checked = mode === "custom";
        chk._currentMode = mode;
      });
      slotsList.querySelectorAll("input[data-slot-idx]").forEach((s) => {
        s._currentMode = mode;
        s.disabled = mode === "custom";
        s.style.opacity = mode === "custom" ? "0.45" : "1";
        if (mode === "percent") {
          s.value = String(s._currentPct ?? refPct);
        }
      });
      slotsList.querySelectorAll("[data-slider-row-slot]").forEach((row) => {
        row.style.display = mode === "custom" ? "none" : "";
        row._currentMode = mode;
      });
      slotsList.querySelectorAll("[data-custom-row-slot]").forEach((row) => {
        row.style.display = mode === "custom" ? "flex" : "none";
        row._currentMode = mode;
      });
      slotsList.querySelectorAll("input[data-scale-input-slot]").forEach((inp) => {
        if (mode === "custom") {
          inp.value = String(inp._currentScale ?? refScale);
        }
      });
      slotsList.querySelectorAll("[data-size-label]").forEach((lab) => {
        const pctVal = lab._currentPct ?? refPct;
        lab.textContent = mode === "custom" ? `${refScale.toFixed(2)}x` : `${pctVal}%`;
      });
      const map2 = currentItemSlotModes[modeKey] || {};
      for (let i = 0; i < slots.length; i++) map2[i] = mode;
      currentItemSlotModes[modeKey] = map2;
    };
  }
  function renderSideList() {
    if (!sideListWrap) return;
    const applySelectionStyle = (btn, selected) => {
      btn.style.border = "1px solid " + (selected ? "#4a6fa5" : "#2b3441");
      btn.style.background = selected ? "rgba(74,111,165,0.18)" : "rgba(24,30,39,0.9)";
      btn.style.fontWeight = selected ? "700" : "600";
    };
    const selectedId = getSelectedId();
    const entries = getSideEntries();
    const sig = `${currentSideMode}:${JSON.stringify(entries)}`;
    const existingList = sideListWrap.querySelector('[data-editor-side-list="list"]');
    if (existingList && existingList.dataset.sig === sig) {
      existingList.querySelectorAll("button[data-id]").forEach((btn) => {
        applySelectionStyle(btn, btn.dataset.id === selectedId);
      });
      return;
    }
    sideListWrap.innerHTML = "";
    const list = document.createElement("div");
    list.dataset.editorSideList = "list";
    list.dataset.sig = sig;
    list.style.display = "grid";
    list.style.gap = "4px";
    const makeItem = (key2, label2, selected) => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.dataset.id = key2;
      Object.assign(btn.style, {
        width: "100%",
        display: "grid",
        gridTemplateColumns: "auto 1fr",
        alignItems: "center",
        gap: "8px",
        padding: "8px",
        borderRadius: "8px",
        color: "#e7eef7",
        cursor: "pointer"
      });
      applySelectionStyle(btn, selected);
      const icon = createSelectionIcon(
        getSideSpriteKind() === "Decor" ? "decor" : "plants",
        label2,
        26,
        key2
      );
      const labelEl = document.createElement("span");
      labelEl.textContent = label2;
      labelEl.style.textAlign = "left";
      labelEl.style.overflow = "hidden";
      labelEl.style.textOverflow = "ellipsis";
      labelEl.style.whiteSpace = "nowrap";
      btn.onclick = () => {
        setSelectedId(key2);
        renderSideList();
        renderSideDetails();
      };
      btn.append(icon, labelEl);
      return btn;
    };
    for (const it of entries) {
      const isSelected = selectedId === it.id;
      list.appendChild(makeItem(it.id, it.label, isSelected));
    }
    if (!list.childElementCount) {
      const empty = document.createElement("div");
      empty.style.opacity = "0.7";
      empty.textContent = "No entries.";
      sideListWrap.appendChild(empty);
      return;
    }
    sideListWrap.appendChild(list);
  }
  function renderSideDetails() {
    if (!sideRightWrap) return;
    sideRightWrap.innerHTML = "";
    const content = document.createElement("div");
    content.style.display = "grid";
    content.style.gap = "10px";
    content.style.minHeight = "0";
    content.style.overflow = "auto";
    content.style.alignContent = "flex-start";
    content.style.justifyItems = "center";
    const actionBar = document.createElement("div");
    actionBar.style.display = "grid";
    actionBar.style.gap = "6px";
    actionBar.style.justifyItems = "start";
    actionBar.style.marginTop = "4px";
    const selId = getSelectedId();
    if (!selId) {
      const empty = document.createElement("div");
      empty.style.opacity = "0.7";
      empty.style.textAlign = "center";
      empty.textContent = "Select an item on the left.";
      content.appendChild(empty);
      sideRightWrap.append(content, actionBar);
      return;
    }
    const entry = getSideEntry(selId);
    const label2 = getSideEntryLabel(selId, entry);
    const infoRow = document.createElement("div");
    infoRow.style.display = "grid";
    infoRow.style.gridTemplateColumns = "auto 1fr";
    infoRow.style.alignItems = "center";
    infoRow.style.gap = "10px";
    infoRow.dataset.editorInfoRow = "true";
    infoRow.dataset.selId = selId;
    const existingInfo = sideRightWrap.querySelector("[data-editor-info-row]");
    const existingIcon = existingInfo?.querySelector("[data-editor-info-icon]");
    const existingLabel = existingInfo?.querySelector("[data-editor-info-label]");
    const icon = existingIcon && existingInfo?.dataset.selId === selId ? existingIcon : (() => {
      const el2 = createSelectionIcon(
        getSideSpriteKind() === "Decor" ? "decor" : "plants",
        label2,
        48,
        selId
      );
      el2.dataset.editorInfoIcon = "true";
      return el2;
    })();
    const nameEl = existingLabel && existingInfo?.dataset.selId === selId ? existingLabel : (() => {
      const el2 = document.createElement("div");
      el2.dataset.editorInfoLabel = "true";
      el2.style.fontWeight = "700";
      el2.style.fontSize = "15px";
      el2.style.whiteSpace = "nowrap";
      el2.style.overflow = "hidden";
      el2.style.textOverflow = "ellipsis";
      return el2;
    })();
    nameEl.textContent = label2;
    infoRow.append(icon, nameEl);
    content.appendChild(infoRow);
    if (currentSideMode === "plants") {
      const maxSlots = getMaxSlotsForSpecies(selId);
      const slotsState = ensureEditorStateForSpecies(selId);
      const slotsConfig = slotsState.slots;
      const applyAll = slotsState.applyAll;
      const slotsPanel = document.createElement("div");
      slotsPanel.style.display = "grid";
      slotsPanel.style.gap = "6px";
      slotsPanel.style.marginTop = "6px";
      slotsPanel.style.width = "100%";
      if (maxSlots > 1) {
        const headerRow = document.createElement("div");
        headerRow.style.display = "flex";
        headerRow.style.justifyContent = "space-between";
        headerRow.style.alignItems = "center";
        headerRow.style.fontSize = "12px";
        headerRow.style.opacity = "0.9";
        const headerLabel = document.createElement("span");
        headerLabel.textContent = "Slots";
        const headerRight = document.createElement("div");
        headerRight.style.display = "flex";
        headerRight.style.gap = "6px";
        headerRight.style.alignItems = "center";
        const countLabel = document.createElement("span");
        countLabel.textContent = `${slotsConfig.length}/${maxSlots}`;
        const btnAdd = document.createElement("button");
        btnAdd.type = "button";
        btnAdd.textContent = "+";
        Object.assign(btnAdd.style, {
          width: "28px",
          height: "28px",
          borderRadius: "50%",
          border: "1px solid #2b3441",
          background: "rgba(16,21,28,0.9)",
          color: "#e7eef7",
          cursor: "pointer",
          fontSize: "14px",
          fontWeight: "600"
        });
        btnAdd.onclick = () => {
          const state3 = ensureEditorStateForSpecies(selId);
          const current = state3.slots;
          if (current.length >= maxSlots) return;
          const defaultScale = computeTargetScaleFromPercent(selId, 100);
          editorPlantSlotsState = {
            ...state3,
            species: selId,
            slots: [
              ...current,
              {
                enabled: true,
                sizePercent: 100,
                customScale: defaultScale,
                sizeMode: "percent",
                mutations: []
              }
            ]
          };
          renderSideDetails();
        };
        const btnRemove = document.createElement("button");
        btnRemove.type = "button";
        btnRemove.textContent = "-";
        Object.assign(btnRemove.style, {
          width: "28px",
          height: "28px",
          borderRadius: "50%",
          border: "1px solid #2b3441",
          background: "rgba(220,80,80,0.18)",
          color: "#e7eef7",
          cursor: "pointer",
          fontSize: "14px",
          fontWeight: "600"
        });
        btnRemove.onclick = () => {
          const state3 = ensureEditorStateForSpecies(selId);
          const current = state3.slots;
          if (current.length <= 1) return;
          editorPlantSlotsState = {
            ...state3,
            species: selId,
            slots: current.slice(0, current.length - 1)
          };
          renderSideDetails();
        };
        headerRight.append(countLabel, btnRemove, btnAdd);
        headerRow.append(headerLabel, headerRight);
        slotsPanel.appendChild(headerRow);
      }
      if (maxSlots > 1) {
        const applyAllRow = document.createElement("label");
        applyAllRow.style.display = "flex";
        applyAllRow.style.alignItems = "center";
        applyAllRow.style.gap = "6px";
        applyAllRow.style.fontSize = "12px";
        applyAllRow.style.opacity = "0.9";
        const applyToggle = document.createElement("input");
        applyToggle.type = "checkbox";
        applyToggle.checked = applyAll;
        applyToggle.onchange = () => {
          editorPlantSlotsState.applyAll = applyToggle.checked;
          renderSideDetails();
        };
        const applyLabel = document.createElement("span");
        applyLabel.textContent = "Edit all slots together";
        applyAllRow.append(applyToggle, applyLabel);
        slotsPanel.appendChild(applyAllRow);
      }
      const list = document.createElement("div");
      list.style.display = "grid";
      list.style.gap = "6px";
      slotsConfig.forEach((cfg, idx) => {
        const slotBox = document.createElement("div");
        Object.assign(slotBox.style, {
          border: "1px solid #2c3643",
          borderRadius: "8px",
          padding: "8px",
          background: "rgba(10,14,20,0.9)",
          display: "grid",
          gap: "6px"
        });
        const initialPct = clampSizePercent(Number.isFinite(cfg.sizePercent) ? cfg.sizePercent : 100);
        const baseScaleFromPct = computeTargetScaleFromPercent(selId, initialPct);
        const initialCustomScale = normalizeCustomScale(
          selId,
          Number.isFinite(cfg.customScale) ? cfg.customScale : baseScaleFromPct
        );
        let currentMode = cfg.sizeMode === "custom" ? "custom" : "percent";
        let currentPct = initialPct;
        let currentScale = currentMode === "custom" ? initialCustomScale : baseScaleFromPct;
        let percentMemory = currentPct;
        let customText = String(currentScale);
        const sizeRow = document.createElement("div");
        sizeRow.style.display = "flex";
        sizeRow.style.justifyContent = "space-between";
        sizeRow.style.alignItems = "center";
        sizeRow.style.fontSize = "11px";
        sizeRow.style.opacity = "0.85";
        const sizeName = document.createElement("span");
        sizeName.textContent = "Size";
        const sizeValue = document.createElement("span");
        sizeValue.dataset.sizeLabel = String(idx);
        sizeRow.append(sizeName, sizeValue);
        const modeRow = document.createElement("label");
        modeRow.style.display = "flex";
        modeRow.style.alignItems = "center";
        modeRow.style.gap = "6px";
        modeRow.style.fontSize = "11px";
        modeRow.style.opacity = "0.9";
        const modeToggle = document.createElement("input");
        modeToggle.type = "checkbox";
        modeToggle.dataset.scaleMode = String(idx);
        modeToggle.checked = currentMode === "custom";
        const modeText = document.createElement("span");
        modeText.textContent = "Use custom scale";
        modeRow.append(modeToggle, modeText);
        const slider = document.createElement("input");
        slider.type = "range";
        slider.min = "50";
        slider.max = "100";
        slider.step = "1";
        slider.value = String(currentPct);
        slider.dataset.slotIdx = String(idx);
        Object.assign(slider.style, {
          width: "100%",
          cursor: "pointer"
        });
        const customRow = document.createElement("div");
        customRow.style.display = "flex";
        customRow.style.alignItems = "center";
        customRow.style.gap = "6px";
        customRow.style.fontSize = "11px";
        customRow.style.opacity = "0.9";
        customRow.dataset.customRow = String(idx);
        const customLabel = document.createElement("span");
        customLabel.textContent = "Custom scale";
        const customInput = document.createElement("input");
        customInput.type = "text";
        customInput.inputMode = "decimal";
        customInput.autocomplete = "off";
        customInput.value = customText;
        customInput.dataset.scaleInput = String(idx);
        Object.assign(customInput.style, {
          width: "90px",
          padding: "4px 6px",
          borderRadius: "6px",
          border: "1px solid #2c3643",
          background: "rgba(10,14,20,0.9)",
          color: "#e7eef7"
        });
        customRow.append(customLabel, customInput);
        const installGameKeyBlocker = (inp) => {
          const stop2 = (ev) => {
            ev.stopImmediatePropagation?.();
            ev.stopPropagation();
          };
          const attach = () => {
            window.addEventListener("keydown", stop2, true);
            window.addEventListener("keyup", stop2, true);
          };
          const detach = () => {
            window.removeEventListener("keydown", stop2, true);
            window.removeEventListener("keyup", stop2, true);
          };
          inp.addEventListener("focus", attach);
          inp.addEventListener("blur", detach);
          inp.addEventListener("keydown", stop2);
        };
        installGameKeyBlocker(customInput);
        const formatScaleLabel = (val) => `${val.toFixed(2)}x`;
        const formatScaleInput = (val) => val.toFixed(2);
        const parseInputNumber = (el2) => {
          const raw = el2.value;
          if (raw === "" || raw == null) return null;
          const normalized = raw.replace(",", ".").replace(/\s+/g, "");
          const n = Number(normalized);
          return Number.isFinite(n) ? n : null;
        };
        const installCharGuard = (inp) => {
          const allowed = /* @__PURE__ */ new Set(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "-", "."]);
          inp.addEventListener("keydown", (ev) => {
            if (ev.ctrlKey || ev.metaKey || ev.altKey) return;
            const k = ev.key;
            if (k === "Backspace" || k === "Delete" || k === "Tab" || k === "Enter" || k === "ArrowLeft" || k === "ArrowRight" || k === "ArrowUp" || k === "ArrowDown" || k === "Home" || k === "End") {
              return;
            }
            if (k.length === 1 && !allowed.has(k)) {
              ev.preventDefault();
            }
          });
          inp.addEventListener("input", () => {
            const cleaned = inp.value.replace(/[^0-9.-]/g, "");
            if (cleaned !== inp.value) {
              inp.value = cleaned;
            }
            customText = inp.value;
          });
        };
        installCharGuard(customInput);
        const syncValueLabel = () => {
          sizeValue.textContent = currentMode === "custom" ? formatScaleLabel(currentScale) : `${currentPct}%`;
        };
        const syncControlState = () => {
          const showPercentMode = currentMode !== "custom";
          slider.disabled = currentMode === "custom";
          slider.style.opacity = currentMode === "custom" ? "0.45" : "1";
          customInput.disabled = currentMode !== "custom";
          customInput.style.opacity = currentMode === "custom" ? "1" : "0.5";
          slider.style.display = showPercentMode ? "" : "none";
          customRow.style.display = showPercentMode ? "none" : "flex";
        };
        const syncApplyAll = () => {
          if (!applyAll || !sideRightWrap) return;
          const showPercentMode = currentMode !== "custom";
          sideRightWrap.querySelectorAll("input[data-slot-idx]").forEach((s) => {
            s.value = String(currentPct);
            s.disabled = currentMode === "custom";
            s.style.opacity = currentMode === "custom" ? "0.45" : "1";
            s.style.display = showPercentMode ? "" : "none";
          });
          sideRightWrap.querySelectorAll("input[data-scale-input]").forEach((inp) => {
            if (currentMode === "custom") {
              inp.value = customText;
            } else {
              inp.value = formatScaleInput(currentScale);
            }
            inp.disabled = currentMode !== "custom";
            inp.style.opacity = currentMode === "custom" ? "1" : "0.5";
          });
          sideRightWrap.querySelectorAll("input[data-scale-mode]").forEach((chk) => {
            chk.checked = currentMode === "custom";
          });
          sideRightWrap.querySelectorAll("[data-size-label]").forEach((lab) => {
            lab.textContent = currentMode === "custom" ? formatScaleLabel(currentScale) : `${currentPct}%`;
          });
          sideRightWrap.querySelectorAll("[data-scale-row]").forEach((row) => {
            row.remove();
          });
          sideRightWrap.querySelectorAll("[data-custom-row]").forEach((row) => {
            row.style.display = showPercentMode ? "none" : "flex";
          });
        };
        const applySlotPatch = (patch2) => {
          const base = ensureEditorStateForSpecies(selId).slots;
          editorPlantSlotsState = {
            ...editorPlantSlotsState,
            species: selId,
            slots: base.map((c, i) => {
              if (!applyAll && i !== idx) return c;
              return { ...c, sizeMode: currentMode, ...patch2 };
            })
          };
        };
        const updatePercent = (nextPct) => {
          const pct = clampSizePercent(nextPct);
          currentPct = pct;
          percentMemory = pct;
          slider.value = String(pct);
          if (currentMode !== "custom") {
            currentScale = computeTargetScaleFromPercent(selId, pct);
          }
          applySlotPatch({
            sizePercent: pct,
            ...currentMode !== "custom" ? { customScale: currentScale } : {}
          });
          syncValueLabel();
          syncApplyAll();
        };
        const updateCustomScale = (nextScale, rawText) => {
          const normalized = normalizeCustomScale(selId, nextScale);
          currentScale = normalized;
          if (typeof rawText === "string") customText = rawText;
          else customText = customInput.value;
          applySlotPatch({ customScale: normalized });
          syncValueLabel();
          syncApplyAll();
        };
        slider.oninput = () => {
          updatePercent(Number(slider.value));
        };
        customInput.oninput = () => {
          const raw = customInput.value;
          customText = raw;
          const n = parseInputNumber(customInput);
          if (n == null) return;
          updateCustomScale(n, raw);
        };
        modeToggle.onchange = () => {
          currentMode = modeToggle.checked ? "custom" : "percent";
          if (currentMode === "custom") {
            percentMemory = currentPct;
            currentScale = normalizeCustomScale(selId, currentScale || computeTargetScaleFromPercent(selId, currentPct));
            customText = customInput.value || String(currentScale);
            applySlotPatch({ customScale: currentScale });
          } else {
            const restoredPct = clampSizePercent(percentMemory);
            currentPct = restoredPct;
            slider.value = String(restoredPct);
            applySlotPatch({ sizePercent: restoredPct });
          }
          syncControlState();
          syncValueLabel();
          syncApplyAll();
        };
        syncControlState();
        syncValueLabel();
        const mutWrap = document.createElement("div");
        mutWrap.style.display = "grid";
        mutWrap.style.gap = "6px";
        const mutTitle = document.createElement("div");
        mutTitle.textContent = "Mutations";
        mutTitle.style.fontSize = "11px";
        mutTitle.style.opacity = "0.85";
        const toggleMutBtn = document.createElement("button");
        toggleMutBtn.type = "button";
        toggleMutBtn.textContent = "+";
        Object.assign(toggleMutBtn.style, {
          width: "28px",
          height: "28px",
          borderRadius: "50%",
          border: "1px solid #2c3643",
          background: "rgba(10,14,20,0.9)",
          color: "#e7eef7",
          fontWeight: "900",
          fontSize: "16px",
          cursor: "pointer",
          display: "inline-flex",
          alignItems: "center",
          justifyContent: "center"
        });
        const activeRow = document.createElement("div");
        activeRow.style.display = "flex";
        activeRow.style.flexWrap = "wrap";
        activeRow.style.gap = "6px";
        activeRow.style.alignItems = "center";
        const mutDropdown = document.createElement("div");
        mutDropdown.style.display = "none";
        mutDropdown.style.gridTemplateColumns = "repeat(auto-fill, minmax(90px, 1fr))";
        mutDropdown.style.gap = "6px";
        mutDropdown.style.padding = "6px";
        mutDropdown.style.border = "1px solid #2c3643";
        mutDropdown.style.borderRadius = "8px";
        mutDropdown.style.background = "rgba(8,12,18,0.9)";
        const mutationKeys = Object.keys(mutationCatalog || {});
        const renderActiveTags = () => {
          activeRow.innerHTML = "";
          const active = Array.isArray(cfg.mutations) ? cfg.mutations : [];
          const allKeys = mutationKeys.map((k) => k === "Amberlit" ? "Ambershine" : k);
          const allSelected = allKeys.every((k) => active.includes(k));
          const styleLetter = (target, mutId) => {
            const color = mutationColorMap[mutId];
            if (!color) return;
            if (color.startsWith("linear-gradient")) {
              target.style.backgroundImage = color;
              target.style.backgroundClip = "text";
              target.style.webkitBackgroundClip = "text";
              target.style.color = "transparent";
              target.style.webkitTextFillColor = "transparent";
            } else {
              target.style.color = color;
            }
          };
          const getLetter = (mutId) => {
            const def = mutationCatalog[mutId] || {};
            const src = def.name || mutId || "?";
            return String(src).charAt(0).toUpperCase();
          };
          for (const mutId of active) {
            const tag = document.createElement("span");
            Object.assign(tag.style, {
              borderRadius: "999px",
              padding: "3px 8px",
              fontSize: "11px",
              fontWeight: "700",
              border: "1px solid #2c3643",
              background: "rgba(10,14,20,0.9)",
              cursor: "pointer"
            });
            const letterSpan = document.createElement("span");
            letterSpan.textContent = getLetter(mutId);
            letterSpan.style.fontWeight = "900";
            styleLetter(letterSpan, mutId);
            tag.title = "Remove mutation";
            tag.onclick = () => {
              const base = ensureEditorStateForSpecies(selId).slots;
              editorPlantSlotsState = {
                ...editorPlantSlotsState,
                species: selId,
                slots: applyAll ? base.map((c) => {
                  const prev = Array.isArray(c.mutations) ? c.mutations : [];
                  const next = prev.filter((m) => m !== mutId);
                  return { ...c, mutations: next };
                }) : base.map((c, i) => {
                  if (i !== idx) return c;
                  const prev = Array.isArray(c.mutations) ? c.mutations : [];
                  const next = prev.filter((m) => m !== mutId);
                  return { ...c, mutations: next };
                })
              };
              renderSideDetails();
            };
            tag.appendChild(letterSpan);
            activeRow.appendChild(tag);
          }
          if (!allSelected) {
            activeRow.appendChild(toggleMutBtn);
          }
        };
        const setDropdownOpen = (open) => {
          mutDropdown.style.display = open ? "grid" : "none";
          toggleMutBtn.style.background = open ? "rgba(32,42,56,0.8)" : "rgba(10,14,20,0.9)";
        };
        toggleMutBtn.onclick = () => {
          const isOpen = mutDropdown.style.display !== "none";
          setDropdownOpen(!isOpen);
        };
        for (const mutKey of mutationKeys) {
          const def = mutationCatalog[mutKey] || {};
          const storedId = mutKey === "Amberlit" ? "Ambershine" : mutKey;
          const isActive = Array.isArray(cfg.mutations) && cfg.mutations.includes(storedId);
          if (isActive) continue;
          const btn2 = document.createElement("button");
          btn2.type = "button";
          btn2.textContent = def.name || mutKey || "?";
          Object.assign(btn2.style, {
            padding: "6px 8px",
            borderRadius: "8px",
            border: isActive ? "1px solid #55d38a" : "1px solid #2c3643",
            background: isActive ? "rgba(85,211,138,0.22)" : "rgba(10,14,20,0.9)",
            color: "#e7eef7",
            fontSize: "11px",
            fontWeight: "700",
            cursor: "pointer",
            textAlign: "left"
          });
          const color = mutationColorMap[storedId];
          if (color) {
            btn2.style.color = color.startsWith("linear-gradient") ? "#e7eef7" : color;
            if (color.startsWith("linear-gradient")) {
              btn2.style.backgroundImage = color;
              btn2.style.backgroundClip = "text";
              btn2.style.webkitBackgroundClip = "text";
              btn2.style.color = "transparent";
              btn2.style.webkitTextFillColor = "transparent";
            }
          }
          btn2.onclick = () => {
            const base = ensureEditorStateForSpecies(selId).slots;
            editorPlantSlotsState = {
              ...editorPlantSlotsState,
              species: selId,
              slots: applyAll ? base.map((c) => {
                const prev = Array.isArray(c.mutations) ? c.mutations : [];
                const has = prev.includes(storedId);
                const next = has ? prev.filter((x) => x !== storedId) : [...prev, storedId];
                return { ...c, mutations: next };
              }) : base.map((c, i) => {
                if (i !== idx) return c;
                const prev = Array.isArray(c.mutations) ? c.mutations : [];
                const has = prev.includes(storedId);
                const next = has ? prev.filter((x) => x !== storedId) : [...prev, storedId];
                return { ...c, mutations: next };
              })
            };
            renderSideDetails();
          };
          mutDropdown.appendChild(btn2);
        }
        mutWrap.append(mutTitle, activeRow, mutDropdown);
        renderActiveTags();
        setDropdownOpen(false);
        slotBox.append(sizeRow, modeRow, slider, customRow, mutWrap);
        list.appendChild(slotBox);
      });
      slotsPanel.appendChild(list);
      content.appendChild(slotsPanel);
    }
    const btn = document.createElement("button");
    btn.type = "button";
    btn.textContent = "Add to inventory";
    Object.assign(btn.style, {
      width: "100%",
      padding: "8px 10px",
      borderRadius: "8px",
      border: "1px solid #2b3441",
      background: "linear-gradient(180deg, rgba(42,154,255,0.12), rgba(30,91,181,0.35))",
      color: "#e7eef7",
      fontWeight: "700",
      cursor: "pointer"
    });
    btn.onclick = () => {
      console.log("[EditorService] addSelectedItemToInventory click", {
        mode: currentSideMode,
        id: selId
      });
      void addSelectedItemToInventory();
    };
    actionBar.appendChild(btn);
    sideRightWrap.append(content, actionBar);
  }
  function compareSlotKeys(a, b) {
    const ai = Number(a);
    const bi = Number(b);
    if (Number.isFinite(ai) && Number.isFinite(bi)) return ai - bi;
    return a.localeCompare(b);
  }
  function findPlayerSlot(slots, playerId2, opts = {}) {
    if (!slots || typeof slots !== "object") return null;
    const isMatch = (slot) => slot && String(slot.playerId || slot.id || "") === String(playerId2);
    if (Array.isArray(slots)) {
      const arr = slots;
      for (let i = 0; i < arr.length; i++) {
        if (isMatch(arr[i])) {
          return { isArray: true, matchSlot: arr[i], matchIndex: i, entries: null, slotsArray: arr };
        }
      }
      return null;
    }
    const entries = Object.entries(slots);
    if (opts.sortObject) entries.sort(([a], [b]) => compareSlotKeys(a, b));
    for (let i = 0; i < entries.length; i++) {
      const [, s] = entries[i];
      if (isMatch(s)) {
        return { isArray: false, matchSlot: s, matchIndex: i, entries, slotsArray: null };
      }
    }
    return null;
  }
  function slotMatchToIndex(meta) {
    if (meta.isArray) return meta.matchIndex;
    const entry = meta.entries?.[meta.matchIndex];
    const k = entry ? entry[0] : null;
    const n = Number(k);
    return Number.isFinite(n) ? n : 0;
  }
  function rebuildUserSlots(meta, buildSlot) {
    if (meta.isArray) {
      const nextSlots = (meta.slotsArray || []).slice();
      nextSlots[meta.matchIndex] = buildSlot(meta.matchSlot);
      return nextSlots;
    }
    const nextEntries = (meta.entries || []).map(
      ([k, s], idx) => idx === meta.matchIndex ? [k, buildSlot(s)] : [k, s]
    );
    return Object.fromEntries(nextEntries);
  }
  function buildStateWithUserSlots(cur, userSlots) {
    return {
      ...cur || {},
      child: {
        ...cur?.child || {},
        data: {
          ...cur?.child?.data || {},
          userSlots
        }
      }
    };
  }
  async function withPatchedWrite(patch2, op) {
    if (!patch2) {
      await op();
      return;
    }
    const { atom, readKey, origRead, writeKey, origWrite } = patch2;
    const savedRead = atom[readKey];
    const savedWrite = writeKey ? atom[writeKey] : void 0;
    try {
      atom[readKey] = origRead;
      if (writeKey && origWrite) atom[writeKey] = origWrite;
      await op();
    } finally {
      atom[readKey] = savedRead;
      if (writeKey) atom[writeKey] = savedWrite;
    }
  }
  async function setStateAtom(next) {
    console.log("[EditorService] setStateAtom attempt", {
      hasPatch: !!statePatch
    });
    await withPatchedWrite(statePatch, async () => {
      try {
        await Atoms.root.state.set(next);
        console.log("[EditorService] setStateAtom success");
      } catch (err) {
        console.log("[EditorService] setStateAtom failed", err);
        throw err;
      }
    });
  }
  async function addSelectedItemToInventory() {
    const selId = getSelectedId();
    if (!selId) return;
    if (currentSideMode === "decor") {
      console.log("[EditorService] addSelectedItemToInventory decor", selId);
      await addDecorToInventory(selId);
    } else {
      console.log("[EditorService] addSelectedItemToInventory plant", selId);
      await addPlantToInventory(selId);
    }
  }
  async function removeSelectedInventoryItem() {
    try {
      const pid = await getPlayerId();
      if (!pid) return false;
      const selectedIndex = await Atoms.inventory.myValidatedSelectedItemIndex.get();
      const inventoryVal = await Atoms.inventory.myInventory.get();
      const items = Array.isArray(inventoryVal?.items) ? inventoryVal.items.slice() : [];
      if (selectedIndex == null || typeof selectedIndex !== "number" || selectedIndex < 0 || selectedIndex >= items.length) {
        return false;
      }
      items.splice(selectedIndex, 1);
      const cur = stateFrozenValue ?? await Atoms.root.state.get();
      const slots = cur?.child?.data?.userSlots;
      const slotMatch = findPlayerSlot(slots, pid);
      if (!slotMatch) return false;
      const slotData = slotMatch.matchSlot?.data || {};
      const slotInv = slotData.inventory || {};
      const favorited = Array.isArray(slotInv.favoritedItemIds) ? slotInv.favoritedItemIds.filter((id) => items.some((it) => it?.id === id)) : void 0;
      const nextUserSlots = rebuildUserSlots(slotMatch, (slot) => {
        const data = slot?.data || {};
        return {
          ...slot || {},
          data: {
            ...data,
            inventory: {
              ...slotInv || {},
              items,
              ...favorited ? { favoritedItemIds: favorited } : {}
            }
          }
        };
      });
      const nextState = buildStateWithUserSlots(cur, nextUserSlots);
      stateFrozenValue = nextState;
      stateOriginalValue = nextState;
      await setStateAtom(nextState);
      const newIdx = Math.max(0, Math.min(items.length - 1, selectedIndex));
      try {
        await Atoms.inventory.myValidatedSelectedItemIndex.set(newIdx);
      } catch {
      }
      return true;
    } catch (err) {
      console.log("[EditorService] removeSelectedInventoryItem failed", err);
      return false;
    }
  }
  async function addTileObjectToInventory(tileObject) {
    try {
      const pid = await getPlayerId();
      if (!pid || !tileObject) return false;
      const cur = stateFrozenValue ?? await Atoms.root.state.get();
      const slots = cur?.child?.data?.userSlots;
      const slotMatch = findPlayerSlot(slots, pid);
      if (!slotMatch) return false;
      const slotData = slotMatch.matchSlot?.data || {};
      const inv = slotData.inventory;
      const items = Array.isArray(inv?.items) ? inv.items.slice() : [];
      if (tileObject.objectType === "plant") {
        const plantItem = {
          itemType: "Plant",
          species: tileObject.species,
          id: tileObject.id,
          slots: Array.isArray(tileObject.slots) ? JSON.parse(JSON.stringify(tileObject.slots)) : [],
          plantedAt: tileObject.plantedAt,
          maturedAt: tileObject.maturedAt
        };
        items.push(plantItem);
      } else if (tileObject.objectType === "decor") {
        items.push({
          itemType: "Decor",
          decorId: tileObject.decorId,
          quantity: 1,
          rotation: typeof tileObject.rotation === "number" ? tileObject.rotation : 0
        });
      } else {
        return false;
      }
      const slotInv = slotData.inventory || {};
      const nextUserSlots = rebuildUserSlots(slotMatch, (slot) => {
        const data = slot?.data || {};
        return {
          ...slot || {},
          data: {
            ...data,
            inventory: { ...slotInv || {}, items }
          }
        };
      });
      const nextState = buildStateWithUserSlots(cur, nextUserSlots);
      stateFrozenValue = nextState;
      stateOriginalValue = nextState;
      await setStateAtom(nextState);
      try {
        await Atoms.inventory.myValidatedSelectedItemIndex.set(items.length - 1);
      } catch {
      }
      return true;
    } catch (err) {
      console.log("[EditorService] addTileObjectToInventory failed", err);
      return false;
    }
  }
  async function addDecorToInventory(decorId) {
    try {
      console.log("[EditorService] addDecorToInventory", decorId);
      const pid = await getPlayerId();
      if (!pid) {
        console.log("[EditorService] addDecorToInventory: no playerId");
        return;
      }
      const cur = stateFrozenValue ?? await Atoms.root.state.get();
      const slots = cur?.child?.data?.userSlots;
      if (!slots || typeof slots !== "object") {
        console.log("[EditorService] addDecorToInventory: no userSlots");
        return;
      }
      const slotMatch = findPlayerSlot(slots, pid);
      if (!slotMatch) {
        console.log("[EditorService] addDecorToInventory: player slot not found");
        return;
      }
      const slotData = slotMatch.matchSlot.data || {};
      const inv = slotData.inventory;
      const items = Array.isArray(inv?.items) ? inv.items.slice() : [];
      console.log("[EditorService] decor before add", { itemsLen: items.length });
      items.push({
        itemType: "Decor",
        decorId,
        quantity: 1
      });
      const nextUserSlots = rebuildUserSlots(slotMatch, (slot) => {
        const slotDataInner = slot?.data || {};
        const slotInv = slotDataInner.inventory;
        return {
          ...slot || {},
          data: {
            ...slotDataInner,
            inventory: { ...slotInv || {}, items }
          }
        };
      });
      const next = buildStateWithUserSlots(cur, nextUserSlots);
      stateFrozenValue = next;
      stateOriginalValue = next;
      try {
        await setStateAtom(next);
      } catch (err) {
        console.log("[EditorService] stateAtom set failed (decor)", err);
      }
      console.log("[EditorService] decor after add", { itemsLen: items.length });
      console.log("[EditorService] decor added", { decorId });
    } catch (err) {
      console.log("[EditorService] failed to add decor", err);
    }
  }
  async function addPlantToInventory(species) {
    try {
      console.log("[EditorService] addPlantToInventory", species);
      const pid = await getPlayerId();
      if (!pid) {
        console.log("[EditorService] addPlantToInventory: no playerId");
        return;
      }
      const cur = stateFrozenValue ?? await Atoms.root.state.get();
      const slots = cur?.child?.data?.userSlots;
      if (!slots || typeof slots !== "object") {
        console.log("[EditorService] addPlantToInventory: no userSlots");
        return;
      }
      const slotMatch = findPlayerSlot(slots, pid);
      if (!slotMatch) {
        console.log("[EditorService] addPlantToInventory: player slot not found");
        return;
      }
      const slotData = slotMatch.matchSlot.data || {};
      const inv = slotData.inventory;
      const items = Array.isArray(inv?.items) ? inv.items.slice() : [];
      const entry = plantCatalog?.[species] ?? {};
      const plantDef = entry?.plant ?? {};
      const isMultipleHarvest = plantDef?.harvestType === "Multiple";
      console.log("[EditorService] plant before add", { itemsLen: items.length, isMultipleHarvest });
      const maxSlots = getMaxSlotsForSpecies(species);
      const slotsConfig = editorPlantSlotsState.species === species ? editorPlantSlotsState.slots.slice(0, maxSlots) : ensureEditorSlotsForSpecies(species).slice(0, maxSlots);
      const slotsArr = [];
      for (const cfg of slotsConfig) {
        if (!cfg.enabled) continue;
        const targetScale = resolveSlotTargetScale(species, cfg);
        const mutations = Array.isArray(cfg.mutations) ? cfg.mutations.slice() : [];
        slotsArr.push({
          species,
          startTime: 1760866288723,
          endTime: 1760867858782,
          targetScale,
          mutations
        });
      }
      const slotCount = slotsArr.length;
      const newItem = {
        id: typeof crypto !== "undefined" && typeof crypto.randomUUID === "function" ? crypto.randomUUID() : `plant-${Math.random().toString(16).slice(2)}`,
        itemType: "Plant",
        species,
        slots: slotsArr,
        plantedAt: 1760779438723,
        maturedAt: 1760865838723
      };
      if (!isMultipleHarvest) {
        newItem.name = entry?.crop?.name ?? plantDef?.name ?? species;
      }
      items.push(newItem);
      const nextUserSlots = rebuildUserSlots(slotMatch, (slot) => {
        const slotDataInner = slot?.data || {};
        const slotInv = slotDataInner.inventory;
        return {
          ...slot || {},
          data: {
            ...slotDataInner,
            inventory: { ...slotInv || {}, items }
          }
        };
      });
      const next = buildStateWithUserSlots(cur, nextUserSlots);
      stateFrozenValue = next;
      stateOriginalValue = next;
      try {
        await setStateAtom(next);
      } catch (err) {
        console.log("[EditorService] stateAtom set failed (plant)", err);
      }
      console.log("[EditorService] plant after add", { itemsLen: items.length + 1 });
      console.log("[EditorService] plant added", {
        species,
        isMultipleHarvest,
        slotCount
      });
    } catch (err) {
      console.log("[EditorService] failed to add plant", err);
    }
  }
  function notify(enabled) {
    listeners3.forEach((cb) => {
      try {
        cb(enabled);
      } catch {
      }
    });
  }
  function applyState(enabled, opts = {}) {
    const next = !!enabled;
    const changed = next !== currentEnabled;
    if (next && overlaysVisible) showOverlay();
    else hideOverlay();
    if (next && overlaysVisible) showSideOverlay();
    else hideSideOverlay();
    if (next && overlaysVisible) showCurrentItemOverlay();
    else hideCurrentItemOverlay();
    if (next && !currentEnabled) {
      void logGardenTilesForEditor();
      void snapshotAndClearGardenForEditor();
      void freezeStateAtom();
    } else if (!next && currentEnabled) {
      void restoreGardenSnapshotForEditor();
      void unfreezeStateAtom();
    }
    currentEnabled = next;
    if (opts.persist !== false) persist(next);
    if (changed && opts.emit !== false) notify(next);
  }
  var EditorService = {
    init() {
      installEditorKeybindsOnce();
      applyState(currentEnabled, { persist: false, emit: false });
    },
    isEnabled() {
      return currentEnabled;
    },
    setEnabled(enabled) {
      applyState(enabled, { persist: true, emit: true });
    },
    onChange(listener) {
      listeners3.add(listener);
      return () => listeners3.delete(listener);
    },
    onSavedGardensChange(listener) {
      savedGardensListeners.add(listener);
      return () => savedGardensListeners.delete(listener);
    }
  };
  var EMPTY_GARDEN = { tileObjects: {}, boardwalkTileObjects: {} };
  function isGardenEmpty(val) {
    const tiles = val?.tileObjects;
    const boards = val?.boardwalkTileObjects;
    const isEmptyObj = (o) => o && typeof o === "object" && Object.keys(o).length === 0;
    return isEmptyObj(tiles) && isEmptyObj(boards);
  }
  function makeEmptyGarden() {
    return { ...EMPTY_GARDEN };
  }
  function sanitizeGarden(val) {
    const tileObjects = val && typeof val === "object" && typeof val.tileObjects === "object" ? val.tileObjects : {};
    const boardwalkTileObjects = val && typeof val === "object" && typeof val.boardwalkTileObjects === "object" ? val.boardwalkTileObjects : {};
    return {
      tileObjects: { ...tileObjects },
      boardwalkTileObjects: { ...boardwalkTileObjects }
    };
  }
  function readSavedGardens() {
    try {
      const parsed = readAriesPath(ARIES_SAVED_GARDENS_PATH);
      const arr = Array.isArray(parsed) ? parsed : [];
      return arr.map((g) => ({
        id: String(g?.id || ""),
        name: String(g?.name || "Untitled"),
        createdAt: Number(g?.createdAt) || Date.now(),
        garden: sanitizeGarden(g?.garden || {})
      })).filter((g) => !!g.id);
    } catch {
      return [];
    }
  }
  function writeSavedGardens(list) {
    try {
      writeAriesPath(ARIES_SAVED_GARDENS_PATH, list || []);
    } catch {
      return;
    }
    notifySavedGardensChanged();
  }
  async function getGardenForPlayer(playerId2) {
    try {
      if (!playerId2) return null;
      const cur = stateFrozenValue ?? await Atoms.root.state.get();
      const slots = cur?.child?.data?.userSlots;
      const slotMatch = findPlayerSlot(slots, playerId2, { sortObject: true });
      if (!slotMatch || !slotMatch.matchSlot) return null;
      const g = slotMatch.matchSlot?.data?.garden;
      return sanitizeGarden(g || {});
    } catch {
      return null;
    }
  }
  async function setCurrentGarden(nextGarden) {
    try {
      const pid = await getPlayerId();
      if (!pid) return false;
      const cur = stateFrozenValue ?? await Atoms.root.state.get();
      const slots = cur?.child?.data?.userSlots;
      const slotMatch = findPlayerSlot(slots, pid, { sortObject: true });
      if (!slotMatch || !slotMatch.matchSlot) return false;
      const userSlotIdx = slotMatchToIndex(slotMatch);
      const updatedSlot = {
        ...slotMatch.matchSlot,
        data: {
          ...slotMatch.matchSlot?.data || {},
          garden: sanitizeGarden(nextGarden)
        }
      };
      const nextUserSlots = rebuildUserSlots(slotMatch, () => updatedSlot);
      const nextState = buildStateWithUserSlots(cur, nextUserSlots);
      stateFrozenValue = nextState;
      stateOriginalValue = nextState;
      await setStateAtom(nextState);
      try {
        await applyGardenToTos(nextGarden, userSlotIdx);
      } catch {
      }
      return true;
    } catch (err) {
      console.log("[EditorService] setCurrentGarden failed", err);
      return false;
    }
  }
  async function applyFriendGardenPreview(garden2) {
    if (!garden2 || typeof garden2 !== "object") return false;
    try {
      const pid = await getPlayerId();
      if (!pid) return false;
      const cur = await Atoms.root.state.get().catch(() => null);
      if (!cur) return false;
      const slots = cur?.child?.data?.userSlots;
      const slotMatch = findPlayerSlot(slots, pid, { sortObject: true });
      if (!slotMatch || !slotMatch.matchSlot) return false;
      const userSlotIdx = slotMatchToIndex(slotMatch);
      const prevGarden = slotMatch.matchSlot?.data?.garden ? sanitizeGarden(slotMatch.matchSlot.data.garden) : makeEmptyGarden();
      friendGardenBackup = { garden: prevGarden, userSlotIdx };
      const updatedSlot = {
        ...slotMatch.matchSlot,
        data: {
          ...slotMatch.matchSlot?.data || {},
          garden: sanitizeGarden(garden2)
        }
      };
      const nextUserSlots = rebuildUserSlots(slotMatch, () => updatedSlot);
      const nextState = buildStateWithUserSlots(cur, nextUserSlots);
      await setStateAtom(nextState);
      try {
        await applyGardenToTos(garden2, userSlotIdx);
      } catch {
      }
      friendGardenPreviewActive = true;
      return true;
    } catch (error) {
      console.error("[EditorService] applyFriendGardenPreview failed", error);
      friendGardenPreviewActive = false;
      return false;
    }
  }
  async function clearFriendGardenPreview() {
    if (!friendGardenPreviewActive) return false;
    friendGardenPreviewActive = false;
    try {
      const backup = friendGardenBackup;
      friendGardenBackup = null;
      if (backup) {
        const pid = await getPlayerId();
        if (pid) {
          const cur = await Atoms.root.state.get().catch(() => null);
          const slots = cur?.child?.data?.userSlots;
          const slotMatch = findPlayerSlot(slots, pid, { sortObject: true });
          if (slotMatch && slotMatch.matchSlot) {
            const updatedSlot = {
              ...slotMatch.matchSlot,
              data: {
                ...slotMatch.matchSlot?.data || {},
                garden: sanitizeGarden(backup.garden)
              }
            };
            const nextUserSlots = rebuildUserSlots(slotMatch, () => updatedSlot);
            const nextState = buildStateWithUserSlots(cur, nextUserSlots);
            await setStateAtom(nextState);
            try {
              await applyGardenToTos(backup.garden, backup.userSlotIdx);
            } catch {
            }
          }
        }
      }
      return true;
    } catch (error) {
      console.error("[EditorService] clearFriendGardenPreview failed", error);
      return false;
    }
  }
  function listSavedGardens() {
    return readSavedGardens();
  }
  async function saveCurrentGarden(name, playerId2) {
    const pid = playerId2 || await getPlayerId();
    if (!pid) return null;
    const garden2 = await getGardenForPlayer(pid);
    if (!garden2) return null;
    const now2 = Date.now();
    const all = readSavedGardens();
    const baseName = name?.trim() || "Untitled";
    const makeUniqueName = (base, existing) => {
      let idx = 1;
      let candidate = base;
      const set3 = new Set(existing);
      while (set3.has(candidate)) {
        candidate = `${base} (${idx})`;
        idx += 1;
      }
      return candidate;
    };
    const existingIdx = all.findIndex((g) => g.name === baseName);
    let finalName = baseName;
    let reuseId = null;
    if (existingIdx >= 0) {
      const canConfirm = typeof window !== "undefined" && typeof window.confirm === "function";
      const overwrite = canConfirm ? window.confirm(`A garden named "${baseName}" already exists. Overwrite it?`) : false;
      if (overwrite) {
        reuseId = all[existingIdx]?.id || null;
      } else {
        finalName = makeUniqueName(baseName, all.map((g) => g.name));
      }
    }
    const saved = {
      id: reuseId || `${now2}-${Math.random().toString(16).slice(2)}`,
      name: finalName,
      createdAt: now2,
      garden: garden2
    };
    let updated = [];
    if (reuseId) {
      updated = all.map((g) => g.id === reuseId ? saved : g);
    } else {
      all.unshift(saved);
      updated = all.slice(0, 50);
    }
    writeSavedGardens(updated);
    return saved;
  }
  async function loadSavedGarden(id) {
    if (!id) return false;
    const all = readSavedGardens();
    const found = all.find((g) => g.id === id);
    if (!found) return false;
    return setCurrentGarden(found.garden);
  }
  function deleteSavedGarden(id) {
    if (!id) return false;
    const all = readSavedGardens();
    const next = all.filter((g) => g.id !== id);
    if (next.length === all.length) return false;
    writeSavedGardens(next);
    return true;
  }
  function exportSavedGarden(id) {
    if (!id) return null;
    const all = readSavedGardens();
    const found = all.find((g) => g.id === id);
    if (!found) return null;
    return JSON.stringify(found.garden, null, 2);
  }
  async function importGarden(name, raw) {
    if (!raw) return null;
    try {
      const parsed = JSON.parse(raw);
      const garden2 = sanitizeGarden(parsed);
      const now2 = Date.now();
      const saved = {
        id: `${now2}-${Math.random().toString(16).slice(2)}`,
        name: name?.trim() || "Imported garden",
        createdAt: now2,
        garden: garden2
      };
      const all = readSavedGardens();
      all.unshift(saved);
      writeSavedGardens(all.slice(0, 50));
      return saved;
    } catch {
      return null;
    }
  }
  async function getPlayerId() {
    try {
      const id = await Atoms.player.playerId.get();
      return typeof id === "string" && id ? id : null;
    } catch {
      return null;
    }
  }
  function buildClearedState(state3, playerId2) {
    const slots = state3?.child?.data?.userSlots;
    const slotMatch = findPlayerSlot(slots, playerId2, { sortObject: true });
    if (!slotMatch || !slotMatch.matchSlot || typeof slotMatch.matchSlot !== "object") {
      return { next: state3, changed: false };
    }
    const garden2 = slotMatch.matchSlot?.data?.garden;
    const inventory = slotMatch.matchSlot?.data?.inventory;
    const hasInventory = inventory && typeof inventory === "object";
    const gardenChanged = !isGardenEmpty(garden2);
    const invChanged = hasInventory && (Array.isArray(inventory.items) ? inventory.items.length > 0 : true ? inventory?.inventory?.items?.length > 0 : false);
    if (!gardenChanged && !invChanged) return { next: state3, changed: false };
    const updatedSlot = {
      ...slotMatch.matchSlot,
      data: {
        ...slotMatch.matchSlot?.data || {},
        garden: makeEmptyGarden(),
        petSlots: buildEmptyPetSlots(slotMatch.matchSlot?.data?.petSlots),
        ...hasInventory ? { inventory: { ...inventory || {}, items: [], favoritedItemIds: [] } } : {}
      }
    };
    const nextUserSlots = rebuildUserSlots(slotMatch, () => updatedSlot);
    const nextState = buildStateWithUserSlots(state3, nextUserSlots);
    return { next: nextState, changed: true };
  }
  async function buildClearedStateSnapshot(playerId2) {
    try {
      const cur = await Atoms.root.state.get();
      const { next } = buildClearedState(cur, playerId2);
      return next;
    } catch {
      return null;
    }
  }
  var savedGardenSnapshot = null;
  async function readUserSlotIdx() {
    try {
      const store = await ensureStore().catch(() => null);
      const atom = store ? getAtomByLabel("myUserSlotIdxAtom") : null;
      const raw = atom ? store?.get(atom) : null;
      if (typeof raw === "number" && Number.isFinite(raw)) return raw;
    } catch {
    }
    return 0;
  }
  async function collectCurrentUserGardenTiles() {
    const [mapData, userSlotIdx] = await Promise.all([
      Atoms.root.map.get().catch(() => null),
      readUserSlotIdx()
    ]);
    const cols = Number(mapData?.cols);
    if (!mapData || !Number.isFinite(cols)) return null;
    const clone = (v) => {
      try {
        return JSON.parse(JSON.stringify(v));
      } catch {
        return v;
      }
    };
    const toPos = (gidx) => ({
      x: gidx % cols,
      y: Math.floor(gidx / cols)
    });
    const stateVal = await Atoms.root.state.get().catch(() => null);
    const slots = stateVal?.child?.data?.userSlots;
    const garden2 = Array.isArray(slots) ? slots?.[userSlotIdx]?.data?.garden : slots?.[String(userSlotIdx)]?.data?.garden;
    const dirtObjs = garden2?.tileObjects || {};
    const boardObjs = garden2?.boardwalkTileObjects || {};
    const dirt = Object.entries(mapData?.globalTileIdxToDirtTile || {}).filter(([, v]) => v && typeof v === "object" && v.userSlotIdx === userSlotIdx).map(([k, v]) => {
      const gidx = Number(k);
      const pos = toPos(gidx);
      const localIdx = Number(v?.dirtTileIdx ?? -1);
      return {
        type: "dirt",
        globalIdx: gidx,
        localIdx,
        obj: clone(dirtObjs?.[String(localIdx)] ?? null),
        ...pos
      };
    });
    const boardwalk = Object.entries(mapData?.globalTileIdxToBoardwalk || {}).filter(([, v]) => v && typeof v === "object" && v.userSlotIdx === userSlotIdx).map(([k, v]) => {
      const gidx = Number(k);
      const pos = toPos(gidx);
      const localIdx = Number(v?.boardwalkTileIdx ?? -1);
      return {
        type: "boardwalk",
        globalIdx: gidx,
        localIdx,
        obj: clone(boardObjs?.[String(localIdx)] ?? null),
        ...pos
      };
    });
    const tiles = [...dirt, ...boardwalk].sort((a, b) => a.globalIdx - b.globalIdx);
    return { userSlotIdx, dirt, boardwalk, tiles };
  }
  async function resolveTileCoords(tileType, userSlotIdx, localTileIndex) {
    const mapData = await Atoms.root.map.get().catch(() => null);
    const cols = Number(mapData?.cols);
    if (!mapData || !Number.isFinite(cols)) return null;
    const entries = tileType === "Dirt" ? Object.entries(mapData?.globalTileIdxToDirtTile || {}) : Object.entries(mapData?.globalTileIdxToBoardwalk || {});
    for (const [gidxStr, v] of entries) {
      const info = v;
      if (!info || typeof info !== "object") continue;
      const slotOk = Number(info.userSlotIdx) === userSlotIdx;
      const localOk = tileType === "Dirt" ? Number(info.dirtTileIdx) === localTileIndex : Number(info.boardwalkTileIdx) === localTileIndex;
      if (slotOk && localOk) {
        const gidx = Number(gidxStr);
        if (!Number.isFinite(gidx)) continue;
        return { x: gidx % cols, y: Math.floor(gidx / cols) };
      }
    }
    return null;
  }
  function injectTileObjectRaw(tx, ty, obj) {
    try {
      const info = tos.getTileObject(tx, ty, { ensureView: true });
      const tv = info?.tileView;
      if (!tv || typeof tv.onDataChanged !== "function") return false;
      const cloned = (() => {
        try {
          return JSON.parse(JSON.stringify(obj));
        } catch {
          return obj;
        }
      })();
      tv.onDataChanged(cloned);
      const status = tos.getStatus();
      const ctx2 = status.engine?.reusableContext;
      if (ctx2 && typeof tv.update === "function") {
        try {
          tv.update(ctx2);
        } catch {
        }
      }
      return true;
    } catch {
      return false;
    }
  }
  async function applyGardenToTos(garden2, userSlotIdx) {
    if (!tos.isReady()) return;
    const mapData = await Atoms.root.map.get().catch(() => null);
    const cols = Number(mapData?.cols);
    if (!mapData || !Number.isFinite(cols)) return;
    const dirtEntries = Object.entries(mapData?.globalTileIdxToDirtTile || {}).filter(
      ([, v]) => v?.userSlotIdx === userSlotIdx
    );
    const boardEntries = Object.entries(mapData?.globalTileIdxToBoardwalk || {}).filter(
      ([, v]) => v?.userSlotIdx === userSlotIdx
    );
    const applyEntry = (entry, type) => {
      const [gidxStr, v] = entry;
      const gidx = Number(gidxStr);
      if (!Number.isFinite(gidx)) return;
      const x = gidx % cols;
      const y = Math.floor(gidx / cols);
      const localIdx = type === "Dirt" ? Number(v?.dirtTileIdx ?? -1) : Number(v?.boardwalkTileIdx ?? -1);
      const obj = type === "Dirt" ? (garden2.tileObjects || {})[String(localIdx)] : (garden2.boardwalkTileObjects || {})[String(localIdx)];
      if (!obj) {
        tos.setTileEmpty(x, y, { ensureView: true, forceUpdate: true });
        return;
      }
      injectTileObjectRaw(x, y, obj);
      const typ = obj.objectType;
      if (typ === "plant") {
        tos.setTilePlant(x, y, {
          species: obj.species,
          plantedAt: obj.plantedAt,
          maturedAt: obj.maturedAt,
          slots: obj.slots
        }, { ensureView: true, forceUpdate: true });
      } else if (typ === "decor") {
        tos.setTileDecor(x, y, { rotation: obj.rotation }, { ensureView: true, forceUpdate: true });
      } else if (typ === "egg") {
        tos.setTileEgg(x, y, { plantedAt: obj.plantedAt, maturedAt: obj.maturedAt }, { ensureView: true, forceUpdate: true });
      } else {
        tos.setTileEmpty(x, y, { ensureView: true, forceUpdate: true });
      }
    };
    dirtEntries.forEach((e) => applyEntry(e, "Dirt"));
    boardEntries.forEach((e) => applyEntry(e, "Boardwalk"));
  }
  async function snapshotAndClearGardenForEditor() {
    if (!tos.isReady()) {
      console.log("[EditorService] snapshot skipped: tos not ready");
      return;
    }
    const info = await collectCurrentUserGardenTiles();
    if (!info) {
      console.log("[EditorService] snapshot skipped: map/user slot not ready");
      return;
    }
    savedGardenSnapshot = info.tiles.map((t) => ({ x: t.x, y: t.y, obj: t.obj }));
    for (const t of savedGardenSnapshot) {
      try {
        tos.setTileEmpty(t.x, t.y, { ensureView: true, forceUpdate: true });
      } catch (err) {
        console.log("[EditorService] clear tile failed", { x: t.x, y: t.y, err });
      }
    }
  }
  async function restoreGardenSnapshotForEditor() {
    if (!tos.isReady()) {
      console.log("[EditorService] restore skipped: tos not ready");
      return;
    }
    const snapshot = savedGardenSnapshot;
    if (!snapshot) return;
    for (const t of snapshot) {
      const obj = t.obj;
      try {
        if (!obj) {
          tos.setTileEmpty(t.x, t.y, { ensureView: true, forceUpdate: true });
          continue;
        }
        const typ = obj?.objectType;
        if (typ === "plant") {
          const patch2 = {
            species: obj.species,
            plantedAt: obj.plantedAt,
            maturedAt: obj.maturedAt,
            slots: obj.slots
          };
          injectTileObjectRaw(t.x, t.y, obj);
          tos.setTilePlant(t.x, t.y, patch2, { ensureView: true, forceUpdate: true });
        } else if (typ === "decor") {
          const patch2 = { rotation: obj.rotation };
          injectTileObjectRaw(t.x, t.y, obj);
          tos.setTileDecor(t.x, t.y, patch2, { ensureView: true, forceUpdate: true });
        } else if (typ === "egg") {
          const patch2 = { plantedAt: obj.plantedAt, maturedAt: obj.maturedAt };
          injectTileObjectRaw(t.x, t.y, obj);
          tos.setTileEgg(t.x, t.y, patch2, { ensureView: true, forceUpdate: true });
        } else {
          tos.setTileEmpty(t.x, t.y, { ensureView: true, forceUpdate: true });
        }
      } catch (err) {
        const ok = obj ? injectTileObjectRaw(t.x, t.y, obj) : false;
        if (!ok) {
          console.log("[EditorService] restore tile failed", { x: t.x, y: t.y, err });
        }
      }
    }
    savedGardenSnapshot = null;
  }
  async function logGardenTilesForEditor() {
    try {
      const info = await collectCurrentUserGardenTiles();
      if (!info) {
        console.log("[EditorService] garden tiles: map/user slot not ready");
        return;
      }
      console.log("[EditorService] garden tiles (for setTileEmpty)", {
        userSlotIdx: info.userSlotIdx,
        total: info.tiles.length,
        dirtCount: info.dirt.length,
        boardwalkCount: info.boardwalk.length,
        tiles: info.tiles
      });
    } catch (err) {
      console.log("[EditorService] garden tiles log failed", err);
    }
  }
  async function logSelectedInventoryItemWithTile() {
    try {
      const store = await ensureStore().catch(() => null);
      let tileType;
      let localTileIndex;
      if (store) {
        const tileAtom = getAtomByLabel("myCurrentGardenTileAtom");
        if (!tileAtom) {
          console.log("[EditorService] logSelectedInventoryItemWithTile: no myCurrentGardenTileAtom");
        } else {
          const tileVal = store.get(tileAtom);
          tileType = tileVal?.tileType;
          localTileIndex = tileVal?.localTileIndex;
        }
      } else {
        console.log("[EditorService] logSelectedInventoryItemWithTile: no jotai store");
      }
      const selectedIndex = await Atoms.inventory.myValidatedSelectedItemIndex.get();
      const inventoryVal = await Atoms.inventory.myInventory.get();
      const rotation = await Atoms.inventory.mySelectedItemRotation.get();
      const items = Array.isArray(inventoryVal?.items) ? inventoryVal.items : [];
      if (selectedIndex == null || typeof selectedIndex !== "number" || selectedIndex < 0 || selectedIndex >= items.length) {
        console.log("[EditorService] logSelectedInventoryItemWithTile: invalid selected index", {
          selectedIndex,
          itemsLen: items.length
        });
        return;
      }
      const selectedItem = items[selectedIndex];
      console.log("[EditorService] selected item placement debug", {
        tileType,
        localTileIndex,
        selectedIndex,
        rotation,
        item: selectedItem
      });
    } catch (err) {
      console.log("[EditorService] logSelectedInventoryItemWithTile failed", err);
    }
  }
  async function placeSelectedItemInGardenAtCurrentTile() {
    try {
      const store = await ensureStore().catch(() => null);
      if (!store) {
        console.log("[EditorService] placeSelectedItemInGardenAtCurrentTile: no jotai store");
        return;
      }
      const tileAtom = getAtomByLabel("myCurrentGardenTileAtom");
      if (!tileAtom) {
        console.log("[EditorService] placeSelectedItemInGardenAtCurrentTile: no myCurrentGardenTileAtom");
        return;
      }
      const tileVal = store.get(tileAtom);
      if (!tileVal) {
        console.log("[EditorService] placeSelectedItemInGardenAtCurrentTile: tileVal is null");
        return;
      }
      const tileType = tileVal.tileType;
      const localTileIndex = tileVal.localTileIndex;
      const userSlotIdxRaw = tileVal.userSlotIdx;
      const userSlotIdx = typeof userSlotIdxRaw === "number" && Number.isFinite(userSlotIdxRaw) ? userSlotIdxRaw : 0;
      if (localTileIndex == null || !Number.isFinite(localTileIndex)) {
        console.log("[EditorService] placeSelectedItemInGardenAtCurrentTile: invalid localTileIndex", {
          localTileIndex
        });
        return;
      }
      const selectedIndex = await Atoms.inventory.myValidatedSelectedItemIndex.get();
      const inventoryVal = await Atoms.inventory.myInventory.get();
      const rotation = await Atoms.inventory.mySelectedItemRotation.get();
      const items = Array.isArray(inventoryVal?.items) ? inventoryVal.items : [];
      if (selectedIndex == null || typeof selectedIndex !== "number" || selectedIndex < 0 || selectedIndex >= items.length) {
        console.log("[EditorService] placeSelectedItemInGardenAtCurrentTile: invalid selected index", {
          selectedIndex,
          itemsLen: items.length
        });
        return;
      }
      const selectedItem = items[selectedIndex];
      if (selectedItem?.itemType !== "Plant" && selectedItem?.itemType !== "Decor") {
        console.log("[EditorService] placeSelectedItemInGardenAtCurrentTile: unsupported itemType", {
          itemType: selectedItem?.itemType
        });
        return;
      }
      let tileObject;
      if (selectedItem.itemType === "Plant") {
        tileObject = {
          objectType: "plant",
          species: selectedItem.species,
          slots: Array.isArray(selectedItem.slots) ? selectedItem.slots : [],
          plantedAt: selectedItem.plantedAt,
          maturedAt: selectedItem.maturedAt
        };
      } else if (selectedItem.itemType === "Decor") {
        tileObject = {
          objectType: "decor",
          decorId: selectedItem.decorId,
          // rotation depuis latom, fallback sur ce quaurait dj litem (au cas o)
          rotation: typeof rotation === "number" ? rotation : selectedItem.rotation ?? 0
        };
      }
      if (!tileObject) {
        console.log("[EditorService] placeSelectedItemInGardenAtCurrentTile: failed to build tileObject");
        return;
      }
      const coords = await resolveTileCoords(tileType, userSlotIdx, localTileIndex);
      if (!coords) {
        console.log("[EditorService] placeSelectedItemInGardenAtCurrentTile: cannot resolve coords", {
          tileType,
          localTileIndex,
          userSlotIdx
        });
        return;
      }
      if (!tos.isReady()) {
        console.log("[EditorService] placeSelectedItemInGardenAtCurrentTile: tos not ready");
        return;
      }
      injectTileObjectRaw(coords.x, coords.y, tileObject);
      if (tileObject.objectType === "plant") {
        tos.setTilePlant(coords.x, coords.y, {
          species: tileObject.species,
          plantedAt: tileObject.plantedAt,
          maturedAt: tileObject.maturedAt,
          slots: tileObject.slots
        }, { ensureView: true, forceUpdate: true });
      } else if (tileObject.objectType === "decor") {
        tos.setTileDecor(coords.x, coords.y, { rotation: tileObject.rotation }, { ensureView: true, forceUpdate: true });
      }
      const cur = stateFrozenValue ?? await Atoms.root.state.get();
      const userSlots = cur?.child?.data?.userSlots;
      if (userSlots && typeof userSlots === "object") {
        const isArray = Array.isArray(userSlots);
        const matchSlot = isArray ? userSlots[userSlotIdx] : userSlots[String(userSlotIdx)];
        if (matchSlot) {
          const slotData = matchSlot.data || {};
          const prevGarden = slotData.garden && typeof slotData.garden === "object" ? slotData.garden : makeEmptyGarden();
          const garden2 = {
            tileObjects: { ...prevGarden.tileObjects || {} },
            boardwalkTileObjects: { ...prevGarden.boardwalkTileObjects || {} }
          };
          const targetKey = tileType === "Dirt" ? "tileObjects" : "boardwalkTileObjects";
          const tileKey = String(localTileIndex);
          const nextTargetMap = { ...garden2[targetKey], [tileKey]: tileObject };
          const nextGarden = {
            tileObjects: targetKey === "tileObjects" ? nextTargetMap : garden2.tileObjects,
            boardwalkTileObjects: targetKey === "boardwalkTileObjects" ? nextTargetMap : garden2.boardwalkTileObjects
          };
          const updatedSlot = {
            ...matchSlot,
            data: {
              ...slotData,
              garden: nextGarden
            }
          };
          const nextUserSlots = isArray ? (() => {
            const nextSlots = userSlots.slice();
            nextSlots[userSlotIdx] = updatedSlot;
            return nextSlots;
          })() : {
            ...userSlots,
            [String(userSlotIdx)]: updatedSlot
          };
          const nextState = buildStateWithUserSlots(cur, nextUserSlots);
          stateFrozenValue = nextState;
          stateOriginalValue = nextState;
          try {
            await setStateAtom(nextState);
          } catch {
          }
        }
      }
      console.log("[EditorService] placed item in garden (tos)", {
        tileType,
        localTileIndex,
        userSlotIdx,
        selectedIndex,
        itemType: selectedItem.itemType,
        species: selectedItem.species,
        decorId: selectedItem.decorId,
        rotation,
        coords
      });
    } catch (err) {
      console.log("[EditorService] placeSelectedItemInGardenAtCurrentTile failed", err);
    }
  }
  async function removeGardenObjectAtCurrentTile() {
    try {
      const store = await ensureStore().catch(() => null);
      if (!store) {
        console.log("[EditorService] removeItemFromGardenAtCurrentTile: no jotai store");
        return false;
      }
      const tileAtom = getAtomByLabel("myCurrentGardenTileAtom");
      if (!tileAtom) {
        console.log("[EditorService] removeItemFromGardenAtCurrentTile: no myCurrentGardenTileAtom");
        return false;
      }
      const tileVal = store.get(tileAtom);
      if (!tileVal) {
        console.log("[EditorService] removeItemFromGardenAtCurrentTile: tileVal is null");
        return false;
      }
      const tileType = tileVal.tileType;
      const localTileIndex = tileVal.localTileIndex;
      const userSlotIdxRaw = tileVal.userSlotIdx;
      const userSlotIdx = typeof userSlotIdxRaw === "number" && Number.isFinite(userSlotIdxRaw) ? userSlotIdxRaw : 0;
      if (localTileIndex == null || !Number.isFinite(localTileIndex)) {
        console.log("[EditorService] removeItemFromGardenAtCurrentTile: invalid localTileIndex", {
          localTileIndex
        });
        return false;
      }
      const coords = await resolveTileCoords(tileType, userSlotIdx, localTileIndex);
      if (!coords) {
        console.log("[EditorService] removeItemFromGardenAtCurrentTile: cannot resolve coords", {
          tileType,
          localTileIndex,
          userSlotIdx
        });
        return false;
      }
      if (!tos.isReady()) {
        console.log("[EditorService] removeItemFromGardenAtCurrentTile: tos not ready");
        return false;
      }
      tos.setTileEmpty(coords.x, coords.y, { ensureView: true, forceUpdate: true });
      const cur = stateFrozenValue ?? await Atoms.root.state.get();
      const userSlots = cur?.child?.data?.userSlots;
      if (userSlots && typeof userSlots === "object") {
        const isArray = Array.isArray(userSlots);
        const matchSlot = isArray ? userSlots[userSlotIdx] : userSlots[String(userSlotIdx)];
        if (matchSlot) {
          const slotData = matchSlot.data || {};
          const prevGarden = slotData.garden && typeof slotData.garden === "object" ? slotData.garden : makeEmptyGarden();
          const garden2 = {
            tileObjects: { ...prevGarden.tileObjects || {} },
            boardwalkTileObjects: { ...prevGarden.boardwalkTileObjects || {} }
          };
          const targetKey = tileType === "Dirt" ? "tileObjects" : "boardwalkTileObjects";
          const tileKey = String(localTileIndex);
          const currentTargetMap = garden2[targetKey] || {};
          const nextTargetMap = { ...currentTargetMap };
          delete nextTargetMap[tileKey];
          const nextGarden = {
            tileObjects: targetKey === "tileObjects" ? nextTargetMap : garden2.tileObjects,
            boardwalkTileObjects: targetKey === "boardwalkTileObjects" ? nextTargetMap : garden2.boardwalkTileObjects
          };
          const updatedSlot = {
            ...matchSlot,
            data: {
              ...slotData,
              garden: nextGarden
            }
          };
          const nextUserSlots = isArray ? (() => {
            const nextSlots = userSlots.slice();
            nextSlots[userSlotIdx] = updatedSlot;
            return nextSlots;
          })() : {
            ...userSlots,
            [String(userSlotIdx)]: updatedSlot
          };
          const nextState = buildStateWithUserSlots(cur, nextUserSlots);
          stateFrozenValue = nextState;
          stateOriginalValue = nextState;
          try {
            await setStateAtom(nextState);
          } catch {
          }
        }
      }
      console.log("[EditorService] removed item from garden (tos + state)", {
        tileType,
        localTileIndex,
        userSlotIdx,
        coords
      });
      return true;
    } catch (err) {
      console.log("[EditorService] removeItemFromGardenAtCurrentTile failed", err);
      return false;
    }
  }
  async function removeItemFromGardenAtCurrentTile() {
    void removeGardenObjectAtCurrentTile();
  }
  async function removeDecorFromGardenAtCurrentTile() {
    void removeGardenObjectAtCurrentTile();
  }
  async function updateGardenObjectAtCurrentTile(updater) {
    try {
      const store = await ensureStore().catch(() => null);
      if (!store) return false;
      const tileAtom = getAtomByLabel("myCurrentGardenTileAtom");
      if (!tileAtom) return false;
      const tileVal = store.get(tileAtom);
      if (!tileVal) return false;
      const tileType = tileVal.tileType;
      const localTileIndex = tileVal.localTileIndex;
      const userSlotIdxRaw = tileVal.userSlotIdx;
      const userSlotIdx = typeof userSlotIdxRaw === "number" && Number.isFinite(userSlotIdxRaw) ? userSlotIdxRaw : 0;
      if (localTileIndex == null || !Number.isFinite(localTileIndex)) return false;
      const cur = stateFrozenValue ?? await Atoms.root.state.get();
      const userSlots = cur?.child?.data?.userSlots;
      if (!userSlots || typeof userSlots !== "object") return false;
      const isArray = Array.isArray(userSlots);
      let matchSlot;
      if (isArray) {
        matchSlot = userSlots[userSlotIdx];
      } else {
        const key2 = String(userSlotIdx);
        matchSlot = userSlots[key2];
      }
      if (!matchSlot) return false;
      const slotData = matchSlot.data || {};
      const prevGarden = slotData.garden && typeof slotData.garden === "object" ? slotData.garden : makeEmptyGarden();
      const garden2 = {
        tileObjects: { ...prevGarden.tileObjects || {} },
        boardwalkTileObjects: { ...prevGarden.boardwalkTileObjects || {} }
      };
      const targetKey = tileType === "Dirt" ? "tileObjects" : "boardwalkTileObjects";
      const tileKey = String(localTileIndex);
      const currentTargetMap = garden2[targetKey] || {};
      const currentObj = currentTargetMap[tileKey];
      if (!currentObj) return false;
      const nextObj = updater(currentObj);
      const nextTargetMap = { ...currentTargetMap, [tileKey]: nextObj };
      const nextGarden = {
        tileObjects: targetKey === "tileObjects" ? nextTargetMap : garden2.tileObjects,
        boardwalkTileObjects: targetKey === "boardwalkTileObjects" ? nextTargetMap : garden2.boardwalkTileObjects
      };
      const updatedSlot = {
        ...matchSlot,
        data: {
          ...slotData,
          garden: nextGarden
        }
      };
      const nextUserSlots = isArray ? (() => {
        const nextSlots = userSlots.slice();
        nextSlots[userSlotIdx] = updatedSlot;
        return nextSlots;
      })() : {
        ...userSlots,
        [String(userSlotIdx)]: updatedSlot
      };
      const nextState = buildStateWithUserSlots(cur, nextUserSlots);
      stateFrozenValue = nextState;
      stateOriginalValue = nextState;
      await setStateAtom(nextState);
      try {
        const coords = await resolveTileCoords(tileType, userSlotIdx, localTileIndex);
        if (coords && tos.isReady()) {
          injectTileObjectRaw(coords.x, coords.y, nextObj);
          if (nextObj.objectType === "plant") {
            tos.setTilePlant(coords.x, coords.y, {
              species: nextObj.species,
              plantedAt: nextObj.plantedAt,
              maturedAt: nextObj.maturedAt,
              slots: nextObj.slots
            }, { ensureView: true, forceUpdate: true });
          } else if (nextObj.objectType === "decor") {
            tos.setTileDecor(coords.x, coords.y, { rotation: nextObj.rotation }, { ensureView: true, forceUpdate: true });
          } else if (nextObj.objectType === "egg") {
            tos.setTileEgg(coords.x, coords.y, {
              plantedAt: nextObj.plantedAt,
              maturedAt: nextObj.maturedAt
            }, { ensureView: true, forceUpdate: true });
          }
        }
      } catch {
      }
      return true;
    } catch {
      return false;
    }
  }
  function clampSizePercent(sizePercent) {
    const pctRaw = Number.isFinite(sizePercent) ? sizePercent : 100;
    return Math.max(50, Math.min(100, Math.round(pctRaw)));
  }
  function getScaleBoundsForSpecies(species) {
    if (!species) return { minScale: 1, maxScale: 1 };
    const entry = plantCatalog[species];
    const maxScaleRaw = Number(entry?.crop?.maxScale);
    const maxScale = Number.isFinite(maxScaleRaw) && maxScaleRaw > 1 ? maxScaleRaw : 1;
    return { minScale: 1, maxScale };
  }
  function clampCustomScale(species, scale) {
    const { minScale, maxScale } = getScaleBoundsForSpecies(species);
    if (!Number.isFinite(scale)) return minScale;
    const upper = Math.max(minScale, maxScale);
    return Math.max(minScale, Math.min(upper, scale));
  }
  function normalizeCustomScale(species, scale) {
    if (!Number.isFinite(scale)) return 1;
    return scale;
  }
  function computeTargetScaleFromPercent(species, sizePercent) {
    const pct = clampSizePercent(sizePercent);
    if (!species) return 1;
    const { minScale, maxScale } = getScaleBoundsForSpecies(species);
    if (!maxScale || maxScale <= minScale) return minScale;
    const t = (pct - 50) / 50;
    return minScale + t * (maxScale - minScale);
  }
  function computePercentFromScale(species, targetScale) {
    const { minScale, maxScale } = getScaleBoundsForSpecies(species);
    if (!maxScale || maxScale <= minScale) return 100;
    const clamped = clampCustomScale(species, targetScale);
    const pct = 50 + (clamped - minScale) / (maxScale - minScale) * 50;
    return clampSizePercent(pct);
  }
  function resolveSlotTargetScale(species, cfg) {
    if (cfg.sizeMode === "custom") {
      return normalizeCustomScale(species, cfg.customScale);
    }
    return computeTargetScaleFromPercent(species, cfg.sizePercent);
  }
  var editorPlantSlotsState = {
    species: null,
    slots: [],
    applyAll: false
  };
  function getMaxSlotsForSpecies(species) {
    const entry = plantCatalog[species];
    const plantDef = entry?.plant ?? {};
    const isMultipleHarvest = plantDef?.harvestType === "Multiple";
    const slotOffsets = Array.isArray(plantDef.slotOffsets) ? plantDef.slotOffsets : [];
    if (isMultipleHarvest && slotOffsets.length > 0) return slotOffsets.length;
    return 1;
  }
  function ensureEditorSlotsForSpecies(species) {
    const maxSlots = getMaxSlotsForSpecies(species);
    if (editorPlantSlotsState.species !== species) {
      const defaultScale = computeTargetScaleFromPercent(species, 100);
      editorPlantSlotsState = {
        species,
        slots: Array.from({ length: maxSlots }, () => ({
          enabled: true,
          sizePercent: 100,
          customScale: defaultScale,
          sizeMode: "percent",
          mutations: []
        })),
        applyAll: false
      };
      return editorPlantSlotsState.slots;
    }
    let slots = editorPlantSlotsState.slots.slice(0, maxSlots);
    if (!slots.length) {
      const defaultScale = computeTargetScaleFromPercent(species, 100);
      slots = [
        {
          enabled: true,
          sizePercent: 100,
          customScale: defaultScale,
          sizeMode: "percent",
          mutations: []
        }
      ];
    }
    slots = slots.map((slot) => {
      const pct = clampSizePercent(slot.sizePercent);
      const mode = slot.sizeMode === "custom" ? "custom" : "percent";
      const fallbackScale = computeTargetScaleFromPercent(species, pct);
      const customScale = normalizeCustomScale(
        species,
        Number.isFinite(slot.customScale) ? slot.customScale : fallbackScale
      );
      const sizePercent = mode === "custom" ? computePercentFromScale(species, customScale) : pct;
      return {
        enabled: slot.enabled !== false,
        sizePercent,
        customScale,
        sizeMode: mode,
        mutations: Array.isArray(slot.mutations) ? slot.mutations : []
      };
    });
    editorPlantSlotsState = { ...editorPlantSlotsState, slots, applyAll: !!editorPlantSlotsState.applyAll };
    return slots;
  }
  function ensureEditorStateForSpecies(species) {
    ensureEditorSlotsForSpecies(species);
    if (editorPlantSlotsState.applyAll == null) {
      editorPlantSlotsState.applyAll = false;
    }
    return editorPlantSlotsState;
  }
  function findReadKey(atom) {
    if (atom && typeof atom.read === "function") return "read";
    for (const k of Object.keys(atom || {})) {
      const v = atom[k];
      if (typeof v === "function" && k !== "write" && k !== "onMount" && k !== "toString") {
        const ar = v.length;
        if (ar === 1 || ar === 2) return k;
      }
    }
    throw new Error("stateAtom read() not found");
  }
  function findWriteKey(atom) {
    if (atom && typeof atom.write === "function") return "write";
    for (const k of Object.keys(atom || {})) {
      const v = atom[k];
      if (typeof v === "function" && k !== "read" && k !== "onMount" && k !== "toString") {
        const ar = v.length;
        if (ar >= 2) return k;
      }
    }
    return null;
  }
  async function freezeStateAtom() {
    await ensureStore().catch(() => {
    });
    const pid = await getPlayerId();
    if (!pid) return;
    const atom = getAtomByLabel("stateAtom");
    if (!atom) return;
    try {
      stateOriginalValue = await Atoms.root.state.get();
    } catch {
      stateOriginalValue = null;
    }
    const frozen = await buildClearedStateSnapshot(pid);
    if (!frozen) return;
    try {
      await Atoms.root.state.set(frozen);
    } catch {
    }
    stateFrozenValue = frozen;
    if (statePatch && statePatch.atom === atom) return;
    let readKey;
    try {
      readKey = findReadKey(atom);
    } catch {
      return;
    }
    const origRead = atom[readKey];
    const writeKey = findWriteKey(atom) || void 0;
    const origWrite = writeKey ? atom[writeKey] : void 0;
    atom[readKey] = () => stateFrozenValue;
    if (writeKey) {
      atom[writeKey] = () => stateFrozenValue;
    }
    statePatch = { atom, readKey, origRead, writeKey, origWrite };
  }
  function unfreezeStateAtom() {
    if (statePatch) {
      try {
        statePatch.atom[statePatch.readKey] = statePatch.origRead;
        if (statePatch.writeKey && statePatch.origWrite) {
          statePatch.atom[statePatch.writeKey] = statePatch.origWrite;
        }
      } catch {
      }
    }
    statePatch = null;
    stateFrozenValue = null;
    if (stateOriginalValue != null) {
      try {
        void Atoms.root.state.set(stateOriginalValue);
      } catch {
      }
    }
    stateOriginalValue = null;
  }
  function buildEmptyPetSlots(prev) {
    if (Array.isArray(prev)) return [];
    if (prev && typeof prev === "object") return {};
    return [];
  }
  shareGlobal("qwsLogSelectedInventoryItemWithTile", () => {
    void logSelectedInventoryItemWithTile();
  });
  shareGlobal("qwsPlaceSelectedItemInGardenAtCurrentTile", () => {
    void placeSelectedItemInGardenAtCurrentTile();
  });
  shareGlobal("qwsRemoveItemFromGardenAtCurrentTile", () => {
    void removeItemFromGardenAtCurrentTile();
  });
  shareGlobal("qwsRemoveDecorFromGardenAtCurrentTile", () => {
    void removeDecorFromGardenAtCurrentTile();
  });
  shareGlobal("qwsEditorListSavedGardens", () => {
    return listSavedGardens();
  });
  shareGlobal("qwsEditorSaveGarden", async (name) => {
    return await saveCurrentGarden(name || "Untitled");
  });
  shareGlobal("qwsEditorClearGarden", async () => {
    const empty = makeEmptyGarden();
    return await setCurrentGarden(empty);
  });
  shareGlobal("qwsEditorLoadGarden", async (id) => {
    return await loadSavedGarden(id);
  });
  shareGlobal("qwsEditorSaveGardenForPlayer", async (playerId2, name) => {
    return await saveCurrentGarden(name || "Untitled", playerId2);
  });
  shareGlobal("qwsEditorDeleteGarden", (id) => {
    return deleteSavedGarden(id);
  });
  shareGlobal("qwsEditorExportGarden", (id) => {
    return exportSavedGarden(id);
  });
  shareGlobal("qwsEditorImportGarden", async (name, raw) => {
    return await importGarden(name, raw);
  });
  shareGlobal("qwsEditorPreviewFriendGarden", async (garden2) => {
    return await applyFriendGardenPreview(garden2);
  });
  shareGlobal("qwsEditorClearFriendGardenPreview", async () => {
    return await clearFriendGardenPreview();
  });
  function installEditorKeybindsOnce() {
    if (editorKeybindsInstalled || typeof window === "undefined") return;
    editorKeybindsInstalled = true;
    window.addEventListener(
      "keydown",
      (ev) => {
        if (shouldIgnoreKeydown(ev)) return;
        if (eventMatchesKeybind("editor.toggle-overlays", ev)) {
          ev.preventDefault();
          ev.stopPropagation();
          if (!currentEnabled) return;
          overlaysVisible = !overlaysVisible;
          if (overlaysVisible) {
            showOverlay();
            showSideOverlay();
            showCurrentItemOverlay();
          } else {
            hideOverlay();
            hideSideOverlay();
            hideCurrentItemOverlay();
          }
          return;
        }
        if (!currentEnabled) return;
        if (eventMatchesKeybind("editor.place-remove", ev)) {
          ev.preventDefault();
          ev.stopPropagation();
          const alreadyHeld = editorActionHeld;
          editorActionHeld = true;
          void handleEditorPlaceRemove(ev, alreadyHeld);
          return;
        }
        if (eventMatchesKeybind("editor.delete-inventory", ev)) {
          ev.preventDefault();
          ev.stopPropagation();
          void removeSelectedInventoryItem();
        }
      },
      true
    );
    window.addEventListener(
      "keyup",
      (ev) => {
        const isSyntheticRF = ev?.__inGameHotkeysRapidSynthetic__ === true;
        if (isSyntheticRF) return;
        if (!currentEnabled) return;
        if (eventMatchesKeybind("editor.place-remove", ev)) {
          editorActionHeld = false;
          lastEditorPressStartTs = 0;
          lastEditorPlaceRemoveTs = 0;
          lastEditorFirstFired = false;
          lastEditorTileKey = null;
          lastEditorTileType = void 0;
          lastEditorFirstActionTs = 0;
        }
      },
      true
    );
  }
  async function hasSelectedInventoryItem() {
    try {
      const inv = await Atoms.inventory.myInventory.get();
      const idx = await Atoms.inventory.myValidatedSelectedItemIndex.get();
      const items = Array.isArray(inv?.items) ? inv.items : [];
      return typeof idx === "number" && !!items[idx];
    } catch {
      return false;
    }
  }
  async function handleEditorPlaceRemove(ev, isHeld = false) {
    const now2 = typeof performance !== "undefined" && typeof performance.now === "function" ? performance.now() : Date.now();
    if (!isHeld || lastEditorPressStartTs === 0) {
      lastEditorPressStartTs = now2;
      lastEditorPlaceRemoveTs = 0;
      lastEditorFirstFired = false;
      lastEditorTileKey = null;
      lastEditorTileType = void 0;
      lastEditorFirstActionTs = 0;
    }
    const { tileObject, tileKey, tileType } = await readCurrentTileContext();
    const hasSelection = await hasSelectedInventoryItem();
    const wantsRemove = !!tileObject;
    const wantsPlace = !tileObject && hasSelection;
    if (!wantsRemove && !wantsPlace) return;
    const tileKeyStr = `${tileType ?? "?"}|${tileKey ?? "none"}`;
    const sameTile = tileKeyStr === `${lastEditorTileType ?? "?"}|${lastEditorTileKey ?? "none"}`;
    if (!sameTile) {
      lastEditorTileKey = tileKey ?? null;
      lastEditorTileType = tileType;
      lastEditorFirstFired = false;
      lastEditorPlaceRemoveTs = 0;
      lastEditorPressStartTs = now2;
      lastEditorFirstActionTs = 0;
    }
    const elapsedSincePress = now2 - lastEditorPressStartTs;
    if (!lastEditorFirstFired) {
      lastEditorFirstFired = true;
      lastEditorPlaceRemoveTs = now2;
      lastEditorFirstActionTs = now2;
    } else {
      const sinceFirstAction = lastEditorFirstActionTs > 0 ? now2 - lastEditorFirstActionTs : elapsedSincePress;
      const gateMs = sinceFirstAction < EDITOR_PLACE_REMOVE_FIRST_DELAY_MS ? EDITOR_PLACE_REMOVE_FIRST_DELAY_MS : EDITOR_PLACE_REMOVE_REPEAT_MS;
      if (now2 - lastEditorPlaceRemoveTs < gateMs) {
        return;
      }
      lastEditorPlaceRemoveTs = now2;
    }
    if (wantsRemove) {
      if (tileObject?.objectType === "plant") {
        await removeItemFromGardenAtCurrentTile();
        void triggerEditorAnimation("dig");
        return;
      }
      if (tileObject?.objectType === "decor") {
        await removeDecorFromGardenAtCurrentTile();
        void triggerEditorAnimation("dig");
        return;
      }
    }
    if (wantsPlace) {
      await placeSelectedItemInGardenAtCurrentTile();
      void triggerEditorAnimation("dropObject");
    }
  }

  // src/hooks/ws-hook.ts
  var wsCloseListeners = [];
  var versionReloadScheduled = false;
  var autoRecoTimer = null;
  var autoRecoCountdownInterval = null;
  var autoRecoOverlay = null;
  function onWebSocketClose(cb) {
    wsCloseListeners.push(cb);
    return () => {
      const idx = wsCloseListeners.indexOf(cb);
      if (idx !== -1) wsCloseListeners.splice(idx, 1);
    };
  }
  function notifyWebSocketClose(ev, ws) {
    for (const listener of [...wsCloseListeners]) {
      try {
        listener(ev, ws);
      } catch {
      }
    }
  }
  function isVersionExpiredClose(ev) {
    return ev?.code === 4710 || /Version\s*Expired/i.test(ev?.reason || "");
  }
  function getRoomConnectionSocket() {
    try {
      const rc = pageWindow.MagicCircle_RoomConnection;
      if (!rc) return null;
      return (rc.ws || rc.socket || rc.currentWebSocket) ?? null;
    } catch {
      return null;
    }
  }
  function startAutoReloadOnVersionExpired() {
    onWebSocketClose((ev) => {
      if (!isVersionExpiredClose(ev)) return;
      const env = detectEnvironment();
      if (env.surface === "discord" || env.isInIframe) return;
      if (versionReloadScheduled) return;
      versionReloadScheduled = true;
      try {
        console.warn("[MagicGarden] Version expired, reloading...");
      } catch {
      }
      try {
        pageWindow.location.reload();
      } catch {
        try {
          window.location.reload();
        } catch {
        }
      }
    });
  }
  function isSupersededSessionClose(ev) {
    if (!ev) return false;
    const reason = ev?.reason || "";
    const reasonLc = reason.toLowerCase();
    if (ev.code === 4300 && reasonLc.includes("heartbeat")) {
      return false;
    }
    return ev.code === 4300 || ev.code === 4250 && (/superseded/i.test(reason) || /newer user session/i.test(reason));
  }
  function ensureAutoRecoOverlayStyle() {
    const STYLE_ID6 = "mgAutoRecoOverlayStyle";
    if (document.getElementById(STYLE_ID6)) return;
    const css3 = `
    #mgAutoRecoOverlay { position: fixed; inset: 0; z-index: 2147483647; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,.65); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #mgAutoRecoOverlay .box { background: #0f1318; color: #fff; padding: 24px 28px; border-radius: 14px; box-shadow: 0 12px 40px rgba(0,0,0,.45); text-align: center; max-width: 92vw; border: 1px solid rgba(255,255,255,.15); }
    #mgAutoRecoOverlay .title { font-size: 24px; font-weight: 900; letter-spacing: .02em; margin: 0 0 8px 0; }
    #mgAutoRecoOverlay .subtitle { font-size: 14px; opacity: .85; margin: 0 0 14px 0; }
    #mgAutoRecoOverlay .btn { margin-top: 6px; padding: 10px 16px; border-radius: 999px; border: 1px solid #7aa2ff; background: #1a2644; color: #fff; font-weight: 700; cursor: pointer; }
    #mgAutoRecoOverlay .btn:focus { outline: 2px solid #7aa2ff; outline-offset: 2px; }
  `;
    const style3 = document.createElement("style");
    style3.id = STYLE_ID6;
    style3.textContent = css3;
    document.documentElement.appendChild(style3);
  }
  function createAutoRecoOverlay(initialMs, onReconnectNow) {
    ensureAutoRecoOverlayStyle();
    const existing = document.getElementById("mgAutoRecoOverlay");
    if (existing) existing.remove();
    const overlay = document.createElement("div");
    overlay.id = "mgAutoRecoOverlay";
    overlay.innerHTML = `
    <div class="box" role="dialog" aria-label="Auto reconnect status">
      <div class="title">Auto reconnect</div>
      <div class="subtitle auto-reco-subtitle">The game will reconnect soon.</div>
      <button class="btn" type="button">Reconnect now</button>
    </div>
  `;
    const subtitle = overlay.querySelector(".auto-reco-subtitle");
    const btn = overlay.querySelector("button.btn");
    const render2 = (ms) => {
      if (!subtitle) return;
      const seconds = Math.max(0, Math.ceil(ms / 1e3));
      const unit = seconds <= 1 ? "second" : "seconds";
      subtitle.textContent = `The game will reconnect in ${seconds} ${unit}...`;
    };
    if (btn) {
      btn.addEventListener("click", (e) => {
        e.preventDefault();
        onReconnectNow();
      });
    }
    document.documentElement.appendChild(overlay);
    render2(initialMs);
    return {
      update: render2,
      destroy: () => {
        try {
          overlay.remove();
        } catch {
        }
      }
    };
  }
  function clearAutoRecoOverlayAndCountdown() {
    if (autoRecoCountdownInterval !== null) {
      clearInterval(autoRecoCountdownInterval);
      autoRecoCountdownInterval = null;
    }
    if (autoRecoOverlay) {
      try {
        autoRecoOverlay.destroy();
      } catch {
      }
      autoRecoOverlay = null;
    }
  }
  function startAutoReconnectOnSuperseded() {
    onWebSocketClose((ev, ws) => {
      if (!isSupersededSessionClose(ev)) return;
      const rcSocket = getRoomConnectionSocket();
      if (rcSocket && ws && ws !== rcSocket) {
        return;
      }
      if (!MiscService.readAutoRecoEnabled(false)) return;
      if (autoRecoTimer !== null) {
        clearTimeout(autoRecoTimer);
        autoRecoTimer = null;
      }
      clearAutoRecoOverlayAndCountdown();
      const delayMs = MiscService.getAutoRecoDelayMs();
      const runReconnect = () => {
        autoRecoTimer = null;
        if (!MiscService.readAutoRecoEnabled(false)) {
          clearAutoRecoOverlayAndCountdown();
          return;
        }
        clearAutoRecoOverlayAndCountdown();
        try {
          const conn = pageWindow.MagicCircle_RoomConnection;
          const connect = conn?.connect;
          if (typeof connect === "function") {
            connect.call(conn);
          }
        } catch (error) {
          console.warn("[MagicGarden] Auto reco failed:", error);
        }
      };
      const triggerManualReconnect = () => {
        if (autoRecoTimer !== null) {
          clearTimeout(autoRecoTimer);
          autoRecoTimer = null;
        }
        runReconnect();
      };
      if (delayMs > 0) {
        autoRecoOverlay = createAutoRecoOverlay(delayMs, triggerManualReconnect);
        let remainingMs = delayMs;
        autoRecoCountdownInterval = window.setInterval(() => {
          remainingMs -= 1e3;
          if (remainingMs < 0) remainingMs = 0;
          if (autoRecoOverlay) autoRecoOverlay.update(remainingMs);
          if (remainingMs <= 0) {
            clearAutoRecoOverlayAndCountdown();
          }
        }, 1e3);
      }
      autoRecoTimer = window.setTimeout(() => {
        runReconnect();
      }, delayMs);
    });
  }
  function installPageWebSocketHook() {
    if (!pageWindow || !NativeWS) return;
    startAutoReloadOnVersionExpired();
    startAutoReconnectOnSuperseded();
    function WrappedWebSocket(url, protocols) {
      const ws = protocols !== void 0 ? new NativeWS(url, protocols) : new NativeWS(url);
      sockets.push(ws);
      ws.addEventListener("open", () => {
        setTimeout(() => {
          if (ws.readyState === NativeWS.OPEN) setQWS(ws, "open-fallback");
        }, 800);
      });
      ws.addEventListener("message", async (ev) => {
        const j = await parseWSData(ev.data);
        if (!j) return;
        if (!hasSharedQuinoaWS() && (j.type === "Welcome" || j.type === "Config" || j.fullState || j.config)) {
          setQWS(ws, "message:" + (j.type || "state"));
        }
      });
      ws.addEventListener("close", (ev) => {
        notifyWebSocketClose(ev, ws);
      });
      return ws;
    }
    WrappedWebSocket.prototype = NativeWS.prototype;
    try {
      WrappedWebSocket.OPEN = NativeWS.OPEN;
    } catch {
    }
    try {
      WrappedWebSocket.CLOSED = NativeWS.CLOSED;
    } catch {
    }
    try {
      WrappedWebSocket.CLOSING = NativeWS.CLOSING;
    } catch {
    }
    try {
      WrappedWebSocket.CONNECTING = NativeWS.CONNECTING;
    } catch {
    }
    pageWindow.WebSocket = WrappedWebSocket;
    if (pageWindow !== window) {
      try {
        window.WebSocket = WrappedWebSocket;
      } catch {
      }
    }
    function hasSharedQuinoaWS() {
      const existing = readSharedGlobal("quinoaWS");
      return !!existing;
    }
    function scheduleRoomConnectionFallback() {
      const FALLBACK_DELAY_MS = 5e3;
      const win = pageWindow || (typeof window !== "undefined" ? window : null);
      if (!win) return;
      win.setTimeout(() => {
        try {
          if (hasSharedQuinoaWS()) return;
          const conn = win.MagicCircle_RoomConnection || readSharedGlobal("MagicCircle_RoomConnection");
          const ws = conn?.currentWebSocket;
          if (ws && ws.readyState === NativeWS.OPEN) {
            setQWS(ws, "room-connection-fallback");
          }
        } catch (error) {
          console.warn("[MagicGarden] Room connection WS fallback failed", error);
        }
      }, FALLBACK_DELAY_MS);
    }
    scheduleRoomConnectionFallback();
    installHarvestCropInterceptor();
  }
  var interceptorsByType = /* @__PURE__ */ new Map();
  var interceptorStatus = readSharedGlobal(
    "__tmMessageHookInstalled"
  ) ? "installed" : "idle";
  var interceptorPoll = null;
  var interceptorTimeout = null;
  function registerMessageInterceptor(type, interceptor) {
    const list = interceptorsByType.get(type);
    if (list) {
      list.push(interceptor);
    } else {
      interceptorsByType.set(type, [interceptor]);
    }
    ensureMessageInterceptorInstalled();
    return () => {
      const current = interceptorsByType.get(type);
      if (!current) return;
      const index = current.indexOf(interceptor);
      if (index !== -1) current.splice(index, 1);
      if (current.length === 0) interceptorsByType.delete(type);
    };
  }
  function ensureMessageInterceptorInstalled() {
    if (interceptorStatus === "installed" || interceptorStatus === "installing") return;
    interceptorStatus = "installing";
    const tryInstall = () => {
      const Conn = pageWindow.MagicCircle_RoomConnection || readSharedGlobal("MagicCircle_RoomConnection");
      if (!Conn) return false;
      const original = resolveSendMessage(Conn);
      if (!original) return false;
      const wrap = function(message, ...rest) {
        let currentMessage = message;
        try {
          const type = currentMessage?.type;
          if (type && interceptorsByType.size > 0) {
            const context = { thisArg: this, args: rest };
            const result = applyInterceptors(type, currentMessage, context);
            if (result.drop) return;
            currentMessage = result.message;
          }
        } catch (error) {
          console.error("[MG-mod] Erreur dans le hook WS :", error);
        }
        return original.fn.call(this, currentMessage, ...rest);
      };
      if (original.kind === "static") {
        Conn.sendMessage = wrap;
      } else {
        Conn.prototype.sendMessage = wrap;
      }
      interceptorStatus = "installed";
      shareGlobal("__tmMessageHookInstalled", true);
      if (interceptorPoll !== null) {
        clearInterval(interceptorPoll);
        interceptorPoll = null;
      }
      if (interceptorTimeout !== null) {
        clearTimeout(interceptorTimeout);
        interceptorTimeout = null;
      }
      return true;
    };
    if (tryInstall()) return;
    interceptorPoll = window.setInterval(() => {
      if (tryInstall()) {
        if (interceptorPoll !== null) {
          clearInterval(interceptorPoll);
          interceptorPoll = null;
        }
      }
    }, 200);
    interceptorTimeout = window.setTimeout(() => {
      if (interceptorPoll !== null) {
        clearInterval(interceptorPoll);
        interceptorPoll = null;
      }
      if (interceptorStatus !== "installed") {
        interceptorStatus = "idle";
      }
      interceptorTimeout = null;
    }, 2e4);
  }
  function applyInterceptors(type, initialMessage, context) {
    const interceptors = interceptorsByType.get(type);
    if (!interceptors || interceptors.length === 0) {
      return { message: initialMessage, drop: false };
    }
    let currentMessage = initialMessage;
    for (const interceptor of [...interceptors]) {
      try {
        const result = interceptor(currentMessage, context);
        if (!result) continue;
        if (result.kind === "drop") {
          return { message: currentMessage, drop: true };
        }
        if (result.kind === "replace") {
          currentMessage = result.message;
        }
      } catch (error) {
      }
    }
    return { message: currentMessage, drop: false };
  }
  function installHarvestCropInterceptor() {
    if (readSharedGlobal("__tmHarvestHookInstalled")) return;
    let latestGardenState = null;
    let friendBonusPercent = null;
    let friendBonusFromPlayers = null;
    let latestEggId = null;
    let latestInventoryCount = 0;
    const inventorySeeds = /* @__PURE__ */ new Set();
    const inventoryDecors = /* @__PURE__ */ new Set();
    const inventoryEggs = /* @__PURE__ */ new Set();
    const inventoryTools = /* @__PURE__ */ new Set();
    const INVENTORY_BLOCK_AT = 99;
    const refreshInventorySnapshot = (raw) => {
      const items = extractInventoryItems(raw);
      latestInventoryCount = items.length;
      inventorySeeds.clear();
      inventoryDecors.clear();
      inventoryEggs.clear();
      inventoryTools.clear();
      for (const entry of items) {
        if (!entry || typeof entry !== "object") continue;
        const source = entry.item && typeof entry.item === "object" ? entry.item : entry;
        if (!source || typeof source !== "object") continue;
        const type = String(source.itemType ?? source.data?.itemType ?? "").toLowerCase();
        if (type === "seed" && source.species) inventorySeeds.add(String(source.species));
        if (type === "decor" && source.decorId) inventoryDecors.add(String(source.decorId));
        if (type === "egg" && source.eggId) inventoryEggs.add(String(source.eggId));
        if (type === "tool" && source.toolId) inventoryTools.add(String(source.toolId));
      }
    };
    const shouldBlockNewInventoryEntry = () => MiscService.readInventorySlotReserveEnabled(false) && latestInventoryCount >= INVENTORY_BLOCK_AT;
    const shouldBlockPurchase = (kind, id) => {
      if (!shouldBlockNewInventoryEntry()) return false;
      if (id == null) return true;
      const key2 = String(id);
      if (!key2) return true;
      if (kind === "seed") return !inventorySeeds.has(key2);
      if (kind === "decor") return !inventoryDecors.has(key2);
      if (kind === "egg") return !inventoryEggs.has(key2);
      return !inventoryTools.has(key2);
    };
    void (async () => {
      try {
        latestGardenState = await Atoms.data.garden.get() ?? null;
      } catch {
      }
      try {
        await Atoms.data.garden.onChange((next) => {
          latestGardenState = next ?? null;
        });
      } catch {
      }
      try {
        const initialObj = await Atoms.data.myCurrentGardenObject.get();
        latestEggId = extractEggId(initialObj);
      } catch {
      }
      try {
        await Atoms.data.myCurrentGardenObject.onChange((next) => {
          latestEggId = extractEggId(next);
        });
      } catch {
      }
      try {
        refreshInventorySnapshot(await Atoms.inventory.myInventory.get());
      } catch {
      }
      try {
        await Atoms.inventory.myInventory.onChange((next) => {
          refreshInventorySnapshot(next);
        });
      } catch {
      }
    })();
    void (async () => {
      try {
        const initial = await Atoms.server.friendBonusMultiplier.get();
        friendBonusPercent = friendBonusPercentFromMultiplier(initial);
      } catch {
      }
      try {
        await Atoms.server.friendBonusMultiplier.onChange((next) => {
          friendBonusPercent = friendBonusPercentFromMultiplier(next);
        });
      } catch {
      }
      try {
        const initialPlayers = await Atoms.server.numPlayers.get();
        friendBonusFromPlayers = friendBonusPercentFromPlayers(initialPlayers);
      } catch {
      }
      try {
        await Atoms.server.numPlayers.onChange((next) => {
          friendBonusFromPlayers = friendBonusPercentFromPlayers(next);
        });
      } catch {
      }
    })();
    const resolveFriendBonusPercent = () => friendBonusPercent ?? friendBonusFromPlayers ?? null;
    registerMessageInterceptor("HarvestCrop", (message) => {
      if (shouldBlockNewInventoryEntry()) {
        console.log("[HarvestCrop] Blocked by inventory reserve");
        return { kind: "drop" };
      }
      const slot = message.slot;
      const slotsIndex = message.slotsIndex;
      if (!Number.isInteger(slot) || !Number.isInteger(slotsIndex)) {
        return;
      }
      const garden2 = latestGardenState;
      const tileObjects = garden2?.tileObjects;
      const tile = tileObjects ? tileObjects[String(slot)] : void 0;
      if (!tile || typeof tile !== "object" || tile.objectType !== "plant") {
        return;
      }
      const slots = Array.isArray(tile.slots) ? tile.slots : [];
      const cropSlot = slots[slotsIndex];
      if (!cropSlot || typeof cropSlot !== "object") {
        return;
      }
      const seedKey = extractSeedKey2(tile);
      const sizePercent = extractSizePercent2(cropSlot);
      const mutations = sanitizeMutations(cropSlot?.mutations);
      const lockerEnabled = (() => {
        try {
          return lockerService.getState().enabled;
        } catch {
          return false;
        }
      })();
      if (lockerEnabled) {
        let harvestAllowed = true;
        try {
          harvestAllowed = lockerService.allowsHarvest({
            seedKey,
            sizePercent,
            mutations
          });
        } catch {
          harvestAllowed = true;
        }
        if (!harvestAllowed) {
          console.log("[HarvestCrop] Blocked by locker", {
            slot,
            slotsIndex,
            seedKey,
            sizePercent,
            mutations
          });
          return { kind: "drop" };
        }
      }
      StatsService.incrementGardenStat("totalHarvested");
      void (async () => {
        try {
          const garden3 = await Atoms.data.garden.get();
          const tileObjects2 = garden3?.tileObjects ?? null;
          const tile2 = tileObjects2 ? tileObjects2[String(slot)] : void 0;
          const cropSlot2 = Array.isArray(tile2?.slots) ? tile2.slots?.[slotsIndex] : void 0;
          console.log("[HarvestCrop]", {
            slot,
            slotsIndex,
            cropSlot: cropSlot2
          });
        } catch (error) {
          console.error("[HarvestCrop] Unable to log crop slot", error);
        }
      })();
    });
    registerMessageInterceptor("RemoveGardenObject", (message) => {
      StatsService.incrementGardenStat("totalDestroyed");
    });
    registerMessageInterceptor("WaterPlant", (message) => {
      StatsService.incrementGardenStat("watercanUsed");
      StatsService.incrementGardenStat("waterTimeSavedMs", 5 * 60 * 1e3);
    });
    registerMessageInterceptor("PlantSeed", (message) => {
      StatsService.incrementGardenStat("totalPlanted");
    });
    registerMessageInterceptor("PurchaseDecor", (message) => {
      const decorId = message?.decorId ?? message?.id;
      if (shouldBlockPurchase("decor", decorId)) {
        console.log("[PurchaseDecor] Blocked by inventory reserve", { decorId });
        return { kind: "drop" };
      }
      StatsService.incrementShopStat("decorBought");
    });
    registerMessageInterceptor("PurchaseSeed", (message) => {
      const species = message?.species ?? message?.id;
      if (shouldBlockPurchase("seed", species)) {
        console.log("[PurchaseSeed] Blocked by inventory reserve", { species });
        return { kind: "drop" };
      }
      StatsService.incrementShopStat("seedsBought");
    });
    registerMessageInterceptor("PurchaseEgg", (message) => {
      const eggId = message?.eggId ?? message?.id;
      if (shouldBlockPurchase("egg", eggId)) {
        console.log("[PurchaseEgg] Blocked by inventory reserve", { eggId });
        return { kind: "drop" };
      }
      StatsService.incrementShopStat("eggsBought");
    });
    registerMessageInterceptor("PurchaseTool", (message) => {
      const toolId = message?.toolId ?? message?.id;
      if (shouldBlockPurchase("tool", toolId)) {
        console.log("[PurchaseTool] Blocked by inventory reserve", { toolId });
        return { kind: "drop" };
      }
      StatsService.incrementShopStat("toolsBought");
    });
    registerMessageInterceptor("PickupObject", () => {
      if (shouldBlockNewInventoryEntry()) {
        console.log("[PickupObject] Blocked by inventory reserve");
        return { kind: "drop" };
      }
    });
    registerMessageInterceptor("PickupDecor", () => {
      if (EditorService.isEnabled()) {
        try {
          const removeFn = readSharedGlobal("qwsRemoveDecorFromGardenAtCurrentTile") || pageWindow.qwsRemoveDecorFromGardenAtCurrentTile;
          if (typeof removeFn === "function") {
            console.log("[PickupDecor][Editor] intercept -> local remove");
            removeFn();
            return { kind: "drop" };
          }
        } catch (err) {
          console.log("[PickupDecor][Editor] remove interceptor error", err);
        }
      }
      const decorLocked = lockerRestrictionsService.isDecorPickupLocked();
      if (decorLocked) {
        console.log("[PickupDecor] Blocked by decor picker");
        return { kind: "drop" };
      }
    });
    registerMessageInterceptor("HatchEgg", () => {
      if (shouldBlockNewInventoryEntry()) {
        console.log("[HatchEgg] Blocked by inventory reserve");
        return { kind: "drop" };
      }
      const locked = lockerRestrictionsService.isEggLocked(latestEggId);
      if (locked) {
        console.log("[HatchEgg] Blocked by egg locker", { eggId: latestEggId });
        void (async () => {
          try {
            await dedupeEggLockToast(latestEggId);
          } catch {
          }
        })();
        return { kind: "drop" };
      }
      void (async () => {
        const previousPets = await readInventoryPetSnapshots();
        const previousMap = buildPetMap(previousPets);
        const nextPets = await waitForInventoryPetAddition(previousMap);
        if (!nextPets) return;
        const newPets = extractNewPets(nextPets, previousMap);
        if (!newPets.length) return;
        for (const pet of newPets) {
          const rarity2 = inferPetRarity(pet.mutations);
          if (pet.species) {
            StatsService.incrementPetHatched(pet.species, rarity2);
          }
        }
      })();
    });
    registerMessageInterceptor("SellAllCrops", (message) => {
      const restrictionState = lockerRestrictionsService.getState();
      const requiredPct = lockerRestrictionsService.getRequiredPercent();
      const requiredPlayers = restrictionState.minRequiredPlayers;
      const currentBonusPct = resolveFriendBonusPercent();
      const allowed = lockerRestrictionsService.allowsCropSale(currentBonusPct);
      if (!allowed) {
        const currentPlayers = currentBonusPct != null ? percentToRequiredFriendCount(currentBonusPct) : null;
        console.log("[SellAllCrops] Blocked by friend bonus restriction", {
          requiredPct,
          requiredPlayers,
          currentBonusPct,
          currentPlayers
        });
        void (async () => {
          try {
            await toastSimple(
              "Friend bonus locker",
              `Require at least ${requiredPct}% friend bonus`,
              "error"
            );
          } catch {
          }
          void removeSellSuccessToast();
        })();
        return { kind: "drop" };
      }
      void (async () => {
        try {
          const items = await Atoms.inventory.myCropItemsToSell.get();
          const count = Array.isArray(items) ? items.length : 0;
          if (count > 0) {
            StatsService.incrementShopStat("cropsSoldCount", count);
          }
        } catch (error) {
          console.error("[SellAllCrops] Unable to read crop items", error);
        }
        try {
          const total = await Atoms.shop.totalCropSellPrice.get();
          const value = Number(total);
          if (Number.isFinite(value) && value > 0) {
            StatsService.incrementShopStat("cropsSoldValue", value);
          }
        } catch (error) {
          console.error("[SellAllCrops] Unable to read crop sell price", error);
        }
      })();
    });
    registerMessageInterceptor("SellPet", (message) => {
      StatsService.incrementShopStat("petsSoldCount");
      void (async () => {
        try {
          const total = await Atoms.pets.totalPetSellPrice.get();
          const value = Number(total);
          if (Number.isFinite(value) && value > 0) {
            StatsService.incrementShopStat("petsSoldValue", value);
          }
        } catch (error) {
          console.error("[SellPet] Unable to read pet sell price", error);
        }
      })();
    });
    shareGlobal("__tmHarvestHookInstalled", true);
  }
  function extractSeedKey2(tile) {
    if (!tile || typeof tile !== "object") return null;
    if (typeof tile.seedKey === "string" && tile.seedKey) return tile.seedKey;
    if (typeof tile.species === "string" && tile.species) return tile.species;
    const fallbacks = ["seedSpecies", "plantSpecies", "cropSpecies", "speciesId"];
    for (const key2 of fallbacks) {
      const value = tile[key2];
      if (typeof value === "string" && value) return value;
    }
    return null;
  }
  var normalizeSpeciesKey2 = (value) => value.toLowerCase().replace(/['`]/g, "").replace(/\s+/g, "").replace(/-/g, "").replace(/(seed|plant|baby|fruit|crop)$/i, "");
  var MAX_SCALE_BY_SPECIES2 = (() => {
    const map2 = /* @__PURE__ */ new Map();
    const register = (key2, value) => {
      if (typeof key2 !== "string") return;
      const normalized = normalizeSpeciesKey2(key2.trim());
      if (!normalized || map2.has(normalized)) return;
      map2.set(normalized, value);
    };
    for (const [species, entry] of Object.entries(plantCatalog)) {
      const maxScale = Number(entry?.crop?.maxScale);
      if (!Number.isFinite(maxScale) || maxScale <= 0) continue;
      register(species, maxScale);
      register(entry?.seed?.name, maxScale);
      register(entry?.plant?.name, maxScale);
      register(entry?.crop?.name, maxScale);
    }
    return map2;
  })();
  function lookupMaxScale2(species) {
    if (typeof species !== "string") return null;
    const normalized = normalizeSpeciesKey2(species.trim());
    if (!normalized) return null;
    const found = MAX_SCALE_BY_SPECIES2.get(normalized);
    if (typeof found === "number" && Number.isFinite(found) && found > 0) {
      return found;
    }
    return null;
  }
  function getMaxScaleForSlot2(slot) {
    if (!slot || typeof slot !== "object") return null;
    const candidates = /* @__PURE__ */ new Set();
    const fromSeedKey = extractSeedKey2(slot);
    if (fromSeedKey) candidates.add(fromSeedKey);
    const fields = [
      "species",
      "seedSpecies",
      "plantSpecies",
      "cropSpecies",
      "baseSpecies",
      "seedKey"
    ];
    for (const field of fields) {
      const value = slot[field];
      if (typeof value === "string" && value) {
        candidates.add(value);
      }
    }
    for (const cand of candidates) {
      const max = lookupMaxScale2(cand);
      if (typeof max === "number" && Number.isFinite(max) && max > 0) {
        return max;
      }
    }
    return null;
  }
  function extractSizePercent2(slot) {
    if (!slot || typeof slot !== "object") return 100;
    const direct = Number(
      slot.sizePercent ?? slot.sizePct ?? slot.size ?? slot.percent ?? slot.progressPercent
    );
    if (Number.isFinite(direct)) {
      return clampPercent3(Math.round(direct), 0, 100);
    }
    const scale = Number(slot.targetScale ?? slot.scale);
    if (Number.isFinite(scale)) {
      const maxScale = getMaxScaleForSlot2(slot);
      if (typeof maxScale === "number" && Number.isFinite(maxScale) && maxScale > 1) {
        const clamped = Math.max(1, Math.min(maxScale, scale));
        const pct2 = 50 + (clamped - 1) / (maxScale - 1) * 50;
        return clampPercent3(Math.round(pct2), 50, 100);
      }
      if (scale > 1 && scale <= 2) {
        const pct2 = 50 + (scale - 1) / 1 * 50;
        return clampPercent3(Math.round(pct2), 50, 100);
      }
      const pct = Math.round(scale * 100);
      return clampPercent3(pct, 0, 100);
    }
    return 100;
  }
  function sanitizeMutations(raw) {
    if (!Array.isArray(raw)) return [];
    const out = [];
    for (let i = 0; i < raw.length; i++) {
      const value = raw[i];
      if (typeof value === "string") {
        if (value) out.push(value);
      } else if (value != null) {
        const str = String(value);
        if (str) out.push(str);
      }
    }
    return out;
  }
  function clampPercent3(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }
  var HATCH_EGG_TIMEOUT_MS = 5e3;
  async function readInventoryPetSnapshots() {
    try {
      const inventory = await Atoms.inventory.myInventory.get();
      return collectInventoryPets(inventory);
    } catch (error) {
      console.error("[HatchEgg] Unable to read inventory", error);
      return [];
    }
  }
  function collectInventoryPets(rawInventory) {
    const items = extractInventoryItems(rawInventory);
    const pets = [];
    for (const entry of items) {
      const pet = toInventoryPet(entry);
      if (pet) pets.push(pet);
    }
    return pets;
  }
  function extractInventoryItems(rawInventory) {
    if (!rawInventory) return [];
    if (Array.isArray(rawInventory)) return rawInventory;
    if (Array.isArray(rawInventory.items)) return rawInventory.items;
    if (Array.isArray(rawInventory.inventory)) return rawInventory.inventory;
    if (Array.isArray(rawInventory.inventory?.items)) return rawInventory.inventory.items;
    return [];
  }
  function toInventoryPet(entry) {
    if (!entry || typeof entry !== "object") return null;
    const source = entry.item && typeof entry.item === "object" ? entry.item : entry;
    if (!source || typeof source !== "object") return null;
    const type = source.itemType ?? source.data?.itemType ?? "";
    if (String(type).toLowerCase() !== "pet") return null;
    const id = source.id ?? source.data?.id;
    const species = source.petSpecies ?? source.data?.petSpecies;
    if (!id || !species) return null;
    const mutations = sanitizeMutations(source.mutations ?? source.data?.mutations);
    return {
      id: String(id),
      species: String(species),
      mutations
    };
  }
  function buildPetMap(pets) {
    const map2 = /* @__PURE__ */ new Map();
    for (const pet of pets) {
      map2.set(pet.id, pet);
    }
    return map2;
  }
  function extractNewPets(pets, previous) {
    return pets.filter((pet) => !previous.has(pet.id));
  }
  function extractEggId(obj) {
    if (!obj || typeof obj !== "object") return null;
    if (obj.objectType !== "egg") return null;
    const eggId = obj.eggId;
    return typeof eggId === "string" && eggId ? eggId : null;
  }
  async function dedupeEggLockToast(latestEggId) {
    const toastsAtom = getAtomByLabel("quinoaToastsAtom");
    const description = latestEggId ? `Hatching locked for ${latestEggId}` : "Hatching locked by egg locker";
    if (!toastsAtom) {
      await toastSimple("Egg hatch locker", description, "error");
      return;
    }
    const list = await jGet(toastsAtom).catch(() => []);
    const filtered = Array.isArray(list) ? list.filter((t) => !(t?.title === "Egg hatch locker")) : [];
    filtered.push({
      isClosable: true,
      duration: 3500,
      title: "Egg hatch locker",
      description,
      variant: "error",
      id: "quinoa-game-toast"
    });
    await jSet(toastsAtom, filtered);
  }
  function inferPetRarity(mutations) {
    if (!Array.isArray(mutations) || mutations.length === 0) {
      return "normal";
    }
    const seen = new Set(mutations.map((m) => String(m).toLowerCase()));
    if (seen.has("rainbow")) return "rainbow";
    if (seen.has("gold") || seen.has("golden")) return "gold";
    return "normal";
  }
  async function waitForInventoryPetAddition(previous, timeoutMs = HATCH_EGG_TIMEOUT_MS) {
    await delay2(0);
    const initial = await readInventoryPetSnapshots();
    if (hasNewInventoryPet(initial, previous)) {
      return initial;
    }
    return new Promise(async (resolve2) => {
      let settled = false;
      let unsub = null;
      let timer = null;
      const finalize = (value) => {
        if (settled) return;
        settled = true;
        if (timer !== null) {
          clearTimeout(timer);
        }
        if (unsub) {
          try {
            unsub();
          } catch {
          }
        }
        resolve2(value);
      };
      const evaluate = (source) => {
        const pets = collectInventoryPets(source);
        if (hasNewInventoryPet(pets, previous)) {
          finalize(pets);
        }
      };
      try {
        unsub = await Atoms.inventory.myInventory.onChange((next) => {
          evaluate(next);
        });
      } catch (error) {
        console.error("[HatchEgg] Unable to observe inventory", error);
        finalize(null);
        return;
      }
      timer = setTimeout(() => {
        void (async () => {
          const latest = await readInventoryPetSnapshots();
          if (hasNewInventoryPet(latest, previous)) {
            finalize(latest);
          } else {
            finalize(null);
          }
        })();
      }, timeoutMs);
    });
  }
  function hasNewInventoryPet(pets, previous) {
    return pets.some((pet) => !previous.has(pet.id));
  }
  function delay2(ms) {
    return new Promise((resolve2) => setTimeout(resolve2, ms));
  }
  function resolveSendMessage(Conn) {
    const isFn = (value) => typeof value === "function";
    if (isFn(Conn.sendMessage)) {
      return { kind: "static", fn: Conn.sendMessage.bind(Conn) };
    }
    if (Conn.prototype && isFn(Conn.prototype.sendMessage)) {
      return { kind: "proto", fn: Conn.prototype.sendMessage };
    }
    return null;
  }
  async function removeSellSuccessToast() {
    try {
      const toastsAtom = getAtomByLabel("quinoaToastsAtom");
      if (!toastsAtom) return;
      const list = await jGet(toastsAtom).catch(() => []);
      const filtered = Array.isArray(list) ? list.filter((t) => {
        if (!t || typeof t !== "object") return true;
        if (t.variant !== "success") return true;
        const icon = t.icon;
        const isTileSell = icon?.type === "tile" && icon?.spritesheet === "items" && Number(icon?.index) === 11;
        const hasCropText = !!t?.description?.props?.values?.cropText;
        return !(isTileSell || hasCropText);
      }) : list;
      if (filtered.length !== list.length) {
        await jSet(toastsAtom, filtered);
      }
    } catch {
    }
  }

  // src/ui/hud.ts
  init_jotai();

  // src/services/pets.ts
  init_fakeModal();
  init_atoms();
  var PATH_PETS_OVERRIDES = "pets.overrides";
  var PATH_PETS_INSTANT_FEED = "pets.instantFeed";
  var PATH_PETS_UI = "pets.ui";
  var PATH_PETS_TEAMS = "pets.teams";
  var PATH_PETS_TEAM_SEARCH = "pets.teamSearch";
  var PATH_PETS_HOTKEYS = "pets.hotkeys";
  var PATH_PETS_ABILITY_LOGS = "pets.abilityLogs";
  var TEAM_HK_MAP = /* @__PURE__ */ new Map();
  var TEAM_HK_UNSUBS = /* @__PURE__ */ new Map();
  var hkNextTeam = null;
  var hkPrevTeam = null;
  var unsubNextHotkey = null;
  var unsubPrevHotkey = null;
  var orderedTeamIds = [];
  var lastUsedTeamId = null;
  var _lastTeamHotkeyAt = 0;
  function syncTeamHotkey(teamId) {
    const hk = getKeybind(getPetTeamActionId(teamId));
    if (hk) TEAM_HK_MAP.set(teamId, hk);
    else TEAM_HK_MAP.delete(teamId);
  }
  function syncNextTeamHotkey() {
    hkNextTeam = getKeybind(PET_TEAM_NEXT_ID);
  }
  function syncPrevTeamHotkey() {
    hkPrevTeam = getKeybind(PET_TEAM_PREV_ID);
  }
  function ensureLegacyTeamHotkeyMigration(teamId) {
    const hotkeys = readAriesPath(PATH_PETS_HOTKEYS) ?? {};
    const legacy = hotkeys[teamId];
    if (!legacy) return;
    const actionId = getPetTeamActionId(teamId);
    const existing = getKeybind(actionId);
    if (!existing) {
      const hk = stringToHotkey(legacy);
      if (hk) {
        setKeybind(actionId, hk);
      }
    }
    const clone = { ...hotkeys };
    delete clone[teamId];
    writeAriesPath(PATH_PETS_HOTKEYS, clone);
  }
  function normalizeTeamList(teams) {
    if (!Array.isArray(teams)) return [];
    const seen = /* @__PURE__ */ new Set();
    const out = [];
    for (const t of teams) {
      const id = String(t?.id ?? "");
      if (!id || seen.has(id)) continue;
      seen.add(id);
      out.push({ id, name: t?.name ?? null });
    }
    return out;
  }
  function ensureLastUsedTeamIsValid() {
    if (!orderedTeamIds.length) {
      lastUsedTeamId = null;
      return;
    }
    if (!lastUsedTeamId || !orderedTeamIds.includes(lastUsedTeamId)) {
      lastUsedTeamId = orderedTeamIds[0] ?? null;
    }
  }
  function markTeamAsUsed(teamId) {
    lastUsedTeamId = teamId ? String(teamId) : null;
  }
  function setTeamsForHotkeys(rawTeams) {
    for (const unsub of TEAM_HK_UNSUBS.values()) {
      try {
        unsub();
      } catch {
      }
    }
    TEAM_HK_UNSUBS.clear();
    if (unsubNextHotkey) {
      try {
        unsubNextHotkey();
      } catch {
      }
      unsubNextHotkey = null;
    }
    if (unsubPrevHotkey) {
      try {
        unsubPrevHotkey();
      } catch {
      }
      unsubPrevHotkey = null;
    }
    const teams = normalizeTeamList(rawTeams);
    updatePetKeybinds(teams);
    orderedTeamIds = teams.map((t) => t.id);
    ensureLastUsedTeamIsValid();
    const keep = new Set(orderedTeamIds);
    for (const teamId of Array.from(TEAM_HK_MAP.keys())) {
      if (!keep.has(teamId)) TEAM_HK_MAP.delete(teamId);
    }
    teams.forEach((team) => {
      ensureLegacyTeamHotkeyMigration(team.id);
      syncTeamHotkey(team.id);
      const unsub = onKeybindChange(getPetTeamActionId(team.id), () => syncTeamHotkey(team.id));
      TEAM_HK_UNSUBS.set(team.id, unsub);
    });
    syncNextTeamHotkey();
    syncPrevTeamHotkey();
    unsubNextHotkey = onKeybindChange(PET_TEAM_NEXT_ID, () => syncNextTeamHotkey());
    unsubPrevHotkey = onKeybindChange(PET_TEAM_PREV_ID, () => syncPrevTeamHotkey());
  }
  function installPetTeamHotkeysOnce(onUseTeam) {
    const FLAG = "__qws_pet_team_hk_installed";
    if (window[FLAG]) return;
    window.addEventListener(
      "keydown",
      async (e) => {
        if (shouldIgnoreKeydown(e)) return;
        const teamsList = orderedTeamIds.slice();
        if (!teamsList.length) return;
        const activeTid = await _currentActiveTeamId();
        if (activeTid && teamsList.includes(activeTid)) {
          lastUsedTeamId = activeTid;
        } else if (!lastUsedTeamId || !teamsList.includes(lastUsedTeamId)) {
          lastUsedTeamId = teamsList[0] ?? null;
        }
        ensureLastUsedTeamIsValid();
        const useTeam = (teamId) => {
          if (!teamId) return;
          markTeamAsUsed(teamId);
          onUseTeam(teamId);
          _lastTeamHotkeyAt = Date.now();
        };
        if (hkPrevTeam && matchHotkey(e, hkPrevTeam)) {
          const baseId = lastUsedTeamId && teamsList.includes(lastUsedTeamId) ? lastUsedTeamId : teamsList[teamsList.length - 1] ?? null;
          const curIdx = baseId ? teamsList.indexOf(baseId) : -1;
          const nextIdx = curIdx >= 0 ? (curIdx - 1 + teamsList.length) % teamsList.length : teamsList.length - 1;
          const target = teamsList[nextIdx] ?? null;
          if (target) {
            e.preventDefault();
            e.stopPropagation();
            useTeam(target);
            return;
          }
        }
        if (hkNextTeam && matchHotkey(e, hkNextTeam)) {
          const baseId = lastUsedTeamId && teamsList.includes(lastUsedTeamId) ? lastUsedTeamId : teamsList[0] ?? null;
          const curIdx = baseId ? teamsList.indexOf(baseId) : -1;
          const nextIdx = curIdx >= 0 ? (curIdx + 1) % teamsList.length : 0;
          const target = teamsList[nextIdx] ?? null;
          if (target) {
            e.preventDefault();
            e.stopPropagation();
            useTeam(target);
            return;
          }
        }
        for (const [teamId, hk] of TEAM_HK_MAP) {
          if (matchHotkey(e, hk)) {
            e.preventDefault();
            e.stopPropagation();
            useTeam(teamId);
            break;
          }
        }
      },
      true
    );
    window[FLAG] = true;
  }
  var _AB = petAbilities ?? {};
  function _abilityName(id) {
    const key2 = String(id ?? "");
    const raw = typeof _AB?.[key2]?.name === "string" && _AB[key2].name.trim() ? _AB[key2].name : key2;
    return String(raw);
  }
  function _abilityNameWithoutLevel(id) {
    const key2 = String(id ?? "");
    const raw = typeof _AB?.[key2]?.name === "string" && _AB[key2].name.trim() ? _AB[key2].name : key2;
    return String(raw).replace(/(?:\s+|-)?(?:I|II|III|IV|V|VI|VII|VIII|IX|X)\s*$/, "").trim();
  }
  function _parseTeamSearch(raw) {
    const s = String(raw || "").trim();
    const m = s.match(/^(ab|sp):\s*(.*)$/i);
    if (!m) return { mode: "text", value: s };
    return { mode: m[1].toLowerCase() === "ab" ? "ability" : "species", value: (m[2] || "").trim() };
  }
  async function _abilityNameToPresentIds(name) {
    await _ensureInventoryWatchersStarted();
    const target = String(name || "").toLowerCase().trim().replace(/(?:\s+|-)?(?:i|ii|iii|iv|v|vi|vii|viii|ix|x)\s*$/i, "");
    const ids = /* @__PURE__ */ new Set();
    if (!target) return ids;
    for (const p of _invPetsCache) {
      const abs = Array.isArray(p.abilities) ? p.abilities : [];
      for (const id of abs) {
        if (_abilityNameWithoutLevel(id).toLowerCase() === target) ids.add(id);
      }
    }
    return ids;
  }
  var _s = (v) => (v ?? "").toLowerCase();
  var _sOpt = (v) => typeof v === "string" ? v : null;
  var _n = (v) => Number.isFinite(v) ? v : 0;
  var _sArr = (v) => Array.isArray(v) ? v.filter((x) => typeof x === "string") : [];
  var _petCatalogKeyByLc = new Map(
    Object.keys(petCatalog).map((k) => [k.toLowerCase(), k])
  );
  function _canonicalSpecies(s) {
    if (!s) return s;
    if (petCatalog[s]) return s;
    const lc = s.toLowerCase();
    const found = _petCatalogKeyByLc.get(lc);
    if (found) return found;
    const t = s.charAt(0).toUpperCase() + s.slice(1).toLowerCase();
    return petCatalog[t] ? t : s;
  }
  function _invPetToRawItem(p) {
    return {
      id: p.id,
      itemType: "Pet",
      petSpecies: _canonicalSpecies(p.petSpecies),
      name: p.name ?? null,
      xp: p.xp,
      hunger: p.hunger,
      mutations: Array.isArray(p.mutations) ? p.mutations.slice() : [],
      targetScale: p.targetScale,
      abilities: Array.isArray(p.abilities) ? p.abilities.slice() : []
    };
  }
  function _dedupeTeams(arr) {
    const seen = /* @__PURE__ */ new Set();
    const out = [];
    for (const t of Array.isArray(arr) ? arr : []) {
      const id = String(t?.id || "");
      if (!id || seen.has(id)) continue;
      seen.add(id);
      const slots = Array.isArray(t?.slots) ? t.slots.slice(0, 3).map((x) => x ? String(x) : null) : [null, null, null];
      out.push({ ...t, id, slots });
    }
    return out;
  }
  function loadTeams() {
    const arr = readAriesPath(PATH_PETS_TEAMS) ?? [];
    if (!Array.isArray(arr)) return [];
    const mapped = arr.map((t) => ({
      id: String(t?.id || ""),
      name: String(t?.name || "Team"),
      slots: Array.isArray(t?.slots) ? t.slots.slice(0, 3).map((x) => x ? String(x) : null) : [null, null, null]
    })).filter((t) => t.id);
    const unique = _dedupeTeams(mapped);
    if (unique.length !== mapped.length) {
      try {
        saveTeams(unique);
      } catch {
      }
    }
    return unique;
  }
  function saveTeams(arr) {
    writeAriesPath(PATH_PETS_TEAMS, arr);
  }
  function _uid() {
    try {
      return crypto.randomUUID();
    } catch {
      return `t_${Date.now().toString(36)}_${Math.random().toString(16).slice(2)}`;
    }
  }
  function _loadTeamSearchMap() {
    const obj = readAriesPath(PATH_PETS_TEAM_SEARCH);
    return obj && typeof obj === "object" ? obj : {};
  }
  function _saveTeamSearchMap(map2) {
    writeAriesPath(PATH_PETS_TEAM_SEARCH, map2);
  }
  var _teams = loadTeams();
  var _teamSearch = _loadTeamSearchMap();
  function _teamIdFromSlots(ids) {
    const wanted = new Set(ids.map((id) => String(id || "")).filter(Boolean));
    if (!wanted.size) return null;
    for (const team of _teams) {
      const slots = (Array.isArray(team?.slots) ? team.slots : []).map((id) => String(id || "")).filter(Boolean);
      if (slots.length !== wanted.size) continue;
      const set3 = new Set(slots);
      let ok = true;
      for (const id of wanted) {
        if (!set3.has(id)) {
          ok = false;
          break;
        }
      }
      if (ok) return team.id;
    }
    return null;
  }
  async function _currentActiveTeamId() {
    try {
      const slots = await _getActivePetSlotIds();
      return _teamIdFromSlots(slots);
    } catch {
      return null;
    }
  }
  var _invRaw = null;
  var _activeRaw = [];
  var _hutchRaw = [];
  var _invPetsCache = [];
  var _invUnsub = null;
  var _activeUnsub = null;
  var _hutchUnsub = null;
  var _invSig = null;
  var _activeSig = null;
  function _inventoryItemToPet(x) {
    if (!x || x.itemType !== "Pet") return null;
    const id = _s(x.id);
    if (!id) return null;
    const speciesRaw = x.petSpecies ?? x.data?.petSpecies;
    return {
      id,
      itemType: "Pet",
      petSpecies: _canonicalSpecies(String(speciesRaw ?? "").trim()),
      name: _sOpt(x.name ?? x.data?.name ?? null),
      xp: _n(x.xp ?? x.data?.xp),
      hunger: _n(x.hunger ?? x.data?.hunger),
      mutations: _sArr(x.mutations ?? x.data?.mutations),
      targetScale: Number.isFinite(x.targetScale ?? x.data?.targetScale) ? Number(x.targetScale ?? x.data?.targetScale) : void 0,
      abilities: _sArr(x.abilities ?? x.data?.abilities)
    };
  }
  function _activeSlotToPet(entry) {
    const slot = entry?.slot;
    if (!slot || typeof slot !== "object") return null;
    const id = _s(slot.id);
    if (!id) return null;
    const speciesRaw = slot.petSpecies;
    return {
      id,
      itemType: "Pet",
      petSpecies: _canonicalSpecies(String(speciesRaw ?? "").trim()),
      name: _sOpt(slot.name ?? null),
      xp: _n(slot.xp),
      hunger: _n(slot.hunger),
      mutations: _sArr(slot.mutations),
      targetScale: Number.isFinite(slot.targetScale) ? Number(slot.targetScale) : void 0,
      abilities: _sArr(slot.abilities)
    };
  }
  function _petSigStableNoXpNoHunger(p) {
    return JSON.stringify({
      id: p.id,
      itemType: "Pet",
      petSpecies: p.petSpecies,
      name: p.name ?? null,
      mutations: Array.isArray(p.mutations) ? p.mutations : [],
      targetScale: Number.isFinite(p.targetScale) ? p.targetScale : null,
      abilities: Array.isArray(p.abilities) ? p.abilities : []
    });
  }
  function _buildInvSigFromInventory(inv) {
    const out = /* @__PURE__ */ new Map();
    const items = Array.isArray(inv?.items) ? inv.items : Array.isArray(inv) ? inv : [];
    for (const it of items) {
      const p = _inventoryItemToPet(it);
      if (p) out.set(p.id, _petSigStableNoXpNoHunger(p));
    }
    return out;
  }
  function _buildActiveSig(list) {
    const out = /* @__PURE__ */ new Map();
    const arr = Array.isArray(list) ? list : [];
    for (const e of arr) {
      const p = _activeSlotToPet(e);
      if (p) out.set(p.id, _petSigStableNoXpNoHunger(p));
    }
    return out;
  }
  function _mapsEqual(a, b) {
    if (!a) return false;
    if (a.size !== b.size) return false;
    for (const [k, v] of b) if (a.get(k) !== v) return false;
    return true;
  }
  function _rebuildInvPets() {
    const map2 = /* @__PURE__ */ new Map();
    const hutchItems = Array.isArray(_hutchRaw) ? _hutchRaw : [];
    const invItems = Array.isArray(_invRaw?.items) ? _invRaw.items : Array.isArray(_invRaw) ? _invRaw : [];
    for (const it of hutchItems) {
      const p = _inventoryItemToPet(it);
      if (p && p.id) map2.set(p.id, p);
    }
    for (const it of invItems) {
      const p = _inventoryItemToPet(it);
      if (p && p.id) map2.set(p.id, p);
    }
    const act = Array.isArray(_activeRaw) ? _activeRaw : [];
    for (const e of act) {
      const p = _activeSlotToPet(e);
      if (p && p.id) map2.set(p.id, p);
    }
    _invPetsCache = Array.from(map2.values());
  }
  async function _startInventoryWatcher() {
    const unsub = await (async () => {
      try {
        const cur = await Atoms.inventory.myInventory.get();
        _invSig = _buildInvSigFromInventory(cur);
        _invRaw = cur;
        _rebuildInvPets();
      } catch {
      }
      return Atoms.inventory.myInventory.onChange((inv) => {
        const nextSig = _buildInvSigFromInventory(inv);
        if (_mapsEqual(_invSig, nextSig)) return;
        _invSig = nextSig;
        _invRaw = inv;
        _rebuildInvPets();
      });
    })();
    _invUnsub = () => {
      try {
        unsub();
      } catch {
      }
    };
  }
  async function _startActivePetsWatcher() {
    const unsub = await (async () => {
      try {
        const cur = await Atoms.pets.myPetInfos.get();
        _activeSig = _buildActiveSig(cur);
        _activeRaw = Array.isArray(cur) ? cur : [];
        _rebuildInvPets();
      } catch {
      }
      return Atoms.pets.myPetInfos.onChange((list) => {
        const nextSig = _buildActiveSig(list);
        if (_mapsEqual(_activeSig, nextSig)) return;
        _activeSig = nextSig;
        _activeRaw = Array.isArray(list) ? list : [];
        _rebuildInvPets();
      });
    })();
    _activeUnsub = () => {
      try {
        unsub();
      } catch {
      }
    };
  }
  async function _startHutchWatcher() {
    const unsub = await (async () => {
      try {
        const cur = await myPetHutchPetItems.get();
        _hutchRaw = Array.isArray(cur) ? cur : [];
        _rebuildInvPets();
      } catch {
      }
      return myPetHutchPetItems.onChange((list) => {
        _hutchRaw = Array.isArray(list) ? list : [];
        _rebuildInvPets();
      });
    })();
    _hutchUnsub = () => {
      try {
        unsub();
      } catch {
      }
    };
  }
  async function _ensureInventoryWatchersStarted() {
    if (!_invUnsub) await _startInventoryWatcher();
    if (!_activeUnsub) await _startActivePetsWatcher();
    if (!_hutchUnsub) await _startHutchWatcher();
    if (!_invPetsCache.length) {
      try {
        const [inv, active, hutch] = await Promise.all([
          Atoms.inventory.myInventory.get(),
          Atoms.pets.myPetInfos.get(),
          myPetHutchPetItems.get()
        ]);
        _invSig = _buildInvSigFromInventory(inv);
        _activeSig = _buildActiveSig(active);
        _invRaw = inv;
        _activeRaw = Array.isArray(active) ? active : [];
        _hutchRaw = Array.isArray(hutch) ? hutch : [];
        _rebuildInvPets();
      } catch {
      }
    }
  }
  async function clearHandSelection() {
    try {
      await Atoms.inventory.setSelectedIndexToEnd.set(null);
    } catch (err) {
    }
    try {
      await Atoms.inventory.myPossiblyNoLongerValidSelectedItemIndex.set(null);
    } catch (err) {
    }
    try {
      await PlayerService.setSelectedItem(null);
    } catch (err) {
    }
    try {
      await PlayerService.dropObject();
    } catch (err) {
    }
  }
  async function _waitValidatedInventoryIndex(timeoutMs = 2e4) {
    await clearHandSelection();
    const t0 = performance.now();
    while (performance.now() - t0 < timeoutMs) {
      try {
        const modalVal = await Atoms.ui.activeModal.get();
        if (!isInventoryOpen(modalVal)) return null;
      } catch {
        return null;
      }
      try {
        const v = await Atoms.inventory.myValidatedSelectedItemIndex.get();
        if (typeof v === "number" && Number.isInteger(v) && v >= 0) return v;
      } catch {
      }
      await new Promise((r) => setTimeout(r, 80));
    }
    return null;
  }
  var _lastAutofeedAttemptAt = /* @__PURE__ */ new Map();
  var _belowThreshold = /* @__PURE__ */ new Map();
  var AUTOF_FEED_MIN_INTERVAL_MS = 2e3;
  var DEFAULT_OVERRIDE = { enabled: false, thresholdPct: 10, crops: {} };
  var DEFAULT_UI = { selectedPetId: null };
  var DEFAULT_INSTANT_FEED = { crops: {} };
  var _currentPets = [];
  var _userTriggerCb = null;
  function saveOverrides(map2) {
    writeAriesPath(PATH_PETS_OVERRIDES, map2);
  }
  function loadOverrides() {
    const obj = readAriesPath(PATH_PETS_OVERRIDES);
    return obj && typeof obj === "object" ? obj : {};
  }
  function saveInstantFeedOverrides(map2) {
    writeAriesPath(PATH_PETS_INSTANT_FEED, map2);
  }
  function loadInstantFeedOverrides() {
    const obj = readAriesPath(PATH_PETS_INSTANT_FEED);
    return obj && typeof obj === "object" ? obj : {};
  }
  function saveUIState(next) {
    writeAriesPath(PATH_PETS_UI, next);
  }
  function loadUIState() {
    const obj = readAriesPath(PATH_PETS_UI);
    const merged = { ...DEFAULT_UI, ...obj || {} };
    return merged;
  }
  function cloneOverride(o) {
    const src = o ?? DEFAULT_OVERRIDE;
    return {
      enabled: !!src.enabled,
      thresholdPct: Math.min(100, Math.max(1, Number(src.thresholdPct) || DEFAULT_OVERRIDE.thresholdPct)),
      crops: { ...src.crops || {} }
    };
  }
  function cloneInstantFeedOverride(o) {
    const src = o ?? DEFAULT_INSTANT_FEED;
    return {
      crops: { ...src.crops || {} }
    };
  }
  function clampPct(n) {
    return Math.max(0, Math.min(100, n));
  }
  function getCompatibleCropsFromData(species) {
    const PC = petCatalog;
    const entry = PC?.[species];
    const raw = entry?.diet ?? entry?.compatibleCrops ?? entry?.crops ?? [];
    const arr = Array.isArray(raw) ? raw : [];
    return arr.filter((c) => typeof c === "string" && c.length > 0);
  }
  function getMaxHungerFromData(species) {
    const v = petCatalog?.[species]?.coinsToFullyReplenishHunger;
    if (typeof v === "number" && Number.isFinite(v) && v > 0) return v;
    return 3e3;
  }
  async function findPetById(petId) {
    try {
      const list = await PlayerService.getPets();
      const arr = Array.isArray(list) ? list : [];
      return arr.find((p) => String(p?.slot?.id || "") === String(petId)) ?? null;
    } catch {
      return null;
    }
  }
  function findFirstCompatibleInvItem(allowed, inv) {
    const arr = Array.isArray(inv) ? inv : [];
    for (const it of arr) {
      const species = String(it?.species || "");
      if (species && allowed.has(species)) return it;
    }
    return null;
  }
  function _emitTrigger(payload) {
    try {
      _userTriggerCb?.(payload);
    } catch {
    }
  }
  async function _evaluatePet(pet) {
    const petId = String(pet?.slot?.id || "");
    if (!petId) return;
    const ov = PetsService.getOverride(petId);
    if (!ov.enabled) {
      _lastAutofeedAttemptAt.delete(petId);
      return;
    }
    const hungerPct = PetsService.getHungerPctFor(pet);
    const thresholdPct = Math.max(1, Math.min(100, ov.thresholdPct | 0 || 10));
    const nowBelow = hungerPct < thresholdPct;
    const now2 = Date.now();
    const lastAttempt = _lastAutofeedAttemptAt.get(petId) || 0;
    if (nowBelow && now2 - lastAttempt >= AUTOF_FEED_MIN_INTERVAL_MS) {
      let allowedSet;
      try {
        allowedSet = await PetsService.getPetAllowedCrops(petId);
      } catch {
        const species = String(pet?.slot?.petSpecies || "");
        allowedSet = new Set(PetsService.getCompatibleCropsForSpecies(species));
      }
      const allowed = Array.from(allowedSet);
      let chosen = null;
      let didUnfavorite = false;
      try {
        const [invRaw, favIdsRaw] = await Promise.all([
          PlayerService.getCropInventoryState(),
          PlayerService.getFavoriteIds?.() ?? []
        ]);
        const inv = Array.isArray(invRaw) ? invRaw : [];
        const favSet = new Set(Array.isArray(favIdsRaw) ? favIdsRaw : []);
        const invNonFav = inv.filter((it) => !favSet.has(String(it?.id)));
        chosen = findFirstCompatibleInvItem(allowedSet, invNonFav);
        if (chosen?.id && PlayerService.feedPet) {
          try {
            await PlayerService.feedPet(petId, chosen.id);
          } catch {
          }
        }
      } catch {
      }
      _emitTrigger({
        pet,
        petId,
        species: String(pet?.slot?.petSpecies || ""),
        hungerPct,
        thresholdPct,
        allowedCrops: allowed,
        chosenItem: chosen,
        didUnfavorite
      });
      _lastAutofeedAttemptAt.set(petId, now2);
    }
    if (!nowBelow) {
      _lastAutofeedAttemptAt.delete(petId);
    }
  }
  async function _evaluateAll() {
    const arr = Array.isArray(_currentPets) ? _currentPets : [];
    for (const p of arr) {
      try {
        await _evaluatePet(p);
      } catch {
      }
    }
  }
  var PetsService = {
    /* --------- Player-facing (UI list/subscribe) --------- */
    getPets() {
      return PlayerService.getPets();
    },
    onPetsChange(cb) {
      return PlayerService.onPetsChange(cb);
    },
    onPetsChangeNow(cb) {
      return PlayerService.onPetsChangeNow(cb);
    },
    /* ------------------------- Abilities utils ------------------------- */
    getAbilityName(id) {
      return _abilityName(id);
    },
    getAbilityNameWithoutLevel(id) {
      return _abilityNameWithoutLevel(id);
    },
    /* ------------------------- Autofeed + per-pet UI state ------------------------- */
    setUIState(next) {
      const cur = loadUIState();
      const merged = { ...cur, ...next || {} };
      saveUIState(merged);
      return merged;
    },
    setSelectedPet(id) {
      return this.setUIState({ selectedPetId: id });
    },
    getSelectedPetId() {
      return loadUIState().selectedPetId ?? null;
    },
    getOverride(petId) {
      const all = loadOverrides();
      return cloneOverride(all[petId]);
    },
    setOverride(petId, patch2) {
      const all = loadOverrides();
      const cur = cloneOverride(all[petId]);
      const next = {
        enabled: patch2.enabled ?? cur.enabled,
        thresholdPct: Number.isFinite(patch2.thresholdPct) ? Math.min(100, Math.max(1, Number(patch2.thresholdPct))) : cur.thresholdPct,
        crops: { ...cur.crops, ...patch2.crops || {} }
      };
      all[petId] = next;
      saveOverrides(all);
      void _evaluateAll();
      return next;
    },
    updateOverride(petId, fn) {
      const all = loadOverrides();
      const cur = cloneOverride(all[petId]);
      const next = cloneOverride(fn(cur));
      all[petId] = next;
      saveOverrides(all);
      void _evaluateAll();
      return next;
    },
    async setPetAutofeedEnabled(petId, enabled) {
      return this.setOverride(petId, { enabled: !!enabled });
    },
    getPetAutofeedEnabled(petId) {
      return this.getOverride(petId).enabled;
    },
    async setPetAutofeedThresholdPct(petId, pct) {
      const v = Math.min(100, Math.max(1, Math.floor(Number(pct) || 10)));
      return this.setOverride(petId, { thresholdPct: v });
    },
    getPetAutofeedThresholdPct(petId) {
      return this.getOverride(petId).thresholdPct;
    },
    async setPetAllowedCrop(petId, crop, allowed) {
      return this.updateOverride(petId, (cur) => {
        const next = cloneOverride(cur);
        const entry = next.crops[crop] ?? { allowed: true };
        next.crops[crop] = { allowed: allowed ?? entry.allowed };
        return next;
      });
    },
    async getPetAllowedCrops(petId) {
      const ov = this.getOverride(petId);
      const pet = await findPetById(petId);
      const species = pet?.slot?.petSpecies || "";
      const compatibles = this.getCompatibleCropsForSpecies(species);
      const allowed = /* @__PURE__ */ new Set();
      for (const c of compatibles) {
        const rule = ov.crops[c];
        if (rule ? !!rule.allowed : true) allowed.add(c);
      }
      return allowed;
    },
    /* ------------------------- Instant feed (per-species) ------------------------- */
    getInstantFeedOverride(species) {
      const key2 = _canonicalSpecies(String(species || ""));
      const all = loadInstantFeedOverrides();
      return cloneInstantFeedOverride(all[key2]);
    },
    isInstantFeedCropAllowed(species, crop) {
      const ov = this.getInstantFeedOverride(species);
      const rule = ov.crops[crop];
      return rule ? !!rule.allowed : true;
    },
    setInstantFeedCropAllowed(species, crop, allowed) {
      const key2 = _canonicalSpecies(String(species || ""));
      const all = loadInstantFeedOverrides();
      const cur = cloneInstantFeedOverride(all[key2]);
      cur.crops[crop] = { allowed: !!allowed };
      all[key2] = cur;
      saveInstantFeedOverrides(all);
      return cloneInstantFeedOverride(cur);
    },
    getInstantFeedAllowedCrops(species) {
      const key2 = _canonicalSpecies(String(species || ""));
      const compatibles = this.getCompatibleCropsForSpecies(key2);
      const ov = this.getInstantFeedOverride(key2);
      const allowed = /* @__PURE__ */ new Set();
      for (const c of compatibles) {
        const rule = ov.crops[c];
        if (rule ? !!rule.allowed : true) allowed.add(c);
      }
      return allowed;
    },
    getCompatibleCropsForSpecies(species) {
      return getCompatibleCropsFromData(species);
    },
    getMaxHungerForSpecies(species) {
      return getMaxHungerFromData(species);
    },
    getHungerPctFor(pet) {
      const cur = Number(pet?.slot?.hunger) || 0;
      const species = String(pet?.slot?.petSpecies || "");
      const max = this.getMaxHungerForSpecies(species);
      const pct = cur / max * 100;
      return +clampPct(pct).toFixed(1);
    },
    async startAutofeedWatcher(onTrigger) {
      _userTriggerCb = onTrigger ?? null;
      const stop2 = await PlayerService.onPetsChangeNow((arr) => {
        _currentPets = Array.isArray(arr) ? arr.slice() : [];
        void _evaluateAll();
      });
      return () => {
        try {
          stop2();
        } catch {
        }
        _currentPets = [];
        _belowThreshold.clear();
        _userTriggerCb = null;
      };
    },
    /* ------------------------- Teams (UI-less core used by UI) ------------------------- */
    _teams: loadTeams(),
    _teamSubs: /* @__PURE__ */ new Set(),
    _notifyTeamSubs() {
      const snap = this.getTeams();
      this._teamSubs.forEach((fn) => {
        try {
          fn(snap);
        } catch {
        }
      });
    },
    getTeams() {
      return Array.isArray(this._teams) ? this._teams.map((t) => ({ ...t, slots: t.slots.slice(0, 3) })) : [];
    },
    onTeamsChange(cb) {
      this._teamSubs.add(cb);
      try {
        cb(this.getTeams());
      } catch {
      }
      return () => {
        this._teamSubs.delete(cb);
      };
    },
    async onTeamsChangeNow(cb) {
      const unsub = this.onTeamsChange(cb);
      try {
        cb(this.getTeams());
      } catch {
      }
      return unsub;
    },
    createTeam(name) {
      const t = { id: _uid(), name: name?.trim() || `Team ${this._teams.length + 1}`, slots: [null, null, null] };
      this._teams.push(t);
      saveTeams(this._teams);
      this._notifyTeamSubs();
      return t;
    },
    deleteTeam(teamId) {
      const i = this._teams.findIndex((t) => t.id === teamId);
      if (i < 0) return false;
      this._teams.splice(i, 1);
      saveTeams(this._teams);
      this._notifyTeamSubs();
      return true;
    },
    saveTeam(patch2) {
      const i = this._teams.findIndex((t) => t.id === patch2.id);
      if (i < 0) return null;
      const cur = this._teams[i];
      const next = {
        id: cur.id,
        name: typeof patch2.name === "string" ? patch2.name : cur.name,
        slots: Array.isArray(patch2.slots) ? patch2.slots.slice(0, 3) : cur.slots
      };
      this._teams[i] = next;
      saveTeams(this._teams);
      this._notifyTeamSubs();
      return next;
    },
    setTeamsOrder(ids) {
      const byId = new Map(this._teams.map((t) => [t.id, t]));
      const next = [];
      for (const id of ids) {
        const t = byId.get(id);
        if (t) {
          next.push(t);
          byId.delete(id);
        }
      }
      for (const rest of byId.values()) next.push(rest);
      this._teams = next;
      saveTeams(this._teams);
      this._notifyTeamSubs();
    },
    getTeamById(teamId) {
      const t = this._teams.find((t2) => t2.id === teamId) || null;
      return t ? { ...t, slots: t.slots.slice(0, 3) } : null;
    },
    getTeamSearch(teamId) {
      return _teamSearch[teamId] || "";
    },
    setTeamSearch(teamId, q) {
      _teamSearch[teamId] = (q || "").trim();
      _saveTeamSearchMap(_teamSearch);
    },
    /* ------------------------- Inventory filters + pickers ------------------------- */
    async getInventoryPets() {
      await _ensureInventoryWatchersStarted();
      return _invPetsCache.slice();
    },
    async buildFilteredInventoryForTeam(teamId, opts) {
      await _ensureInventoryWatchersStarted();
      const { mode, value } = _parseTeamSearch(this.getTeamSearch(teamId) || "");
      let list = await this.getInventoryPets();
      if (mode === "ability" && value) {
        const idSet = await _abilityNameToPresentIds(value);
        list = idSet.size ? list.filter((p) => Array.isArray(p.abilities) && p.abilities.some((a) => idSet.has(a))) : [];
      } else if (mode === "species" && value) {
        const vv = value.toLowerCase();
        list = list.filter((p) => (p.petSpecies || "").toLowerCase() === vv);
      } else if (value) {
        const q = value.toLowerCase();
        list = list.filter(
          (p) => _s(p.id).includes(q) || _s(p.petSpecies).includes(q) || _s(p.name).includes(q) || Array.isArray(p.abilities) && p.abilities.some((a) => _s(a).includes(q) || _s(_abilityName(a)).includes(q)) || Array.isArray(p.mutations) && p.mutations.some((m) => _s(m).includes(q))
        );
      }
      if (opts?.excludeIds?.size) {
        const ex = opts.excludeIds;
        list = list.filter((p) => !ex.has(p.id));
      }
      const items = list.map(_invPetToRawItem);
      let favoritedItemIds = [];
      try {
        const favAll = await Atoms.inventory.favoriteIds.get().catch(() => []);
        const keep = new Set(list.map((p) => p.id));
        favoritedItemIds = (favAll || []).filter((id) => keep.has(id));
      } catch {
      }
      return { items, favoritedItemIds };
    },
    async buildFilteredInventoryByQuery(query, opts) {
      await _ensureInventoryWatchersStarted();
      const q = (query || "").toLowerCase().trim();
      let list = await this.getInventoryPets();
      if (q) {
        list = list.filter(
          (p) => _s(p.id).includes(q) || _s(p.petSpecies).includes(q) || _s(p.name).includes(q) || Array.isArray(p.abilities) && p.abilities.some((a) => _s(a).includes(q) || _s(_abilityName(a)).includes(q)) || Array.isArray(p.mutations) && p.mutations.some((m) => _s(m).includes(q))
        );
      }
      if (opts?.excludeIds?.size) {
        const ex = opts.excludeIds;
        list = list.filter((p) => !ex.has(p.id));
      }
      const items = list.map(_invPetToRawItem);
      let favoritedItemIds = [];
      try {
        const favAll = await Atoms.inventory.favoriteIds.get().catch(() => []);
        const keep = new Set(list.map((p) => p.id));
        favoritedItemIds = (favAll || []).filter((id) => keep.has(id));
      } catch {
      }
      return { items, favoritedItemIds };
    },
    async chooseSlotPet(teamId, slotIndex, searchOverride) {
      const idx = Math.max(0, Math.min(2, Math.floor(slotIndex || 0)));
      const team = this.getTeamById(teamId);
      if (!team) return null;
      const exclude = /* @__PURE__ */ new Set();
      team.slots.forEach((id, i) => {
        if (i !== idx && id) exclude.add(String(id));
      });
      const payload = searchOverride && searchOverride.trim().length ? await this.buildFilteredInventoryByQuery(searchOverride, { excludeIds: exclude }) : await this.buildFilteredInventoryForTeam(teamId, { excludeIds: exclude });
      const items = Array.isArray(payload?.items) ? payload.items : [];
      try {
        const rawHutch = await myPetHutchPetItems.get();
        const hutchArr = Array.isArray(rawHutch) ? rawHutch : [];
        let hutchPets = hutchArr.map((it) => _inventoryItemToPet(it)).filter((p) => !!p);
        const teamSearch = this.getTeamSearch(teamId) || "";
        if (searchOverride && searchOverride.trim().length) {
          const q = searchOverride.toLowerCase().trim();
          if (q) {
            hutchPets = hutchPets.filter(
              (p) => _s(p.id).includes(q) || _s(p.petSpecies).includes(q) || _s(p.name).includes(q) || Array.isArray(p.abilities) && p.abilities.some((a) => _s(a).includes(q) || _s(_abilityName(a)).includes(q)) || Array.isArray(p.mutations) && p.mutations.some((m) => _s(m).includes(q))
            );
          }
        } else if (teamSearch && teamSearch.trim().length) {
          const { mode, value } = _parseTeamSearch(teamSearch);
          if (mode === "ability" && value) {
            const idSet = await _abilityNameToPresentIds(value);
            hutchPets = idSet.size ? hutchPets.filter((p) => Array.isArray(p.abilities) && p.abilities.some((a) => idSet.has(a))) : [];
          } else if (mode === "species" && value) {
            const vv = value.toLowerCase();
            hutchPets = hutchPets.filter((p) => (p.petSpecies || "").toLowerCase() === vv);
          } else if (value) {
            const q = value.toLowerCase();
            hutchPets = hutchPets.filter(
              (p) => _s(p.id).includes(q) || _s(p.petSpecies).includes(q) || _s(p.name).includes(q) || Array.isArray(p.abilities) && p.abilities.some((a) => _s(a).includes(q) || _s(_abilityName(a)).includes(q)) || Array.isArray(p.mutations) && p.mutations.some((m) => _s(m).includes(q))
            );
          }
        }
        if (exclude.size) hutchPets = hutchPets.filter((p) => !exclude.has(p.id));
        const seen = new Set(items.map((it) => String(it?.id ?? "")));
        for (const p of hutchPets) {
          if (!seen.has(p.id)) {
            items.push(_invPetToRawItem(p));
            seen.add(p.id);
          }
        }
      } catch {
      }
      if (!items.length) return null;
      await fakeInventoryShow(payload, { open: true });
      const selIndex = await _waitValidatedInventoryIndex(2e4);
      await closeInventoryPanel();
      if (selIndex == null || selIndex < 0 || selIndex >= items.length) return null;
      const chosenPet = _inventoryItemToPet(items[selIndex]);
      if (!chosenPet) return null;
      const next = team.slots.slice(0, 3);
      next[idx] = String(chosenPet.id);
      this.saveTeam({ id: team.id, slots: next });
      try {
        await clearHandSelection();
      } catch {
      }
      return chosenPet;
    },
    async pickPetViaFakeInventory(search) {
      const payload = await this.buildFilteredInventoryByQuery(search || "");
      const items = Array.isArray(payload?.items) ? payload.items : [];
      if (!items.length) return null;
      await fakeInventoryShow(payload, { open: true });
      const selIndex = await _waitValidatedInventoryIndex(2e4);
      await closeInventoryPanel();
      if (selIndex == null || selIndex < 0 || selIndex >= items.length) return null;
      await clearHandSelection();
      return _inventoryItemToPet(items[selIndex]);
    },
    /* ------------------------- Team switching ------------------------- */
    async useTeam(teamId, opts) {
      const t = this.getTeams().find((tt) => tt.id === teamId) || null;
      if (!t) throw new Error("Team not found");
      const targetInvIds = (t.slots || []).filter((x) => typeof x === "string" && x.length > 0).slice(0, 3);
      return _equipPetIds(targetInvIds, { markTeamId: teamId, markUsed: opts?.markUsed });
    },
    async usePetIds(targetInvIds) {
      return _equipPetIds(targetInvIds, { markTeamId: null });
    },
    async getActivePetIds() {
      return _getActivePetSlotIds();
    },
    /* ------------------------- Ability logs ------------------------- */
    _logs: [],
    _logsMax: 500,
    _seenPerfByPet: /* @__PURE__ */ new Map(),
    _logSubs: /* @__PURE__ */ new Set(),
    _logsCutoffMs: 0,
    _logsCutoffSkewMs: 1500,
    _logsStorageKey: PATH_PETS_ABILITY_LOGS,
    _logsSessionStart: Date.now(),
    _extractAbilityValue(abilityId, rawData) {
      const num = (value) => {
        const parsed = Number(value);
        return Number.isFinite(parsed) ? Math.max(0, parsed) : 0;
      };
      const data = rawData ?? {};
      const base = petAbilities[abilityId]?.baseParameters ?? {};
      switch (abilityId) {
        case "CoinFinderI":
        case "CoinFinderII":
        case "CoinFinderIII":
        case "SnowyCoinFinder": {
          const value = data["coinsFound"] ?? data["coins"] ?? 0;
          return num(value);
        }
        case "SellBoostI":
        case "SellBoostII":
        case "SellBoostIII":
        case "SellBoostIV": {
          const value = data["bonusCoins"] ?? data["coinsEarned"] ?? 0;
          return num(value);
        }
        case "ProduceEater":
          return num(data["sellPrice"] ?? 0);
        case "ProduceScaleBoost":
        case "ProduceScaleBoostII":
        case "SnowyCropSizeBoost": {
          const inc = data["scaleIncreasePercentage"] ?? data["cropScaleIncreasePercentage"] ?? base["scaleIncreasePercentage"] ?? 0;
          return num(inc);
        }
        case "EggGrowthBoost":
        case "EggGrowthBoostII_NEW":
        case "EggGrowthBoostII":
        case "SnowyEggGrowthBoost": {
          const minutes = data["eggGrowthTimeReductionMinutes"] ?? data["minutesReduced"] ?? data["reductionMinutes"] ?? base["eggGrowthTimeReductionMinutes"] ?? 0;
          return num(minutes) * 60 * 1e3;
        }
        case "PlantGrowthBoost":
        case "PlantGrowthBoostII":
        case "SnowyPlantGrowthBoost": {
          const minutes = data["minutesReduced"] ?? data["reductionMinutes"] ?? data["plantGrowthReductionMinutes"] ?? base["plantGrowthReductionMinutes"] ?? 0;
          return num(minutes) * 60 * 1e3;
        }
        case "PetXpBoost":
        case "SnowyPetXpBoost":
        case "PetXpBoostII": {
          const xp = data["bonusXp"] ?? base["bonusXp"] ?? 0;
          return num(xp);
        }
        case "PetAgeBoost":
        case "PetAgeBoostII": {
          const xp = data["bonusXp"] ?? base["bonusXp"] ?? 0;
          return num(xp);
        }
        case "PetHatchSizeBoost":
        case "PetHatchSizeBoostII": {
          const strength = data["strengthIncrease"] ?? 0;
          return num(strength);
        }
        case "HungerRestore":
        case "HungerRestoreII":
        case "SnowyHungerRestore": {
          const amount = data["hungerRestoreAmount"] ?? data["hungerRestoredPercentage"] ?? base["hungerRestorePercentage"] ?? 0;
          return num(amount);
        }
        case "HungerBoost":
        case "HungerBoostII":
        case "SnowyHungerBoost": {
          const pct = data["hungerDepletionRateDecreasePercentage"] ?? base["hungerDepletionRateDecreasePercentage"] ?? 0;
          return num(pct);
        }
        default:
          return 0;
      }
    },
    async startAbilityLogsWatcher() {
      await _ensureInventoryWatchersStarted();
      const indexInfosByPetId = (list) => {
        const out = {};
        const arr = Array.isArray(list) ? list : [];
        for (const e of arr) {
          const id = String(e?.slot?.id ?? e?.id ?? "");
          if (id) out[id] = e;
        }
        return out;
      };
      let myInfosMap = {};
      try {
        myInfosMap = indexInfosByPetId(await Atoms.pets.myPetInfos.get());
      } catch {
      }
      let stopInfos = null;
      try {
        stopInfos = await Atoms.pets.myPetInfos.onChange((list) => {
          try {
            myInfosMap = indexInfosByPetId(list);
          } catch {
          }
        });
      } catch {
      }
      const extractFlat = (src) => {
        const out = {};
        if (!src || typeof src !== "object") return out;
        const obj = src;
        for (const petId of Object.keys(obj)) {
          const entry = obj[petId] ?? {};
          const lat = entry.lastAbilityTrigger ?? null;
          let rawH = entry.hungerPct ?? entry.hunger_percentage ?? entry.hunger ?? entry.stats?.hungerPct ?? entry.stats?.hunger?.pct ?? entry.stats?.hunger?.percent ?? null;
          if (rawH == null) {
            const info = myInfosMap[petId];
            rawH = info?.hungerPct ?? info?.hunger_percentage ?? info?.hunger ?? info?.slot?.hungerPct ?? info?.slot?.hunger ?? info?.stats?.hungerPct ?? info?.stats?.hunger?.pct ?? info?.stats?.hunger?.percent ?? null;
          }
          let hungerPct = Number.isFinite(Number(rawH)) ? Number(rawH) : null;
          if (hungerPct != null && hungerPct > 0 && hungerPct <= 1) hungerPct *= 100;
          out[petId] = {
            petId,
            abilityId: lat?.abilityId ?? null,
            performedAt: Number.isFinite(lat?.performedAt) ? lat.performedAt : null,
            data: lat?.data ?? null,
            position: entry.position ?? null,
            hungerPct
          };
        }
        return out;
      };
      try {
        this._ingestAbilityMap(extractFlat(await Atoms.pets.myPetSlotInfos.get()));
      } catch {
      }
      const stopSlots = await Atoms.pets.myPetSlotInfos.onChange((src) => {
        try {
          this._ingestAbilityMap(extractFlat(src));
        } catch {
        }
      });
      return () => {
        try {
          stopSlots();
        } catch {
        }
        try {
          stopInfos?.();
        } catch {
        }
      };
    },
    getAbilityLogs(opts) {
      const ids = opts?.abilityIds && opts.abilityIds.length ? new Set(opts.abilityIds) : null;
      const since = Number.isFinite(opts?.since) ? opts.since : 0;
      const lim = Math.max(0, Math.floor(opts?.limit ?? 0));
      let arr = this._logs.filter(
        (e) => (since ? e.performedAt >= since : true) && (ids ? ids.has(e.abilityId) : true)
      );
      arr = arr.sort((a, b) => b.performedAt - a.performedAt);
      return lim ? arr.slice(0, lim) : arr;
    },
    getAbilityLogsSessionStart() {
      return this._logsSessionStart;
    },
    onAbilityLogs(cb) {
      this._logSubs.add(cb);
      try {
        cb(this.getAbilityLogs());
      } catch {
      }
      return () => {
        this._logSubs.delete(cb);
      };
    },
    getSeenAbilityIds() {
      const set3 = /* @__PURE__ */ new Set();
      for (const e of this._logs) set3.add(e.abilityId);
      return Array.from(set3).sort();
    },
    clearAbilityLogs() {
      this._logs.length = 0;
      this._seenPerfByPet.clear();
      this._logsCutoffMs = Date.now();
      this._notifyLogSubs();
      this._persistAbilityLogs();
    },
    _notifyLogSubs() {
      const snap = this.getAbilityLogs();
      this._logSubs.forEach((fn) => {
        try {
          fn(snap);
        } catch {
        }
      });
    },
    _pushLog(e) {
      this._logs.push(e);
      if (this._logs.length > this._logsMax) {
        this._logs.splice(0, this._logs.length - this._logsMax);
      }
      this._notifyLogSubs();
      this._persistAbilityLogs();
    },
    _persistAbilityLogs() {
      try {
        const payload = {
          version: 1,
          cutoff: this._logsCutoffMs,
          logs: this._logs.map((entry) => ({
            petId: entry.petId,
            species: entry.species ?? null,
            name: entry.name ?? null,
            mutations: Array.isArray(entry.mutations) ? entry.mutations.slice() : void 0,
            abilityId: entry.abilityId,
            abilityName: entry.abilityName,
            data: entry.data,
            performedAt: entry.performedAt,
            time12: entry.time12
          }))
        };
        writeAriesPath(PATH_PETS_ABILITY_LOGS, payload);
      } catch {
      }
    },
    _restoreAbilityLogsFromStorage() {
      try {
        const parsed = readAriesPath(PATH_PETS_ABILITY_LOGS);
        if (!parsed || typeof parsed !== "object") return;
        const logsRaw = Array.isArray(parsed.logs) ? parsed.logs : [];
        const restored = [];
        for (const item of logsRaw) {
          if (!item || typeof item !== "object") continue;
          const abilityId = typeof item.abilityId === "string" ? String(item.abilityId) : "";
          const performedAt = Number(item.performedAt) || 0;
          if (!abilityId || !performedAt) continue;
          const mutsRaw = item.mutations;
          const mutations = Array.isArray(mutsRaw) ? mutsRaw.map((m) => String(m ?? "").trim()).filter(Boolean) : void 0;
          restored.push({
            petId: typeof item.petId === "string" ? String(item.petId) : "",
            species: typeof item.species === "string" && item.species ? String(item.species) : void 0,
            name: typeof item.name === "string" && item.name ? String(item.name) : void 0,
            mutations: mutations && mutations.length ? mutations : void 0,
            abilityId,
            abilityName: typeof item.abilityName === "string" && item.abilityName ? String(item.abilityName) : abilityId,
            data: typeof item.data === "string" ? String(item.data) : item.data,
            performedAt,
            time12: typeof item.time12 === "string" && item.time12 ? String(item.time12) : new Date(performedAt).toLocaleTimeString("en-US", { hour: "numeric", minute: "2-digit", hour12: true })
          });
        }
        restored.sort((a, b) => a.performedAt - b.performedAt);
        this._logs = restored.slice(-this._logsMax);
        this._seenPerfByPet.clear();
        for (const entry of this._logs) {
          const prev = this._seenPerfByPet.get(entry.petId) || 0;
          if (entry.performedAt > prev) this._seenPerfByPet.set(entry.petId, entry.performedAt);
        }
        const cutoff = Number(parsed.cutoff);
        if (Number.isFinite(cutoff) && cutoff > 0) this._logsCutoffMs = cutoff;
      } catch {
      }
    },
    _ingestAbilityMap(map2) {
      if (!map2 || typeof map2 !== "object") return;
      const abilityDisplayName = (abilityId) => {
        const def = petAbilities[abilityId];
        return def?.name && def.name.trim() || abilityId;
      };
      const fmtTime12 = (ms) => new Date(ms).toLocaleTimeString("en-US", { hour: "numeric", minute: "2-digit", hour12: true });
      const fmtInt = (n) => Number.isFinite(Number(n)) ? Math.round(Number(n)).toLocaleString("en-US") : "0";
      const fmtPct0 = (n) => `${Number.isFinite(Number(n)) ? Number(n).toFixed(0) : "0"}%`;
      const fmtMin1 = (n) => `${Number.isFinite(Number(n)) ? Number(n).toFixed(1) : "0.0"} min`;
      const formatDetails = (abilityId, data) => {
        const d = data ?? {};
        const base = petAbilities[abilityId]?.baseParameters ?? {};
        const label2 = (value, fallback) => {
          const s = typeof value === "string" ? value.trim() : "";
          return s || fallback;
        };
        const percentOr = (value, fallback) => value != null ? value : fallback;
        const cropNameFromGrowSlot = (src) => {
          if (!src || typeof src !== "object") return null;
          const species = src.species;
          if (typeof species !== "string" || !species.trim()) return null;
          const key2 = species.trim();
          const variants = [key2, key2.charAt(0).toUpperCase() + key2.slice(1), key2.toLowerCase()];
          for (const v of variants) {
            const name = plantCatalog?.[v]?.crop?.name;
            if (typeof name === "string" && name.trim()) return name;
          }
          return null;
        };
        switch (abilityId) {
          case "CoinFinderI":
          case "CoinFinderII":
          case "CoinFinderIII":
          case "SnowyCoinFinder": {
            const coins = d["coinsFound"] ?? d["coins"] ?? base["baseMaxCoinsFindable"];
            return coins != null ? `+ ${fmtInt(coins)} coins` : "Coins found";
          }
          case "SeedFinderI":
          case "SeedFinderII":
          case "SeedFinderIII":
          case "SeedFinderIV": {
            const seed = label2(d["seedName"], "seed");
            return `x1 ${seed}`;
          }
          case "HungerRestore":
          case "HungerRestoreII":
          case "SnowyHungerRestore": {
            const whoRaw = d["petName"];
            const who = label2(whoRaw === "itself" ? "itself" : whoRaw, "pet");
            const amount = d["hungerRestoreAmount"];
            const pct = percentOr(d["hungerRestoredPercentage"], base["hungerRestorePercentage"]);
            if (amount != null) return `${who}: +${fmtInt(amount)} hunger`;
            return pct != null ? `${who}: ${fmtPct0(pct)}` : `${who}: Hunger restored`;
          }
          case "DoubleHarvest": {
            const crop = label2(d["cropName"], "crop");
            return `+1 ${crop}`;
          }
          case "DoubleHatch": {
            const pet = label2(d["petName"], "pet");
            return `+1 ${pet}`;
          }
          case "ProduceEater": {
            const name = label2(d["cropName"], "crop");
            if (d["sellPrice"] != null) return `Sold ${name}: +${fmtInt(d["sellPrice"])} coins`;
            const pct = base["cropSellPriceIncreasePercentage"];
            return pct != null ? `Eaten: ${name} (+${fmtPct0(pct)} value)` : `Eaten: ${name}`;
          }
          case "ProduceRefund": {
            const n = d["numCropsRefunded"] ?? d["numItemsRefunded"];
            return n != null ? `+ ${fmtInt(n)} crop(s)` : "Crops refunded";
          }
          case "SellBoostI":
          case "SellBoostII":
          case "SellBoostIII":
          case "SellBoostIV": {
            if (d["bonusCoins"] != null) return `Sale bonus: +${fmtInt(d["bonusCoins"])} coins`;
            const pct = base["cropSellPriceIncreasePercentage"];
            return pct != null ? `+ ${fmtPct0(pct)}` : "Sale bonus";
          }
          case "GoldGranter":
          case "RainbowGranter": {
            const cropFromSlot = cropNameFromGrowSlot(d["growSlot"]);
            const crop = label2(d["cropName"], cropFromSlot ?? "crop");
            const mut = abilityId === "GoldGranter" ? "Gold" : "Rainbow";
            return `${crop}`;
          }
          case "RainDance": {
            const cropFromSlot = cropNameFromGrowSlot(d["growSlot"]);
            const crop = label2(d["cropName"], cropFromSlot ?? "crop");
            const muts = Array.isArray(d.mutations) ? d.mutations : Array.isArray(d.growSlot?.mutations) ? d.growSlot.mutations : [];
            const hasFrozen = muts.some((m) => typeof m === "string" && m.toLowerCase() === "frozen");
            return hasFrozen ? `${crop}: Chilled + Frozen` : `${crop}: Wet`;
          }
          case "SnowGranter":
          case "FrostGranter": {
            const cropFromSlot = cropNameFromGrowSlot(d["growSlot"]);
            const crop = label2(d["cropName"], cropFromSlot ?? "crop");
            return `${crop}`;
          }
          case "ProduceScaleBoost":
          case "ProduceScaleBoostII":
          case "SnowyCropSizeBoost": {
            const inc = d["scaleIncreasePercentage"] ?? d["cropScaleIncreasePercentage"] ?? base["scaleIncreasePercentage"];
            return inc != null ? `+ ${fmtPct0(inc)}` : "Crop size boosted";
          }
          case "ProduceMutationBoost":
          case "ProduceMutationBoostII":
          case "PetMutationBoost":
          case "PetMutationBoostII": {
            const inc = percentOr(d["mutationChanceIncreasePercentage"], base["mutationChanceIncreasePercentage"]);
            return inc != null ? `+ ${fmtPct0(inc)} mutation chance` : "Mutation chance up";
          }
          case "EggGrowthBoost":
          case "EggGrowthBoostII_NEW":
          case "EggGrowthBoostII":
          case "SnowyEggGrowthBoost": {
            const mins = d["minutesReduced"] ?? d["eggGrowthTimeReductionMinutes"] ?? base["eggGrowthTimeReductionMinutes"];
            return mins != null ? `- ${fmtMin1(mins)}` : "Egg growth reduced";
          }
          case "PlantGrowthBoost":
          case "PlantGrowthBoostII":
          case "SnowyPlantGrowthBoost": {
            const mins = d["minutesReduced"] ?? d["reductionMinutes"] ?? base["plantGrowthReductionMinutes"];
            return mins != null ? `- ${fmtMin1(mins)}` : "Plant growth reduced";
          }
          case "PetXpBoost":
          case "SnowyPetXpBoost":
          case "PetXpBoostII": {
            const xp = d["bonusXp"] ?? base["bonusXp"];
            return `+ ${fmtInt(xp)} XP`;
          }
          case "PetAgeBoost":
          case "PetAgeBoostII": {
            const xp = d["bonusXp"] ?? base["bonusXp"];
            const who = label2(d["petName"], "pet");
            return `+ ${fmtInt(xp)} XP (${who})`;
          }
          case "PetHatchSizeBoost":
          case "PetHatchSizeBoostII": {
            const who = label2(d["petName"], "pet");
            if (d["strengthIncrease"] != null) return `+${fmtInt(d["strengthIncrease"])} strength (${who})`;
            const pct = base["maxStrengthIncreasePercentage"];
            return pct != null ? `+ ${fmtPct0(pct)} (${who})` : `Strength increased (${who})`;
          }
          case "HungerBoost":
          case "HungerBoostII":
          case "SnowyHungerBoost": {
            const pct = base["hungerDepletionRateDecreasePercentage"];
            return pct != null ? `- ${fmtPct0(pct)} hunger drain` : "Hunger reduced";
          }
          case "PetRefund":
          case "PetRefundII": {
            const egg = d["eggName"] ?? null;
            return egg ? `x1 ${egg}` : `Pet refunded as egg`;
          }
          case "Copycat":
            return "Copied another ability";
          case "MoonKisser":
            return "Amber mutations empowered";
          case "DawnKisser":
            return "Dawn mutations empowered";
          default: {
            const meta = petAbilities[abilityId];
            if (d && typeof d === "object" && Object.keys(d).length) return JSON.stringify(d);
            return meta?.description || "\u2014";
          }
        }
      };
      const EPS = 1e-6;
      for (const petId of Object.keys(map2)) {
        const entry = map2[petId];
        if (!entry || typeof entry !== "object") continue;
        const abilityId = entry.abilityId ?? null;
        const performedAtNum = Number(entry.performedAt) || 0;
        if (!abilityId || !performedAtNum) continue;
        const prev = this._seenPerfByPet.get(petId) || 0;
        if (performedAtNum <= prev) continue;
        if (this._logsCutoffMs && performedAtNum < this._logsCutoffMs - this._logsCutoffSkewMs) {
          this._seenPerfByPet.set(petId, performedAtNum);
          continue;
        }
        let hungerPct = Number.isFinite(Number(entry.hungerPct)) ? Number(entry.hungerPct) : null;
        if (hungerPct != null && hungerPct > 0 && hungerPct <= 1) hungerPct *= 100;
        if (hungerPct != null && hungerPct <= EPS) {
          this._seenPerfByPet.set(petId, performedAtNum);
          continue;
        }
        const pet = _invPetsCache.find((p) => String(p.id) === String(petId)) || null;
        const abilityIdStr = String(abilityId);
        const logLine = {
          petId,
          species: pet?.petSpecies || void 0,
          name: pet?.name ?? void 0,
          mutations: Array.isArray(pet?.mutations) ? pet.mutations.map((m) => String(m ?? "").trim()).filter(Boolean) : void 0,
          abilityId: abilityIdStr,
          abilityName: abilityDisplayName(abilityId),
          data: formatDetails(abilityIdStr, entry.data),
          performedAt: performedAtNum,
          time12: fmtTime12(performedAtNum)
        };
        this._seenPerfByPet.set(petId, performedAtNum);
        try {
          StatsService.incrementAbilityStat(abilityIdStr, "triggers");
          const abilityValue = this._extractAbilityValue(abilityIdStr, entry.data);
          if (abilityValue > 0) {
            StatsService.incrementAbilityStat(abilityIdStr, "totalValue", abilityValue);
          }
        } catch {
        }
        this._pushLog(logLine);
      }
    }
  };
  try {
    PetsService._restoreAbilityLogsFromStorage();
  } catch {
  }
  async function _getActivePetSlotIds() {
    try {
      const arr = await PlayerService.getPets();
      const list = Array.isArray(arr) ? arr : [];
      return list.map((p) => String(p?.slot?.id || "")).filter((id) => !!id).slice(0, 3);
    } catch {
      return [];
    }
  }
  async function _waitForActivePetsMatch(targetIds, timeoutMs = 5e3) {
    const wanted = new Set(targetIds.map((id) => String(id || "")).filter(Boolean));
    if (!wanted.size) return true;
    const snapshotMatches = async () => {
      try {
        const cur = await Atoms.pets.myPetInfos.get();
        const set3 = new Set((Array.isArray(cur) ? cur : []).map((p) => String(p?.slot?.id || "")).filter(Boolean));
        return [...wanted].every((id) => set3.has(id));
      } catch {
        return false;
      }
    };
    if (await snapshotMatches()) return true;
    return new Promise((resolve2) => {
      const deadline = Date.now() + timeoutMs;
      let unsub = null;
      let pendingUnsub = null;
      let stopped = false;
      const doUnsub = (fn) => {
        if (fn) {
          try {
            fn();
          } catch {
          }
        }
      };
      const stop2 = (ok) => {
        if (stopped) return;
        stopped = true;
        if (unsub) {
          doUnsub(unsub);
        } else if (pendingUnsub) {
          pendingUnsub.then((fn) => doUnsub(fn)).catch(() => {
          });
        }
        resolve2(ok);
      };
      const check = async (state3) => {
        const set3 = new Set((Array.isArray(state3) ? state3 : []).map((p) => String(p?.slot?.id || "")).filter(Boolean));
        if ([...wanted].every((id) => set3.has(id))) {
          stop2(true);
        } else if (Date.now() >= deadline) {
          stop2(false);
        }
      };
      try {
        const res = Atoms.pets.myPetInfos.onChange((state3) => {
          void check(state3);
        });
        if (typeof res === "function") {
          unsub = res;
        } else if (res && typeof res.then === "function") {
          pendingUnsub = res;
          pendingUnsub.then((fn) => {
            unsub = fn;
            if (stopped) {
              doUnsub(fn);
            }
          }).catch(() => {
          });
        }
      } catch {
        stop2(false);
        return;
      }
      void check();
      setTimeout(() => stop2(false), timeoutMs + 50);
    });
  }
  async function _waitForInventoryState(predicate, timeoutMs = 4e3) {
    const snapshotMatches = async () => {
      try {
        const cur = await Atoms.inventory.myInventory.get();
        const set3 = new Set(
          (Array.isArray(cur?.items) ? cur.items : Array.isArray(cur) ? cur : []).map((p) => String(p?.id || "")).filter(Boolean)
        );
        return predicate(set3);
      } catch {
        return false;
      }
    };
    if (await snapshotMatches()) return true;
    return new Promise((resolve2) => {
      const deadline = Date.now() + timeoutMs;
      let unsub = null;
      let pendingUnsub = null;
      let stopped = false;
      const doUnsub = (fn) => {
        if (fn) {
          try {
            fn();
          } catch {
          }
        }
      };
      const stop2 = (ok) => {
        if (stopped) return;
        stopped = true;
        if (unsub) {
          doUnsub(unsub);
        } else if (pendingUnsub) {
          pendingUnsub.then((fn) => doUnsub(fn)).catch(() => {
          });
        }
        resolve2(ok);
      };
      const check = async (state3) => {
        const set3 = new Set(
          (Array.isArray(state3?.items) ? state3.items : Array.isArray(state3) ? state3 : []).map((p) => String(p?.id || "")).filter(Boolean)
        );
        if (predicate(set3)) {
          stop2(true);
        } else if (Date.now() >= deadline) {
          stop2(false);
        }
      };
      try {
        const res = Atoms.inventory.myInventory.onChange((state3) => {
          void check(state3);
        });
        if (typeof res === "function") {
          unsub = res;
        } else if (res && typeof res.then === "function") {
          pendingUnsub = res;
          pendingUnsub.then((fn) => {
            unsub = fn;
            if (stopped) {
              doUnsub(fn);
            }
          }).catch(() => {
          });
        }
      } catch {
        stop2(false);
        return;
      }
      void check();
      setTimeout(() => stop2(false), timeoutMs + 50);
    });
  }
  async function _waitForHutchState(predicate, timeoutMs = 4e3) {
    const snapshotMatches = async () => {
      try {
        const cur = await myPetHutchPetItems.get();
        const set3 = new Set(
          (Array.isArray(cur) ? cur : []).map((p) => String(p?.id || "")).filter(Boolean)
        );
        return predicate(set3);
      } catch {
        return false;
      }
    };
    if (await snapshotMatches()) return true;
    return new Promise((resolve2) => {
      const deadline = Date.now() + timeoutMs;
      let unsub = null;
      let pendingUnsub = null;
      let stopped = false;
      const doUnsub = (fn) => {
        if (fn) {
          try {
            fn();
          } catch {
          }
        }
      };
      const stop2 = (ok) => {
        if (stopped) return;
        stopped = true;
        if (unsub) {
          doUnsub(unsub);
        } else if (pendingUnsub) {
          pendingUnsub.then((fn) => doUnsub(fn)).catch(() => {
          });
        }
        resolve2(ok);
      };
      const check = async (state3) => {
        const set3 = new Set(
          (Array.isArray(state3) ? state3 : []).map((p) => String(p?.id || "")).filter(Boolean)
        );
        if (predicate(set3)) {
          stop2(true);
        } else if (Date.now() >= deadline) {
          stop2(false);
        }
      };
      try {
        const res = myPetHutchPetItems.onChange((state3) => {
          void check(state3);
        });
        if (typeof res === "function") {
          unsub = res;
        } else if (res && typeof res.then === "function") {
          pendingUnsub = res;
          pendingUnsub.then((fn) => {
            unsub = fn;
            if (stopped) {
              doUnsub(fn);
            }
          }).catch(() => {
          });
        }
      } catch {
        stop2(false);
        return;
      }
      void check();
      setTimeout(() => stop2(false), timeoutMs + 50);
    });
  }
  async function _equipPetIds(targetInvIdsRaw, opts) {
    const markId = (opts?.markTeamId ?? null) || null;
    const targetInvIds = (Array.isArray(targetInvIdsRaw) ? targetInvIdsRaw : []).map((v) => String(v || "")).filter((v) => v.length > 0).slice(0, 3);
    const markResolved = markId ?? _teamIdFromSlots(targetInvIds) ?? null;
    const shouldMark = opts?.markUsed !== false && !!markResolved;
    if (!targetInvIds.length) {
      if (shouldMark) markTeamAsUsed(markResolved);
      return { swapped: 0, placed: 0, skipped: 0 };
    }
    const targetSet = new Set(targetInvIds);
    let activeSlots = await _getActivePetSlotIds();
    const HUTCH_MAX = 25;
    let hutchCount = (() => {
      try {
        return Number(myNumPetHutchItems.get());
      } catch {
        return 0;
      }
    })();
    try {
      hutchCount = Number(await myNumPetHutchItems.get());
    } catch {
      hutchCount = 0;
    }
    let freeHutch = Math.max(0, HUTCH_MAX - (Number.isFinite(hutchCount) ? hutchCount : 0));
    let hutchItemsSet = /* @__PURE__ */ new Set();
    try {
      const hutchItems = await myPetHutchPetItems.get();
      if (Array.isArray(hutchItems)) {
        hutchItemsSet = new Set(hutchItems.map((it) => String(it?.id ?? "")));
      }
    } catch {
    }
    const missingFromActive = targetInvIds.filter((id) => !activeSlots.includes(id));
    const missingFromHutch = missingFromActive.filter((id) => hutchItemsSet.has(id));
    if (missingFromHutch.length > 0) {
      let invFull = false;
      try {
        invFull = !!await isMyInventoryAtMaxLength.get();
      } catch {
        invFull = false;
      }
      if (invFull && freeHutch <= 0) {
        try {
          await toastSimple("Inventory Full", "Cannot equip team: required pets are in the Pet Hutch and your inventory is full.");
        } catch {
        }
        if (shouldMark) markTeamAsUsed(markResolved);
        return { swapped: 0, placed: 0, skipped: targetInvIds.length };
      }
    }
    let swapped = 0, placed = 0, skipped = 0;
    for (const invId of targetInvIds) {
      const isAlreadyActive = activeSlots.includes(invId);
      if (isAlreadyActive) {
        skipped++;
        continue;
      }
      const livesInHutch = hutchItemsSet.has(invId);
      if (livesInHutch) {
        let invFull = false;
        try {
          invFull = !!await isMyInventoryAtMaxLength.get();
        } catch {
          invFull = false;
        }
        if (invFull) {
          if (freeHutch > 0) {
            try {
              const invPets = await PetsService.getInventoryPets();
              const invPet = (Array.isArray(invPets) ? invPets : []).find((p) => {
                const id = String(p?.id || "");
                return id && !hutchItemsSet.has(id) && !activeSlots.includes(id) && !targetSet.has(id);
              });
              if (invPet) {
                await PlayerService.putItemInStorage(invPet.id, "PetHutch");
                freeHutch = Math.max(0, freeHutch - 1);
                void _waitForHutchState((set3) => set3.has(String(invPet.id)), 3e3);
              } else {
                try {
                  await toastSimple("Inventory Full", "Cannot equip team: no free slot to retrieve a pet from the Pet Hutch.", "error");
                } catch {
                }
                if (shouldMark) markTeamAsUsed(markResolved);
                return { swapped, placed, skipped };
              }
            } catch {
              try {
                await toastSimple("Inventory Full", "Cannot equip team: failed to free up a slot.", "error");
              } catch {
              }
              if (shouldMark) markTeamAsUsed(markResolved);
              return { swapped, placed, skipped };
            }
          } else {
            try {
              await toastSimple("Inventory Full", "Cannot equip team: required pets are in the Pet Hutch and your inventory is full.", "error");
            } catch {
            }
            if (shouldMark) markTeamAsUsed(markResolved);
            return { swapped, placed, skipped };
          }
        }
        try {
          await PlayerService.retrieveItemFromStorage(invId, "PetHutch");
          hutchItemsSet.delete(invId);
          freeHutch = Math.min(25, freeHutch + 1);
        } catch {
          continue;
        }
        void _waitForHutchState((set3) => !set3.has(String(invId)), 3e3);
      }
      const offTargetActive = activeSlots.find((id) => !targetSet.has(id));
      if (offTargetActive) {
        try {
          await PlayerService.swapPet(offTargetActive, invId);
          swapped++;
          if (freeHutch > 0) {
            try {
              await PlayerService.putItemInStorage(offTargetActive, "PetHutch");
              freeHutch = Math.max(0, freeHutch - 1);
            } catch {
            }
            void _waitForHutchState((set3) => set3.has(String(offTargetActive)), 3e3);
          }
          activeSlots = activeSlots.filter((x) => x !== offTargetActive);
          activeSlots.push(invId);
        } catch {
          try {
            await PlayerService.placePet(invId, { x: 0, y: 0 }, "Boardwalk", 64);
            placed++;
            activeSlots.push(invId);
          } catch {
          }
        }
      } else {
        try {
          await PlayerService.placePet(invId, { x: 0, y: 0 }, "Boardwalk", 64);
          placed++;
          activeSlots.push(invId);
        } catch {
        }
      }
    }
    try {
      try {
        hutchCount = Number(await myNumPetHutchItems.get());
      } catch {
      }
      freeHutch = Math.max(0, HUTCH_MAX - (Number.isFinite(hutchCount) ? hutchCount : 0));
      const leftovers = activeSlots.filter((id) => !targetSet.has(id));
      for (const slotId of leftovers) {
        if (freeHutch <= 0) break;
        try {
          await PlayerService.storePet(slotId);
          await PlayerService.putItemInStorage(slotId, "PetHutch");
          freeHutch = Math.max(0, freeHutch - 1);
          activeSlots = activeSlots.filter((x) => x !== slotId);
          void _waitForHutchState((set3) => set3.has(String(slotId)), 3e3);
        } catch {
        }
      }
    } catch {
    }
    const res = await _applyTeam(targetInvIds);
    try {
      await _waitForActivePetsMatch(targetInvIds, 5e3);
    } catch {
    }
    try {
      await _waitForInventoryState((set3) => targetInvIds.every((id) => set3.has(id)), 3e3);
    } catch {
    }
    try {
      await _waitForHutchState((set3) => targetInvIds.every((id) => !set3.has(id)), 3e3);
    } catch {
    }
    if (shouldMark) markTeamAsUsed(markResolved);
    return res;
  }
  async function _applyTeam(targetInvIds) {
    let activeSlots = await _getActivePetSlotIds();
    const targetSet = new Set(targetInvIds);
    const extras = activeSlots.filter((id) => !targetSet.has(id));
    const mustStore = Math.max(0, activeSlots.length - targetInvIds.length);
    if (mustStore > 0) {
      const toStore = extras.slice(0, mustStore);
      for (const itemId of toStore) {
        try {
          await PlayerService.storePet(itemId);
          activeSlots = activeSlots.filter((id) => id !== itemId);
        } catch {
        }
      }
    }
    const alreadyActive = /* @__PURE__ */ new Set();
    for (const invId of targetInvIds) if (activeSlots.includes(invId)) alreadyActive.add(invId);
    let swapped = 0, placed = 0, skipped = 0;
    if (alreadyActive.size) {
      activeSlots = activeSlots.filter((slotId) => !alreadyActive.has(slotId));
      skipped = alreadyActive.size;
    }
    const toDo = targetInvIds.filter((id) => !alreadyActive.has(id));
    for (const invId of toDo) {
      const slotId = activeSlots.shift();
      try {
        if (slotId) {
          await PlayerService.swapPet(slotId, invId);
          swapped++;
        } else {
          await PlayerService.placePet(invId, { x: 0, y: 0 }, "Boardwalk", 64);
          placed++;
        }
      } catch {
      }
    }
    return { swapped, placed, skipped };
  }

  // src/services/shops.ts
  init_atoms();
  var SHOP_KEYBINDS = [
    { id: "shops.seeds", modal: "seedShop" },
    { id: "shops.eggs", modal: "eggShop" },
    { id: "shops.decors", modal: "decorShop" },
    { id: "shops.tools", modal: "toolShop" }
  ];
  var shopKeybindsInstalled = false;
  function installShopKeybindsOnce() {
    if (shopKeybindsInstalled || typeof window === "undefined") return;
    shopKeybindsInstalled = true;
    window.addEventListener(
      "keydown",
      (event) => {
        if (shouldIgnoreKeydown(event)) return;
        for (const { id, modal } of SHOP_KEYBINDS) {
          if (!eventMatchesKeybind(id, event)) continue;
          event.preventDefault();
          event.stopPropagation();
          void Atoms.ui.activeModal.set(modal);
          break;
        }
      },
      true
    );
  }
  var ShopsService = {
    buyOne(kind, it) {
      if (kind === "seeds") {
        const species = it.species ?? it.name;
        if (species) {
          try {
            sendToGame({ type: "PurchaseSeed", species });
            StatsService.incrementShopStat("seedsBought");
          } catch (err) {
          }
        }
        return;
      }
      if (kind === "tools") {
        const toolId = it.toolId ?? it.id;
        if (toolId) {
          try {
            sendToGame({ type: "PurchaseTool", toolId });
            StatsService.incrementShopStat("toolsBought");
          } catch (err) {
          }
        }
        return;
      }
      if (kind === "eggs") {
        const eggId = it.eggId ?? it.id;
        if (eggId) {
          try {
            sendToGame({ type: "PurchaseEgg", eggId });
            StatsService.incrementShopStat("eggsBought");
          } catch (err) {
          }
        }
        return;
      }
      if (kind === "decor") {
        const decorId = it.decorId ?? it.id;
        if (decorId) {
          try {
            sendToGame({ type: "PurchaseDecor", decorId });
            StatsService.incrementShopStat("decorBought");
          } catch (err) {
          }
        }
        return;
      }
    }
  };

  // src/utils/sellAllPets.ts
  init_atoms();
  init_jotai();

  // src/utils/inventoryValue.ts
  init_atoms();

  // src/utils/petCalcul.ts
  var SEC_PER_HOUR = 3600;
  var XP_STRENGTH_MAX = 30;
  var BASE_STRENGTH_FLOOR = 30;
  var getCatalogEntry = (species) => {
    if (!species) return null;
    const entry = petCatalog[species];
    return entry ?? null;
  };
  var getMutationEntry = (mutation) => {
    if (!mutation) return null;
    const entry = mutationCatalog[mutation];
    return entry ?? null;
  };
  var getTargetScale = (pet) => {
    const raw = pet?.targetScale;
    return typeof raw === "number" && Number.isFinite(raw) ? raw : 1;
  };
  var getXp = (pet) => {
    const raw = pet?.xp;
    return typeof raw === "number" && Number.isFinite(raw) ? Math.max(0, raw) : 0;
  };
  var getPetMaxStrength = (pet) => {
    const entry = getCatalogEntry(pet?.petSpecies ?? "");
    if (!entry) return 0;
    const maxScale = typeof entry.maxScale === "number" && entry.maxScale > 1 ? entry.maxScale : 1;
    const targetScale = getTargetScale(pet);
    const ratio = maxScale > 1 ? (targetScale - 1) / (maxScale - 1) : 0;
    const raw = ratio * 20 + 80;
    const strength = Math.floor(Number.isFinite(raw) ? raw : 0);
    return Math.max(strength, 0);
  };
  var getBaseStrength = (maxStrength) => {
    const base = maxStrength - BASE_STRENGTH_FLOOR;
    return Math.max(base, 0);
  };
  var getPetStrength = (pet) => {
    const entry = getCatalogEntry(pet?.petSpecies ?? "");
    if (!entry) return 0;
    const hoursToMature = typeof entry.hoursToMature === "number" && entry.hoursToMature > 0 ? entry.hoursToMature : 1;
    const maxStrength = getPetMaxStrength(pet);
    if (maxStrength <= 0) return 0;
    const xpRate = getXp(pet) / (hoursToMature * SEC_PER_HOUR);
    const xpComponent = Math.min(Math.floor(xpRate * XP_STRENGTH_MAX), XP_STRENGTH_MAX);
    const baseStrength = getBaseStrength(maxStrength);
    const strength = Math.min(baseStrength + xpComponent, maxStrength);
    return Math.max(strength, 0);
  };
  var getPetCoinMultiplier = (pet) => {
    const mutations = Array.isArray(pet?.mutations) ? pet.mutations : [];
    return mutations.reduce((acc, mutation) => {
      const entry = getMutationEntry(mutation);
      const multiplier = entry?.coinMultiplier;
      if (typeof multiplier === "number" && Number.isFinite(multiplier) && multiplier > 0) {
        return acc * multiplier;
      }
      return acc;
    }, 1);
  };
  var getPetValue = (pet) => {
    const entry = getCatalogEntry(pet?.petSpecies ?? "");
    if (!entry) return 0;
    const maturitySellPrice = typeof entry.maturitySellPrice === "number" ? entry.maturitySellPrice : 0;
    const maxStrength = getPetMaxStrength(pet);
    if (maxStrength <= 0) return 0;
    const strength = getPetStrength(pet);
    const targetScale = getTargetScale(pet);
    const coinMultiplier = getPetCoinMultiplier(pet);
    const raw = maturitySellPrice * (strength / maxStrength) * targetScale * coinMultiplier;
    if (!Number.isFinite(raw)) return 0;
    return Math.round(Math.max(raw, 0));
  };
  var getPetInfo = (pet) => ({
    value: getPetValue(pet),
    strength: getPetStrength(pet),
    maxStrength: getPetMaxStrength(pet),
    coinMultiplier: getPetCoinMultiplier(pet)
  });

  // src/utils/calculators.ts
  var key = (s) => String(s ?? "").trim();
  var lowerKey = (s) => key(s).toLowerCase();
  function resolveSpeciesKey(species) {
    const wanted = key(species).toLowerCase();
    if (!wanted) return null;
    for (const k of Object.keys(plantCatalog)) {
      if (k.toLowerCase() === wanted) return k;
    }
    return null;
  }
  function findAnySellPriceNode(obj) {
    if (!obj || typeof obj !== "object") return null;
    if (typeof obj.baseSellPrice === "number" && Number.isFinite(obj.baseSellPrice)) {
      return obj.baseSellPrice;
    }
    for (const k of ["produce", "crop", "item", "items", "data"]) {
      if (obj[k]) {
        const v = findAnySellPriceNode(obj[k]);
        if (v != null) return v;
      }
    }
    try {
      const seen = /* @__PURE__ */ new Set();
      const stack = [obj];
      while (stack.length) {
        const cur = stack.pop();
        if (!cur || typeof cur !== "object" || seen.has(cur)) continue;
        seen.add(cur);
        if (typeof cur.baseSellPrice === "number") {
          const v = cur.baseSellPrice;
          if (Number.isFinite(v)) return v;
        }
        for (const v of Object.values(cur)) if (v && typeof v === "object") stack.push(v);
      }
    } catch {
    }
    return null;
  }
  function defaultGetBasePrice(species) {
    const spKey = resolveSpeciesKey(species);
    if (!spKey) return null;
    const node = plantCatalog[spKey];
    const cands = [
      node?.produce?.baseSellPrice,
      node?.crop?.baseSellPrice,
      node?.item?.baseSellPrice,
      node?.items?.Produce?.baseSellPrice
    ].filter((v) => typeof v === "number" && Number.isFinite(v));
    if (cands.length) return cands[0];
    return findAnySellPriceNode(node);
  }
  function applyRounding(v, mode = "round") {
    switch (mode) {
      case "floor":
        return Math.floor(v);
      case "ceil":
        return Math.ceil(v);
      case "none":
        return v;
      case "round":
      default:
        return Math.round(v);
    }
  }
  function friendBonusMultiplier2(playersInRoom) {
    if (!Number.isFinite(playersInRoom)) return 1;
    const n = Math.max(1, Math.min(6, Math.floor(playersInRoom)));
    return 1 + (n - 1) * 0.1;
  }
  var MUTATION_MULTIPLIER_BY_KEY = (() => {
    const map2 = {};
    if (!mutationCatalog || typeof mutationCatalog !== "object") return map2;
    for (const [rawKey, rawValue] of Object.entries(mutationCatalog)) {
      const mult = Number(rawValue?.coinMultiplier);
      if (!Number.isFinite(mult)) continue;
      const name = key(rawValue?.name);
      const lowerName = lowerKey(name);
      const lowerRawKey = lowerKey(rawKey);
      if (lowerName) map2[lowerName] = mult;
      if (lowerRawKey) map2[lowerRawKey] = mult;
    }
    return map2;
  })();
  function mutationMultiplier(name) {
    const k = lowerKey(name);
    if (!k) return null;
    const mult = MUTATION_MULTIPLIER_BY_KEY[k];
    return Number.isFinite(mult) ? mult : null;
  }
  function isColor(m) {
    return m === "Gold" || m === "Rainbow";
  }
  function isWeather(m) {
    return m === "Wet" || m === "Chilled" || m === "Frozen" || m === "Thunderstruck";
  }
  function isTime(m) {
    return m === "Dawnlit" || m === "Dawnbound" || m === "Amberlit" || m === "Amberbound";
  }
  function normalizeMutationName(m) {
    const s = lowerKey(m);
    if (!s) return "";
    if (s === "amberglow" || s === "ambershine" || s === "amberlight") return "Amberlit";
    if (s === "dawn" || s === "dawnlight") return "Dawnlit";
    if (s === "golden") return "Gold";
    if (s === "gold") return "Gold";
    if (s === "rainbow") return "Rainbow";
    if (s === "wet") return "Wet";
    if (s === "chilled") return "Chilled";
    if (s === "frozen") return "Frozen";
    if (s === "thunderstruck" || s === "thunder") return "Thunderstruck";
    if (s === "thunderstruckground" || s === "thunderstruck_ground") return "Thunderstruck";
    if (s === "dawnlit") return "Dawnlit";
    if (s === "dawnbound") return "Dawnbound";
    if (s === "amberlit") return "Amberlit";
    if (s === "dawncharged" || s === "dawnradiant" || s === "dawn-radiant" || s === "dawn charged") return "Dawnbound";
    if (s === "amberbound" || s === "ambercharged" || s === "amberradiant" || s === "amber-radiant" || s === "amber charged") return "Amberbound";
    return m;
  }
  function computeColorMultiplier(mutations) {
    if (!Array.isArray(mutations)) return 1;
    let best = 1;
    for (const raw of mutations) {
      const m = normalizeMutationName(raw);
      if (isColor(m)) {
        const mult = mutationMultiplier(m);
        if (typeof mult === "number" && mult > best) best = mult;
      }
    }
    return best;
  }
  function pickWeather(mutations) {
    if (!Array.isArray(mutations)) return null;
    const candidates = /* @__PURE__ */ new Set();
    let hasWet = false;
    let hasChilled = false;
    for (const raw of mutations) {
      const m = normalizeMutationName(raw);
      if (m === "Wet") {
        hasWet = true;
        continue;
      }
      if (m === "Chilled") {
        hasChilled = true;
        continue;
      }
      if (isWeather(m)) candidates.add(m);
    }
    if (hasWet && hasChilled) {
      candidates.add("Frozen");
    } else if (hasWet) {
      candidates.add("Wet");
    } else if (hasChilled) {
      candidates.add("Chilled");
    }
    if (!candidates.size) return null;
    let pick = null;
    let best = -Infinity;
    for (const cand of candidates) {
      const mult = mutationMultiplier(cand) ?? 1;
      if (mult > best) {
        best = mult;
        pick = cand;
      }
    }
    return pick;
  }
  function pickTime(mutations) {
    if (!Array.isArray(mutations)) return null;
    const candidates = /* @__PURE__ */ new Set();
    for (const raw of mutations) {
      const m = normalizeMutationName(raw);
      if (isTime(m)) candidates.add(m);
    }
    if (!candidates.size) return null;
    let pick = null;
    let best = -Infinity;
    for (const cand of candidates) {
      const mult = mutationMultiplier(cand) ?? 1;
      if (mult > best) {
        best = mult;
        pick = cand;
      }
    }
    return pick;
  }
  function combineWeatherMultipliers(multipliers) {
    if (!multipliers.length) return 1;
    const sum = multipliers.reduce((acc, value) => acc + value, 0);
    return sum - multipliers.length + 1;
  }
  function computeWeatherTimeMultiplier(weather2, time) {
    if (!weather2 && !time) return 1;
    const multipliers = [];
    if (weather2) {
      const mult = mutationMultiplier(weather2);
      if (typeof mult === "number") multipliers.push(mult);
    }
    if (time) {
      const mult = mutationMultiplier(time);
      if (typeof mult === "number") multipliers.push(mult);
    }
    if (!multipliers.length) return 1;
    return combineWeatherMultipliers(multipliers);
  }
  function mutationsMultiplier(mutations) {
    const color = computeColorMultiplier(mutations);
    const weather2 = pickWeather(mutations);
    const time = pickTime(mutations);
    const wt = computeWeatherTimeMultiplier(weather2, time);
    return color * wt;
  }
  function estimateProduceValue(species, scale, mutations, opts) {
    const getBase = opts?.getBasePrice ?? defaultGetBasePrice;
    const sXform = opts?.scaleTransform ?? ((_, s) => s);
    const round = opts?.rounding ?? "round";
    const base = getBase(species);
    if (!(Number.isFinite(base) && base > 0)) return 0;
    const sc = Number(scale);
    if (!Number.isFinite(sc) || sc <= 0) return 0;
    const effScale = sXform(species, sc);
    if (!Number.isFinite(effScale) || effScale <= 0) return 0;
    const mutMult = mutationsMultiplier(mutations);
    const friendsMult = friendBonusMultiplier2(opts?.friendPlayers);
    const pre = base * effScale * mutMult * friendsMult;
    const out = Math.max(0, applyRounding(pre, round));
    return out;
  }
  function valueFromInventoryProduce(item, opts, playersInRoom) {
    if (!item || item.itemType !== "Produce") return 0;
    const merged = playersInRoom == null ? opts : { ...opts, friendPlayers: playersInRoom };
    return estimateProduceValue(item.species, item.scale, item.mutations, merged);
  }
  function valueFromGardenSlot(slot, opts, playersInRoom) {
    if (!slot) return 0;
    const merged = playersInRoom == null ? opts : { ...opts, friendPlayers: playersInRoom };
    return estimateProduceValue(slot.species, slot.targetScale, slot.mutations, merged);
  }
  function valueFromGardenPlant(plant, opts, playersInRoom) {
    if (!plant || plant.objectType !== "plant" || !Array.isArray(plant.slots)) return 0;
    const merged = playersInRoom == null ? opts : { ...opts, friendPlayers: playersInRoom };
    let sum = 0;
    for (const s of plant.slots) sum += valueFromGardenSlot(s, merged);
    return sum;
  }
  function sumInventoryValue(items, opts, playersInRoom) {
    if (!Array.isArray(items)) return 0;
    const merged = playersInRoom == null ? opts : { ...opts, friendPlayers: playersInRoom };
    let sum = 0;
    for (const it of items) {
      if (it?.itemType === "Produce") {
        sum += valueFromInventoryProduce(it, merged);
      }
    }
    return sum;
  }
  function sumGardenValue(garden2, opts, playersInRoom) {
    if (!garden2 || typeof garden2 !== "object") return 0;
    const merged = playersInRoom == null ? opts : { ...opts, friendPlayers: playersInRoom };
    let sum = 0;
    for (const k of Object.keys(garden2)) {
      const p = garden2[k];
      if (p?.objectType === "plant") {
        sum += valueFromGardenPlant(p, merged);
      }
    }
    return sum;
  }
  var DefaultPricing = Object.freeze({
    getBasePrice: defaultGetBasePrice,
    rounding: "round"
  });

  // src/utils/inventoryValue.ts
  var INVENTORY_VALUE_CATEGORIES = [
    {
      itemType: "Seed",
      identifierKey: "species",
      resolveCoinPrice: (identifier) => {
        if (!identifier) return null;
        const entry = plantCatalog[identifier];
        const price = entry?.seed?.coinPrice;
        return getFiniteNumber(price);
      },
      logKey: "seeds",
      emptyLogMessage: "[InventorySorting] Aucune seed trouv\xE9e dans l'inventaire pour le calcul de valeur.",
      createEntry: (identifier, quantity, coinPrice, value) => ({
        species: identifier,
        quantity,
        coinPrice,
        value
      })
    },
    {
      itemType: "Tool",
      identifierKey: "toolId",
      resolveCoinPrice: (identifier) => {
        if (!identifier) return null;
        const entry = toolCatalog[identifier];
        const price = entry?.coinPrice;
        return getFiniteNumber(price);
      },
      logKey: "tools",
      emptyLogMessage: "[InventorySorting] Aucun tool trouv\xE9 dans l'inventaire pour le calcul de valeur.",
      createEntry: (identifier, quantity, coinPrice, value) => ({
        toolId: identifier,
        quantity,
        coinPrice,
        value
      })
    },
    {
      itemType: "Egg",
      identifierKey: "eggId",
      resolveCoinPrice: (identifier) => {
        if (!identifier) return null;
        const entry = eggCatalog[identifier];
        const price = entry?.coinPrice;
        return getFiniteNumber(price);
      },
      logKey: "eggs",
      emptyLogMessage: "[InventorySorting] Aucun egg trouv\xE9 dans l'inventaire pour le calcul de valeur.",
      createEntry: (identifier, quantity, coinPrice, value) => ({
        eggId: identifier,
        quantity,
        coinPrice,
        value
      })
    },
    {
      itemType: "Decor",
      identifierKey: "decorId",
      resolveCoinPrice: (identifier) => {
        if (!identifier) return null;
        const entry = decorCatalog[identifier];
        const price = entry?.coinPrice;
        return getFiniteNumber(price);
      },
      logKey: "decors",
      emptyLogMessage: "[InventorySorting] Aucun decor trouv\xE9 dans l'inventaire pour le calcul de valeur.",
      createEntry: (identifier, quantity, coinPrice, value) => ({
        decorId: identifier,
        quantity,
        coinPrice,
        value
      })
    }
  ];
  var currentSnapshot = null;
  var watcherPromise = null;
  var unsubscribe = null;
  var computeCounter = 0;
  var listeners4 = /* @__PURE__ */ new Set();
  function getFiniteNumber(value) {
    if (typeof value === "number") {
      return Number.isFinite(value) ? value : null;
    }
    if (typeof value === "string" && value.trim()) {
      const parsed = Number(value);
      return Number.isFinite(parsed) ? parsed : null;
    }
    return null;
  }
  function extractItems(inventory) {
    if (!inventory || typeof inventory !== "object") return null;
    const items = inventory.items;
    if (!Array.isArray(items)) return [];
    return items;
  }
  function toNormalizedIdentifier(raw) {
    if (typeof raw === "string") {
      const trimmed = raw.trim();
      return trimmed ? trimmed : null;
    }
    if (typeof raw === "number") {
      return Number.isFinite(raw) ? String(raw) : null;
    }
    return null;
  }
  function getInventoryValueCategoryByItemType(itemType) {
    return INVENTORY_VALUE_CATEGORIES.find((config) => config.itemType === itemType);
  }
  function computeInventoryItemValue(item, context = {}) {
    if (!item || typeof item !== "object") return null;
    const rawType = typeof item?.itemType === "string" ? item.itemType.trim() : "";
    if (!rawType) return null;
    switch (rawType) {
      case "Pet": {
        const info = getPetInfo(item);
        const value = info.value;
        return typeof value === "number" && Number.isFinite(value) ? value : null;
      }
      case "Plant": {
        const slots = Array.isArray(item?.slots) ? item.slots : [];
        const playersInRoom = context.playersInRoom ?? void 0;
        let total = 0;
        for (const slot of slots) {
          const slotSpecies = typeof slot?.species === "string" ? slot.species : null;
          const rawTarget = slot?.targetScale;
          const target = Number.isFinite(rawTarget) ? rawTarget : Number(rawTarget);
          const targetScale = Number.isFinite(target) ? target : null;
          const mutations = Array.isArray(slot?.mutations) ? slot.mutations.filter((m) => typeof m === "string") : [];
          if (!slotSpecies || targetScale == null) continue;
          const value = estimateProduceValue(slotSpecies, targetScale, mutations, {
            friendPlayers: playersInRoom
          });
          if (typeof value === "number" && Number.isFinite(value)) {
            total += value;
          }
        }
        return total;
      }
      case "Produce": {
        const playersInRoom = context.playersInRoom ?? void 0;
        const value = valueFromInventoryProduce(item, void 0, playersInRoom);
        return typeof value === "number" && Number.isFinite(value) ? value : null;
      }
      default: {
        const category = getInventoryValueCategoryByItemType(rawType);
        if (!category) return null;
        const identifier = toNormalizedIdentifier(item?.[category.identifierKey]);
        const quantity = getFiniteNumber(item?.quantity);
        const coinPrice = category.resolveCoinPrice(identifier);
        if (quantity == null || coinPrice == null) return null;
        const value = coinPrice * quantity;
        return Number.isFinite(value) ? value : null;
      }
    }
  }
  function computePetValues(items) {
    const pets = items.filter((item) => {
      const type = typeof item?.itemType === "string" ? item.itemType.trim() : "";
      return type === "Pet";
    });
    const entries = pets.map((pet) => {
      const info = getPetInfo(pet);
      const id = typeof pet?.id === "string" ? pet.id : null;
      const name = typeof pet?.name === "string" && pet.name.trim() ? pet.name : null;
      const species = typeof pet?.petSpecies === "string" ? pet.petSpecies : null;
      return {
        id,
        name,
        petSpecies: species,
        value: info.value,
        strength: info.strength,
        maxStrength: info.maxStrength,
        coinMultiplier: info.coinMultiplier
      };
    });
    const totalValue = entries.reduce(
      (acc, entry) => acc + (Number.isFinite(entry.value) ? entry.value : 0),
      0
    );
    return { totalValue, pets: entries };
  }
  function computePlantValues(items, playersInRoom) {
    const plants = items.filter((item) => {
      const type = typeof item?.itemType === "string" ? item.itemType.trim() : "";
      return type === "Plant";
    });
    const entries = plants.map((plant) => {
      const id = typeof plant?.id === "string" ? plant.id : null;
      const species = typeof plant?.species === "string" ? plant.species : null;
      const plantedAt = Number.isFinite(plant?.plantedAt) ? plant.plantedAt : null;
      const maturedAt = Number.isFinite(plant?.maturedAt) ? plant.maturedAt : null;
      const slots = Array.isArray(plant?.slots) ? plant.slots : [];
      const slotEntries = slots.map((slot) => {
        const slotSpecies = typeof slot?.species === "string" ? slot.species : null;
        const targetScaleRaw = slot?.targetScale;
        const targetScale = Number.isFinite(targetScaleRaw) ? targetScaleRaw : Number(targetScaleRaw);
        const scaleValue = Number.isFinite(targetScale) ? targetScale : null;
        const mutations = Array.isArray(slot?.mutations) ? slot.mutations.filter((m) => typeof m === "string") : [];
        const value2 = slotSpecies && scaleValue != null ? estimateProduceValue(slotSpecies, scaleValue, mutations, {
          friendPlayers: playersInRoom
        }) : 0;
        return {
          species: slotSpecies,
          targetScale: scaleValue,
          mutations,
          value: value2
        };
      });
      const value = slotEntries.reduce(
        (acc, entry) => acc + (Number.isFinite(entry.value) ? entry.value : 0),
        0
      );
      return {
        id,
        species,
        plantedAt,
        maturedAt,
        value,
        slots: slotEntries
      };
    });
    const totalValue = entries.reduce(
      (acc, entry) => acc + (Number.isFinite(entry.value) ? entry.value : 0),
      0
    );
    return {
      totalValue,
      playersInRoom: Number.isFinite(playersInRoom) ? playersInRoom : null,
      plants: entries
    };
  }
  function computeCropValues(items, playersInRoom) {
    const crops = items.filter((item) => {
      const type = typeof item?.itemType === "string" ? item.itemType.trim() : "";
      return type === "Produce";
    });
    const entries = crops.map((crop) => {
      const id = typeof crop?.id === "string" ? crop.id : null;
      const species = typeof crop?.species === "string" ? crop.species : null;
      const rawScale = crop?.scale;
      const scale = Number.isFinite(rawScale) ? rawScale : Number(rawScale);
      const scaleValue = Number.isFinite(scale) ? scale : null;
      const mutations = Array.isArray(crop?.mutations) ? crop.mutations.filter((m) => typeof m === "string") : [];
      const value = valueFromInventoryProduce(crop, void 0, playersInRoom);
      return {
        id,
        species,
        scale: scaleValue,
        mutations,
        value
      };
    });
    const totalValue = entries.reduce(
      (acc, entry) => acc + (Number.isFinite(entry.value) ? entry.value : 0),
      0
    );
    return { totalValue, crops: entries };
  }
  function computeMiscValues(items) {
    const aggregated = {
      seeds: { totalValue: 0, items: [] },
      tools: { totalValue: 0, items: [] },
      eggs: { totalValue: 0, items: [] },
      decors: { totalValue: 0, items: [] }
    };
    for (const config of INVENTORY_VALUE_CATEGORIES) {
      const filteredItems = items.filter((item) => {
        const type = typeof item?.itemType === "string" ? item.itemType.trim() : "";
        return type === config.itemType;
      });
      const entries = filteredItems.map((item) => {
        const rawIdentifier = item?.[config.identifierKey];
        const identifier = toNormalizedIdentifier(rawIdentifier);
        const rawQuantity = item?.quantity;
        const quantity = getFiniteNumber(rawQuantity);
        const coinPrice = config.resolveCoinPrice(identifier);
        const value = quantity != null && coinPrice != null ? coinPrice * quantity : null;
        return config.createEntry(identifier, quantity, coinPrice, value);
      });
      const totalValue = entries.reduce((acc, entry) => {
        const entryValue = entry.value;
        return typeof entryValue === "number" && Number.isFinite(entryValue) ? acc + entryValue : acc;
      }, 0);
      aggregated[config.logKey] = { totalValue, items: entries };
    }
    return aggregated;
  }
  async function resolvePlayersInRoom() {
    try {
      const rawPlayers = await Atoms.server.numPlayers.get();
      return Number.isFinite(rawPlayers) ? rawPlayers : void 0;
    } catch {
      return void 0;
    }
  }
  async function computeSnapshotFromInventory(inventory) {
    const items = extractItems(inventory);
    if (items === null) return null;
    const safeItems = items ?? [];
    const playersInRoom = await resolvePlayersInRoom();
    return {
      pets: computePetValues(safeItems),
      plants: computePlantValues(safeItems, playersInRoom),
      crops: computeCropValues(safeItems, playersInRoom),
      misc: computeMiscValues(safeItems)
    };
  }
  function notifyListeners(snapshot) {
    for (const listener of listeners4) {
      try {
        listener(snapshot);
      } catch (error) {
        console.warn("[InventoryValue] Listener error", error);
      }
    }
  }
  async function refreshSnapshot(nextInventory) {
    const computeId = ++computeCounter;
    try {
      const snapshot = await computeSnapshotFromInventory(nextInventory);
      if (computeId !== computeCounter) return;
      currentSnapshot = snapshot;
      notifyListeners(currentSnapshot);
    } catch (error) {
      if (computeId !== computeCounter) return;
      currentSnapshot = null;
      console.warn("[InventoryValue] Impossible de calculer la valeur de l'inventaire", error);
    }
  }
  async function ensureInventoryValueWatcher() {
    if (watcherPromise) return watcherPromise;
    watcherPromise = (async () => {
      try {
        const inventory = await Atoms.inventory.myInventory.get();
        await refreshSnapshot(inventory);
      } catch (error) {
        currentSnapshot = null;
        console.warn("[InventoryValue] Impossible de r\xE9cup\xE9rer l'inventaire initial", error);
      }
      try {
        unsubscribe = await Atoms.inventory.myInventory.onChange((next) => {
          void refreshSnapshot(next);
        });
      } catch (error) {
        console.warn("[InventoryValue] Impossible de s'abonner \xE0 myInventory", error);
      }
    })();
    return watcherPromise;
  }
  function getInventoryValueSnapshot() {
    return currentSnapshot;
  }
  function onInventoryValueChange(listener) {
    listeners4.add(listener);
    return () => {
      listeners4.delete(listener);
    };
  }

  // src/utils/sellAllPets.ts
  var SELL_ALL_PETS_EVENT = "sell-all-pets:list";
  var SELL_ALL_PETS_DRY_RUN = false;
  var SELL_ALL_PETS_CONFIRM_MODAL_ID = "tm-sellallpets-confirm";
  var DEFAULT_THEME = {
    text: "var(--chakra-colors-Neutral-TrueWhite, #FFFFFF)",
    bg: "var(--chakra-colors-Blue-Magic, #0067B4)",
    border: "var(--chakra-colors-Blue-Light, #48ADF4)",
    hoverBg: "var(--chakra-colors-Blue-Light, #48ADF4)",
    hoverBorder: "var(--chakra-colors-Blue-Baby, #25AAE2)",
    activeBg: "var(--chakra-colors-Blue-Dark, #264093)",
    ring: "var(--chakra-ring-color, rgba(66,153,225,0.6))"
  };
  var DEFAULTS = {
    rootSelector: ".McFlex.css-wqzc3n",
    // gate inchang : bloc qui contient le bouton
    checkSelector: ".McFlex.css-bvyqr8",
    // nouveau bouton "Sell Pet"
    buttonSelectorWide: "button.chakra-button.css-o7uz17, button.chakra-button, button.css-o7uz17",
    buttonSelectorStrict: "button.chakra-button.css-o7uz17",
    targetText: "Sell Pet",
    // Back-compat only
    injectText: "Sell all Pets",
    injectedClass: "tm-injected-sell-all",
    styleId: "tm-injected-sell-all-style"
  };
  function startInjectSellAllPets(options = {}) {
    if (!isBrowser()) return noSSRController();
    const ROOT_SEL = options.rootSelector ?? DEFAULTS.rootSelector;
    const CHECK_SEL = options.checkSelector ?? DEFAULTS.checkSelector;
    const BTN_WIDE = options.buttonSelectorWide ?? DEFAULTS.buttonSelectorWide;
    const BTN_STRICT = options.buttonSelectorStrict ?? DEFAULTS.buttonSelectorStrict;
    const BTN_TEXT = options.targetText ?? DEFAULTS.targetText;
    const INJ_TEXT = options.injectText ?? DEFAULTS.injectText;
    const INJ_CLASS = options.injectedClass ?? DEFAULTS.injectedClass;
    const THEME = options.theme ?? DEFAULT_THEME;
    const OBS_HIST = options.observeHistory ?? true;
    const logger = typeof options.log === "function" ? options.log : options.log ? (...a) => console.debug("[injectSellAllPets]", ...a) : () => {
    };
    const HANDLE = options.onClick ?? createDefaultClickHandler(logger);
    ensureStyle(INJ_CLASS, THEME);
    let running = true;
    let pending = false;
    const processAll = () => {
      if (!running || pending) return;
      pending = true;
      requestAnimationFrame(() => {
        try {
          document.querySelectorAll(ROOT_SEL).forEach((root) => processRoot(root));
        } finally {
          pending = false;
        }
      });
    };
    function processRoot(root) {
      const gate = root.querySelector(CHECK_SEL);
      if (!gate) {
        cleanup(root, INJ_CLASS);
        return;
      }
      const target = findTargetButton(root, BTN_WIDE, BTN_STRICT, BTN_TEXT);
      if (!target) {
        cleanup(root, INJ_CLASS);
        return;
      }
      ensureInjectedNextTo(target, INJ_CLASS, INJ_TEXT, (ev, ctx2) => {
        safeInvokeClick(HANDLE, ev, ctx2, logger);
      });
    }
    const mo = new MutationObserver(processAll);
    mo.observe(document.documentElement, { childList: true, subtree: true });
    processAll();
    let unhookHistory = null;
    if (OBS_HIST) {
      unhookHistory = hookHistory(processAll);
    }
    return {
      stop() {
        if (!running) return;
        running = false;
        mo.disconnect();
        unhookHistory?.();
        logger("stopped");
      },
      runOnce() {
        processAll();
      },
      isRunning() {
        return running;
      }
    };
  }
  async function runSellAllPetsFlow(logger = () => {
  }) {
    try {
      logger("sell-all-pets:log-items");
    } catch {
    }
    await PlayerService.logItems();
    const pets = await runDefaultSellAllPetsAction(logger);
    if (pets.length === 0) return;
    await sellPetsFromInventory(pets, logger);
  }
  async function getUnfavoritedInventoryPets() {
    try {
      await ensureStore();
    } catch {
    }
    const [inventory, favoriteIds2] = await Promise.all([
      Atoms.inventory.myInventory.get().catch(() => null),
      Atoms.inventory.favoriteIds.get().catch(() => [])
    ]);
    const favSet = new Set(
      Array.isArray(favoriteIds2) ? favoriteIds2.filter((id) => typeof id === "string") : []
    );
    const items = Array.isArray(inventory?.items) ? inventory.items : [];
    const availablePets = [];
    items.forEach((item, index) => {
      if (!isInventoryPetItem(item)) return;
      if (favSet.has(item.id)) return;
      console.log("[sellAllPets] inventory index", index, item);
      availablePets.push({ ...item, inventoryIndex: index });
    });
    return availablePets;
  }
  function createDefaultClickHandler(logger) {
    return async () => {
      try {
        logger("sell-all-pets:click");
      } catch {
      }
      await runSellAllPetsFlow(logger);
    };
  }
  async function runDefaultSellAllPetsAction(logger) {
    const pets = await getUnfavoritedInventoryPets();
    const detail = { pets, count: pets.length };
    globalThis.__sellAllPetsCandidates = pets;
    try {
      logger("collected-non-favorite-pets", detail);
    } catch {
    }
    try {
      globalThis.dispatchEvent?.(
        new CustomEvent(SELL_ALL_PETS_EVENT, { detail })
      );
    } catch {
    }
    return pets;
  }
  async function sellPetsFromInventory(pets, logger) {
    const toSell = pets.filter((pet) => typeof pet?.id === "string" && pet.id.trim().length > 0);
    if (toSell.length === 0) {
      try {
        logger("no-sellable-pets", { requested: pets.length });
      } catch {
      }
      try {
        globalThis.__sellAllPetsResult = { attempted: 0, sold: 0, failures: [] };
      } catch {
      }
      return;
    }
    if (!await confirmHighValuePetSale(toSell, logger)) {
      try {
        logger("sell-pets:cancelled");
      } catch {
      }
      try {
        toastSimple("Sell all Pets", "Sale cancelled.", "info");
      } catch {
      }
      return;
    }
    const failures = [];
    let sold = 0;
    const totalValue = computeTotalPetSellValueFromInventory(toSell);
    try {
      logger("sell-pets:total-value", { attempted: toSell.length, totalValue });
    } catch {
    }
    if (SELL_ALL_PETS_DRY_RUN) {
      try {
        logger("sell-pets:dry-run", { attempted: toSell.length, totalValue });
      } catch {
      }
      try {
        toastSimple("Sell all Pets", `Dry run: ${toSell.length} pets detected (no sale).`, "info");
      } catch {
      }
      try {
        globalThis.__sellAllPetsResult = { attempted: toSell.length, sold: 0, failures: [] };
      } catch {
      }
      return;
    }
    for (const pet of toSell) {
      try {
        logger("sell-pet:start", { id: pet.id, pet });
      } catch {
      }
      try {
        await PlayerService.sellPet(pet.id);
        sold += 1;
        StatsService.incrementShopStat("petsSoldCount");
        void (async () => {
          try {
            const total = await Atoms.pets.totalPetSellPrice.get();
            const value = Number(total);
            if (Number.isFinite(value) && value > 0) {
              StatsService.incrementShopStat("petsSoldValue", value);
            }
          } catch (error) {
            console.error("[SellPet] Unable to read pet sell price", error);
          }
        })();
        try {
          logger("sell-pet:success", { id: pet.id, pet });
        } catch {
        }
      } catch (error) {
        failures.push({ pet, error });
        try {
          logger("sell-pet:error", { id: pet.id, error, pet });
        } catch {
        }
      }
    }
    if (failures.length === 0) {
      toastSimple("Sell all Pets", `${sold} pets have been sold for ${totalValue} coins!`, "success");
    }
    try {
      globalThis.__sellAllPetsResult = { attempted: toSell.length, sold, failures };
    } catch {
    }
    audioPlayer.playSellNotification();
    try {
      logger("sell-pets:complete", { attempted: toSell.length, sold, failures });
    } catch {
    }
  }
  function computeTotalPetSellValueFromInventory(pets) {
    if (!pets.length) return "";
    let total = 0;
    for (const pet of pets) {
      const value = computeInventoryItemValue(pet);
      if (typeof value === "number" && Number.isFinite(value)) {
        total += value;
      }
    }
    return total.toLocaleString("en-US");
  }
  async function confirmHighValuePetSale(pets, logger) {
    const rules = lockerRestrictionsService.getSellAllPetsRules();
    if (!rules?.enabled) return true;
    const mutationProtect = /* @__PURE__ */ new Set();
    if (rules.protectGold) mutationProtect.add("gold");
    if (rules.protectRainbow) mutationProtect.add("rainbow");
    const maxStrThreshold = Number.isFinite(rules.maxStrThreshold) ? Math.max(0, Math.min(100, Math.round(rules.maxStrThreshold))) : 0;
    const checkMaxStr = !!rules.protectMaxStr;
    if (mutationProtect.size === 0 && !checkMaxStr) return true;
    const flagged = [];
    for (const pet of pets) {
      const rawMutations = Array.isArray(pet?.mutations) ? pet.mutations : [];
      const mutations = rawMutations.filter((m) => typeof m === "string");
      const foundMutations = mutationProtect.size ? mutations.map((m) => m.toLowerCase()).filter((m) => mutationProtect.has(m)).map((m) => m === "gold" ? "Gold" : "Rainbow") : [];
      const hasMutation = foundMutations.length > 0;
      const maxStrength = getPetInfo(pet)?.maxStrength;
      const strongEnough = checkMaxStr && typeof maxStrength === "number" && Number.isFinite(maxStrength) ? maxStrength >= maxStrThreshold : false;
      if (!hasMutation && !strongEnough) continue;
      const reasons = [];
      if (hasMutation) {
        for (const mut of Array.from(new Set(foundMutations))) {
          reasons.push(`Mutation: ${mut}`);
        }
      }
      if (strongEnough) {
        reasons.push(`Max STR: ${Math.floor(maxStrength ?? 0)}`);
      }
      flagged.push({
        pet,
        reasons,
        maxStrength: typeof maxStrength === "number" && Number.isFinite(maxStrength) ? maxStrength : null,
        mutations
      });
    }
    if (flagged.length === 0) return true;
    if (!isBrowser()) {
      try {
        logger("sell-pets:confirm-unavailable", { flagged: flagged.length });
      } catch {
      }
      return false;
    }
    const confirmed = await showSellAllPetsConfirmModal(flagged);
    if (!confirmed) {
      try {
        logger("sell-pets:confirm-cancelled", { flagged: flagged.length });
      } catch {
      }
    }
    return confirmed;
  }
  function showSellAllPetsConfirmModal(flagged) {
    return new Promise((resolve2) => {
      if (!isBrowser()) {
        resolve2(false);
        return;
      }
      const existing = document.getElementById(SELL_ALL_PETS_CONFIRM_MODAL_ID);
      if (existing) existing.remove();
      const overlay = document.createElement("div");
      overlay.id = SELL_ALL_PETS_CONFIRM_MODAL_ID;
      overlay.style.position = "fixed";
      overlay.style.inset = "0";
      overlay.style.zIndex = "2147483647";
      overlay.style.display = "flex";
      overlay.style.alignItems = "center";
      overlay.style.justifyContent = "center";
      overlay.style.background = "rgba(0,0,0,0.6)";
      const box = document.createElement("div");
      box.style.minWidth = "320px";
      box.style.maxWidth = "520px";
      box.style.background = "#0f1318";
      box.style.color = "#ffffff";
      box.style.border = "1px solid rgba(255,255,255,0.15)";
      box.style.borderRadius = "14px";
      box.style.boxShadow = "0 12px 40px rgba(0,0,0,0.45)";
      box.style.padding = "18px 20px";
      box.style.display = "grid";
      box.style.gap = "12px";
      box.style.fontFamily = "system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";
      const title = document.createElement("div");
      title.textContent = "Confirm sell all pets";
      title.style.fontSize = "18px";
      title.style.fontWeight = "800";
      const body = document.createElement("div");
      body.textContent = "The following pets match protected rules:";
      body.style.opacity = "0.9";
      body.style.fontSize = "13px";
      body.style.lineHeight = "1.4";
      const list = document.createElement("div");
      list.style.display = "grid";
      list.style.gap = "8px";
      list.style.maxHeight = "260px";
      list.style.overflow = "auto";
      list.style.paddingRight = "4px";
      const buildPetRow = (entry) => {
        const row = document.createElement("div");
        row.style.display = "grid";
        row.style.gridTemplateColumns = "48px 1fr";
        row.style.gap = "10px";
        row.style.alignItems = "center";
        row.style.padding = "6px 8px";
        row.style.border = "1px solid rgba(255,255,255,0.08)";
        row.style.borderRadius = "10px";
        row.style.background = "rgba(255,255,255,0.03)";
        const imgWrap = document.createElement("div");
        imgWrap.style.width = "48px";
        imgWrap.style.height = "48px";
        imgWrap.style.borderRadius = "10px";
        imgWrap.style.background = "rgba(255,255,255,0.08)";
        imgWrap.style.display = "flex";
        imgWrap.style.alignItems = "center";
        imgWrap.style.justifyContent = "center";
        imgWrap.style.overflow = "hidden";
        const label2 = entry.pet.petSpecies || entry.pet.name || "Pet";
        const fallback = document.createElement("div");
        fallback.textContent = String(label2).slice(0, 2).toUpperCase();
        fallback.style.fontSize = "12px";
        fallback.style.fontWeight = "700";
        imgWrap.appendChild(fallback);
        const species = String(entry.pet.petSpecies || "").trim();
        const mutations = Array.isArray(entry.mutations) ? entry.mutations.map((m) => String(m ?? "").trim()).filter(Boolean) : [];
        if (species) {
          attachSpriteIcon(
            imgWrap,
            ["pet"],
            [species, entry.pet.name || ""],
            48,
            "sell-all-pets-confirm",
            {
              mutations
            }
          );
        }
        const info = document.createElement("div");
        info.style.display = "grid";
        info.style.gap = "4px";
        const name = document.createElement("div");
        name.textContent = entry.pet.name ? `${entry.pet.name} (${entry.pet.petSpecies ?? "Pet"})` : entry.pet.petSpecies ?? "Pet";
        name.style.fontWeight = "700";
        name.style.fontSize = "13px";
        const reasons = document.createElement("div");
        reasons.style.display = "flex";
        reasons.style.flexWrap = "wrap";
        reasons.style.gap = "6px";
        for (const reason of entry.reasons) {
          const chip = document.createElement("div");
          chip.textContent = reason;
          chip.style.fontSize = "11px";
          chip.style.padding = "2px 6px";
          chip.style.borderRadius = "999px";
          chip.style.background = "rgba(122,162,255,0.2)";
          chip.style.border = "1px solid rgba(122,162,255,0.4)";
          chip.style.color = "#dbe7ff";
          reasons.appendChild(chip);
        }
        info.append(name, reasons);
        row.append(imgWrap, info);
        return row;
      };
      for (const entry of flagged) {
        list.appendChild(buildPetRow(entry));
      }
      const actions = document.createElement("div");
      actions.style.display = "flex";
      actions.style.justifyContent = "flex-end";
      actions.style.gap = "8px";
      const btnCancel = document.createElement("button");
      btnCancel.type = "button";
      btnCancel.textContent = "Cancel";
      btnCancel.style.padding = "8px 12px";
      btnCancel.style.borderRadius = "10px";
      btnCancel.style.border = "1px solid rgba(255,255,255,0.2)";
      btnCancel.style.background = "transparent";
      btnCancel.style.color = "#ffffff";
      btnCancel.style.cursor = "pointer";
      const btnConfirm = document.createElement("button");
      btnConfirm.type = "button";
      btnConfirm.textContent = "Sell";
      btnConfirm.style.padding = "8px 14px";
      btnConfirm.style.borderRadius = "10px";
      btnConfirm.style.border = "1px solid rgba(122,162,255,0.7)";
      btnConfirm.style.background = "#1a2644";
      btnConfirm.style.color = "#ffffff";
      btnConfirm.style.cursor = "pointer";
      btnConfirm.style.fontWeight = "700";
      let settled = false;
      const close = (value) => {
        if (settled) return;
        settled = true;
        overlay.remove();
        document.removeEventListener("keydown", onKeyDown, true);
        resolve2(value);
      };
      const onKeyDown = (ev) => {
        if (ev.key === "Escape") {
          ev.preventDefault();
          close(false);
        }
      };
      btnCancel.addEventListener("click", () => close(false));
      btnConfirm.addEventListener("click", () => close(true));
      overlay.addEventListener("click", (ev) => {
        if (ev.target === overlay) close(false);
      });
      actions.append(btnCancel, btnConfirm);
      box.append(title, body, list, actions);
      overlay.appendChild(box);
      document.body.appendChild(overlay);
      document.addEventListener("keydown", onKeyDown, true);
      btnConfirm.focus();
    });
  }
  function safeInvokeClick(handler, ev, ctx2, logger) {
    try {
      const result = handler(ev, ctx2);
      if (isPromiseLike(result)) {
        result.catch((err) => logClickError(err, logger));
      }
    } catch (err) {
      logClickError(err, logger);
    }
  }
  function logClickError(error, logger) {
    try {
      logger("sell-all-click-error", error);
    } catch {
    }
  }
  function isPromiseLike(value) {
    return !!value && (typeof value === "object" || typeof value === "function") && typeof value.then === "function";
  }
  function isInventoryPetItem(item) {
    return !!item && item.itemType === "Pet" && typeof item.id === "string";
  }
  function isBrowser() {
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function noSSRController() {
    return { stop() {
    }, runOnce() {
    }, isRunning: () => false };
  }
  function norm(s) {
    return (s ?? "").replace(/\s+/g, " ").trim();
  }
  function getLabel(el2) {
    const t = norm(el2.textContent);
    if (t) return t;
    const a = norm(el2.getAttribute("aria-label"));
    return a;
  }
  function getWords(label2) {
    return label2.trim().split(/\s+/).filter(Boolean);
  }
  function isSellTwoWordLabel(label2) {
    const words = getWords(label2);
    return words.length === 2 && /^sell$/i.test(words[0]);
  }
  function findTargetButton(scope, btnWide, btnStrict, _btnText) {
    const all = Array.from(/* @__PURE__ */ new Set([
      ...Array.from(scope.querySelectorAll(btnWide)),
      ...Array.from(scope.querySelectorAll(btnStrict))
    ])).filter((b) => b instanceof HTMLButtonElement).filter((b) => !b.classList.contains(DEFAULTS.injectedClass));
    const target = all.find((b) => {
      const label2 = getLabel(b);
      if (/crops/i.test(label2)) return false;
      return isSellTwoWordLabel(label2);
    });
    return target ?? null;
  }
  function ensureInjectedNextTo(targetBtn, injectedClass, injectedText, onClick) {
    const parent = targetBtn.parentElement || targetBtn.closest(".McFlex, .css-0") || targetBtn.parentNode;
    if (!parent) return;
    let injected = parent.querySelector(`.${injectedClass}`);
    if (injected) {
      if (targetBtn.nextElementSibling !== injected) {
        parent.insertBefore(injected, targetBtn.nextSibling);
      }
      if (injected.textContent !== injectedText) injected.textContent = injectedText;
      return;
    }
    injected = document.createElement("button");
    injected.type = "button";
    injected.className = `${injectedClass} chakra-button`;
    injected.textContent = injectedText;
    injected.setAttribute("aria-label", injectedText);
    injected.title = injectedText;
    injected.style.marginLeft = "8px";
    const cs = getComputedStyle(parent);
    if (cs.display !== "flex") {
      injected.style.display = "inline-flex";
      injected.style.alignItems = "center";
    }
    injected.addEventListener("click", (ev) => onClick(ev, {
      host: targetBtn.closest(".McFlex.css-1wu1jyg"),
      targetBtn,
      injectedBtn: injected
    }));
    parent.insertBefore(injected, targetBtn.nextSibling);
  }
  function cleanup(root, injectedClass) {
    root.querySelectorAll(`.${injectedClass}`).forEach((n) => n.remove());
  }
  function ensureStyle(injectedClass, theme) {
    const STYLE_ID6 = `${injectedClass}-style`;
    if (document.getElementById(STYLE_ID6)) return;
    const css3 = `
.${injectedClass}{
  font-synthesis: none;
  -webkit-font-smoothing: antialiased;
  -webkit-text-size-adjust: 100%;
  cursor: pointer;
  display: inline-flex;
  appearance: none;
  align-items: center;
  justify-content: center;
  user-select: none;
  white-space: nowrap;
  vertical-align: middle;

  outline: transparent solid 2px;
  outline-offset: 2px;
  line-height: 1.2;

  border-radius: 15px;                        /* aligns with provided design */
  font-weight: 700;
  height: auto;
  min-width: var(--chakra-sizes-10, 2.5rem);
  box-shadow: rgba(0, 0, 0, 0.3) 0px 4px 12px;
  transform: translateY(0px);
  transition: 0.2s;

  border: 2px solid ${theme.border};
  color: ${theme.text};
  background: ${theme.bg};

  text-transform: none;
  overflow: hidden;
  font-size: 20px;
  padding-inline-start: var(--chakra-space-4, 1rem);
  padding-inline-end: var(--chakra-space-4, 1rem);
  padding-top: var(--chakra-space-3, 0.75rem);
  padding-bottom: var(--chakra-space-3, 0.75rem);

  -webkit-tap-highlight-color: transparent;
}
.${injectedClass}:hover{
  transform: translateY(-1px);
  background: ${theme.hoverBg};
  border-color: ${theme.hoverBorder};
}
.${injectedClass}:active{
  transform: translateY(1px);
  background: ${theme.activeBg};
}
.${injectedClass}:focus-visible{
  box-shadow: 0 0 0 3px ${theme.ring};
}
`.trim();
    const s = document.createElement("style");
    s.id = STYLE_ID6;
    s.textContent = css3;
    document.head.appendChild(s);
  }
  function hookHistory(onNavigate) {
    const p = history.pushState?.bind(history);
    const r = history.replaceState?.bind(history);
    const wrap = (fn) => fn ? function(...args) {
      const ret = fn.apply(this, args);
      onNavigate();
      return ret;
    } : fn;
    if (p) history.pushState = wrap(p);
    if (r) history.replaceState = wrap(r);
    const onPop = () => onNavigate();
    window.addEventListener("popstate", onPop);
    return () => {
      if (p) history.pushState = p;
      if (r) history.replaceState = r;
      window.removeEventListener("popstate", onPop);
    };
  }

  // src/services/sell.ts
  var sellKeybindsInstalled = false;
  function installSellKeybindsOnce() {
    if (sellKeybindsInstalled || typeof window === "undefined") return;
    sellKeybindsInstalled = true;
    window.addEventListener(
      "keydown",
      (event) => {
        if (shouldIgnoreKeydown(event)) return;
        if (eventMatchesKeybind("sell.sell-all", event)) {
          event.preventDefault();
          event.stopPropagation();
          void PlayerService.sellAllCrops();
          return;
        }
        if (eventMatchesKeybind("sell.sell-all-pets", event)) {
          event.preventDefault();
          event.stopPropagation();
          void runSellAllPetsFlow();
        }
      },
      true
    );
  }

  // src/services/petHutchKeybind.ts
  init_atoms();
  var ACTION_ID = "game.pet-hutch";
  var PET_HUTCH_MODAL_ID = "petHutch";
  var petHutchKeybindsInstalled = false;
  async function togglePetHutchModal() {
    try {
      const current = await Atoms.ui.activeModal.get();
      const next = current === PET_HUTCH_MODAL_ID ? null : PET_HUTCH_MODAL_ID;
      await Atoms.ui.activeModal.set(next);
    } catch {
    }
  }
  function installPetHutchKeybindsOnce() {
    if (petHutchKeybindsInstalled || typeof window === "undefined") return;
    petHutchKeybindsInstalled = true;
    window.addEventListener(
      "keydown",
      (event) => {
        if (shouldIgnoreKeydown(event)) return;
        if (!eventMatchesKeybind(ACTION_ID, event)) return;
        event.preventDefault();
        event.stopPropagation();
        void togglePetHutchModal();
      },
      true
    );
  }

  // src/services/journalKeybind.ts
  init_atoms();
  init_fakeModal();
  var ACTION_ID2 = "game.journal";
  var journalKeybindsInstalled = false;
  async function toggleJournalModal() {
    try {
      const current = await Atoms.ui.activeModal.get();
      const next = current === JOURNAL_MODAL_ID ? null : JOURNAL_MODAL_ID;
      await Atoms.ui.activeModal.set(next);
    } catch {
    }
  }
  function installJournalKeybindsOnce() {
    if (journalKeybindsInstalled || typeof window === "undefined") return;
    journalKeybindsInstalled = true;
    window.addEventListener(
      "keydown",
      (event) => {
        if (shouldIgnoreKeydown(event)) return;
        if (!eventMatchesKeybind(ACTION_ID2, event)) return;
        event.preventDefault();
        event.stopPropagation();
        void toggleJournalModal();
      },
      true
    );
  }

  // src/services/decorShedKeybind.ts
  init_atoms();
  var ACTION_ID3 = "game.decor-shed";
  var DECOR_SHED_MODAL_ID = "decorShed";
  var decorShedKeybindsInstalled = false;
  async function toggleDecorShedModal() {
    try {
      const current = await Atoms.ui.activeModal.get();
      const next = current === DECOR_SHED_MODAL_ID ? null : DECOR_SHED_MODAL_ID;
      await Atoms.ui.activeModal.set(next);
    } catch {
    }
  }
  function installDecorShedKeybindsOnce() {
    if (decorShedKeybindsInstalled || typeof window === "undefined") return;
    decorShedKeybindsInstalled = true;
    window.addEventListener(
      "keydown",
      (event) => {
        if (shouldIgnoreKeydown(event)) return;
        if (!eventMatchesKeybind(ACTION_ID3, event)) return;
        event.preventDefault();
        event.stopPropagation();
        void toggleDecorShedModal();
      },
      true
    );
  }

  // src/services/seedSiloKeybind.ts
  init_atoms();
  var ACTION_ID4 = "game.seed-silo";
  var SEED_SILO_MODAL_ID = "seedSilo";
  var seedSiloKeybindsInstalled = false;
  async function toggleSeedSiloModal() {
    try {
      const current = await Atoms.ui.activeModal.get();
      const next = current === SEED_SILO_MODAL_ID ? null : SEED_SILO_MODAL_ID;
      await Atoms.ui.activeModal.set(next);
    } catch {
    }
  }
  function installSeedSiloKeybindsOnce() {
    if (seedSiloKeybindsInstalled || typeof window === "undefined") return;
    seedSiloKeybindsInstalled = true;
    window.addEventListener(
      "keydown",
      (event) => {
        if (shouldIgnoreKeydown(event)) return;
        if (!eventMatchesKeybind(ACTION_ID4, event)) return;
        event.preventDefault();
        event.stopPropagation();
        void toggleSeedSiloModal();
      },
      true
    );
  }

  // src/utils/audio.ts
  var EMBED_DEFAULT_MP3_BASE64 = "SUQzBAAAAAAAIlRTU0UAAAAOAAADTGF2ZjYxLjEuMTAwAAAAAAAAAAAAAAD/+1QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABJbmZvAAAADwAAAFIAAHvAAAQHCg0RERQXGh0gICMmKSwsMDM2OTw8P0JFSEhMT1JVWFhbXmFkZGdrbnF0dHd6fYCDg4aKjZCQk5aZnJ+foqaprKyvsrW4u7u+wcXIyMvO0dTX19rd4OTk5+rt8PPz9vn8/wAAAABMYXZjNjEuMy4AAAAAAAAAAAAAAAAkAkAAAAAAAAB7wKXVMdj/+5RkAAQADACAAgAACAGgEABgAAEHaUyIwIBLKM+o0SQQCSQDEIaNCM1/ySH1oT/q///zvyf9YG/SjE//w48Qevu9CaCJBDzvPQn6ORUIT2oyoUcWIDpVOp+BlKPfgK5H/0AoAQKo1/HXt//3//9mPXq7p1q7kX8///Orf/6nnckjI3QlZXFhG3V00IuCERBPt4qB84TVBEWrkSJvtJkEz0M3rvQfekFCTNggegdtW+E8vSBBntIAYny+IxOgyoQhc51CnI5z812/y4bOBinWP16+/0TiWf7f8wwdtV0l275xZRfkwiGI7856yFfOnZPHgXrL6OZaLBLf5CERxhRPInDTOuOwRV5CNxKN4VYJ9JLLcaBoI9rZ4afOcubE4URZc3Pfu3ubUJIOBwajID/BjwqJ9nY1e/3VnhgDV/BAgsL3wYA0ozmZes4Ds+pv5e9pBwtfdOIjLvP/Ek0977ltnPVZZSWHCur2ZbfxiL4FEB50+2frHL0heWUmm2PKNvz/+5RkdIiFHWOnkSx/oJrMNQIZj+ZN5Y7IwYTKwb0wWVgxpnkn96XYcbXn/r36LFjjB4vUSw6IYVpnVcZgSCcHQ4LhZLeXBWRIe/ArHjm4LgpULvCcNzvH+4DJhWRI9G9nXBoOCkJwZZKyxwKEgEwZbR2oVw0EMZJyAiAQDREz6EA4nyckjO4TbPd97e9uiCDGbEZ3Tu88Z/D2CBGdzyex/ZRDNdqIIP3tlEJvYMy+eTv/tEf8/c7Zafu3YhykHMCIMQ93RDN/eIjH2EOxBAwyJAetD7Dk7J5exIOtyYwHC9c+2jWiGe2QhECIBQ5k56I5n7i/QviUOBr08g4tDgAX8/+JQ4un4cDhH1/30nAAnPguu46IjgCE7u57miFym/oAAFR9TJ+e2j3UGUgVJ6y0aTCjEIo0DFwYyc+mFzaaOdIEEoZ8nPYZOekCD76QZO0bajGqOnm8PfIx7JZs2Pg41+Y+cH/7xu9/+COSNf0BR+YEY3wMsZJ9tZiD7+722P7/+5RkFA2SmGM7gCE08k/sV4kEI55MeZD+NCQAAVcxoAKCcAHbMs9MxV3u+9iMt0HPTghj3l3dEIeyGE9swYDpiw4ARJshGECB48wgaF7HcyFFEgAuY2zNSzeU3/NzkCBGNwKSwL5I/UtbG/8kYyWBDcGP/ecjFwDNL7vuaIW5lTTRHfdzQu+aU48JycyDsTxksLRzc0KhzQgAnlFhBi8BIuSpqXtWr/XP/fN6c/+0f/zH999f+33//z///NffaL//dPCbxxL9NM9Q6vacrZCvePmkU6yVPb6tHDs+4NmDjKNKFxwfw1kl2LkjIUPg5IIEEHqNQeg4G4jiHhwC8hQWB+Wn/+evXTt/2p//3r7r76v/z85kOq16503fnr2R5xVDDXoZJq63dY3MdjGLoqFzCpxAfigSS9jpYgVHjRWHmkBeL2MHCJQqe7PG44WKIxODwRBSPEyBAQoCDOBDThAAAAB1eqWyAjLzO9Kq/uP77r7Wkal8/q9/QUAlidP+qEH/+5RkE4AC+oFDzhSgAF8wKEDAlAAOgO1ruYeAEMPAooMAIABRcgp7rr6VW7H1sv5S5UZSJ3TmNmIY4mcpxFWHjZBqkcVFVMJCi93puoqVjDv////xit////+5RRVLtkWzJf//7ITZP2/3q6/107P+nIRu/siFRrJ1XZDKZhfIg9kIrKOM4dVGKNFh4pUzCYoEgOaKkD48XZ7OEgkAgIBw+UjCJzgQOKqgYeOCYmKv////+BlF/////3BBob5IT7PK6HR6Pa7IaEf/Uetc4NTnyXv2kYkV/xCcpBkOdnQwIS5U+aMkpfRzmJv6c1XhsTlPT/01jUSC2rcPH+v8a3FZ8R4sQ9xyOpNfO7/4pelKUjZtGg334Gv//qmvSt81+qYmFfvWmfBs0eV/+iqecPJf/////////////1///T37olUzfuX3ZEdyq/MqNUsrHbI7qrNkWpv////z/////5ShaqAIAAACKkkKjqNYHpHrgEqzZ2UlgRaLCUK7Yq40Mwz/+5RkD4L0FTtWV2YgBCngqIDhCAAPvO9FTbxWwLsQo0CTCTi44jkEoFzJBB6GiViZIqOWaBf0OwpSjeOUoOVIKefSRLpmOa58umTpo6Rso6QViiOaXR/FKk6gkjTQSZklqsk7PSXT7aVHpPWaol1FHMUg7BU7Ku4KxK9ook8WsmG4hEwNPO9f+QWbify5cH3kEwff6D/8P///+3/8vsvAZMSVD5eUKOGlHpCxI8HgGeFoAAARmsIS1GVk3gNDQUdjETBUEAg8SaZFqPy3VwpVONfJAOqSHAshgEWUkkVDUWdlNJVZ5wcOxTda23AuJBB+21vNYu8Rz0Mbol1hhjeTfkfwGBRXURITx3A1JNO13mwWmUyspK9+s30OJXBHDGMNtW8hzTCcAA1g89DhXXK/+qguFw2ShZNO99poP78REA4DT73rTBML99+R6uT/U65AggaH////////96FXzFWAAAARdDntlBrvNqD85WDjK8fMEAFGkzMHTA+lCNankkv/+5RkEI7ETUrOu4kWIC6kaTIBhw4PxPM4biR4gL2RZYj0lShlEKWaBQBeQCjQy+BA4FOFAzZIGa0XdQCg0CDQLgrPkGNgYigEeaT0tXHLvUNAMKikhehAPZUvKAS0+AoWE4nFIC5BE6x2bxTqpLi1LK1fS0yWkFOBGZFlEkQ/7M9d9SXYhzLDNONxkNABICcd1jZimHwBqDVv5yJw8MKECl1cWERKe8m48EoqN5iPW+n76zCtiyez2/7qUpQoMmiBZyaGG5wgIG7lMEHIwEMhoFmEvOEalkzNlcug68aMBhJOVAiAgcKANWmxQ0TXWbMgZ6gdLab77Kpxo0PU9jWGW4xyAQsvuqbnG6qKqFPicDg0hFblzgsQOP1A8P608ty8v1f4ZlATLHMEzgwzE06FUEakw6yeY4klIIYB+pTIT8sVzLuTJpafnSIYUEB5N7eddC8GSXjEUDB335QUun39IdYwY6qru/+pgAAAGpRTL7JKmZIFxudJm3SgY+AAkAj/+5RkC47DlzjOO4sdQC7jGXIxJ0wOBOM2bjCxQMkRJcj0nSjLAgMH60ewKQCMs/k06lSEa64okBHEh2Gf/UOvy/4nMkks8RCSYuji7a6SVN7ab7o4dGoYGxQs0pa2DsGC5AlUhXS55VT568lIu5QUEscRsQouh4SkTo5Jhgjq3ARoE2RDEyfRl4gh8SZfj1xBRGS6Ttt+I+4CldyTGQhDGu1ZQ9CVZgUArg76f/+luQPQoqIrmQgQ1w+jVU9KCeVAUZwCZhj7k2pTVTIac+7TqNFZOplgOFpcF5kvomSwAMDhRTbGR4IARzf5zb9Zpy77t9rmW7PbswHiQpXGNGUIMPKpNqopaM1Lu7saYodFY1AhCrEvdxwGI9TAiSeM1gBwH6KQkuJoYbyAEeDGSqeLgk8dHWkZJLaLKqja13UBgFJ9jtVEV/X79R8fGw/++z/0qoAwLVJHIq5BKmxlQ6zy85VQyZidohmpx1IpYjM4hF3EaOHjR9OMEzB9YAqvxYT/+5RkFwAjMzfW6wkbzjEESZc9J0oMcLNBrbBrgMwRZnD2FWBQIBVP5+8QYI7bz+5HQRGDt+FghrmFuYZDgmjiTUU6XKvIf/1AKbiz0zDZdkyIL269V8CdhAMAeyAoAARgD5Ph4fJjLJ/HWL08l8i5gaDQJkDDzO+UFy4+mhihARp+6tXTrv8k3yb/Z/0YAABBkJMfbiEqLiCNBVmYE4GgwocAtKMkBAJwjUTDQPu1GLw7GhCjLSy1OvGlHof7TvaZHrc5M6qmW7odOzLYx5tk3CwRaaQQ1JVUOBqHFTrmijhdgQHMWhbCJuzarFaXNSSUAAHSCOA+R7NAYQQ1vYxdwqLIkrWrqVJImk40Vqln6vlM1asNExH/u7dv34kYLBHf/V/RwAsUgoW/BorlgxGmiRQZOP5pYUFYXQ+MQA0wHIx5SscUAe+SLgeCUR6ae4NmKzaSmZONRrpWjN7X/mmBBrX6c5kW4V8aCGgqlJRVKYw1SuXq+5k4fTccab5J1pf/+5RkLgiDLSzPU4kUMjMiicoBhggMSN8/TaRtSL4M52jzCWCpvf9pXbq77Q3oACDhICcAF5EACJRuwYl8INt34iNBAsCsne4SBwQn/34GOMqTi4O3dEuXDX9DvksK3gghhUoB9+KBdYIPTsQ01tyN5ZA4EbAk4BOUmcYOaVygFkQrNogwhk1L4TnBWu6/SSoLiafvKRgwgiqF//+3d6fS4NwgyqbNSd1UhSuXCtvrSn4R6wXzwkHKfskveV7bnVfec7AwQGxqAPiCfQ4j621MhzBMabHQoOmtK5OrdLoJFaIqDCO026DRVesUWExH92a3fpXBB2kmzEkGmteaSGWzRHTBMV9v6UACxLKAN8F7on0AnmZLatH+UiIOQlNyxEuivPW4yqhepNK40haajFOxiBVZJqYXXDjIsUEwuH2SOt3fuF+Ip65+GGjyQUGo2KBMzj22OdcdajWAB5TCa3AHxoxdJB1AU50B596WQlKwIILVUWQeCoNNRVnDUj/rfU7/+5RkRoCDMTfTU0lC/DMEWeo8x1YM0Tc5rhxPQMkRpxzzCWD9Te54in/9P65lQeVAAAAAACzbsHCTmMDE42KBjfqGMYQJCcWoMOA0LUEaNtI2lNchUfpXMFY6Q8sOhQMrtICO5n3WgmJHE2RVosMLBThww1lo1JjYxVKyverWUnrZkjHuznV21RkZtbdd31bprS4V7z1IgC1qAPiwzRuhC6vjvLCDpj/HiiTgQAIsnOH7pgA3qLXs/WTT5qDKVAAYWKav10/36R6AAQUGjruHRfYGIIDYYI3poNCiwga+FgABI2UEV1AFImTZTNjklp+jz8pxMCxY+UKExdvnYwHFDGTeqlR+5xBqPGPTa6q44VnRUINS1a3qVeZOhUZaW96Wa20qq2xquWUJCxEEI4AACslpWmwAYRBKJn9ROMcvkOL1iw4omyl2B+N0sjjcakvZ2Y0MHo5Zmu+9txo7+vV/1wAAKpIpISSBgKHIRRBxIWdahm7B5ENNcDGgG8ZESzb/+5RkW4ADKk7O04wqwDKkOh0Bhw0M4Mk9raSw6MSRaTDDjp6qdPNxKCnRlEvW82mYTkXVSeDWyqciJhS5XC2eQpWP+zzFLUIi7OisMS827NVGQm79XD3561XidOozz/2oXMIva8p9rjO318rAAEbbanQJ2UAxPqVwu1l1EVd4wMwmD15ZA/zqipUDXViInDVv4oO1v01+uIX+Kf/oAQAEG5BDiyhAwxkOFhrogBl+qw8NhEDZgsBJgtAoYELDhtGMvoxwPBQB9hFo+eLC/7GY4L3sykw4CGtXueIKKJ/+Fbsymk7pn2mJ5oR+UOBF51aWBVh1BmKXLmxrYmOOGo3c10jBwAIMbrrlNYA4zg6KVLE9JBFUJChyAz/GiUe3aBRAGBt1/PrsZudN+qQMVxsQf6W9/rvagAJwASktEfUWEVuM3mw4u7wbfU50TzCgoMM7khqECPJTSaRCARhmj1UWpY3hLKnIIAb29g8M6v5+5WZt4e/mU0GiHALWy+kmK6P/+5RkcYADMyhMO69CwDKECq0JKGmM7KMzTj0JSM8RKvQUrZ6G7PylcjQ1qusf/NE8i/DUhvmpKNPVddr/dSo1JoAIGR2xyyQAdAIjOHMeYamVH0ESF2si4iC5z2LvPjc2v++HvnmuvmJefuYPikZuhL9H0enAFxwXpt+IyxohyjERk1CWNSpg4SvkS4FvGLtqJrpSUxlhy4xXURTeTHzEKf3aHX9X8vRrSSy3Y4pqJINtxRgVVvcjB/ozXNRxMl0hNpMgTY2m6iP+L168fQ1k+WdOs3+HP9fXfLAAotzaS6AAD+pvgQiU+5qIYDQaHkhGVcA8eDY9bz5hMW2tZakolszPeKxRHbdNMGN9gAEiAuS7YKUAACCNnA5OjrFNTjMIJgAARhACGJYaFgchZMv+71WZpICkfCgmTP1AeRxU3UMYff31W/Zd2377nutspmxjXL4SdFNSdx4OoSs+dYFwVLMBwo95RSMcAmv1PY9iA8Cz10AASORqV1gDJ3izvcD/+5RkhYADLS1O02xCwjHESs0hRrGM0KE5VcWAAM8RanaSgAb7Hv9cLhDDkNB8SQ1lKdv+nAkr//mXPVub+IRFe5KwRQhKeRYr/0UAABJ6j6ez+7a2CMMgQqLJmlVY2MVOkbCoMbQRRcADWJpdJIyJuXAYMEGAEswbVAWCAWDhthOg2CQamgLUA+UQeGZAOLgZQcAUMC2AGEAANAjQLzcaAWKFEkA302Ho6bjPCFScL47yBizxxilCAl4ckMwYFI+akyO4hyI1xYwy2OebmZcRupBA4ZIs6a00xzBzCIDLkC/61K0GHBKZPpqQIp/+93boMRcn4nc2NC+n////kTIoaMRQihoRcvusvm4AAABsn22m12gAAAAAHQckWNOGmpghn//0cBKTmyJm5F9F1FqUpNBnrkGUKpPlN0uDBu1vtw0jG3mE3l4rWWjLrxXbw61mXcFcGILSgAAAAAF3bHvl0mAIAABKYHphVKEsokGGgEjoI0QiXGIImWBhm6KBee7/+5RkmoAF/17X7maEhEyEOp3DPACZ0UVNua2AAHmE62sGEAIaM75mQEmftYGHTSh0iLzAYpBQaNFilgbZozklAkaBGDpvBjQWVeV4Y49y6pPgBQJDFPlhSGNq3W1qlrTlvFdrWq0WiUA5xmW52qGpIqTtjDB/X+jbi0IjBLW914Fq0luXfLZDUcwtu/jovte1JY05EZ/v//ItWrc1j/14anCoBF3jAQZK6RZd5Mx2SLaZLZ3/9xpcN2cv/6arZpcst/laq8fb/2QqAAeAgQJBIAAAAABXoDeCaPE9hAwtFl2fO/PUfK0l1YjE8ga7tYlBCJ8XYRk6jfL6lbCCjGWh2sB9wjAUUkgfR6o1ByzszMSguiRSCOafWNqK1oPqprooOtSblA+pFnMUqVF2Q2Rdv/UkZPWiv6XV+vq9F0nSzJEuoGRq5SRNFszJI2rrV/LyMJ1AG6VO1yE6WARqUPQ10eTKbu9bjOVBOcU6RSeHY+7msur/+8YwsIuDPooBb6//+5RkS4ADPVFa7z2gDDGDOcPsIAAMnUVdrCxReMORKnRTDlb/9fBgVQcUsjRYV0u2aU4QNLwCzl22E21P/GZxROAF1PZM1ikpsPlSAUWPokE38gTrQ+SYjGa16nN4nbxs+zK40OYCaVuzGfR//qYSMKbZi6M6s3/81DIAqygzGFqVSslqVajku+JbYBAoCkkriIFRrh52soZFA62tq27VE7CPmHYDnD67/DM6l82wcMmZdzkCBz/9jP//0IAQWASvWmS5PV9yY4LLhY0xSB2glVKVg7Dd51o8cSlswC45HBUM+hi+OCPxkWWnlkzL8j2YhjJ+ccrXdRAdunQesrbTMY9HGykILo3M+zuv29pdDNAx2ZSQ4ooHVKKDxVbicJRQh3j2FgMCS6oD9s9bO011dwBDy6yam7Zf2FiGIY3GxFM0QBNHqo/7ZFIdfb1tGECAc//NtT//1QAAAAAFFSChlzFAaVQVSAjGmXEihXE0/DBDjJjfDrR5xkIwCjCwCHj/+5RkYgADUFFTY0ssPjHkSdNhhVQNmSM3rhxUSMaQqrQ3nM4W8hhcahuhly9bUwpfU+5XED4QlySRCCNpSwaMpKU6jNkQoMhtvadLOQqzKSxtAZUEEmHO9K0f//6s2s6iZI+luBZze9wA1MhVuR1kDejimLFuQ8ies3SVcx9CgwKxkEbodcbF39tkep3+1JMee3f9gu/e63/6qoAAAAITaiSoVRMByk60GTwpTMO54KgALhMHNQL/siryjK7VuJKgAeGFUoNAwwAEQwrNk/WA15y/UKbGIwEg23IXGJgMrW62MKzi8HNhc3l7kug0OC6/i7mxoixNMcULgTiFSGqCu1ZpSLqSh2OVnsSO4UlEOSzjd8aMWtIf7+a6tEoQhBh88Ss6IObmqIqiSMYNHD2qSwielFi7V9hcAICAFpSKggMmGLeMkOlTeZV07Krqfrq6fSkoeR5Cs79NOqv///QjkYAAGYJzKbGEKb+MMaSyOBiVHgSMlBTMFMxA1PlykWz/+5RkcoQE7lJK051DwCZjGp0AxweT+TUiDvkPAMsianRwC8aYIEBZgUJxhSYYOHUGBFGAaOqbEgEM2YBgCsIdUwKABVbIlGX5CAAYCt6tOszFQ2KsZU9nuu7uPDwe5T1Z7JQHgtkVYkOA6oIxbJHxcMWfLNFO0bkTv/waWOuVRe/21+Tbe+eN6pLRbU+hlR9973NSgxwkI3jlqaomutdK44xVAAhCDEZGIwKFBkXFMfCEYmutEa9sxVHyYfm1q/9sjQ7b2WyFVIf+ZBhVuUWv///6ZwQ9h8t2Ib9NWBmN45tNqD2McQfCgQmCQUBXdQjJyYOR0FR4BVSgAXDJwgTC8BQSCYYGBKZtJAYmACAMYCIDDzteDAX2Bw7EKEaAXeKMRqCqjC2c1VG2oXLeTFkjQwMk0EekjdJYKz52aNzhgSTiizIiGoEozp6iVe6qdUW6lU5PNOxVPmqmJuf+Jm7673R7KTYm9Zi3JRuZaiKVAHjH5cmhZe36eX//7+2BEWL/+5RkVQyFOUXIA75bwjfGKfY8xVWWXWsgTvkPiR0iJeWECiBA+CoLUYhK82mO0eOabeSFKEhR0faogDFJY4uA4gv9BiUdSPS9O5Hb//6f8wiplkx/40YTNgIzMpFATMCrdMjCNNUKcNt08ARoAgQTNAUDFDKRrMhoKVEEWUtwYNxhofhg2BykTBOKNNgAB8wBwEBEAutZkJgFAEMie51GBp1RiLQw8E1AMBxdR1q2+anqejrS+nvbtd+/jnXeGnsVdIGgaALI2tRyUVlvLy1RSHLaIQQD4SA9iLFCYtxr15Gb9Nw+0Q7012OTD0OGQZiu6q1wMQtyC2xouOqDcaa6fuvDVcEEXbzY6dBuAA+2DGsOaWcaTg7k/L2kJ+kwKaL3s6VYN3oEUWXoESiHKIcgLOkGmyoTm1f+9wGxEajm6Tm7sAmEN6f//y4Vf////0RSIoQEFIgh7wsypjWGpUXEyWUsMBcLAKYZA6DXVCG6ftOpKCPgAIAgKgMIAFB0wOb/+5RkFowUE09KE6wtMDVGKq0F5QOQUTcmLph4QMkY6zQ3lOYU86Bttk7p94FVW400iiYxWtHEcXIK8aUW5iia8edWr//v/0MeXwYJ0RCrSrojIRdkmLtuHSDmHVmrtO3R/9dEK5rgdiEPTkuYrMoaYcUEj3fEWMf9UYIEIEkkkiAkFEttUZqM3G0Sn6GIYhxggCkMLnvW/EWy/66IYLe1CJ//+S40JHa2xyP+QgZwFN2XyCGbMtwwM11gFF8AoIAwGTBICDA5vyiBmJMZQhbQwCBowyHFVMYE8wAes9WBNkwqANyHw4Dnns0mcU1qW5XL7OIvBc7Vr/7ng3h/XiIoWOy3Zh08lKFCXh6H28nVvKCGpUjkyjQstY3nDL4XGhkRHmnpl/tbBeGA+5AQydjLNFAdnTclglCAiB0yXgziJseioX/bLEYDkZLvvOp4Kx5KLXxP//pEAGN////mhxN1Sf/zaoIAkzM66xgh7mtRcbWcZotagYUioBDEKYErZNf/+5RkDgAD3k3Ks50bwC9mOmoFIgOPATUoTnRPAL6Y6nSgD8a4cdxfvgwLGKhMgTBgXhVbzkoAWeMMlVKnBAu7taQ1uzFurOUlaP3vs9Pj2qlTpZhR4cHBGJXI+qZqVIuXPM8+yCUQiI2y3LZX//9L/GdFzzixpPKkpFnq4ZyELT/YP7MAMCLsQRAkcPDQxRnGh7VRQzv0XMZPMVUe6LKFGR0C0Wv1k2////2BAYrR//QMDwAMBBK8zBC9OTmE5C4A7MAIZEAJMLAkwfbRrttdYUvynBgWHRQLAAwGAkwLa05SA9lS76CaXPD2+YvljLpPnbgp4NzOFPziupWUQfKvKO5FipCs2a/ISZdkzIjIzixiOSDBJKwdm3/t3vMqXDOzJt6UWQGkwc79lYQIGZDakgbAwrBAQkbIiNEINh1RAMp/8+p1CCyf31JO/+vcgLjX/pBR//1tJBNgZsTCuxLbtbJBiM2lcKSToyC70FNES9gyRzNhuuPNkbTx1rLFrWr/+5RkEoATEE7XaeYVrjRjOn08yzmMURs1TaRwgL8RaCT0lK4pq6ma9YglAuM/p9bAk2nl7ZVOO7bDXEHKl1O6oSeis/IyJdwhYt1ZmRmpXe2v0WyC9ld4J1S/1ZGMGsOxiNAjFbVbhIFqxisQ5Ui1FDsK4NBGAYAMBrB+Cx08TRyjlnLtKv/uKYLEIX7Fm//5Sj//81gBgATTkcDqqSVIa+ID28YEzs/bqJDojhyimnL7atwbINALU1GixPguRMn0UxLuUobj4p6bEDftPKBw+XT7CmpkWDdMv/KZvKnXL1OWcY8/sP7c1XKl//nMi9JYx0EUK5WjNIYYCOPyvoAfpdgoNELQ5p1gNcqkydJmpYsjLdqRD9DuLAccQaT/9RMgv//IlS2eRaAAGAAXHIixA7XRwUBvZwBBhGkDPW4opJKM3G6SCCHoTkvwYQWx+y4i1j6nYIuyrohQgJq6pa9BtXHHu83x5oNRZ1ccv1qyFknnrbXd0tdcWY8JGposruX/+5RkLAADFTNO60gceDHmOq08xU2MxHsqTfEqyMSRKzUDFN7vXEzyx3YBhWdwGAvjWJG6IIAP86L0epC08dwRQbvNMIBm/9Tlz4OX4ZUlI/11HNl//QpGf///+c4DGdkgkWx/VpAx8A7me+8m/u5EWEoOJEgh+ymLbZwoqz5GRViFKWgXn50AC3HmjFcwjrXiSdIHMQcmr/Xl+maTqV3scyeNfAyt/77+4MS/0/+Hw/ffT//v05iIvLpGJcAmNPhKQ2tQ80zlK5GpNjtocAsdjeIABeKTNnORlAECbu/QlAsWYzHVDf6qd9P6NqQoac//lv//Eri4eWAAOACU5JExXtklARccjQdqx90U4RyOUZ7TLZYyqYVLLrAguk5nkz/AsUoJlBfgQ5H+RNXIybkNDBPaeoGOOpfCSvt+/QWnltEosYMLaGKRfCL3Nv/Xfrl6ubEaa1E177+K6wYB0C25HEgPtruLWlysUW26bluuiH3cle//N3dD6cYlAwDBn7b/+5RkRAADFTTO6zoZajOEam08xWmMUHkoLfEHgM6MaDTzChTJo/99aCI5/7Oysz//9ZtTi8hjcODBDWZs2eeHhAsBpMDQZLRrpwAqpUjydgCFil44BwBXTiAHjippbHYa+zx0Q8IhzmJDY13uppNZ3WpWYhRjQRUFUUWquHlEjQIYBUJPfniilE6OlTOy1Qesyv//cAIF6BicGJAP21nDkLil2mGRgtJmF8r29EpC9lVT/lmLkQn3p4UH+tYIkX/Jt//zP//QihU/vlQ7cA5zMWjjDrOGSqBhiAI/Ebjmms65BCsgAAE1C6opNRbU4Njo8xFNQYKmGoIcGHhyG3953uRSj1hL7VRjtb7DD5y9YLzBNY1RSPPCuPrFiB1oiONpOpFiI4CDe0nXFp2BcBwauXQMASsXM9hMDc8DXx9URUD0c1ot6OWTOJGAgla7IERZf8QTS7bE96kHv//BKCrPZ7yENkYQOAClMsghIKLAGLFIg7SeKjNh+25L6AAK9pb/+5RkW4gDGCHKi3xDlDGEap0F5R+MjIsqzfEOANUMaPQXoD70GSUBVkogPFPF6sGwPkjxilmokvMDbdLLeP77qiPqKXFMNBpiGGN1j0AgbDKqT+OPTiQgphi4gUGtoArYHNNDaSbZocIbSkQQAkmBcw4B9laQm57CIx3zI8ze2mI2woSbZirFFxFjmU83//djyAcxAQRHAb/+hCqAICkNpyNtIQW7yL06hOZO9jd7xUKUC9VB824XITc4WGqECKWKaJfAjNERoEQy7qLUWRlR/bSogSVSRqrDZBfySfXKmfkxziDDjOEesgsFCkY4tKnOUz/MQ+sDFU+SYl1JgDCdIBGlsqmBKScQcvA1zMR4YxaQjhVpBEWxqJ4OwLcxOt2bZIOMFwGd4lK/U7Z/+qd//+kCAS0pg/AXngh9OEizaj0SAywChxwYFuh71ArPs5IvoIDIGRoEMtDKC77uUtJKat3CHKfCjmJnFQMs+7roKrZH2+CQuEuwd2tEra0YnET/+5RkcgADBUDSawgcXDVh+f8F5g8MTI0ozfBuwNMJ6rQMJCbxUTKOJCLs8bF7rE0C4CkU+33//WG+t4JZboIALldHZiQcAUHXbExGKARITF2mecFzDmPWLKlR7enPICxgmvLvvUogED4Ef//LVQAQMAADXMYPsIzMHMkz6QjFZmZwkuLCUQLcWj1Oo8uYLABoyXCwjDhWAkTxB4V42s+OiIeeTUljDJmXvLQdcszm+ymd3yFn6l5mJCliJwHF2Gi/AOechf3p9NoQXYvoBOB6BjckAYG0SE3RxgLXTDnxMBHgMErnTnYWq/FXKITBAqDQpV9vb9b6UjUDwp///+z5wEjYNliAQKAAE25GxGoFEZYRVJswqQorOUPXMFIcmwostBWtYLJK1/KAgtw6RIKXFln1eP/f0gM2t7VkGze5eiyGCh2Oe075KT/S/th1SLzmJOKR4+PYaWWHWqR6221O9I00AeBoHHJYGgP/fuVBSB4Xn5cjkdDo4IKCOcicMn//+5RkiQAC+ChK44kcIDfEal0F5R2LxNMvrZhxAOGRKbWGFP6pv45VlubrtpCin++j6s3ZN0UcJCZn/+L///oVQAAgCBVcqSCgCZRFUKQRhiUKbqmYOQytvOMye+NVmoytxhTOUNQIQldSsFEiExAKmZk6oOQxk/z4YYbPgiYJUsk4xEkTtMdGU7fKpn71s3VQu6pV3Tvrt0r//7zvN/AZwBUDMNuWwIAf54ZJfytJFuE09PINAqWPFqfB9kayG9aWSb9OTQhG879dCCFp2V7u9Cigg+z/9zAIFAJLkkbQl8raWPkgcAoTai3dzBzEnfnXbkTROtc+OFiWULQsi/Q8vo+87W9BfzN8Tsb/9/bdo538smUWoHPm4tcaA852vIaQkn5p8rnxZw2XKmHv9b+f//j/1/7/QAGABSAE1spnnFAAoq9z7teiQk+yfavA0NtTVveQsVgH3HhSIeqodTEQ+k0t4rpOvkgLa5bcUD3/+hUCA/caaKnYPLTa1kzA3Zv/+5RkoAADBCxNaHoYejakSl08woeL6Is3rOjKqOeKJOQdJDiX1ZYFLUfdn/l8Dt2nlWQUrswDzJuUlj8dSd7HhiqvZt2fcGdNnf6gKnZBjdgRD3PIyMYqKtnUGtjU2OyuzW0221R2thDxK6WFKCROZ9Fa8WV/6tKBgFgkTlYQA+ZYwPA7qksrefop4tsKiOCYew1hMWe3W7+KB0h3YgALPv1cK9UpZtDMWYBMf//iMwCsqRpyxC1i4KbI+GFsyuB0JAxSIKEPjpFJJPATjBgCwxgIM+ybpQArbsqiXwFg1qJhTpsAimbzj5BR8+AjgZQtAuRHB2fcH1E1EyYLAuo2aJqVFKQEcQp1CWjMmq3oyPt3eLdAE2C17QyceOwuMyt6XReCzT2qHdrLpVETKDtXh1umCNTzUUgoN2n/dXxT8V/8JNbqNhWUMJHdc44YND1zEZVfo6JmOCphH6Ph6BHbi8TY0JCBhaNYEs4tmGjOkyenilWK22nhHh0DssEgwkH/+5RktYgTFzrJq2wUNDiESi09goOMiGMkTbDQQMaRZyQMID6iDFrkdn7xbr01NU3CQIMMY3OtDAGqfCbDpN4qeQ1JlSgMWCgJARqR5UhNPSbZqfY9QVpWOTRzmSlQBQIQBLAAa2wtS8+AMQA40ok7vKQoocfZ4ZS/7VJCQrEZyJpmXvIjAbewKEEaTNIs2/etqBJLX9NvAlZzKhcVWjGBRONHdPgLPJSBwdBs/Nvsj5Py8gjwyxImhOk15yIQRl4QgkiZn75mTl70np4YylX6drFYl90di5mkIim+Z0sCNOqErb1JJIy7Dyyczr5EIf/9ZAgGAKJ2oYAmmTiAzjGJokdEaNXKkuweR5kZAOpj2VBEUK50sP96VNV6LrROVhiX/+8gACAAAJKNtYwCSWyzJlnIYmgVWVJkRUSPXhKFvReGoEwvivcMcgbsMxGZlTZ9hxcL/8kh08yM/LqmdMqZfnCJyMzzshpxLzRizggaY0TLMB4MVE6EPcDQxrDWRU7/+5RkyoADlCbHg3xCUDSCeWxjKTkL7MsozZixQMaRJvQXiDxiAV6/6ABQ2gAC6wABOyvcCMCg5OqdYcUsnzKLWduuzqHZESSViAhVp0qpeR0MJk8qcpFrdgUAAwCJM9uEkWNDRraoZEaq7TJStKjiJuWDjvg+kiLosFVQCluClSEw/rYSBTx6rffBSJAr92TPluYy27TMOYMmHZNkvtvTxkVgGhTbF5qQtA7fR/cbUx5CMkhwymHqmt/yL7zzOP8nM5vKaKHBLY6vSvWqTC/7iwA8zAr8gfUCw4OHg3sCncUq27L0tblbaCO1kFpyjQiyZKX5Q1zB02uAwKA7P3rE1q6+aXuEBAOB9pB//pV6ldgxumMwGbcOZgtBA4BBYHjwxMEOEDkpia8ZqOMSGgQ45KBAZLRIywY6Do0sjoZ621AECVAG5H5kZKIkFbDejs6nSXycZyzkvtwuutPTeHl1DzIzJ8h2zSHFEktLMqRfS3GMGGZ1yjBoWHIUGq3D4pP/+5Rk3IITEDLK60MUcDFCWX0HAw4OcT0lTZhzgP8RpAmmFhCS7scLrCSaCCBIBQAHJogDhIqMDSjG0VkMLVkAsEbaBy6ET028JeKH2qDC0UAQG19bn2pTpTaPzNVQLlXP6nVjryQW7cDf/yrv//bABMQS1ARSJroaeicGLp7TRwFMOCzB6UByzlwFIm2rDQIpVEgJ2maAyyKV/p6QSympnCDac2WrbXYGHQS/3U0qy3eGffRJ52ZUWGc7naRIDUyiM9NqdY0pAwY0hXjhUBJQp7ByFBhpY/qQLUIyYUZTagrKCrg5qAAgAOv0QDRMBmUIotAkwmrKBioGqgezvNDjT7Dyt2a8VgQ4xQkLDApkDCS81h/YkmISrgUdPkECxZpy067ULj5xb//Z//////+hAAAgAAdTJXi4ogmhhBuASZAGLqUxY6DFseotL2tNDvrVbtBIxHjTQ9kVpOMYLydbkINZBB7rqRjSOBWTB6zMxQxQpT5tPSQ0p1+iqqNZzu//+5Rk5wgT1jtHA4kdMEJjGPZth4QO1M0fDaR0wSgRY+W0nhDYnRW7/boVR7WCB4SDagiM/bVv/69AAEAAwAH3CwgFj5n3hoZSkBwKLAgDOK9GHoxEcIqrGulNEUYAEoLlpJ+tgo6AsM1F8WSNRtC6i7RemTCNoe//r///sKTcjYvVRgaJRgF3CEUUbmuEkWk0+TRF93p+KM6YaMQxZKYG6lrSRyM7o5ZIgFeuq9vdrtfbLAm/IbCOZovcyhFTaGT5yUuTSjLOKZW+efBTAL3LY6YqquLf/9/rFzRCoMOENg/MFbZqIhZZEATCnWY++9I8sYYA8iBEcUBJdUrD/XD/NVAehXJbY4Dj0tlZbtfIA3/////Vb9P99ffd29JgQioF9/slFdBJuHQfpjA24pAS10ylxVNEww3IzHFC4iIIJEEznULFnUaM/PVJWMpWvBZkVQQZmrE9YhtRi/eKRr2Xh9/LJe89ypAkEiR8wIkLbI1Ir3o70gQAgAP2VCwoATX/+5Rk1gzTLTvJY2gU0EMiePlraUgLiO0qbSBxQQ+JY4WtsRgRoyRMbEOAZacwIsD/qcf1+pQ7BapJ5BOYSdAZYA2clg/q7dkajvdYJqEeiHNa9OeDLrppKKLAzP////1f6f//6UIQGIpELc0rLHZu8NaM5RQEAjIYKIQlIsXTlshp47DN4kKlm6sqxuuaiAJ8BjQJG92sOQ10T9C5ZgIn6NLVUFcT0N6oz6hqbIFYg1RWSQuTu7WilO6oQGGSTToIwQeJAACCBAC4vwITlWncabYafCb6RSxiuRkMcn4ChlpcJWqCCorREETE3VdYWYdYDhangXkaTdV+vMmn0LA25Kz4DWDf/+3/////+uoAjCAC1EkKF0BQobiN7w0T4OUrSEEHYu3lzMXKj0fZy286OMSbU4r62MjCxWhAFll3rY8iuZPlsb7TmNdIWDBc1LNVRHFfNY1EqeXVziwIn4RcfZYMSo0LkVAITsRW6so5hOJGoQ6j6vv1gCAQBgAbwIT/+5Rk34ASxz3QYeUcXExj+NZtgoYLwL8zrAkSoSQM5DWdoLBQOSH1JG8co1ipVXgqDIwNeswt3H7V2/4QCBhMGYgewVjcNU0O0sOwe5DyWLlPLr44BQNkGT1mdTjr+SOIAT////+/7v/oX9vt0T5NgTrM5tS2toUs8thJsVBtQf9qoUDFiGTa6OAIKh63Aj9RQqiVJJ6w/KrJaG7Rt0Wi7FJN//W/DIbMdvtNYZnfOuCRj+S2GrFilkB4DpiFLW95wWJLaTMnZk2UF9369VABCAC/iUg19H3AF0OQIx4kEMQYE/qL0EDPpCF5F3H7AnMbYBCSPwYnTdj9IStY8sVLaovm7EnkKMiJNVMKh7/+U////9f7E8apnyy6QEg7GltssbGVRKRPMZMuZqzSaQQ9KV+wqkcuVwA5MfJQqjfiNRiQkil8KMTG85VthlVubkqP/fa+76NDZr63I6qjZEGkqiGZShcLlRhB0oHykxWNaLrl9KKGYs+bMVpUAQAgCAj/+5Rk5wATUS1JUzpCQFOj6Mlrh0wL5L81rRhzIS6J4yGtsRiQP6Y0TJJn4+Ymhq5T3CoYZEFkaNL5XXuSMiC0+I2FaoDRqsCsd2XDhI+gSIeo0q9h4Gv9Mee9FbW+3Tl9H/2f/+//v2N+sAACgABJKJoWH+JWQFBGikiJDE1DVsjC8jvU7btNa5EXVqNbHX5FPDClMks+4yPy1RdhZ5lTK9kgzWG/T7dxp+bpF7z7MOst2vQQASX8u/Z/5w/Mnh1sgYQ09iab+QrSy0cU//7X9pUEZygBzohtkCZ4iDhQEWiGv2671x6AnuQPEIBbuF5ATEAOJRtyvjs6MaIZN9vkTLEgNy0NuYt933kf//////u21ruT/NbDxqoBDACk422IMVJnPOOIYMmmZqcCOcb6sv7SyuSvbOuWOUi34DkvUzsY+mrhDnijWtmZ/cPm5fbfpsjeTCYwGhwGppMEhQY1qGvHY9tCmLfFnO+b15IvxX/9f0IyXB4U7cs2pBB0YAr/+5Rk4IAC/y3NawYsyEujKOptJZIMtPslrSRwwSSJ4sGuPRgomKSh4P2/MXeB6gwNIyiIHgCSGCACDwE0jSjm3VZtlSlHZGdORZNQ63RVkwA7//////3L/iquY1BtOdJwBgCmQht0hm4okfJiZMeulL0eKhfqG1pWjM8jgRWHEglbCW+AvzlMkgK4MKRkI7MVUXOYcV216VEQ8YwXgZHIVtyKnzCIjEg+Dk4VcI2PcXExZ5lZ9DVvCfEONG7/9b9G62Za0hagATBAIy0SNXiRMBgmt4aW6mZAOimmCPwTmN3ftOyJJxNBfwL6gsOrnikauBfaQicsmnJp5FH//GuxocLHLI6WWL//UtXd9v7P/5BH/+/ZZEBzNjksjSEGUsmg1oqmN/nuWvOs8ErDgr8Mq0GgVWrGoJUjeIcujLORLqtblQuD3aHnAlARBnMmMBhHc1WOFGRGPhCWrKtMmxoNH2Dhc3HJvJ/10R185YnKPEKcmomjkiKsnUDBpMRMiVL/+5Rk4QgCwx9KUHkwcEoCmLBrjEYMzIsfjSUSQTiMo2mdmOgv1ehmXS90BIJNMQkCKKA5KK3P64mCKMWK1Af6eRfKUtw7VY29emIRQ/////0+3o/6bSXAayaWvKvYkAECgEBVcGEMEsQMmgO4ZcRHEv1LRWWPbrC6WmKAeyFu7jBROAhQBGRDEXq6OGPZD5EGAmPpczYJE4RmMwcpvuTSeUjEeFqGxM6GUDDIOKAoTHOAM2G1l5mNX/Qln+yzQ33pJqsMsTSDzVdDLt2KjodHwK6Tg4AZPTTsKvBwbc8qAgkmgYyWKQLZhLGEsiWJiCH42hIpH8hE3dex0oL+vyeEf///72/RX/dyNodkTSC6HFQzhuAFZNS0EslkjSG7mcmhjpEXMuKpBIkOqJi5tEcBeKdofC3SS7xG9zc71k9KcapqEKOwbxq50zVfzDB5COEgRtsK8y84DgFDCSiSD5IzPjVa4r6tN+qS5z6QcagYyaembgImsMCzClgJbFuFDcj/+5Rk44DSyCzRaeYcrEyCiLBrjEgMUKMhjSRwgU4NYoWuLSDh2ONgAQfL6skHZcZ4ASgcTltxLE5eZh+hh950xPk26+/rUf7d6P////r2fpqX/whzN6rxVIcAAwFP+gsuoMvCep+UGBMv504dKmY9tVlD8PHnDcQd4RokU5HWs2TxNuLRdeWGHpevvli/cT4X+hDYYCoPjn0fMs3zvnvlomWjEOYxSzLyTwEkUAiwIbmzKbWdnVT1/6md8ABTSH9HSMmFDDDwycKkJc8OHBlTI1OHl4u5L4809lSU4NujcgcUiz0ZnCkDIn1ias1yPJ5n7UV2o9PnTrH//dk///Y7/u7/qcL+ETq1ABAgAAUjjRFu2QkDehz5meO02OxQRnlCUzHopL/fePOyQgkTcNTVXE6t1ZGG7+aQKX6d2jZCiyu0HZw1SQtXiyWsW2wUChU2wDCxYyOAiGPQtPiJG+MR/+rZ/+oCAAbulhSHJBSOZJyz9LUBAQDpE6OKstyuM7T/+5Rk44CCqihRaeka/EwDGKBri0gMJKEhLLDQgTSRYyW0ihgeS0BgCOZAO5B8ThVl5MQyOGHqMD6bFtleVPs/ELP////6fs093etalsehrbSkIlVUsAVkwnSY3w9i27ivYKpjzcje6kinGUwyy8cHJww+0YaYhQOHbIvd0MHS6CoJJBM2ERAJTqDrCcspgPkkJUmqKIGqa8XXXZETizmq2a/d2f+VRrg63DhpvfRYhNOC4lDYwgkw8LO7EojYbGAg+DgWHAgZihnYIlsnFgSkzld+inkIN33rfzMMFHdb9SEFRH70PC3/////7l/n9rQKUZc8poVPpUoCQKyBk3QRpxtiFbpj4SYjVV0DqIv+9mFWKPuxJglcEuhqTD4o78qo4lRSWUAGQgQxOAMLt65kFJOyPRUuK0MsiKTKcMgrXnlGK3ykc8rPuflg1uRSSyu9sY73btzobx84leSQKAAYACIo2T/CwXLsGiUgUTIUPQEACrEf3cZG/DtUbloC2hD/+5Rk6YSy4ChI6yYcsEnieLVraUYKeE8gQ+TBwUcM4kGuCPhXkxBIQOxByFiQlCYRQIVHT+n1frdG1DP99Sv/6/sTtc/r7/9ruoBBCAlUCaYSK0T0DTF6BHnX4mWn8IUoHzwJGNRpsbJXTh0R5SguEAmKuNePfOYEg2V2O2Y6EGsl67tHSDD062HjMWhlRCKUXiATJAKwUFwVCSWygoYMESS7SYv2Ve2wUNVBHpPp03m9jVSDqoAgTOofokKx0/2REppK5gValJaLvbXitMpU9NYkfIwhutXQx+7NECrzz/QmXudv9Osl9f9X7df/f/crMdXtsakQVQAAEBQDdIX38JYpFRMtRMY4aczF7R0+T1rVJlSwyull7LxmmuQ0xDE4XRhxzEiWcErqMLY+14hgZ0ih+Zq2dZUA0qPAede1pdAylAuo8QIhwEHhxHAkXTu39//Q1Nf9SQIG59wqJ0sz3MwuaWYOh1BQtQhL1DbxRnLQCC17iwSKRQs4tNfiISj/+5Rk8YCDJzjGs1kZcEhkWOpowoQNeIkZLTDSQQSJZDGNMORAMmw2bDqjFlEnog6/cDHrYjd/Vq3f3XVdI3YUQ/Z8lZRZTd4MuogAFZA218cuhDE3cgHb04WZwCOuxfVAkexl89Oo+N0FMYZsFumebxhEotWQZtDATpcSoKBsMABbSAlbDrjyjRaG4+Fw2eMGdwdpZvejFc/6t4g9ez9swSfQhAEwhjTFQdJgI3UMFCdkqyTHggVoSNPe6bjmo4FQ9OlL4RtAdCr3bM8MrcOS1GIobtLUzcSwK30gxvvfG//r9v1OK9UVIW+vt2v1wuL7+YSixQAIAB2AKr8EusMcnOhmwbpnlQCv0QKRPdAMMQ9XssNVsS5FcYPQBksRWICqJCBQJspVrU0H1d+33UjPG6UkQLQOxBAdAzhwq4gdAQmgwKtFguijRTilqPv6RtqaDi7G0e/DimSVIEAYgCY4Eo7G9AYkEKiVnMKChzTAX1IYFeuVsKU1TnWAAqcBjij/+5Rk8giDACXHY08cAE6CaKVraToLNFMbLS0wAUGMoom2CkiDHOGLUFxzlisF9RrNx6D+3fWW/7/7f/+S02Chq/sRjFiA45Uwgw0UWu8BDAAr1CSQ+QQY2b0gYWI6C2UfAq3Iyz3PFJ7mMRpnOGGpFNAhdE8vVTVFXlSLKIFIO9ztgwiOuYksxEMrQBmJARGZpCLPy8fMOea7N22/R9/9913qnu3dTqbS1FkY5sFAoQ/wqAiAEEWWRV61X2uUDDFMkqsAKWFFQf5SKhXM7W1vT2K2HSOyxyHsn1gjN/Yv//t/Z1cpWqjYxsuvK3RwPloutsitZAiFVQIEICBAKR3RS2ZcIEwTH2RYCwlHAKaRPFK7kxTUatrsyoUSk1ANHiUV6RpGxoEmvOMelGUtysqDNppJcAEyqRKLtWUYRhpYmYLGQIRPPxT3OkEKHJn/r/YddSCeQW1SWseSFI8uX3QKUAp0fwUDC7zoemICIxEg5eajD348WHXgnGEBYGoAJmD/+5Rk84CTKx7GS0k0IE+ieKYHaQ4LFLEdLSRwgUKMokG3ihDvJIzd1cIvsusxwHbkXtu/Lf///i+3JI6H2XozwvUK0BR99oVY+sYDxFoEjP24QiVyaeB4ObMIDxOqUrACC9DMaVvjMtebIsRiRd4Rlo9cAQCID8IiLSguExSqlWtqZQINn/ycb9yx5D/UIqB6Ve4kj/CdSwHxRW0Jvln5wbvrh7K3uasr8Qkx/+0/670Dhi+uf2Xr/+J/HYvJm3liZiEFkDGVDAwvofFqIkkOScGBQbXD07OPxiQiAdbxdEcvD3QOlnD8msxUCw9O8nO7VJjlPp0Dv1/tV7fu7P/+Pmhr/uthttEKqgIFhLV9hYZGqc0QWMxKEuGZiwSKRYQnVWtQG69+fVUZ4BTUOOQeXzJozqGB7JwWzRBQrNWnQMxsmhmRxC9fHareElVjaroaNAZYBaXP8Y9C0po/yKXuUss2ldRko5bFEEF0BxbzYkB4AD5gqFggSdB8YUOogMj/+5Rk8gHDLhpFy0xMEEwiiJBrbCoOnIMSrbBxCRmJ4omssRgVHAAlKObzzEPxmGE1IJUrKrGlBoMTqRfdmkRVnKLgifIsHOKVodv//////6zvuue6tnovQ4LqlrpFlDmRw2kzMckVFU5zFAkyzLKDp9HmygV6EfAUEoLhePNEBgPylWkmjGUpqgjBgfJ0kwuEFibJRxWHckBWB2HW0QamDYaW6VLMA0aWu3ks1DtRUSyOVouDUDQ8cvC4VLEnJUCAaIB8ekkSGmUgAIQDGPDo4ZQAGlwZiQa9MhMEAHF4S/lz3OxGocGASvVkmV5hDRI+LwM/RgyJkTa8S6CUkjJ72Z3/////+j//a1O4A+GUQAOQZyJWAAgAqxxsi5mSHUBsWCjDfQazUcxIupDN7xxWBlM+IqZM8sn2DKs8NLSU6KtYHSNTHCc+MtJCHLUdtVSV+7+3JbMXb/Vu/3/SBANGAmJ8LEBt8YvphJMWlxbgKPjfEEyiW19pKQGyZhJW0Pj/+5Rk6QgTKy1Fq2kcJEejGLZpJYINzGUODb0wAS2KImG9JLBCPXYcOE14XiFjNdUxifndFUksb6VYv/69FX2//pR0l9fZykpeSxyhQ2UQvFATNKMQlMDIaTZkWSx9MUAwR8W5lSddyYQGqmgIUqzJgV9GnQPbDpFyYT7GJMTAQRv/aUfSjGHHr27vb9ziyD3zS/uri32GE29FwseWhwbFmFWirHARgtGvfgx0KSEdwiyIkmSMaSIQ9F8I1LsKHKHkHHKT1JqQyM1ng6VJBIXtlopIHrfP8zPBkrEb+G6f/lKq77VEEv2VexnZr/+jsorqAgEiAUMFFiEAyUNNZjRWle/ScRiAWGNjQXfhlnUfbViCmQAZSh8XRTwq6RJXYKRDLoUW7xBGn/BhJHNa+Sq7m9v/7uyOlWmTp/t/v/T/l86X36t/reyZPXqy2VjJK6LNSZUcO4Ag40DKIioqGNpk8IDAx3lgy6Jhw2AwaGc6aCHiQJLDlygQXgZIBiPx6dD/+5RE44iCPxPHUzpKoE4DKKZrKxwLEGUSTWzKwSOMoxmWGgC27DhqUL61VGJMls/64Z0SWUYYrbr/DaqXqQ37b32+3SnZSdnm743EQWcPTYLPGiIQjj5UNVAm5gqbAgQDnQrtF1qsTMgAfpp6Hc1LGswWoeWDxdAAjAUrCSYGB+ITzbfvXslXz09LUTVlh813jErT0V5L2X1XdPq6Ppc9rlNuJpm40pQXAjDBwo90A99DUpFU5RANtPMKUgRoKNIhFhnabbBFYIdhgMBWB02NsBSfWvZ+KIlK712lIwEn9ghtdhja3/9y5GL4Gy/5Q7s/012bkUuQGJ9z4wHaCQAIpHix8JmBikmTapq+xaEVeDxaeapIMgdao6SoumgJcyhxXYtioRobUJO2gHnSgHZ//1OpEclGALobQ7/93+7d+YzSmJL3PFhw5AgQ4PDZ5R49MJrvE4NSBqOkNMxgc8t4xbWHHDR6BgkWnMXgKkh5bSZrAWRmEuIPQGgyOSRB67H/+5Rk9YiDIWPEM2sUoF6jWIZthoQK3GMSTWWDgTeMYpmmChBBw3dHE4pLF5////r5Z3qSpl5T/XszdiLvRrMtbRWpFlobF+HxxEoUAiVgydBJQtKIty4K+AeVEYgMYoRMYMqOCsRDF0Lc1H51VI0BCEjACqkQAw1AwRqWFhStGdQZUH51/dyvFmP2AM8cfNixAk7Ykz9ti+lS2PHr81dCgMuNmb58uJrJQNKAygHmwoKioRoPGA3lVKt9eZ5opAWrw4iiMnyiFKKWYehRZHBlKAUw+xN4C05qaikxMaDU0YnYVrkhxqus50K2iX/sJI9fkNG3ai4l2t4pECkhyPSApRqWgREssD0kGABkCEjDdjjSskaH1KgMK4wj/HnV1QuUQgUQBYMYy+HaADgwQVKtYZ+hLOuyti4hmxhCaYWe7VUj+x+xn/Z55dtqpZtTk4rYSE97hEIVFg+IXPYoXAhMW4YEewfEnUYgRdSVkExg3ySbrymR0TPyydUZBAZsE1H/+5Rk747ywRlEE1lI8FtDKIJraVYMWGsOLWEowUIJ4gGtmVgxeclEiO3Vjocn1oGdZgj46stVf6tH1fFO6N/6Pq0PfC1qmvUrAWRz4nLiaWJgJJaAxjpVCwUsGjAxYOa77gIBMbiSankcginYaLqo3AwRZQNq/a152yZA+QALUSYL5hY/P/lb9hTTeyqx/so6WNchHGR7f+m/oJhNgpm6XS1RAiwwo8NARQgVBPVkIJmDb09IoxZlkqJiWBkWxaxi1Ncl8DF/yEOoADYkLJpc9elnDrOGCRzQTI2fowaxLxZaUVaknv/dTr55fg/1psImEYlWGQINcxg0Ci5asa1hc2KIDbBWgGUCFAA69S/2RhrJjBmQA09YVnwpBDi0midmejSfnWcgXMDoAM1HQQ36DEFBuAeoq5vrZdFdCf9KvG2UK3o9CfEdEy+z36E/2nxubHKw8IpDgCSN7OAI0MJvyLjhWepE/xAAqZoFEsyPNDoQDqaHDgSsJchQWAikbq3/+5RE6gxStxPDiHpgcE+ieIFrbEgLMGUQTeDKwW8J4dWuGcimvp+ub//b/t8jf2bkz7dqdv2fVrNpZVZKpTLV2+ipRdarsFVyUjPspHMx1OP7BGEOSIS4WmLACH+lEr2rEIS9REGSIEjJm3hyBqQUYa9fhUkpKd5otjfkM9mJMGVmn2EG2/Xt3v3//t/0Rk/2dvdrr69f0/zsyXrRsbc5lJp8teyb+T0r5LmbaepCIIZYAxuiiTqA3gaMBE2gLBjQQK4Y2HwNE+U9dGlh6GYpajAK0J/c5XdU5oeaQsuQafKzzP5f1jGnX6Nr/6G9cbr7OyT5FnYm1x4UQpZBJF6QgXkwVTFAdIMDptUquQ7SlVUToGiDIhZvDqrArNGh9PH9TVZfKVDW0EKmTz3qa8VL2II9qjqAaB8imxQVXt/imlJfravf36399vVvfq0a02JFTS0z9lwfFDGmTkFjo4kzMmB5ehJSFMG0ydmmL8FXpQjiW+acMzLYkxpDMWzdDUv/+5Rk6gCCNw/FyzphUFnMGHFnYh5MYY8MDRR3gWqM4dmNpHij2MfeYV1YRARP8/Jp/1//56/+/T/36f7fYlZ/r2R5lyW3Kzq6zV6F2nZWlKt6nM1B2WQ/M5CSrStQr4AOmtMrTpBEkmpxah7TzTSFhxIBhnNOPd182cIgcUXRXsDQfoNHZwqu5ttPT+gnq1L1lWPWfsSmz9iFH2EHEBM9RNbxHF3uDzCQTEQgEhORID9FQQHRm9EBQHocNWkLRRsFKX0rxymg564DFHb5NpP98TXHAxnY83xP6+u5tKx2ysVqJO/mP/T/0Fv1W19ljFxVygBDToGdOVIYlVZSbFSrDPt4DNJNyj0G35fdb5TRcoWwy5yJ+Q3VwWOYgznhNSUMzM+3d3e/Trfun9e357+9/9v5U//8mm7bb6dSdEJNqvVK3zURirR3ZVWpgnGZyJQDdQkFggyM1TRGIxtRAFBoUjTOwZxbUMy6nXmXXY+LEIczskl0svOQPbeeiqhqZQj/+5Rk6IwCYBPFEzoxYFwMOGFthZJKWE8SLWDK0R6J4umdDLCHKnnl9/9/6v///tr///p//fX37qnb6FYliqiXoVGXkdEPR9CqlbHDmdkGyBLIFJLxxuAmAACArKpJpKoBjqPfodoKS9eL6sOiYgfhBsaEoMY5WNRR3J1LhSa9GnGMH/tuen0dX61To2c6m/0XtjLJy0qmKFioXCQeEYneSARMoMAUTRA/RUWEhzKyMJCBHQSgGNZmAUB0MZtTLTVXq2CsQOxAAnl1OKr3MUCrVr19OiDvNETK84fPOJv9mSlhNxynTdOdo6UVMsuqxOXnHmWlxhwqk2ICZlld9WwlV0ghoKAZ+ZmQ0wLgxIgYaaDxzq7nY09JANeZS8yAMw5IHRYx9LnTY7B9MUEbQQMLPyor1Yn7f6/++dNE/p/6dP/9f3ullTedaf50k0PQu8hTPZnRURa3FVQjEe51EGAAAgSZA/IsQF8wRKapLmu4DgkGToC/HOkU/Hn4l1CuQUT/+5Rk9QjC4mDEM0YUol2sWHJtIpRKlGUQTSSwgWOJ4g2dMKgCQEp3WZy70tNhz6h58c837+++v6rfY/WnzGzuyfPQW0IYqtLyjSRgTimTCgUhssGWMBhQO2SVi1A1BgUxxeMt2OIIXDmYHnZucEAxeydEaxekQNkT6OLRIRaqQQ7nOt06Gxu9aIhT/Z39VxfVdVtNu459ouQFDrHKMjxVTRORIDGvMmASLERPEShUTPbqFU0nFABZK11UhYJMBcycQi3c68qZG+c8DH4aGReTIL2V8zY6YTuwWsiJWX5hm7rb3b12/2P7aNNNBp9zPeKqosMJfiiiI8LmwcBNrAeBpSZAChsjilIYUamarPdK25kzZSHI4zT9sqiGjUEo6qRxvRH5P8EAlvF/KXsFyxIGhYnFEKd6v+j/d/QL11ZypTnBivSt4FY4uowkaLuRIjRpBQe3MMuGhRIgASOUh0h0giQkRdSpGJW0ZniQyZRjK4BkAAYIvVdZC5Yh/LpQXUj/+5Rk7wyTBGPDC0wsIFNCeHlnZiwLIFEOTWUnAUcKIhmNsOCdt//////7vfHjsWYQUIWXCcIQkMeGhOKwgRDASDxQPHx6BIBVl4iRgKGa1UcUuTFJWuQxSUI/wqapX/UPERVn7Sy1gfbTollumcvBIGkSy4iJYqEAVf9V/+vWyt/k7/+nq/3b/+mj+j6/dX62ZER1RazMp1Vn46RnM1jJ0wJXLjAcSAkAKYE0DkteYM7DrXEbQp/CcLqzlBKaBXQODslBpcfAvNF7VIYacJBQQQaZmYD/t1+3/7f+7N9/T9/5/2/1/5NP7siNMlLa1M5+5LId0SjxMQcimd3HqePVbSQmICKhCHF5uRKaYmkQWikBhgkdw6mn260sfaKl4QAKXxjEAPmVeKQzqznVxgui3X5Zzoe0ef/+5CIbka3neeVf/GXrWl97c5/KJCMnRljMz7y6PTARxI0pnEZbq0BbS0YIcETkJycmGcFkAEAIBVFesuejC23EkRBaLW2Kex3/+5Rk7YzCkhPDk1lJYE5ieHBnaTgMIV0MTSRSSWivYYkNFHmSLCtLlpUnDuRpMfyXagjFvMzvVQt67//////R9qlc8ruskj1I5TQkHjIcOPC9qEgLAExERwZM1Cx9PMvmi4i8wEGBbNHqZqL+3mjtqXWgVGQxu8MtEluM2ebKlhmU37Mjr4Y2+4yvvf/W84FF77H4/VYNTyNtGM9Uz/ykfGVQoamIwBeLY0Vl18zNkKNMsKxBSZCrmopDjR8vOtQ5DhnxIWiFEAiYCJNvAtAY6ynEPMtCsLT871aMySTPwv4kFbMJz6PepHhVGO5B+Ves9f//////796b7tCvc1qUJTS+bJiAdlRiAE1VAbuJSjSc6xAxM1yWjv0IJ40ugSf5yGky39fYQNk6TUaHoN8uNHPGzIlEwfXaB0/JL1xQz9GqmvH5/b6WWueLV6DARUUSxJBbQEXBw1EoTFFhMSjHYB+14tPAzcQL3FqNYIJJEbYta3MZuuwpiQiJMJdi7ln/+5Rk7YzTYGDCi2EeYkKiiIEHKQ4OtY8ITYR5QP2J4kgcsDjlW1nYr6xzs5d3r/////0/31on9l0syUkfmUfa/jlkq7f3XYn2sFWssKgGPKtOU8XulKngGPR6/FO7eeUI4rUk4siXY6XJHT1Ka/Zh0TIRDR5A06f1X9U/+vv//9f//7//f/63fy/6eSFPt/eHKUT3OnGOyteMWQ8XQxlmpAymdjTjJQwYacsddghgx5PjVWxqXPSx5lpgpaDjsAJluBQx0NYMed/2j8JGyW2jrpevpY7/2Im3z//cO9anBwJvIvHiywwegQ2GhwUAYufCAnI1ACKtAUOSfzVTu8AfxMI6LdzA8KZpbNYUktHQIlFhYROEpGSBReDpIB7KYvnEZufyPx67PX0ShPR7G3V1bBZSFwEt26tmLGoACyRQmkLHXJTEAWZ/gPzkAKsVOg97qtzSwJMo1jvUPPk00oK4pIxK0YDNMJx8eMmdk2Y1JtQ51f3Dq+hWhOLa9fZlvXr/+5Rk6YjCuRHEM0xMAETKyIFoAshKxX0MLRR1yVGJocmNsOAti5cdeqmulJrH0MNCZYQMuOghORxVYvcIHc0Jxd9sIKLxyuHp964blsAxlrpMCo8CxWLJgFVCBG+hsri084vQnMMgGX379O/obq2S6+v+ZCyU6UT12Vcjfmf222Qqse2+dHaYk5rtEmMdmclTw6hGG8o5COMRzlItijnBxMKv6BvNMgabOOozl0g3DLsg2eRm3ymqS29bOZ4vWYIWRj45FM+GOyAhDAwzWEg/+366fei+/0/11Wr/9LvezJ+XV/3p1p/2dKKzI9XKtGQxuHdStRlZVVigk0K4hVeYCaxj6OJq4hDQZ5KVPjHoShUczNxGTIdVyvGKy1SmmLXNrFgabbkvKJ/5vas39rJ///26dU70tZOn+n2/r9luivR3YfTZxVV7mXXvFtxfTAqM8uAgbkAz4VQBkjSDRDCpFgUpQoXH11JuxEn1mXhYkMBgjciCHbJ7ISEsWQBcLV3/+5Rk9AiClBRDsy9MAEsieIJjSSoNdY8ILbCwgXEvYdmdCLHM/Xr//d/yL6tRtW8olesfdOBww9TCCSFSg+QBkEXHAmFXzdRo4QNOpDM/XY6NAUVwL6QivYyuJy8uQ2YmJGMRjQB55icu2r27tQPOwgdYIZqf1//f///0///v9dfm0vTZvVfbOfhlachDxTudL8G+HBqbrbVANaFNsNQFUIdHHuOSTgYrEzxoZKZqsqkRIIEppbhKI9KG7KowUYMACxcCPxO1uYc+C5Zy9jzAGrf+3+///////tr/z9uxq21+haZV7Feb5las7S90lHcqomUg7hIxGiWUH1RsMfKoFYU4Ko1RIeBqmLxmFyF+KR6Mo3YJQybkBGbsl3Q1A2vBmUR4zDVIU5xyvL7X+vf7p231XrqZ//vt/+/U7b6kStWardxBXRDvIxTi8c5JKMPpothiGR7IVAsguWKsOIRXMKgwMoBrBKQvGfDRyBLPYqoYkWEDP/XoprJs7ZGMgi//+5Rk7wySo1LDk0YUIk/CGHZjRhwLwY8KDRR1wV+wYUGhDvkT6h6duY519bjFn/t5/LfZ6/P+X5f/9//p/r96/jM7z7rmpERHlxUiIYkjQiXNpEKKbsW0YRkuMEMINIHagyHLSkSEy5B7WxNSApQmGQrHvthUpdlxTJQVCj5DjdT1yIfeSPchRH/b/9//Z20/Wv/6r+3r1/TT9H2T8l9ne6t3uqlRHZX1ZQ1rEQFOxR5OPN2FIxpEDmknICNtwWZ/IcZgFYurqlsU0pWBo58wGicO0A2kPdGhqORzonFfdRXn/Nf7ulD+78pXDk3Nyq2XhJIBe0u2VvcGgdGiwlWESAkeCGCnGyAQCV7SEUwte7OPewgmpfod2bL8LajAByi0C5pVN8th3IFAdBHrSxF30Cmm8q+qbYaASmPXo9njayYzevF06iY2UYY4nQsEk3vAEHVAGRYCWFEFAMpalEGukksXlN+zblK8HjiZi0FHwBwPLtsxZfdZ0sejrCLVK/r/+5Rk8AyDNWLCi0ksIlbL2GJkI75K2X0OTRhQiTsJ4h2MmRi2Uct00UzhRSlfe7MNJaqKb1gglVhUThwH1h8JrEiDQcJExAlVQdgphIAgRIbs1fEIDD4BxYxIqZ9a7cELjIYQju2Js9JUxpcbjvjynlYwaV/9va/3Z+23/7+n+ZdkT+del/fkRWVGSvLO35vR/o1+/29p5mvncwixkcqRerPLku72KSyehpUEFoAAAnj9EISahpUgDhdzfxsRWi0ci3vC/L3EbKmkG1lHNNn+nR0IZTLouv/r/9P1/9r/ujfv/98tbeqL0z96VMtKrd9ze+jV2vQZb2lPaMHJBSkGhgxuAAAIjpAq+Q2r2YSZaLJWjLFQ5ldX16m3hyf1MI1HBtcWvUuvK7jYInC32cU/W/VYo73C+9Z/Tt7iu+39S9VyjZNCosKMQPKuLH2mDJQMFZKdDYqPII9wH6U6SxNWABPsUeuWAwkWii1NXzia62tOWtETXjBKqIdOSZEMscL/+5Rk7IACag/EuDhIcFICOHYHKQ4M2YkILRTV2VcuYaGUihG/dW6t+r3d8mlur7H/JjK700tUl4hQ9tBc1RInGHA6ITAaEAUE4GICSb8ypKENDA4Kxd9QBQ0Ewx6JL6GvfquC77dQLSDAROMI0GVuTIK7AEEx/tO/ZX9TzfF9nalL0K+RS6MkIooY0XjhEEEhdDBQ0OLlCANmAGLmCQODRAYGk5CQB2o+ynj1U0Fh++txpbbU/L1qC4w/8HmInB3oQmptKypyqDcXu4TY1N+1O+h9Tv6v7//sqqQLulmng4dtYymKsQ0KY8IAgsN1AAYlKSNIDWZIkm2YWAE1iVMAFdSayjlNP8EQQ6D8iEwiQAcltHNV8VkPettbNpuPjUaXClAoihS5Orp/pU8bopqQVIMff9O0mulJNiHsQyJEQoRG4gBeElPLgLSUNYmQsISpRTFmvOrfjEUJMw8efcaChkoGx6yDc+8h7WbteD1yHHGEmb3s69P6Brf3tuUPxDn/+5Rk7ImCpxPDyywcEE+B+HJnRlQK3EUOzOknASyJ4h2NJOAYhWaKqHJaVWNMDCVig2NQ5qSGIj+A5UAhALZIlQv1MW5YypQyTuGYWVlExA0X7TgyixhgBDFFh8RGhq/XbTfVV1/1/0/09qKrbs1T5+vT1cryZ0mpXP6cuZFr9IyMO4l1hC6pO5ORAgS0QghmoIESeKQyE0mMGciU3G0SK9+A6qVTM+ypmzfFFDu7PwxCYMlJhYwKMCc5KE/rxkzUNQYaXB6ldvca4X+lEulKCYC1XVvHdC47ShBisUx1MSKKBVEst7XAcJDj7SBxBJUAAAl75DWbWCnZ5ACHTEsRNC1coWTncb92zIIfGFIsJBaF4YJosgsEyp4OP96nZDaN9SVSJRjskhqt791Owbv1aV20DeAyBBjSxE8YCpEBuDsDOJULIAmqm/YOzgQtFnATkL+CZC7nzOCnSZM1UEiR8oOMhnIRwENYIrKF/v9M1Lv//637J2rmZPpr/6f1723/+5Rk9wgCkxPE0xlJwEjhaIMHGggNvY8GLZRzwVCJohwdJDgq/RL/mpketpmau1X5mg0Rkd0KoUppIKUYEC7oYMCYsBlTPjV6L+LymItlbRzMPlTwspaU0owAJ+8IBsZTeOt05joqTBU+3Lp1p9n3/7f2/tXy/tv9idEt2rS2pfsDgw6nTpkRSmaVhcjz/IQcqGAEqBE8I+OAL9oQhA7ZIQlA42IwJkJSKBBI1FMXFZ7VXkENEZTGzCVsFQMutT1/nL1u/O56u/wyDf9fnzl/y7/z/6/35b3vS6xDVuQJXpqhZyLiCzKrg0HYhKHtA4McoWLAhS1KZfTBuMFyKgFpORogcrECijQOuWhe+AmsoykbIrH1aGToqogTYXY0hJ01I7irWZW1BC78/42R3KzzVrUnLaFoa9z+q4WQl9K37bHXh+Wh5AsoEVp1oB9MNCygCBBKsjRAkgW3I37LY1ZIn2rKPw0l/P6eleGcET7VgZUeEpOhYi6BrHDEK3EdaNP/+5Rk9gjClg9ESxpJUFZL2HMHQg5MCY8ILQh1wX+woQWwjvFJPIfoVst7N6G+jUxghH1UN3yY8uZHqGBU84JAAwkhLcNNAdAVydx6HvJbSeWtHc4hEWG6TWOKgp2tWbVyctYY5znP//aAv0RsiMvzy+///5v/+ROaOcGidfMliGdJEMjJNzMEoH9qoODQzC6GrZGS2mRJuoOHQYgZgijiqsKo6TLZmIpBUpUUWfgxYsfg0UZkONZZqlTFxl23GB5dXwpce1I6AVCnqjf/////Tt/r7L/0f/Ry4eVaKiw0spdSdI/OPkv9L8SlE9jFwcBJqQpIYAOdEkKcjA8ZmDsSVR/0CCZ8PFENIBXjr7JglQ0px3Nf2wzqExohKW0jmjrhhM/q319l+nb6mtrX172Ikpns3//zOn/v6UrTrRedl+2fQ7yISV8zOytRhJDxp31EBg7ohWO6adgDScMr7ZfGBI9Tx3PWbzvTEB3QGBnTpruOuZ7q2u55d2Ea/+f5eqL/+5Rk7wgClBREOw9KoEnBWJoHGQIMWYUITIR3iXyw4QGhDrH/n//Nr79+a88AdovyhRNfbmZ+Yenk3Q6qZb4Efkgh7mo4ZlSEArkVUEjCUznRUbQAtsCuzHeARDfvQ5IVRK6rW+YUzCXrutaXOjPlbIRowECun+RQu7Nqa/cm1KHtd3t1+hFKLXjJbU950yi28KMEj3EQWHDQgw840N8GXC0B8EoIMYZL8iMhUdyU1rsobpbkAKODoJ+Dr+eOH7piwkI0v/Xs//8v/zl1P/+WuufS8CnXPy0ff8jLPJEctLkOkMjxqY0M0LIgpvli1LNUqgAguOIAfoqIQ0MZwkTUaaCxyo9Gkxt1ewxXYaDfVaKV2Y58An3FjO9jKxGLrF6E11Xqk0XJaz2UOe7GvnHrThFIenJgc0vACg2hhwhSCSi7oZHmDJ4auO4BjZxC6DTyy5agy1HwtulvYSuQupOlQAERq+r+HO/lK7/7w7yBf785+nzL85bP9b/y37Nuf/D/+5RE7YzCglvDkFkQclwMOEFoI7xJcEcQYORBwVGv4UWQjrnOCfAKRyiCfEd/IOixRsZ1U1cQJ0OIW5A4sGNwox8IUPGjJEiBv0OTNAYQEXppeyZI8OPSV7tWVwmUxcKQw42QK7flXRi4GHFPLjWd8ERrWSZpP2RjS3uUgV3M3otd+6LKoAghSBjziioJFlqueLFVjMayOhMyBWYLhX9Z4kiIZYdZtWd5QXDTtQcQDEfoRc/+7w+lYpCkH//9////////7/53SsyfLy826Z/f/cqUJ+mZKUqnAdSTFSadJFtIZyZmqsMEZg44YNGMNlJMZsPIV25fWvTMRZK6LGjDDzegHVi0p32lxwjMW3jhzqIK/r9+//7P/+uze6+zU9lXd6EVa16ostmRkT51eQjj7O4Oh7MzBa07VnrauVt5Eo4yWKwCY5ZtwGIOsompbd9cSEmML/Vody/MRMhehDKKrG5NIhCFZb6NlE2f7m77iWVbAc81z/+roRu/67lo+xf/+5Rk9QjSoQ9DuxkyoFpsWFFoI77KED8Q7GkqgUEwoUGgjrnfF7d7L9rL2jRqQDvysaoGTDJJbVpLHHWI+mzyWpLYBZWvBwk0hYsNt6g9taWbc9GVv2deir5G0v7eRN/v2//rSmv2/zbV0ZDIzdpKq2LVFQ5qODIxyWBNCpcE+YJBB+UTRl2/oCqcDAzKhIGxCZLoBfSpCQ3dxyacukU2IJSo4pnS7v/T4U1nmeOXMX///L/7//zX85eeisg5BPRZ1oPDCQmtpxt23qPe9nrMKz5DSW/9Zmf7jSc/dZz3EiFIaoxVEoABAT/QP4z8mJAwoOZgeDX2XmTlY4fnH1VItLUdyhPK3r+95q5W/e+Zv/xcl13WdF/y/9Jxfl9en/y/lyM6OqkiyFpFBIjr8zScU0NIV+Itru6Y4oGQA3UKo4WLBQGtGRwYGDRxmJKH9puVo4h80p+ixSWvQzmeWuZarc/G7zdf/l5/v5ev//85+uXLFlAcv22s4E9PmbklsvL/+5Rk+wwDLWNBg0I18j0iCMoHEAgLWW8KTJhQiXoxoMGgmvEcT2Q1y6qhTIx3QxDPubNFUnQEBsEEEEqAZXSqeBhTvGM3B7H/XoiGN5Tt6vdd19mmSsOAFzorVim4opQICsliMf9divRvf/6fv/X3PZUS3/9KeH3mqdYqus87tuhktKmKoWqDoKUOpG6AgmCZA4JC8mpKQoDD9Eg4tMIDGlDpAPuFUjDwVIdJGHQc8QLK+UWWGcaZdKXlMNl1SPet5/z79v+fn5n/Bhakf0WfrrrP80vyv/+Rn7kcpUQtVXktmdOZIEhEbEQ2R5CYtrTppZnXRKYoY8TVTEFNRQhACvVISKFIckELuhpfBMselSOvalE4revx/AuOFtdJqxljWxzlVn+5c0QT+cpXXl/WVLL/785+zY/qWFqTvCvzPWdwxdKQqzNBJML1xsyhDtXHhI4Uw5BmQJAQgYSHguiA9AxYsjEIFGlGGlbm0BI9kYCJOeZ+fyRCd3vPymYL0ur/+5Rk+wDComHDyyEd8lxsaEJoI7wM3Y0GTJRzyV6xIUmAjvhxqTc+IKHbNP6vfWHD/6Pptt+2Tzm3/czr6qU6lG888BERkrZGiCNJ2IOOWofp3YZGZUks9d5HbblWRQRGobVAzAwZBRADHtjFQlSdDPafM1GFagFj32kKVlgnNHh1gokYsUEAtxc1VeK3i47EiGtWLsMiW8QBCIljZAtQ6Hbd23GE+Wep42sfwzkFPC1oEzyAzLtOLBUK3+yjmk61G6a3od5qFNzIUZajbbGWdu/Z1Cwhs6kFWPc1igqkDtVF2NmSFA41GIMUtGIIY8wmt8kMWruEIqyLUVv28s/vfMg+zP5rUuJ/WVrl/XmbMykydf5Vf7nn5J+ul/wZ3pvO58rvPKQ+iPmOAkVjxWnBycGJoukoZwgsHREgzKB3jGSIc+yy47ZmsiQC6SYKrP1e0sJadcLhwJ3Kmwxsc/weqsjDGfromdaX/bQrvRFsdO+RE0Ps7ulF6MymG7fkVHf/+5Rk7wADUmNBk0Ed0jdB+LcF4w4KvD0RQORBwQwH4lwMFDhV8u6b9vSD96IbuTDz3LUx0nvmXEPMbZWtzTYfaRpdiNZI8GNslIcwB+0C2QF3xwe97dHIC8ciwb3vHCBqkEEEZLilt4c5jvVtXLv/nX9Tkbvr+eX0Dy/5df9N/I59kJ3/Gvp/7vv5lTMxPJLGciz61yMr5ytVpEJgXSBzUBoRgsR+Z9xJaoY1OjwxpsKe4xIGFCVnJzeXcseW7X9/+z/83uUjNZ+ULw5f5z2Ti/ZylUw5fcXe8ZGJpGssC84zQLFy6cOnSLAzrDGLBssKSF3xM9UATf8hltTuLPIQESqJKsEfZSBO1tnAPI6pj4RRlV+8PFJkFXChqjcrbdXzeVi0jooZwS7EMFiQHeqH33vKChtcOxBfS606KMHCFgMNLCc0GDDP0Sjlujnbo9P0uJlzDIVcwnIAlF0vMEFg/F85nDmG6nYjlzlj/o7z/9fnsZfn7/rL7+LPS+NlnmT/+5RE/4zC9WJCk0EdYmqMeDJkRq4KUY8MTQR1wWIxYUmQjvlDBMCDCyGNqNbNxu1vuY/46E0bOTnYcjH64MKrmGfSOi8bqyVlokTCfW4/QAY1srfRfQHt6+zXRTUpMn7m/uNEoZhW0oFAi2pkLZm6fp9/X/9V/9vfr//9L9Ju7S2dfs6LuvmfnWrO19CFoh3rb5DFKhBAaiMjIGMOD+QN6SnpRaBUsnrNoOhjzlffPr14EiojlIiJdY1zf83WUiHRL/+O7y93n7r/I785/l/zg/5n8qUjXyXeSVyK859IjJ0UqZ9JkSs6Usqb3LDhiBLI1sqhUoxREBgr3OgngItZGYl2VypJHoVLFC0ZFNg/DdrVTD7jl5//r////l///T/Kee8fcwgRsvyU0qMfEPmUrpDtQ4t2GMU2KWChAkKewwkBFBCHEAwEcIAigCGAg0dbGiMOKd7SLaQ6z6QCn6TJsZ75TuDH4OCyYrDbYtwZynjPcSN0oOnhaD6EC0zekaP/+5RE8wjCjAxDsynCkGJseCBkJrwJ5YcMQORByU+xYYmQjrmU7oWwupKApP8gyLmUTe6ppQVBp5ZcxcVehFiCRS0UYEnc3BS7MGbFR0olBfkUjkXWk7UmsnhkDviiceISy7rmtYZ7KcNJffl3z/f/9/+8WWv+Ymb3f8y0pc2+fw519vPft86mi/Op9stszOb0CvJbM9VGklUYOqTJMwoO7LBZg5EZbHoefsLpGoyDmq0zCF9rqgVRmhpMs8d75kM5TN37dd/9v1v9v7/+///+1+ikYOS6dTK5GO2/Xb/M7Z71sqMzJamz7Bdvk4zq9syzWNt0b6gKoSMlagAicoGOa2Q5bPFdwlp0OlQodXlTLL4aq0xfxqFDjj9Oh2XL//PXc4ET9Z3y/X3Pjl5/fkS+bTizItTOlS9y3+rKkY6NQRCzuwhRJ0NkalDh3xAJmDHRIajDoJP2ncgeZXhKK9sBOvGR7V+LfLnvqy6Njiqwty5Uzzz5vgy76N/p////7///+5RE9Y0C2mLBg0EdclNh6JpgJoALVY8ITQTVwXExoQWBGrn/q/6ddt2pckvKrVkmV7vk4zNL7rS3ufZutVZMxlJHdsfTFTCOzCeToEcYMno8nlxTtIMuwtGB5IwwEFjMKt8xoGAO69hKRCiU3t5b/mqosgbX////////56/5fORSJgUBZax0iz3yPw8dzBVhB6gtn1F2yZ2vEiPY5qVB8o8EQABB1t6bFDwNpJhGzwtYaB0DZBS27daYjUrBBiLdzHetfjnkq5v////////+5/L54/NXxwSMz+AHw2O/jK35r1m00Fslhk5KbY2pc6XLm+O50xLRmsV09z04N9lokuEFohR6QM+CrYQxbx3uONvBj5EoQ+pVzwxv7/9jec2n71ZUC9GcL6o3aOsz/kWY5/qss7m5m7RmzLcUXOf40+vW1b/YfcTi93sTQbyzqGyY6NGsmczVRxfN3C1IkawAEECNtADW4800KuTG1ZgVVdf/W3CA4bWIROIEp0uzcjv/+5Rk8Ijy1mHCMwEc8ljsODBkRq5KjY0IDAR1yVKw4QGQmrlyjPFMxuq9VNX7H/+FHI1UKGjokQZAqoqeEp5UQCM3ya27I2AMeQbYRgg7pEgELBkq7K1D2s/wasYVkbhHQ7eSExBVvSQTt1fkLS14mS8h/pXey9l1LEtizd4YkVLOLpCgQvID+Q2VgHQ+WV5C10iAkWanq3K2p+GLQwcRYWL3dsjwzrEv/nl///L/9/f8sss3rCLL+3/32Nz2Q6V08zaKbEJyaE73YNnjiwa0YQtuqKzKDGCtgw4YYJEKEAIEpyREDeEACyjClRiRt0ZCIISaHnM9R5fTmPcOulABPM0uKEHCPyYzzvrtJJldGxF1/vFpuhm3UIzq1yLVMb1T2jdY6hxGTnlmVSQ4NtT6U9k7nwsjPaMryWc1epAawvZy1HKiXHaoD3TEpABoLUliIHe1W9OoGeeCriAlq79KYYVLZT+JoXmuHFgzcx2pKvfVUhizpWZL3tgSuha0NVf/+5Rk8AgDFGPBiyE1dEGhWIpg2FIITC0S58XkwV+xoQWQjngK0oatjUr991aMWTsa8gMJhoWCIHY8uBSuPXqUmMLBcaTUbviOMiVqW/oMq7OKYLDiw8C7/fM9V9GQam3/P6l/6l//zgL8+9k8qoj/PsNQWphuE8MsoU4bR6ZQIY/WfI6ISI4UICNKc3MNmw70OHAAj1SEMPQQsdq7aThB+Jb+HMkqBFKiPFrv4R5pTOYcHQhMHKdvb/X8uh+Qj/9//////wS7z/zyCMEi5kRUSMSRkAzJv5Xa4pszq739M8XKS3hE06S77Rue6yT0DlQPvUTiFaU03QpkDL+O+BtjB5vrHAv0WXapb+68AwxAiUseoiPpfxf5EvOv8//zryqnMzdNK/z/r3fdc89cnSszMe5UbRWapiFUznMtSuibGV3u5SmZDqHB4RnFzpRtogFwNcDyN+a5PAogR2c2w/eP52TDY7fQw2cqkuha0pptXc1zOoZSCwGV1Riw9elbRqH/+5Rk/oADZWNC0xkZUE0BaIph+CgL2Y0GDIR1iXEw4MGQmrnIoUw4MpMrUOLnSw1AROizHgZBcaWULEodBIgIG818KXhQYYQhPvo3g5ZHk2r0/em4Yd+XKaiRyzq9+Gsc7ucOT/r/f/ef/8/z/f/3JmWaMoLqMSzJCYrrnoMZpsvDItDQY+T3p6aw3imUPq97G5sOzJyQvrm8TD1mOxsgZxpVBFlgnmcgJgVOzubjUTvTQ9q/a4dSA94PsdpxS2dSzSYS6xZWinrVpOkW7UIRfAGQWfkJrdsWKlRYzAwuJioHAZgVaNUIMKySy5zCJCF52G2EBeuHPuX9YvU+kbFCAhShw5+OPfq2tfzX4/13/znr41Ov2XNe6/hUyIzbaJGAJAJIiNE1MZNw9Z2xbulMFy1mz0ZKkb1xLtIqwMvJzrbssw0uLv0QosYdBGoAIAPvUP1JH6TnZnlSqtC8EmFS/fdVpinpnnFhvedw5/55nl0Rojnmf998uHXa5k7eUiD/+5RE8gyCn2PCkwEscE9BeHMF+AwLlYkGLQTVySsGIhzw4UB8ym/yPy13K/8hSyL83RYX+RHkzpO9kdKKhHuqEZK+tZ4IrAGOCE26kiB34MctOZQGjqwcMpLtuLKCbBPgRziFb53v3WtTRCRrv+7RLVd+SZ/W3XrU3OeYgng2KiwAAwcD5Q25TTgMgB/Z6ndRTTUNuqFMIsCp8sa01GHUsiqMiGX949odI6/Z//7/6V/0///v+t+ttXLPz/Ne5r0prz54I8+O5tVPJVmwJFJLeHhw0fpbLUygt7g1UjIMJUxBTUVVEDelGlLzaNFaJDlIQIuNL/XrauS2jlgUCG0c8MN/h3uV7mv58eCtSRrLL/8vX1/+Po3cpknqd09RmYU0Zkoz+cpvGef5bbj1koXJNfY/Cmg76zmrc9zi30H6JlDcRTBjAMmnowfgvtuAyDWUzh8QwAQ65Z2X6zj0Jfx+yGKpbX3Y2akMsn3X/0eD5dfH/8Yuej83nO+dbv4vd+3/+5Rk+oCDLmPBCyE14FhMKGloI65IHC0Q7CHogVex4QmhDnj9f/vtOcp7nvCHzr5bvg3Ofrx0EO3ty2hzGNVZvM6Pk2OSraTQuXFiUtCXJGiAWPP2DpBcMzarA4y1980smGF6tFhhJG0NK0tdeFTToSSmRFwJCy0BMXdcuyvxk4rLuFXFndConVprFxVjlCgwRBqGyRoeoqaihEXJLRksZAkNZwEgL7A8pJeE63++UVJaIFy8FASo2K+mZ1aI5JFh/tWLrurU11ikf6sZXnuhPVsQXGklCBbHw0FGHRYQDfGNvMAnTOAgaUOQQ/iwFLhbzqzNaMiAdZ1bD8cMsfrLo/f+1hJ6rv1+frXl1L/8zCf8yMmzxmQJGFaZ2mm8/HfS9nUG+w5ana9zPUw27URztZ14g8WOJJECmCC7tFxX41YJhtNLnGBMQiJ2+d1aYXgwNhQYMxsU37wy3W5vuf5f8/+quc2v7+Dl54IJfLyESczA6EejYPy2zZxDU/n0z7H/+5Rk+4iDG2RBCyE14GEsiCFoJp4J9C0O4OHgQP+FYlwWYBBxMOdaS1Wz+zs5ypxcmajL2omcK55xEDacZQAw9Rtj4mEAolPSBWARXkUssubpZmcmKODnmlH/tNM81lny/Rv9a7///y/nXXNLVmpOT/z/LZS9q1LrnfohVNXevsgSrEU1Bhu+BCHCiQxLVHogKEUdxARxVHh7ClCzdDLJQJGVpCkhWDLrvL1V/J687SA2/dxx/+aum6Zye/5n685FOtZf/9oeXyy6vTfx/8Tx8r9VBrTFwnLXK2hGnHUVtJMFpKlIkDBziljpFMcZweooEZawOYbIekg1jBLXjiIMKdt+xhlMC1f/OtELEJgGIVNd13ffzFd6+1/tr3/383/+//dH/J6UZ0psXI7m8EWYrn7LyNrWKbG9R9mLZ9P73Mnztu+8gyRCtjqEaHNJ6TY1xKAALIB/Wy2AMCm7F7DiiupMpP5483lFH6Z53+81PNZuX/zP1/5n/nz73Lq+/57/+5RE/4zS5mLBkyE1cF8MWCFoJq5LYY0GTIRzwX+xYMWQorEF/+R3z+/pbTkfy71oFpIv5q9R7k4dUr1zClDM2BPQjMYIGHeC6CFFLvJldxnthah+ppu0oQoncu37V/uKHdoN/lfmLZStmv8/8zXU/z//y5/lmeU3D4eEu5f1bmzAyheUI5oRMa5UFeIY0ORdQghwgQabwIodw7uUuTWChtwOK/VetDcBPhkhGJIrwAVSZLPZ6/cbhl2Bgovy9hvwqze+f/y/1/+vnL1rMfpHVcxT863qunji/m5uofHKOqqiuyaidUSqIqUsgs4YeehdBxUl0IxVjxBWyKl5ewjJehDvCY2AIccZIGO5uLjgkAdFNYOwTI2y3cYegXcZ71Ua3J3FAES9+7YtTFatVvb++YRyrGqh+SsH54mg3UYNlg+5RCbUHEgOABQd+DVfiViAuEWFwjGKkeZ7rzl2XRQkQVZSaz5na/r/8+///8l//y93/0I7//vmXr2zLK5mnMP/+5Rk8g1C0mDBiyI1clWsaEZkI54LAY0GLIRzyYSx4IGgoniq7HuRq2xCrRscydAcAzjoEJAw40FuaCyAWBEYUdcoAVuNVboMHjzrZ4MhaSg+5/e4172V0QFjSfM8Nciak4rGCNq//XB1+f+v5H/WzzX8uGdh/T/rf+v0rGLg1LPM3Jvg5skfYRdBQSAmiOarQoVGBipTASgsfkA5qOqcgp9PGLU3BimP5fztBI6KJDjyLFrD/83+zlwjVJg6OM9Vy/Ly9vkcvWa+Xs/bMrFmvD3Uv/2UGUwZT30Lifk7hW0Z1UjFswmwzI0tGJscI6jKISreTRUmzAQM9htLTZioqToXv3nYlD95KbJ1TfNe5CLAP2fPf0v/+f1//P137vXy7nqp+WmOIfaa51HPwYly0fFZhOkGxLG25yGDbFlq2ZxitY1A4qbRixxR4T1JvebY0+E800qJfUSEcBPDb/lPyIX28EAZR9vtvhkYxL1fn/9f////88/7+dmH9W5x+sT/+5Rk64TCFgrEOwF6gFWsSEVkI55LDYcITIRzyWIx4QmQjniP/DFmXUHhpXgYKiwj0jItaDYoKCJwwYeA8MCCDGJuOoIQJFQEHjhJiW1NwKgKQTnbpNVZyKIIqeEtci87LqvPjrDXFvdx/v/r9eT//////////8X/O/34YjQv//nbVV62e+zRaNdv5k3Nlkv54MsiVZJ2XPNImgx6LJVuEpwRk5xtEkjOFydK6U44SZKtPgOpWFyUrA5KVwmCTAGQasapCi+pBXrShYhskHhSRHScOBoQjCMWFSqaA+hRJoD6EhSXc0qk25kNUMSzoQpY4x2EatYayUjWUjakatczs/X6ssMtcmvSZausPNb1Z7MvsZNtBRrR1vBf8Fl4/xpo2gYAPVqmZh3Zqv0o3AwpxomhWHeCsQjJYtDR7Oz09UeaGmZLiY9UBT1bvBXDXLaLg7lpUq79eJRnBoGZcjQTIU2QmlCpBRpZLpk6gKKER4ApYROtLHiXKhLWJYoV9Wv/+5RE9I8C3GLBgyFE8lsMeDBkI54KgY8CDATVwgApIWj0jpl1oLeWDtoUPes6hly6zueDsS8io9hriUNB3GPDCgoloBCgoCpRstUAnAQHUSTcAmVGcv2VV/9aWqqu212q5xjVZI4mG8LIwk8L0T/zXdc6WGAln0Kv8/jUBpZGq6nVUmNf89VL2oCVJjqk2qiS//YwrDQXEBQxI1VUaWqnglaJ0ZnIUsbjOFEozLLDhrJUFUmZpqv9Vv9mjF7HV2XZv9s/2Paeaw1JVh3NZ3alqp89m2L6vxi1jBjFS8S7FguQVjiwFeb/8O/5ZkxBTUUzLjEwMKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqr/+5Rk3QDBygs8yCEYED0hV4IEJgwLEY7GIYR+QVyl2chTDDGqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqo=";
  function clamp01(v) {
    return Math.max(0, Math.min(1, v));
  }
  function looksLikeDataURL(s) {
    return /^data:audio\/[a-z0-9.+-]+;base64,/i.test(s.trim());
  }
  function toDataUrl(dataOrBase64, mime = "audio/mpeg") {
    const s = (dataOrBase64 || "").trim();
    if (!s) return "";
    if (looksLikeDataURL(s)) return s;
    return `data:${mime};base64,${s}`;
  }
  var AUDIO_SETTINGS_PATH = "audio.settings";
  var AUDIO_LIBRARY_PATH = "audio.library";
  var AudioNotifier = class {
    constructor(opts) {
      // ===== Core state
      __publicField(this, "enabled", true);
      __publicField(this, "volume", 0.7);
      __publicField(this, "minPlayGapMs", 1200);
      __publicField(this, "lastPlayTs", 0);
      // ===== Sound Library (name -> dataURL)
      __publicField(this, "library", /* @__PURE__ */ new Map());
      __publicField(this, "defaultSoundName", null);
      // Legacy fallback (pour compat)
      __publicField(this, "defaultSoundDataUrl", null);
      // Playback logic
      __publicField(this, "mode", "oneshot");
      __publicField(this, "stopConf", { mode: "manual" });
      __publicField(this, "loopIntervalMs", 1500);
      __publicField(this, "weatherMode", "oneshot");
      __publicField(this, "weatherStopConf", { mode: "manual" });
      __publicField(this, "weatherLoopIntervalMs", 1500);
      __publicField(this, "petMode", "oneshot");
      __publicField(this, "petStopConf", { mode: "manual" });
      __publicField(this, "petLoopIntervalMs", 1500);
      __publicField(this, "loops", /* @__PURE__ */ new Map());
      __publicField(this, "oneshotQueue", []);
      __publicField(this, "oneshotQueueTimer", null);
      __publicField(this, "oneshotProcessing", false);
      __publicField(this, "weatherVolume", 0.7);
      __publicField(this, "weatherDefaultSoundName", null);
      __publicField(this, "petVolume", 0.7);
      __publicField(this, "petDefaultSoundName", null);
      // Optional purchase checker (for stop: purchase)
      __publicField(this, "purchaseChecker");
      // WebAudio priming (optional)
      __publicField(this, "audioCtx", null);
      __publicField(this, "primed", false);
      __publicField(this, "builtinDefault", null);
      __publicField(this, "suppressPersist", 0);
      if (opts?.minPlayGapMs != null) this.minPlayGapMs = Math.max(0, opts.minPlayGapMs | 0);
      if (opts?.volume != null) this.volume = clamp01(opts.volume);
      this.suppressPersist++;
      try {
        if (EMBED_DEFAULT_MP3_BASE64 && EMBED_DEFAULT_MP3_BASE64.trim() && EMBED_DEFAULT_MP3_BASE64.indexOf("TODO:") === -1) {
          const dataUrl = toDataUrl(EMBED_DEFAULT_MP3_BASE64);
          this.registerSound("Default", dataUrl);
          this.defaultSoundName = "Default";
          this.builtinDefault = { name: "Default", dataUrl };
        }
        if (opts?.defaultSound) {
          const du = toDataUrl(opts.defaultSound);
          this.defaultSoundDataUrl = du;
          this.registerSound("LegacyDefault", du);
          this.defaultSoundName = "LegacyDefault";
        }
      } finally {
        this.suppressPersist--;
      }
      this.loadFromStorage();
      this.ensureBuiltinPresent();
      if (this.ensureDefaultSoundValidity()) this.persistSettings();
    }
    ensureBuiltinPresent() {
      if (this.builtinDefault && !this.library.has(this.builtinDefault.name)) {
        this.library.set(this.builtinDefault.name, this.builtinDefault.dataUrl);
      }
    }
    ensureDefaultSoundValidity() {
      let changed = false;
      const fallback = () => {
        if (this.builtinDefault && this.library.has(this.builtinDefault.name)) {
          return this.builtinDefault.name;
        }
        const first = this.library.keys().next();
        return first.done ? null : first.value;
      };
      const ensureName = (current, prefer) => {
        if (current && this.library.has(current)) return current;
        if (prefer && this.library.has(prefer)) return prefer;
        return fallback();
      };
      const nextShops = ensureName(this.defaultSoundName);
      if (nextShops !== this.defaultSoundName) {
        this.defaultSoundName = nextShops;
        changed = true;
      }
      const nextWeather = ensureName(this.weatherDefaultSoundName, nextShops);
      if (nextWeather !== this.weatherDefaultSoundName) {
        this.weatherDefaultSoundName = nextWeather;
        changed = true;
      }
      const nextPets = ensureName(this.petDefaultSoundName, nextShops);
      if (nextPets !== this.petDefaultSoundName) {
        this.petDefaultSoundName = nextPets;
        changed = true;
      }
      return changed;
    }
    persistSettings() {
      if (this.suppressPersist > 0) return;
      try {
        const payload = {
          enabled: this.enabled,
          volume: this.volume,
          minPlayGapMs: this.minPlayGapMs,
          mode: this.mode,
          stop: this.stopConf,
          loopIntervalMs: this.loopIntervalMs,
          defaultSoundName: this.defaultSoundName,
          contexts: {
            shops: {
              volume: this.volume,
              mode: this.mode,
              stop: this.stopConf,
              loopIntervalMs: this.loopIntervalMs,
              defaultSoundName: this.defaultSoundName
            },
            weather: {
              volume: this.weatherVolume,
              mode: this.weatherMode,
              stop: this.weatherStopConf,
              loopIntervalMs: this.weatherLoopIntervalMs,
              defaultSoundName: this.weatherDefaultSoundName
            },
            pets: {
              volume: this.petVolume,
              mode: this.petMode,
              stop: this.petStopConf,
              loopIntervalMs: this.petLoopIntervalMs,
              defaultSoundName: this.petDefaultSoundName
            }
          }
        };
        writeAriesPath(AUDIO_SETTINGS_PATH, payload);
      } catch {
      }
    }
    persistLibrary() {
      if (this.suppressPersist > 0) return;
      try {
        const entries = [];
        for (const [name, data] of this.library.entries()) {
          if (this.builtinDefault && name === this.builtinDefault.name) continue;
          entries.push({ name, data });
        }
        writeAriesPath(AUDIO_LIBRARY_PATH, entries);
      } catch {
      }
    }
    loadFromStorage() {
      this.suppressPersist++;
      try {
        try {
          const parsed = readAriesPath(AUDIO_LIBRARY_PATH);
          if (Array.isArray(parsed)) {
            this.library.clear();
            this.ensureBuiltinPresent();
            for (const entry of parsed) {
              const name = String(entry && entry.name || "").trim();
              const data = String(entry && entry.data || "").trim();
              if (!name || !data) continue;
              if (this.builtinDefault && name === this.builtinDefault.name) continue;
              this.library.set(name, looksLikeDataURL(data) ? data : toDataUrl(data));
            }
          }
        } catch (err) {
        }
        try {
          const parsed = readAriesPath(AUDIO_SETTINGS_PATH);
          if (parsed && typeof parsed === "object") {
            if (typeof parsed.enabled === "boolean") this.enabled = parsed.enabled;
            if (typeof parsed.minPlayGapMs === "number") this.minPlayGapMs = Math.max(0, parsed.minPlayGapMs | 0);
            if (typeof parsed.volume === "number") this.volume = clamp01(parsed.volume);
            if (parsed.mode === "loop" || parsed.mode === "oneshot") this.mode = parsed.mode;
            if (parsed.stop && typeof parsed.stop === "object") {
              const stopMode = parsed.stop.mode;
              if (stopMode === "purchase") {
                this.stopConf = { mode: "purchase" };
              } else if (stopMode === "manual") {
                this.stopConf = { mode: "manual" };
              } else if (stopMode === "repeat") {
                this.stopConf = { mode: "manual" };
              }
            }
            if (typeof parsed.loopIntervalMs === "number") this.loopIntervalMs = Math.max(150, parsed.loopIntervalMs | 0);
            if (typeof parsed.defaultSoundName === "string") {
              const nm = parsed.defaultSoundName.trim();
              this.defaultSoundName = nm ? nm : null;
            }
            let weatherVolumeLoaded = false;
            let weatherModeLoaded = false;
            let weatherStopLoaded = false;
            let weatherLoopLoaded = false;
            let weatherDefaultLoaded = false;
            let petVolumeLoaded = false;
            let petModeLoaded = false;
            let petStopLoaded = false;
            let petLoopLoaded = false;
            let petDefaultLoaded = false;
            const applyContext = (ctx2, conf) => {
              if (!conf || typeof conf !== "object") return;
              const applyVolume = (value) => {
                if (typeof value !== "number") return;
                const normalized = clamp01(value);
                if (ctx2 === "weather") {
                  this.weatherVolume = normalized;
                  weatherVolumeLoaded = true;
                } else if (ctx2 === "pets") {
                  this.petVolume = normalized;
                  petVolumeLoaded = true;
                } else this.volume = normalized;
              };
              const applyMode = (value) => {
                if (value === "loop" || value === "oneshot") {
                  if (ctx2 === "weather") {
                    this.weatherMode = value;
                    weatherModeLoaded = true;
                  } else if (ctx2 === "pets") {
                    this.petMode = value;
                    petModeLoaded = true;
                  } else this.mode = value;
                }
              };
              const applyStop = (value) => {
                if (!value || typeof value !== "object") return;
                const mode = value.mode;
                if (mode === "purchase") {
                  if (ctx2 === "weather") {
                    this.weatherStopConf = { mode: "purchase" };
                    weatherStopLoaded = true;
                  } else if (ctx2 === "pets") {
                    this.petStopConf = { mode: "purchase" };
                    petStopLoaded = true;
                  } else this.stopConf = { mode: "purchase" };
                } else if (mode === "manual") {
                  if (ctx2 === "weather") {
                    this.weatherStopConf = { mode: "manual" };
                    weatherStopLoaded = true;
                  } else if (ctx2 === "pets") {
                    this.petStopConf = { mode: "manual" };
                    petStopLoaded = true;
                  } else this.stopConf = { mode: "manual" };
                } else if (mode === "repeat") {
                  if (ctx2 === "weather") {
                    this.weatherStopConf = { mode: "manual" };
                    weatherStopLoaded = true;
                  } else if (ctx2 === "pets") {
                    this.petStopConf = { mode: "manual" };
                    petStopLoaded = true;
                  } else {
                    this.stopConf = { mode: "manual" };
                  }
                }
              };
              const applyLoop = (value) => {
                if (typeof value !== "number" || !Number.isFinite(value)) return;
                const normalized = Math.max(150, Math.floor(value));
                if (ctx2 === "weather") {
                  this.weatherLoopIntervalMs = normalized;
                  weatherLoopLoaded = true;
                } else if (ctx2 === "pets") {
                  this.petLoopIntervalMs = normalized;
                  petLoopLoaded = true;
                } else this.loopIntervalMs = normalized;
              };
              const applyDefault = (value) => {
                if (typeof value !== "string") return;
                const nm = value.trim();
                if (ctx2 === "weather") {
                  this.weatherDefaultSoundName = nm ? nm : null;
                  weatherDefaultLoaded = true;
                } else if (ctx2 === "pets") {
                  this.petDefaultSoundName = nm ? nm : null;
                  petDefaultLoaded = true;
                } else this.defaultSoundName = nm ? nm : null;
              };
              applyVolume(conf.volume);
              applyMode(conf.mode);
              applyStop(conf.stop);
              applyLoop(conf.loopIntervalMs);
              applyDefault(conf.defaultSoundName);
            };
            if (parsed.contexts && typeof parsed.contexts === "object") {
              applyContext("shops", parsed.contexts.shops);
              applyContext("weather", parsed.contexts.weather);
              applyContext("pets", parsed.contexts.pets);
            }
            if (!weatherVolumeLoaded) this.weatherVolume = this.volume;
            if (!weatherModeLoaded) this.weatherMode = this.mode;
            if (!weatherStopLoaded) {
              this.weatherStopConf = this.stopConf.mode === "purchase" ? { mode: "purchase" } : { mode: "manual" };
            }
            if (!weatherLoopLoaded) this.weatherLoopIntervalMs = this.loopIntervalMs;
            if (!weatherDefaultLoaded) this.weatherDefaultSoundName = this.defaultSoundName;
            if (!petVolumeLoaded) this.petVolume = this.volume;
            if (!petModeLoaded) this.petMode = this.mode;
            if (!petStopLoaded) {
              this.petStopConf = this.stopConf.mode === "purchase" ? { mode: "purchase" } : { mode: "manual" };
            }
            if (!petLoopLoaded) this.petLoopIntervalMs = this.loopIntervalMs;
            if (!petDefaultLoaded) this.petDefaultSoundName = this.defaultSoundName;
          }
        } catch (err) {
        }
      } finally {
        this.suppressPersist--;
      }
    }
    isProtectedSound(name) {
      return !!(this.builtinDefault && this.builtinDefault.name === name);
    }
    // =========================
    // Sound Library API
    // =========================
    /** Add or replace a sound in the registry by name. Accepts dataURL or bare base64. */
    registerSound(name, dataOrBase64, mime) {
      const safeName = String(name || "").trim();
      if (!safeName) return;
      const dataUrl = toDataUrl(dataOrBase64, mime || "audio/mpeg");
      this.library.set(safeName, dataUrl);
      const prevDefault = this.defaultSoundName;
      const prevWeatherDefault = this.weatherDefaultSoundName;
      const prevPetDefault = this.petDefaultSoundName;
      if (!this.defaultSoundName) this.defaultSoundName = safeName;
      if (!this.weatherDefaultSoundName) this.weatherDefaultSoundName = safeName;
      if (!this.petDefaultSoundName) this.petDefaultSoundName = safeName;
      this.ensureBuiltinPresent();
      this.persistLibrary();
      if (prevDefault !== this.defaultSoundName || prevWeatherDefault !== this.weatherDefaultSoundName || prevPetDefault !== this.petDefaultSoundName) {
        this.persistSettings();
      }
    }
    unregisterSound(name) {
      if (this.isProtectedSound(name)) return;
      const existed = this.library.delete(name);
      if (!existed) return;
      const prevDefault = this.defaultSoundName;
      const prevWeatherDefault = this.weatherDefaultSoundName;
      const prevPetDefault = this.petDefaultSoundName;
      if (prevDefault === name) this.defaultSoundName = null;
      if (prevWeatherDefault === name) this.weatherDefaultSoundName = null;
      if (prevPetDefault === name) this.petDefaultSoundName = null;
      const changed = prevDefault === name || prevWeatherDefault === name || prevPetDefault === name || this.ensureDefaultSoundValidity();
      this.persistLibrary();
      if (changed) this.persistSettings();
    }
    listSounds() {
      return Array.from(this.library.keys());
    }
    setDefaultSoundByName(name, context = "shops") {
      if (!this.library.has(name)) return;
      if (context === "weather") {
        if (this.weatherDefaultSoundName === name) return;
        this.weatherDefaultSoundName = name;
      } else if (context === "pets") {
        if (this.petDefaultSoundName === name) return;
        this.petDefaultSoundName = name;
      } else {
        if (this.defaultSoundName === name) return;
        this.defaultSoundName = name;
      }
      this.persistSettings();
    }
    resetLibrary(entries) {
      const prevDefault = this.defaultSoundName;
      const prevWeatherDefault = this.weatherDefaultSoundName;
      this.suppressPersist++;
      try {
        this.library.clear();
        this.ensureBuiltinPresent();
        const added = [];
        for (const e of entries) {
          const safeName = String(e?.name || "").trim();
          if (!safeName) continue;
          if (this.isProtectedSound(safeName)) continue;
          const dataUrl = looksLikeDataURL(e.data) ? e.data : toDataUrl(e.data);
          this.library.set(safeName, dataUrl);
          added.push(safeName);
        }
        if (added.length) {
          this.defaultSoundName = added[0];
          this.weatherDefaultSoundName = added[0];
        }
      } finally {
        this.suppressPersist--;
      }
      const changed = this.ensureDefaultSoundValidity() || prevDefault !== this.defaultSoundName || prevWeatherDefault !== this.weatherDefaultSoundName;
      this.persistLibrary();
      if (changed) this.persistSettings();
    }
    setNotificationBase64(dataUriOrBase64) {
      const du = dataUriOrBase64 && dataUriOrBase64.trim() ? looksLikeDataURL(dataUriOrBase64) ? dataUriOrBase64 : toDataUrl(dataUriOrBase64) : "";
      this.defaultSoundDataUrl = du || null;
      if (du) {
        this.registerSound("LegacyDefault", du);
        this.defaultSoundName = "LegacyDefault";
        this.weatherDefaultSoundName = "LegacyDefault";
      }
      this.persistSettings();
    }
    getDefaultSoundName(context = "shops") {
      if (context === "weather") {
        return this.weatherDefaultSoundName ?? this.defaultSoundName;
      }
      if (context === "pets") {
        return this.petDefaultSoundName ?? this.defaultSoundName;
      }
      return this.defaultSoundName;
    }
    resolveToDataUrl(src, context) {
      if (!src) {
        const name = context === "weather" ? this.weatherDefaultSoundName ?? this.defaultSoundName : context === "pets" ? this.petDefaultSoundName ?? this.defaultSoundName : this.defaultSoundName;
        if (name && this.library.has(name)) return this.library.get(name);
        return this.defaultSoundDataUrl || null;
      }
      const s = src.trim();
      if (this.library.has(s)) return this.library.get(s);
      if (looksLikeDataURL(s)) return s;
      if (/^[A-Za-z0-9+/=\s]+$/.test(s) && s.length > 100) return toDataUrl(s);
      return null;
    }
    // =========================
    // Settings API (Playback)
    // =========================
    setEnabled(on) {
      const next = !!on;
      if (this.enabled === next) return;
      this.enabled = next;
      this.persistSettings();
    }
    isEnabled() {
      return this.enabled;
    }
    setMute(muted) {
      this.setEnabled(!muted);
    }
    isMuted() {
      return !this.enabled;
    }
    setVolume(v, context = "shops") {
      const next = clamp01(v);
      if (context === "weather") {
        if (this.weatherVolume === next) return;
        this.weatherVolume = next;
      } else if (context === "pets") {
        if (this.petVolume === next) return;
        this.petVolume = next;
      } else {
        if (this.volume === next) return;
        this.volume = next;
      }
      this.forEachLoop(context, (st) => {
        st.baseVolume = next;
        if (st.volumeOverride == null) st.volume = next;
      });
      this.persistSettings();
    }
    getVolume(context = "shops") {
      if (context === "weather") return this.weatherVolume;
      if (context === "pets") return this.petVolume;
      return this.volume;
    }
    setMinPlayGap(ms) {
      const next = Math.max(0, ms | 0);
      if (this.minPlayGapMs === next) return;
      this.minPlayGapMs = next;
      this.persistSettings();
    }
    getMinPlayGap() {
      return this.minPlayGapMs;
    }
    setPlaybackMode(mode, context = "shops") {
      if (context === "weather") {
        if (this.weatherMode === mode) return;
        this.weatherMode = mode;
      } else if (context === "pets") {
        if (this.petMode === mode) return;
        this.petMode = mode;
      } else {
        if (this.mode === mode) return;
        this.mode = mode;
      }
      this.persistSettings();
    }
    getPlaybackMode(context = "shops") {
      if (context === "weather") return this.weatherMode;
      if (context === "pets") return this.petMode;
      return this.mode;
    }
    setStopRepeat(repeats, context = "shops") {
      this.setStopManual(context);
    }
    setStopManual(context = "shops") {
      if (context === "weather") {
        if (this.weatherStopConf.mode === "manual") return;
        this.weatherStopConf = { mode: "manual" };
      } else if (context === "pets") {
        if (this.petStopConf.mode === "manual") return;
        this.petStopConf = { mode: "manual" };
      } else {
        if (this.stopConf.mode === "manual") return;
        this.stopConf = { mode: "manual" };
      }
      this.forEachLoop(context, (st) => {
        st.baseStop = { mode: "manual" };
      });
      this.persistSettings();
    }
    setStopPurchase(context = "shops") {
      if (context === "weather") {
        if (this.weatherStopConf.mode === "purchase") return;
        this.weatherStopConf = { mode: "purchase" };
      } else if (context === "pets") {
        if (this.petStopConf.mode === "purchase") return;
        this.petStopConf = { mode: "purchase" };
      } else {
        if (this.stopConf.mode === "purchase") return;
        this.stopConf = { mode: "purchase" };
      }
      this.forEachLoop(context, (st) => {
        st.baseStop = { mode: "purchase" };
      });
      this.persistSettings();
    }
    clearStopCondition(context = "shops") {
      this.setStopManual(context);
    }
    setLoopInterval(ms, context = "shops") {
      const next = Math.max(150, ms | 0);
      if (context === "weather") {
        if (this.weatherLoopIntervalMs === next) return;
        this.weatherLoopIntervalMs = next;
      } else if (context === "pets") {
        if (this.petLoopIntervalMs === next) return;
        this.petLoopIntervalMs = next;
      } else {
        if (this.loopIntervalMs === next) return;
        this.loopIntervalMs = next;
      }
      this.forEachLoop(context, (st) => {
        st.baseLoopInterval = next;
      });
      this.persistSettings();
    }
    getLoopInterval(context = "shops") {
      if (context === "weather") return this.weatherLoopIntervalMs;
      if (context === "pets") return this.petLoopIntervalMs;
      return this.loopIntervalMs;
    }
    setPurchaseChecker(fn) {
      this.purchaseChecker = fn;
    }
    getPlaybackSettings(context = "shops") {
      const volume = this.getVolume(context);
      const mode = this.getPlaybackMode(context);
      const stop2 = context === "weather" ? this.weatherStopConf : context === "pets" ? this.petStopConf : this.stopConf;
      const stopSnapshot = stop2.mode === "purchase" ? { mode: "purchase" } : { mode: "manual" };
      const loopIntervalMs = this.getLoopInterval(context);
      const defaultSoundName = this.getDefaultSoundName(context);
      return {
        enabled: this.enabled,
        volume,
        minPlayGapMs: this.minPlayGapMs,
        mode,
        stop: stopSnapshot,
        loopIntervalMs,
        primed: this.primed,
        defaultSoundName,
        hasLegacyDefault: !!this.defaultSoundDataUrl,
        librarySize: this.library.size,
        libraryNames: this.listSounds()
      };
    }
    // =========================
    // Actions
    // =========================
    async notify(context = "shops") {
      const du = this.resolveToDataUrl(null, context);
      await this.playOnce(du, this.getVolume(context), context);
    }
    async playNotify(context = "shops") {
      await this.notify(context);
    }
    /**
     * Trigger using the current mode.
     * @param key  Unique key (e.g. item id). "global" if generic.
     * @param sound Optional: NAME from registry or a dataURL/bare base64 to override.
     */
    async trigger(key2 = "global", overrides = {}, context = "shops") {
      const normalizeSound = (raw) => {
        if (typeof raw !== "string") return void 0;
        const trimmed = raw.trim();
        return trimmed ? trimmed : void 0;
      };
      const normalizeStop = (raw) => {
        if (!raw) return null;
        if (raw.mode === "purchase") return { mode: "purchase" };
        if (raw.mode === "manual") return { mode: "manual" };
        if (raw.mode === "repeat") return { mode: "manual" };
        return { mode: "manual" };
      };
      const normalizeVolume = (raw) => {
        if (raw == null) return null;
        const n = Number(raw);
        if (!Number.isFinite(n)) return null;
        return clamp01(n);
      };
      const sound = normalizeSound(overrides.sound ?? null);
      const baseMode = this.getPlaybackMode(context);
      const mode = overrides.mode === "oneshot" || overrides.mode === "loop" ? overrides.mode : baseMode;
      const baseStopSource = context === "weather" ? this.weatherStopConf : context === "pets" ? this.petStopConf : this.stopConf;
      const baseStop = baseStopSource.mode === "purchase" ? { mode: "purchase" } : { mode: "manual" };
      const baseLoopInterval = this.getLoopInterval(context);
      const baseVolume = this.getVolume(context);
      const volumeOverride = normalizeVolume(overrides.volume ?? null);
      const effectiveVolume = volumeOverride ?? baseVolume;
      if (mode === "oneshot") {
        this.stopLoop(key2);
        const du = this.resolveToDataUrl(sound ?? null, context);
        this.enqueueOneshot({ key: key2, dataUrl: du, volume: effectiveVolume, context });
        return;
      }
      this.stopLoop(key2);
      const stopOverride = normalizeStop(overrides.stop ?? null);
      const loopIntervalOverride = overrides.loopIntervalMs != null && Number.isFinite(overrides.loopIntervalMs) ? Math.max(150, Math.round(overrides.loopIntervalMs)) : null;
      const state3 = {
        key: key2,
        timer: null,
        plays: 0,
        soundOverride: sound,
        stopped: false,
        stopOverride,
        loopIntervalOverride,
        context,
        baseStop,
        baseLoopInterval,
        baseVolume,
        volumeOverride,
        volume: effectiveVolume
      };
      this.loops.set(key2, state3);
      this.scheduleNext(state3, 0);
    }
    forEachLoop(context, fn) {
      for (const st of this.loops.values()) {
        if (st.context === context) fn(st);
      }
    }
    stopLoop(key2 = "global") {
      const st = this.loops.get(key2);
      if (!st) return;
      st.stopped = true;
      if (st.timer != null) {
        clearTimeout(st.timer);
        st.timer = null;
      }
      this.loops.delete(key2);
    }
    stopAllLoops(context) {
      if (context) {
        for (const [k, st] of this.loops) {
          if (st.context === context) this.stopLoop(k);
        }
        return;
      }
      for (const [k] of this.loops) this.stopLoop(k);
    }
    /** Prime audio once on a user gesture for stricter browsers. */
    async prime() {
      try {
        if (!this.audioCtx) this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (this.audioCtx.state === "suspended") await this.audioCtx.resume();
        const o = this.audioCtx.createOscillator();
        const g = this.audioCtx.createGain();
        g.gain.value = 1e-4;
        o.connect(g).connect(this.audioCtx.destination);
        o.start();
        o.stop(this.audioCtx.currentTime + 0.02);
        this.primed = true;
      } catch {
        this.primed = true;
      }
    }
    // =========================
    // Import / compression  200 KB
    // =========================
    async importFileAsSound(file, opts = {}) {
      const {
        name,
        maxBytes = 200 * 1024,
        maxSeconds = 10,
        bitrates = [48e3, 32e3, 2e4, 12e3, 8e3],
        maxInputBytes = 8 * 1024 * 1024
      } = opts;
      const notifyInvalid = (description) => {
        try {
          toastSimple("Audio import", description, "error").catch(() => {
          });
        } catch {
        }
      };
      let decoded = null;
      const ensureDecoded = async () => {
        if (!decoded) decoded = await this.decodeFileToBuffer(file);
        return decoded;
      };
      if (!file || !(file instanceof File)) throw new Error("No file provided.");
      const allowedMimeByExtension = /* @__PURE__ */ new Map([
        ["mp3", /* @__PURE__ */ new Set(["audio/mpeg", "audio/mp3"])],
        ["wav", /* @__PURE__ */ new Set(["audio/wav", "audio/x-wav", "audio/wave"])],
        ["ogg", /* @__PURE__ */ new Set(["audio/ogg"])]
      ]);
      const fileType = (file.type || "").toLowerCase();
      const fileExtension = (file.name?.split(".").pop() || "").toLowerCase();
      if (!fileExtension || !allowedMimeByExtension.has(fileExtension)) {
        notifyInvalid("Unsupported audio format. Allowed formats: MP3, WAV, OGG.");
        throw new Error(`Unsupported audio extension: ${fileExtension || "unknown"}`);
      }
      const allowedMimes = allowedMimeByExtension.get(fileExtension);
      if (!fileType || !allowedMimes.has(fileType)) {
        notifyInvalid("File extension and MIME type must match (MP3, WAV, OGG only).");
        throw new Error(
          fileType ? `MIME type ${fileType} is not valid for .${fileExtension} files.` : `Missing MIME type for .${fileExtension} files.`
        );
      }
      if (file.size > maxInputBytes) throw new Error(`Input file too large (${Math.round(file.size / 1024)}KB). Limit is ${Math.round(maxInputBytes / 1024)}KB.`);
      if (file.size <= maxBytes) {
        const buf = await ensureDecoded();
        if (buf.duration > maxSeconds) {
          const duration = buf.duration;
          const formattedLimit = maxSeconds.toFixed(1).replace(/\.0$/, "");
          const formattedDuration = duration.toFixed(1).replace(/\.0$/, "");
          notifyInvalid(`File duration is ${formattedDuration}s (limit: ${formattedLimit}s).`);
          throw new Error(`Audio duration ${formattedDuration}s exceeds limit of ${formattedLimit}s.`);
        }
        const dataUrl = await this.blobToDataURL(file);
        const finalName = this.uniqueName(name || file.name);
        this.registerSound(finalName, dataUrl);
        return { name: finalName, dataUrl, bytes: file.size, wasCompressed: false };
      }
      const mime = this.chooseAudioMime();
      const canEncode = !!mime && typeof MediaRecorder !== "undefined" && MediaRecorder.isTypeSupported?.(mime);
      if (!canEncode) throw new Error("Compression unavailable in this browser; file exceeds 200KB.");
      decoded = await ensureDecoded();
      if (decoded.duration > maxSeconds) {
        const duration = decoded.duration;
        const formattedLimit = maxSeconds.toFixed(1).replace(/\.0$/, "");
        const formattedDuration = duration.toFixed(1).replace(/\.0$/, "");
        notifyInvalid(`File duration is ${formattedDuration}s (limit: ${formattedLimit}s).`);
        throw new Error(`Audio duration ${formattedDuration}s exceeds limit of ${formattedLimit}s.`);
      }
      for (const br of bitrates) {
        const blob = await this.recordBufferToBlob(decoded, mime, br);
        if (blob.size <= maxBytes) {
          const dataUrl = await this.blobToDataURL(blob);
          const finalName = this.uniqueName(name || file.name);
          this.registerSound(finalName, dataUrl);
          return { name: finalName, dataUrl, bytes: blob.size, wasCompressed: true };
        }
      }
      notifyInvalid(`Unable to compress under ${Math.round(maxBytes / 1024)}KB. Try a shorter clip.`);
      throw new Error(`Could not compress under ${Math.round(maxBytes / 1024)}KB. Try a shorter clip.`);
    }
    // =========================
    // Internals
    // =========================
    async playOnce(dataUrl, volume, _context, opts = {}) {
      if (!this.enabled) return true;
      const now2 = Date.now();
      if (now2 - this.lastPlayTs < this.minPlayGapMs) return false;
      this.lastPlayTs = now2;
      if (!dataUrl) {
        if (this.primed && this.audioCtx) {
          try {
            const o = this.audioCtx.createOscillator();
            const g = this.audioCtx.createGain();
            g.gain.value = volume * 0.1;
            o.frequency.value = 880;
            o.connect(g).connect(this.audioCtx.destination);
            o.start();
            o.stop(this.audioCtx.currentTime + 0.06);
          } catch {
          }
        }
        return true;
      }
      try {
        const a = new Audio();
        a.src = dataUrl;
        a.volume = volume;
        a.muted = !this.enabled;
        a.crossOrigin = "anonymous";
        const awaitEnd = opts?.awaitEnd === true;
        let endPromise = null;
        let resolveEnd = null;
        if (awaitEnd) {
          endPromise = new Promise((resolve2) => {
            const cleanup2 = () => {
              a.removeEventListener("ended", cleanup2);
              a.removeEventListener("error", cleanup2);
              resolve2();
            };
            resolveEnd = cleanup2;
            a.addEventListener("ended", cleanup2);
            a.addEventListener("error", cleanup2);
          });
        }
        const p = a.play();
        if (p && typeof p.then === "function") await p.catch(() => {
          resolveEnd?.();
        });
        if (endPromise) await endPromise;
      } catch {
      }
      return true;
    }
    scheduleNext(state3, delayMs) {
      const run = async () => {
        if (state3.stopped) return;
        const stopConf = state3.stopOverride ?? state3.baseStop;
        if (stopConf.mode === "purchase" && this.purchaseChecker) {
          try {
            if (this.purchaseChecker(state3.key)) {
              this.stopLoop(state3.key);
              return;
            }
          } catch {
          }
        }
        const du = this.resolveToDataUrl(state3.soundOverride, state3.context);
        const played = await this.playOnce(
          du,
          state3.volume,
          state3.context,
          { awaitEnd: true }
        );
        if (played) state3.plays++;
        if (stopConf.mode === "repeat") {
          const max = Math.max(1, stopConf.repeats | 0);
          if (state3.plays >= max) {
            this.stopLoop(state3.key);
            return;
          }
        }
        const intervalBase = state3.loopIntervalOverride ?? state3.baseLoopInterval;
        const gap = Math.max(150, intervalBase | 0);
        state3.timer = setTimeout(() => this.scheduleNext(state3, 0), gap);
      };
      if (delayMs > 0) state3.timer = setTimeout(run, delayMs);
      else run().catch(() => {
      });
    }
    enqueueOneshot(entry) {
      if (entry.context === "weather") {
        const idx = this.oneshotQueue.findIndex((item) => item.context !== "weather");
        if (idx === -1) this.oneshotQueue.push(entry);
        else this.oneshotQueue.splice(idx, 0, entry);
      } else {
        this.oneshotQueue.push(entry);
      }
      this.scheduleOneshotProcessing();
    }
    scheduleOneshotProcessing() {
      if (!this.oneshotQueue.length) return;
      if (this.oneshotQueueTimer != null) return;
      const delta = Date.now() - this.lastPlayTs;
      const wait2 = Math.max(0, this.minPlayGapMs - delta);
      this.oneshotQueueTimer = window.setTimeout(() => {
        this.oneshotQueueTimer = null;
        if (this.oneshotProcessing) return;
        this.processOneshotQueue();
      }, wait2);
    }
    processOneshotQueue() {
      if (this.oneshotProcessing) return;
      if (!this.oneshotQueue.length) return;
      const next = this.oneshotQueue.shift();
      this.oneshotProcessing = true;
      const run = async () => {
        let replay = false;
        try {
          const played = await this.playOnce(next.dataUrl, next.volume, next.context);
          replay = !played;
        } finally {
          this.oneshotProcessing = false;
          if (replay) this.enqueueOneshot(next);
          this.scheduleOneshotProcessing();
        }
      };
      run().catch(() => {
      });
    }
    // ===== Helpers import/compress =====
    chooseAudioMime() {
      const candidates = ["audio/webm;codecs=opus", "audio/ogg;codecs=opus", "audio/webm", "audio/ogg", "audio/mp4"];
      for (const m of candidates) {
        try {
          if (typeof MediaRecorder !== "undefined" && MediaRecorder.isTypeSupported?.(m)) return m;
        } catch {
        }
      }
      return null;
    }
    uniqueName(raw) {
      const base = String(raw || "Sound").replace(/\.[a-z0-9]+$/i, "").trim() || "Sound";
      if (!this.library.has(base)) return base;
      let i = 2;
      while (this.library.has(`${base} (${i})`)) i++;
      return `${base} (${i})`;
    }
    async blobToDataURL(blob) {
      return await new Promise((resolve2, reject) => {
        const fr = new FileReader();
        fr.onload = () => resolve2(String(fr.result));
        fr.onerror = reject;
        fr.readAsDataURL(blob);
      });
    }
    async decodeFileToBuffer(file) {
      const arrayBuf = await file.arrayBuffer();
      const Ctx = window.AudioContext || window.webkitAudioContext;
      const ctx2 = new Ctx();
      try {
        const buf = await new Promise((res, rej) => {
          ctx2.decodeAudioData(arrayBuf.slice(0), res, rej);
        });
        await ctx2.close().catch(() => {
        });
        return buf;
      } catch (e) {
        try {
          await ctx2.close();
        } catch {
        }
        throw new Error("Failed to decode audio file.");
      }
    }
    async recordBufferToBlob(buffer, mime, bitsPerSecond) {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      const ctx2 = new Ctx();
      const dest = ctx2.createMediaStreamDestination();
      const src = ctx2.createBufferSource();
      src.buffer = buffer;
      const gain = ctx2.createGain();
      gain.gain.value = 0.9;
      src.connect(gain).connect(dest);
      const chunks = [];
      const rec = new MediaRecorder(dest.stream, { mimeType: mime, bitsPerSecond });
      const recorded = new Promise((resolve2, reject) => {
        rec.ondataavailable = (e) => {
          if (e.data && e.data.size) chunks.push(e.data);
        };
        rec.onerror = (e) => reject(e.error || new Error("MediaRecorder error"));
        rec.onstop = () => {
          try {
            resolve2(new Blob(chunks, { type: mime }));
          } catch (err) {
            reject(err);
          }
        };
      });
      rec.start();
      src.start();
      await new Promise((res) => {
        src.onended = () => res();
      });
      rec.stop();
      const out = await recorded;
      try {
        await ctx2.close();
      } catch {
      }
      return out;
    }
  };
  var audio = new AudioNotifier({
    minPlayGapMs: 1200,
    volume: 0.7
  });

  // src/services/pet-alerts.ts
  var clampPct2 = (v) => Math.max(1, Math.min(100, Math.round(v)));
  var prefs = {
    globalEnabled: true,
    generalEnabled: false,
    defaultThresholdPct: 25,
    pets: {}
  };
  var started = false;
  var unsubPets = null;
  var lastPets = [];
  var seenBelow = /* @__PURE__ */ new Map();
  function loadPrefs() {
    try {
      const parsed = readAriesPath("pets.alerts");
      if (parsed && typeof parsed === "object") {
        prefs = {
          globalEnabled: parsed.globalEnabled !== false,
          generalEnabled: !!parsed.generalEnabled,
          defaultThresholdPct: clampPct2(parsed.defaultThresholdPct ?? prefs.defaultThresholdPct),
          pets: typeof parsed.pets === "object" && parsed.pets ? parsed.pets : {}
        };
      }
    } catch {
    }
    return prefs;
  }
  function savePrefs() {
    try {
      writeAriesPath("pets.alerts", prefs);
    } catch {
    }
  }
  function prefFor(petId) {
    const baseThreshold = clampPct2(prefs.defaultThresholdPct);
    if (prefs.generalEnabled) {
      return { enabled: prefs.globalEnabled !== false, thresholdPct: baseThreshold };
    }
    if (!petId) return { enabled: false, thresholdPct: baseThreshold };
    const entry = prefs.pets[petId] ?? {};
    const enabled = entry.enabled ?? false;
    const thresholdPct = clampPct2(entry.thresholdPct ?? baseThreshold);
    return { enabled, thresholdPct };
  }
  async function triggerAlert(key2) {
    try {
      await audio.trigger(key2, {}, "pets");
    } catch {
    }
  }
  function evaluatePet(pet) {
    const petId = String(pet?.slot?.id || "");
    if (!petId || !prefs.globalEnabled) {
      seenBelow.set(petId, false);
      return;
    }
    const { enabled, thresholdPct } = prefFor(petId);
    const hungerPct = PetsService.getHungerPctFor(pet);
    const below = enabled && Number.isFinite(hungerPct) && hungerPct < thresholdPct;
    const wasBelow = seenBelow.get(petId) === true;
    const loopKey = prefs.generalEnabled ? "pets:general" : `pet:${petId}`;
    const mode = audio.getPlaybackMode?.("pets") ?? "oneshot";
    if (below) {
      if (mode === "loop") {
        void triggerAlert(loopKey);
      } else if (!wasBelow) {
        void triggerAlert(loopKey);
      }
    } else {
      try {
        audio.stopLoop(loopKey);
      } catch {
      }
    }
    seenBelow.set(petId, below);
  }
  async function evaluateAll(pets = null) {
    const list = pets ?? lastPets;
    for (const pet of Array.isArray(list) ? list : []) {
      try {
        evaluatePet(pet);
      } catch {
      }
    }
  }
  async function ensureStarted() {
    if (started) return;
    loadPrefs();
    try {
      unsubPets = await PetsService.onPetsChangeNow((arr) => {
        lastPets = Array.isArray(arr) ? arr.slice(0, 3) : [];
        void evaluateAll(lastPets);
      });
    } catch {
      unsubPets = null;
    }
    started = true;
  }
  function stop() {
    try {
      unsubPets?.();
    } catch {
    }
    unsubPets = null;
    started = false;
    seenBelow.clear();
  }
  var PetAlertService = {
    async start() {
      await ensureStarted();
      return () => stop();
    },
    isGlobalEnabled() {
      return prefs.globalEnabled !== false;
    },
    setGlobalEnabled(on) {
      prefs.globalEnabled = !!on;
      if (!on) seenBelow.clear();
      savePrefs();
    },
    isGeneralEnabled() {
      return !!prefs.generalEnabled;
    },
    setGeneralEnabled(on) {
      prefs.generalEnabled = !!on;
      savePrefs();
      void this.refreshNow();
    },
    getGeneralThresholdPct() {
      return clampPct2(prefs.defaultThresholdPct);
    },
    setGeneralThresholdPct(pct) {
      const next = clampPct2(pct);
      prefs.defaultThresholdPct = next;
      savePrefs();
      void this.refreshNow();
      return next;
    },
    getDefaultThresholdPct() {
      return clampPct2(prefs.defaultThresholdPct);
    },
    setDefaultThresholdPct(pct) {
      const next = clampPct2(pct);
      prefs.defaultThresholdPct = next;
      savePrefs();
      return next;
    },
    isPetEnabled(petId) {
      return prefFor(petId).enabled;
    },
    setPetEnabled(petId, on) {
      if (!petId) return;
      prefs.pets[petId] = { ...prefs.pets[petId] || {}, enabled: !!on };
      savePrefs();
      void evaluateAll();
    },
    getPetThresholdPct(petId) {
      return prefFor(petId).thresholdPct;
    },
    setPetThresholdPct(petId, pct) {
      if (!petId) return this.getDefaultThresholdPct();
      const next = clampPct2(pct);
      prefs.pets[petId] = { ...prefs.pets[petId] || {}, thresholdPct: next };
      savePrefs();
      void evaluateAll();
      return next;
    },
    async refreshNow() {
      await evaluateAll();
    }
  };

  // src/services/notifier.ts
  init_atoms();
  var PATH_NOTIFIER_PREFS = "notifier.prefs";
  var PATH_NOTIFIER_RULES = "notifier.rules";
  var PATH_NOTIFIER_WEATHER = "notifier.weatherPrefs";
  var PATH_NOTIFIER_DEFAULTS = "notifier.loopDefaults";
  var DISPLAY_RARITY = {
    [rarity.Common]: "Common",
    [rarity.Uncommon]: "Uncommon",
    [rarity.Rare]: "Rare",
    [rarity.Legendary]: "Legendary",
    [rarity.Mythic]: "Mythical",
    [rarity.Divine]: "Divine",
    [rarity.Celestial]: "Celestial"
  };
  var norm2 = (s) => String(s ?? "").toLowerCase();
  var formatRuleSummary = (rule) => {
    if (!rule) return "";
    const parts = [];
    if (rule.sound) {
      const names = audio.listSounds();
      const label2 = names.includes(rule.sound) ? rule.sound : rule.sound.length > 32 ? `${rule.sound.slice(0, 29)}\u2026` : rule.sound;
      parts.push(`Sound: ${label2}`);
    }
    if (rule.volume != null) {
      const pct = Math.round(Math.max(0, Math.min(1, Number(rule.volume))) * 100);
      parts.push(`Volume: ${pct}%`);
    }
    if (rule.playbackMode === "oneshot") parts.push("Mode: One-shot");
    else if (rule.playbackMode === "loop") parts.push("Mode: Loop");
    if (rule.stopMode === "purchase") parts.push("Stop: Until purchase");
    else if (rule.stopMode === "manual") parts.push("Stop: Manual");
    if (rule.loopIntervalMs != null) {
      const raw = Number(rule.loopIntervalMs);
      if (Number.isFinite(raw)) {
        const ms = Math.max(1, Math.round(raw));
        const seconds = ms / 1e3;
        const label2 = seconds >= 1 ? `${(seconds >= 10 ? Math.round(seconds) : Math.round(seconds * 10) / 10).toFixed(seconds >= 10 ? 0 : 1)} s` : `${ms} ms`;
        parts.push(`Interval: ${label2}`);
      }
    }
    return parts.join(" \u2022 ");
  };
  var formatLastSeen = (timestamp, isCurrent) => {
    if (isCurrent) {
      const title = timestamp ? new Date(timestamp).toLocaleString() : "Currently active";
      return { label: "Now", title };
    }
    if (!timestamp) return { label: "Never", title: "Never seen" };
    const now2 = Date.now();
    const diff = Math.max(0, now2 - timestamp);
    let label2;
    if (diff < 45e3) label2 = "Just now";
    else if (diff < 9e4) label2 = "1 min ago";
    else if (diff < 60 * 60 * 1e3) {
      const mins = Math.round(diff / 6e4);
      label2 = `${mins} min${mins > 1 ? "s" : ""} ago`;
    } else if (diff < 36 * 60 * 60 * 1e3) {
      const hours = Math.round(diff / 36e5);
      label2 = `${hours} hour${hours > 1 ? "s" : ""} ago`;
    } else {
      const days = Math.round(diff / 864e5);
      label2 = `${days} day${days > 1 ? "s" : ""} ago`;
    }
    return { label: label2, title: new Date(timestamp).toLocaleString() };
  };
  var weatherStateSignature = (rows) => JSON.stringify(
    rows.map((r) => [r.id, r.notify ? 1 : 0, r.lastSeen || 0, r.isCurrent ? 1 : 0])
  );
  var formatWeatherMutation = (mutation) => {
    const parts = [mutation.name];
    if (mutation.multiplier != null) {
      const raw = Number(mutation.multiplier);
      if (Number.isFinite(raw)) {
        const rounded = Math.abs(raw - Math.round(raw)) < 0.01 ? Math.round(raw) : Math.round(raw * 100) / 100;
        parts[0] = `${parts[0]} \xD7${rounded}`;
      }
    }
    return parts.join(" ");
  };
  var normalizeNumber = (value) => {
    const num = typeof value === "number" ? value : Number(value);
    return Number.isFinite(num) ? num : void 0;
  };
  var normalizeCycle = (raw) => {
    if (!raw || typeof raw !== "object") return null;
    const rawKind = typeof raw.kind === "string" ? raw.kind.trim() : "";
    const kindLc = rawKind.toLowerCase();
    let kind = "unknown";
    if (kindLc === "weather" || kindLc === "lunar" || kindLc === "base") kind = kindLc;
    const meta = { kind, rawKind: rawKind || void 0 };
    const startWindowMin = normalizeNumber(raw.startWindowMin);
    if (startWindowMin !== void 0) meta.startWindowMin = startWindowMin;
    const startWindowMax = normalizeNumber(raw.startWindowMax);
    if (startWindowMax !== void 0) meta.startWindowMax = startWindowMax;
    const durationMinutes = normalizeNumber(raw.durationMinutes);
    if (durationMinutes !== void 0) meta.durationMinutes = durationMinutes;
    const periodMinutes = normalizeNumber(raw.periodMinutes);
    if (periodMinutes !== void 0) meta.periodMinutes = periodMinutes;
    return meta;
  };
  var normalizeMutations = (raw) => {
    if (!Array.isArray(raw)) return [];
    const items = [];
    for (const entry of raw) {
      if (!entry || typeof entry !== "object") continue;
      const name = typeof entry.name === "string" ? entry.name.trim() : "";
      if (!name) continue;
      const mutation = { name };
      const multiplier = normalizeNumber(entry.multiplier);
      if (multiplier !== void 0) mutation.multiplier = multiplier;
      const conditional = typeof entry.conditional === "string" ? entry.conditional.trim() : "";
      if (conditional) mutation.conditional = conditional;
      items.push(mutation);
    }
    return items;
  };
  var WEATHER_DEFS = (() => {
    const entries = [];
    for (const [rawName, rawValue] of Object.entries(weatherCatalog ?? {})) {
      const safeName = String(rawName || "").trim();
      if (!safeName) continue;
      const rawDisplayName = typeof rawValue?.displayName === "string" ? String(rawValue.displayName).trim() : "";
      const displayName = (rawDisplayName || safeName).replace(/([a-z])([A-Z])/g, "$1 $2").replace(/_/g, " ").replace(/\s+/g, " ").trim();
      const atomValue = typeof rawValue?.atomValue === "string" ? String(rawValue.atomValue).trim() : "";
      const type = atomValue || displayName;
      const description = typeof rawValue?.description === "string" ? String(rawValue.description).trim() : null;
      const weightInCycle = normalizeNumber(rawValue?.weightInCycle);
      const cycle = normalizeCycle(rawValue?.cycle);
      const mutations = normalizeMutations(rawValue?.mutations);
      entries.push({
        id: `Weather:${safeName}`,
        name: displayName || safeName,
        atomValue,
        type,
        description,
        cycle,
        weightInCycle: weightInCycle ?? null,
        mutations
      });
    }
    return entries;
  })();
  var WEATHER_BY_ID = /* @__PURE__ */ new Map();
  var WEATHER_BY_ATOM = /* @__PURE__ */ new Map();
  var WEATHER_BY_NAME = /* @__PURE__ */ new Map();
  for (const def of WEATHER_DEFS) {
    WEATHER_BY_ID.set(def.id, def);
    WEATHER_BY_NAME.set(def.name.toLowerCase(), def);
    WEATHER_BY_ATOM.set(def.atomValue.toLowerCase(), def);
    WEATHER_BY_NAME.set(def.id.slice("Weather:".length).toLowerCase(), def);
  }
  var _staticMeta = null;
  function buildStaticMeta() {
    if (_staticMeta) return _staticMeta;
    const map2 = /* @__PURE__ */ new Map();
    for (const [species, entry] of Object.entries(plantCatalog)) {
      if (entry?.seed) {
        const id = `Seed:${species}`;
        map2.set(id, {
          type: "Seed",
          name: entry.seed.name,
          rarity: DISPLAY_RARITY[entry.seed.rarity] ?? entry.seed.rarity
        });
      }
    }
    for (const [eggId, entry] of Object.entries(eggCatalog)) {
      const id = `Egg:${eggId}`;
      map2.set(id, {
        type: "Egg",
        name: entry.name,
        rarity: DISPLAY_RARITY[entry.rarity] ?? entry.rarity
      });
    }
    for (const [toolId, entry] of Object.entries(toolCatalog)) {
      const id = `Tool:${toolId}`;
      map2.set(id, {
        type: "Tool",
        name: entry.name,
        rarity: DISPLAY_RARITY[entry.rarity] ?? entry.rarity
      });
    }
    for (const [decorId, entry] of Object.entries(decorCatalog)) {
      const id = `Decor:${decorId}`;
      map2.set(id, {
        type: "Decor",
        name: entry.name,
        rarity: DISPLAY_RARITY[entry.rarity] ?? entry.rarity
      });
    }
    _staticMeta = map2;
    return map2;
  }
  var _prefs = /* @__PURE__ */ new Map();
  var _weatherPrefs = /* @__PURE__ */ new Map();
  var _weatherPrefsLoaded = false;
  var _contextDefaults = {};
  var _contextDefaultsLoaded = false;
  var _rules = /* @__PURE__ */ new Map();
  var _rulesLoaded = false;
  var _rulesSubs = /* @__PURE__ */ new Set();
  var _hasOwn = Object.prototype.hasOwnProperty;
  var _weatherState = null;
  var _weatherSig = null;
  var _weatherSubs = /* @__PURE__ */ new Set();
  var _currentWeatherId = null;
  var _currentWeatherValue = null;
  var _unsubWeather = null;
  function _ensureRulesLoaded() {
    if (_rulesLoaded) return;
    _rulesLoaded = true;
    _rules = /* @__PURE__ */ new Map();
    try {
      const obj = readAriesPath(PATH_NOTIFIER_RULES);
      if (obj && typeof obj === "object") {
        for (const [id, value] of Object.entries(obj)) {
          const norm3 = _normalizeRule(value);
          if (norm3) _rules.set(String(id), norm3);
        }
      }
    } catch {
      _rules = /* @__PURE__ */ new Map();
    }
  }
  function _normalizeRule(raw) {
    const patch2 = {};
    if (_hasOwn.call(raw ?? {}, "sound")) patch2.sound = raw?.sound ?? null;
    if (_hasOwn.call(raw ?? {}, "volume")) patch2.volume = raw?.volume ?? null;
    if (_hasOwn.call(raw ?? {}, "playbackMode")) patch2.playbackMode = raw?.playbackMode ?? null;
    if (_hasOwn.call(raw ?? {}, "stopMode")) patch2.stopMode = raw?.stopMode ?? null;
    if (_hasOwn.call(raw ?? {}, "stopRepeats")) patch2.stopRepeats = raw?.stopRepeats ?? null;
    if (_hasOwn.call(raw ?? {}, "loopIntervalMs")) patch2.loopIntervalMs = raw?.loopIntervalMs ?? null;
    return _mergeRule(void 0, patch2);
  }
  function _saveRules() {
    if (!_rulesLoaded) return;
    try {
      const obj = {};
      for (const [id, rule] of _rules.entries()) {
        obj[id] = { ...rule };
      }
      writeAriesPath(PATH_NOTIFIER_RULES, obj);
    } catch {
    }
  }
  function _ensureWeatherPrefsLoaded() {
    if (_weatherPrefsLoaded) return;
    _weatherPrefsLoaded = true;
    _weatherPrefs = /* @__PURE__ */ new Map();
    try {
      const obj = readAriesPath(PATH_NOTIFIER_WEATHER);
      if (obj && typeof obj === "object") {
        for (const [id, value] of Object.entries(obj)) {
          if (!id) continue;
          const pref = {};
          if (typeof value?.notify === "boolean") pref.notify = !!value.notify;
          if (typeof value?.lastSeen === "number" && Number.isFinite(value.lastSeen)) {
            pref.lastSeen = Number(value.lastSeen);
          }
          _weatherPrefs.set(String(id), pref);
        }
      }
    } catch {
      _weatherPrefs = /* @__PURE__ */ new Map();
    }
  }
  function _saveWeatherPrefs() {
    if (!_weatherPrefsLoaded) return;
    try {
      const obj = {};
      for (const [id, pref] of _weatherPrefs.entries()) {
        const entry = {};
        if (pref.notify) entry.notify = true;
        if (typeof pref.lastSeen === "number" && Number.isFinite(pref.lastSeen)) entry.lastSeen = pref.lastSeen;
        if (entry.notify || entry.lastSeen != null) obj[id] = entry;
      }
      writeAriesPath(PATH_NOTIFIER_WEATHER, obj);
    } catch {
    }
  }
  function _getWeatherPref(id) {
    _ensureWeatherPrefsLoaded();
    const existing = _weatherPrefs.get(id);
    if (existing) return existing;
    const fresh = {};
    _weatherPrefs.set(id, fresh);
    return fresh;
  }
  function _ensureContextDefaultsLoaded() {
    if (_contextDefaultsLoaded) return;
    _contextDefaultsLoaded = true;
    _contextDefaults = {};
    try {
      const obj = readAriesPath(PATH_NOTIFIER_DEFAULTS);
      if (obj && typeof obj === "object") {
        for (const [context, value] of Object.entries(obj)) {
          const ctx2 = context;
          if (ctx2 !== "shops" && ctx2 !== "weather") continue;
          const modeRaw = value?.stopMode;
          const stopMode = modeRaw === "purchase" ? "purchase" : "manual";
          const repeatsRaw = Number(value?.stopRepeats);
          const stopRepeats = Number.isFinite(repeatsRaw) ? Math.max(1, Math.floor(repeatsRaw)) : null;
          const intervalRaw = Number(value?.loopIntervalMs);
          const playback = audio.getPlaybackSettings(ctx2);
          const baseLoop = Number.isFinite(intervalRaw) ? intervalRaw : playback.loopIntervalMs;
          const loopIntervalMs = Math.max(150, Math.floor(baseLoop || 0));
          _contextDefaults[ctx2] = { stopMode, stopRepeats, loopIntervalMs };
        }
      }
    } catch {
      _contextDefaults = {};
    }
  }
  function _saveContextDefaults() {
    if (!_contextDefaultsLoaded) return;
    try {
      const obj = {};
      for (const [ctx2, value] of Object.entries(_contextDefaults)) {
        if (!value) continue;
        const loopIntervalMs = Math.max(150, Math.floor(value.loopIntervalMs | 0));
        const normalizedRepeats = value.stopRepeats != null ? Math.max(1, Math.floor(value.stopRepeats | 0)) : null;
        obj[ctx2] = {
          stopMode: value.stopMode,
          stopRepeats: normalizedRepeats,
          loopIntervalMs
        };
      }
      writeAriesPath(PATH_NOTIFIER_DEFAULTS, obj);
    } catch {
    }
  }
  function _getContextStopDefaultsInternal(context) {
    _ensureContextDefaultsLoaded();
    const stored = _contextDefaults[context];
    const playback = audio.getPlaybackSettings(context);
    const playbackLoop = Math.max(150, Math.floor(playback.loopIntervalMs || 0));
    const storedLoop = stored?.loopIntervalMs;
    const loopIntervalMs = Math.max(150, Math.floor(storedLoop ?? playbackLoop));
    const storedMode = stored?.stopMode === "purchase" ? "purchase" : null;
    const playbackMode = playback.stop.mode === "purchase" ? "purchase" : null;
    if (context === "shops") {
      const stopMode = storedMode ?? playbackMode ?? "purchase";
      return { stopMode, stopRepeats: null, loopIntervalMs };
    }
    return { stopMode: "manual", stopRepeats: null, loopIntervalMs };
  }
  function _notifyWeather() {
    if (!_weatherState) return;
    _weatherSubs.forEach((fn) => {
      try {
        fn(_weatherState);
      } catch {
      }
    });
  }
  function _recomputeWeatherState() {
    _ensureWeatherPrefsLoaded();
    const rows = WEATHER_DEFS.map((def) => {
      const pref = _getWeatherPref(def.id);
      const notify2 = !!pref.notify;
      const lastSeen = typeof pref.lastSeen === "number" && Number.isFinite(pref.lastSeen) ? pref.lastSeen : null;
      return {
        id: def.id,
        name: def.name,
        type: def.type,
        atomValue: def.atomValue,
        notify: notify2,
        lastSeen,
        isCurrent: def.id === _currentWeatherId,
        description: def.description,
        cycle: def.cycle ? { ...def.cycle } : null,
        weightInCycle: def.weightInCycle,
        mutations: def.mutations.map((mutation) => ({ ...mutation }))
      };
    });
    const sig = JSON.stringify(rows.map((r) => [r.id, r.notify ? 1 : 0, r.lastSeen || 0, r.isCurrent ? 1 : 0]));
    const changed = sig !== _weatherSig;
    _weatherSig = sig;
    _weatherState = {
      updatedAt: Date.now(),
      currentId: _currentWeatherId,
      rows
    };
    if (changed) _notifyWeather();
  }
  function _buildWeatherOverrides(id) {
    const overrides = {};
    const rule = _rules.get(id);
    if (rule?.sound) overrides.sound = rule.sound;
    if (rule?.volume != null) overrides.volume = rule.volume;
    overrides.mode = "oneshot";
    return overrides;
  }
  function _triggerWeatherNotification(id) {
    const def = WEATHER_BY_ID.get(id);
    if (!def) return;
    const overrides = _buildWeatherOverrides(id);
    audio.trigger(id, overrides, "weather").catch(() => {
    });
  }
  function _handleWeatherUpdate(raw, opts = {}) {
    const normalize3 = (value) => {
      if (value == null) return "";
      if (typeof value === "string") return value.trim();
      return String(value || "").trim();
    };
    const nextValue = normalize3(raw);
    if (!opts.force && _currentWeatherValue === nextValue) return;
    const lookupKey = nextValue.toLowerCase();
    let def = WEATHER_BY_ATOM.get(lookupKey) || WEATHER_BY_NAME.get(lookupKey);
    if (!def && lookupKey) {
      const noSpace = lookupKey.replace(/\s+/g, "");
      def = WEATHER_BY_NAME.get(noSpace);
    }
    const prevId = _currentWeatherId;
    const now2 = Date.now();
    if (def) {
      const pref = _getWeatherPref(def.id);
      pref.lastSeen = now2;
      _weatherPrefs.set(def.id, pref);
    }
    _currentWeatherId = def?.id ?? null;
    _currentWeatherValue = nextValue;
    if (_currentWeatherId) {
      StatsService.incrementWeatherStat(_currentWeatherId.replace("Weather:", ""));
    }
    if (prevId && prevId !== _currentWeatherId) {
      audio.stopLoop(prevId);
    }
    if (def && _getWeatherPref(def.id).notify) {
      _triggerWeatherNotification(def.id);
    }
    if (def) _saveWeatherPrefs();
    _recomputeWeatherState();
  }
  function _rulesEqual(a, b) {
    if (!a && !b) return true;
    if (!a || !b) return false;
    return a.sound === b.sound && a.volume === b.volume && a.playbackMode === b.playbackMode && a.stopMode === b.stopMode && a.loopIntervalMs === b.loopIntervalMs;
  }
  function _sanitizeSound(value) {
    if (typeof value !== "string") return void 0;
    const trimmed = value.trim();
    return trimmed ? trimmed : void 0;
  }
  function _sanitizeVolume(value) {
    if (value == null) return void 0;
    const num = Number(value);
    if (!Number.isFinite(num)) return void 0;
    const normalized = num > 1 ? num / 100 : num;
    const clamped = Math.max(0, Math.min(1, normalized));
    return clamped;
  }
  function _sanitizePlaybackMode(value) {
    if (value == null) return void 0;
    const v = String(value);
    return v === "oneshot" || v === "loop" ? v : void 0;
  }
  function _sanitizeStopMode(value) {
    if (value == null) return void 0;
    const v = String(value);
    if (v === "purchase") return "purchase";
    return void 0;
  }
  function _sanitizeLoopInterval(value) {
    if (value == null) return void 0;
    const n = Number(value);
    if (!Number.isFinite(n)) return void 0;
    const normalized = Math.max(150, Math.floor(n));
    return normalized >= 150 ? normalized : void 0;
  }
  function _mergeRule(prev, patch2) {
    const next = { ...prev ?? {} };
    if (_hasOwn.call(patch2, "sound")) {
      const s = _sanitizeSound(patch2.sound);
      if (s) next.sound = s;
      else delete next.sound;
    }
    if (_hasOwn.call(patch2, "volume")) {
      const vol = _sanitizeVolume(patch2.volume);
      if (vol != null) next.volume = vol;
      else delete next.volume;
    }
    if (_hasOwn.call(patch2, "playbackMode")) {
      const mode = _sanitizePlaybackMode(patch2.playbackMode);
      if (mode) next.playbackMode = mode;
      else delete next.playbackMode;
    }
    if (_hasOwn.call(patch2, "stopMode")) {
      const mode = _sanitizeStopMode(patch2.stopMode);
      if (mode) next.stopMode = mode;
      else delete next.stopMode;
      delete next.stopRepeats;
    }
    if (_hasOwn.call(patch2, "stopRepeats")) {
      delete next.stopRepeats;
    }
    if (_hasOwn.call(patch2, "loopIntervalMs")) {
      const interval = _sanitizeLoopInterval(patch2.loopIntervalMs);
      if (interval != null) next.loopIntervalMs = interval;
      else delete next.loopIntervalMs;
    }
    return Object.keys(next).length ? next : null;
  }
  function _rulesSnapshot() {
    _ensureRulesLoaded();
    const out = {};
    for (const [id, rule] of _rules.entries()) {
      out[id] = {
        ...rule.sound ? { sound: rule.sound } : {},
        ...rule.volume != null ? { volume: rule.volume } : {},
        ...rule.playbackMode ? { playbackMode: rule.playbackMode } : {},
        ...rule.stopMode ? { stopMode: rule.stopMode } : {},
        ...rule.loopIntervalMs != null ? { loopIntervalMs: rule.loopIntervalMs } : {}
      };
    }
    return out;
  }
  function _emitRules() {
    if (!_rulesLoaded) return;
    const snap = _rulesSnapshot();
    _rulesSubs.forEach((fn) => {
      try {
        fn(snap);
      } catch {
      }
    });
  }
  function _loadPrefs() {
    try {
      const obj = readAriesPath(PATH_NOTIFIER_PREFS) ?? {};
      const m = /* @__PURE__ */ new Map();
      if (obj && typeof obj === "object") {
        for (const [k, v] of Object.entries(obj)) {
          const n = Number(v) | 0;
          const popupBits = n & 1;
          if (k && popupBits !== void 0) m.set(String(k), popupBits);
        }
      }
      _prefs = m;
    } catch {
      _prefs = /* @__PURE__ */ new Map();
    }
  }
  function _savePrefs() {
    try {
      const obj = {};
      for (const [k, v] of _prefs) obj[k] = v & 1;
      writeAriesPath(PATH_NOTIFIER_PREFS, obj);
    } catch {
    }
  }
  var _getPrefBits = (id) => (_prefs.get(id) ?? 0) & 1;
  var _setPrefBits = (id, bits) => {
    if (!id) return;
    const masked = bits & 1;
    if (masked) _prefs.set(id, masked);
    else _prefs.delete(id);
    _savePrefs();
    _recomputeFromCacheAndNotify();
  };
  var _rowsById = /* @__PURE__ */ new Map();
  var _lastSig = "";
  var _state = null;
  var _unsubShops = null;
  var _unsubPurchases = null;
  var _subs = /* @__PURE__ */ new Set();
  var _toolInv = /* @__PURE__ */ new Map();
  var _unsubToolInv = null;
  var TOOL_CAPS = {
    Shovel: 1,
    WateringCan: 99,
    CropCleanser: 99
  };
  function _isToolCapReached(toolId) {
    const cap = TOOL_CAPS[toolId];
    if (!cap) return false;
    const q = _toolInv.get(toolId) || 0;
    return q >= cap;
  }
  function _updateToolInv(raw) {
    try {
      const arr = Array.isArray(raw) ? raw : [];
      _toolInv = new Map(arr.map((it) => [String(it.toolId), Number(it.quantity) || 0]));
    } catch {
      _toolInv = /* @__PURE__ */ new Map();
    }
    _recomputeFromCacheAndNotify();
  }
  function _resolveToolInvAtom() {
    const a = Atoms;
    return a.inventory?.myToolInventory ?? a.shop?.myToolInventory ?? a.myToolInventoryAtom ?? null;
  }
  function _computeSig(ids) {
    return ids.slice().sort().join("|");
  }
  var _purchasesSubs = /* @__PURE__ */ new Set();
  function _coercePurchases(raw) {
    const co = (sec) => ({
      createdAt: Number(sec?.createdAt) || 0,
      purchases: sec?.purchases && typeof sec.purchases === "object" ? sec.purchases : {}
    });
    return {
      seed: co(raw?.seed),
      egg: co(raw?.egg),
      tool: co(raw?.tool),
      decor: co(raw?.decor)
    };
  }
  function _notifyPurchases(raw) {
    const snap = _coercePurchases(raw);
    _purchasesSubs.forEach((fn) => {
      try {
        fn(snap);
      } catch {
      }
    });
  }
  var _shopsSubs = /* @__PURE__ */ new Set();
  function _coerceSnap(raw) {
    const co = (sec) => ({
      inventory: Array.isArray(sec?.inventory) ? sec.inventory : [],
      secondsUntilRestock: Number(sec?.secondsUntilRestock) || 0
    });
    return {
      seed: co(raw?.seed),
      egg: co(raw?.egg),
      tool: co(raw?.tool),
      decor: co(raw?.decor)
    };
  }
  function _notifyShops(raw) {
    const snap = _coerceSnap(raw);
    _shopsSubs.forEach((fn) => {
      try {
        fn(snap);
      } catch {
      }
    });
  }
  function _recomputeFromRaw(raw) {
    const staticMeta = buildStaticMeta();
    const sections = [
      { key: "seed", type: "Seed" },
      { key: "egg", type: "Egg" },
      { key: "tool", type: "Tool" },
      { key: "decor", type: "Decor" }
    ];
    const seen = /* @__PURE__ */ new Set();
    for (const { key: key2, type } of sections) {
      const sec = raw?.[key2] ?? {};
      const inv = Array.isArray(sec?.inventory) ? sec.inventory : [];
      for (const entry of inv) {
        const id = type === "Seed" ? `Seed:${entry.species}` : type === "Egg" ? `Egg:${entry.eggId}` : type === "Tool" ? `Tool:${entry.toolId}` : `Decor:${entry.decorId}`;
        seen.add(id);
        const meta = staticMeta.get(id);
        const bits = _getPrefBits(id);
        const popup = !!(bits & 1);
        const row = {
          id,
          type,
          name: meta?.name ?? id.split(":")[1] ?? id,
          rarity: meta?.rarity,
          popup,
          followed: popup
          // compat
        };
        _rowsById.set(id, row);
      }
    }
    for (const id of Array.from(_rowsById.keys())) {
      if (!seen.has(id)) _rowsById.delete(id);
    }
    const rows = Array.from(_rowsById.values());
    const followed = rows.reduce((n, r) => n + (r.followed ? 1 : 0), 0);
    const next = {
      updatedAt: Date.now(),
      rows,
      counts: { items: rows.length, followed }
    };
    const sig = _computeSig(rows.map((r) => r.id));
    const changed = sig !== _lastSig;
    _state = next;
    if (changed) {
      _lastSig = sig;
      _notify();
    } else {
    }
  }
  function _recomputeFromCacheAndNotify() {
    if (!_state) return;
    for (const [id, row] of _rowsById) {
      const bits = _getPrefBits(id);
      let popup = !!(bits & 1);
      if (id.startsWith("Tool:")) {
        const toolId = id.slice(5);
        if (_isToolCapReached(toolId)) {
          popup = false;
        }
      }
      row.popup = popup;
      row.followed = popup;
    }
    const rows = Array.from(_rowsById.values());
    const followed = rows.reduce((n, r) => n + (r.followed ? 1 : 0), 0);
    _state = {
      ..._state,
      updatedAt: Date.now(),
      rows,
      counts: { items: rows.length, followed }
    };
    _notify();
  }
  function _notify() {
    if (!_state) return;
    const snap = { ..._state, rows: _state.rows.slice() };
    _subs.forEach((fn) => {
      try {
        fn(snap);
      } catch {
      }
    });
  }
  var _started = false;
  async function _ensureStarted() {
    if (_started) {
      return;
    }
    _started = true;
    _loadPrefs();
    _ensureRulesLoaded();
    try {
      const cur = await Atoms.shop.shops.get();
      _recomputeFromRaw(cur);
      _notifyShops(cur);
    } catch (err) {
    }
    try {
      _unsubShops = await Atoms.shop.shops.onChange((next) => {
        try {
          _recomputeFromRaw(next);
        } catch {
        }
        try {
          _notifyShops(next);
        } catch {
        }
      });
    } catch (err) {
    }
    try {
      const curP = await Atoms.shop.myShopPurchases.get();
      _notifyPurchases(curP);
    } catch (err) {
    }
    try {
      _unsubPurchases = await Atoms.shop.myShopPurchases.onChange((next) => {
        try {
          _notifyPurchases(next);
        } catch {
        }
      });
    } catch (err) {
    }
    try {
      const invAtom = _resolveToolInvAtom();
      if (invAtom) {
        try {
          _updateToolInv(await invAtom.get());
        } catch (err) {
        }
        try {
          _unsubToolInv = await invAtom.onChange((next) => {
            try {
              _updateToolInv(next);
            } catch {
            }
          });
        } catch (err) {
        }
      }
    } catch (err) {
    }
    try {
      const weatherAtom = Atoms.data?.weather;
      if (weatherAtom) {
        try {
          _handleWeatherUpdate(await weatherAtom.get(), { force: true });
        } catch (err) {
        }
        try {
          _unsubWeather = await weatherAtom.onChange((next) => {
            try {
              _handleWeatherUpdate(next);
            } catch {
            }
          });
        } catch (err) {
        }
      } else {
      }
    } catch (err) {
    }
  }
  function _stop() {
    try {
      _unsubShops?.();
    } catch {
    }
    _unsubShops = null;
    try {
      _unsubPurchases?.();
    } catch {
    }
    _unsubPurchases = null;
    try {
      _unsubToolInv?.();
    } catch {
    }
    _unsubToolInv = null;
    try {
      _unsubWeather?.();
    } catch {
    }
    _unsubWeather = null;
    if (_currentWeatherId) {
      try {
        audio.stopLoop(_currentWeatherId);
      } catch {
      }
    }
    _currentWeatherId = null;
    _currentWeatherValue = null;
    _started = false;
  }
  var NotifierService = {
    // lifecycle
    async start() {
      await _ensureStarted();
      return () => _stop();
    },
    async get() {
      await _ensureStarted();
      if (!_state) {
        _recomputeFromRaw(await Atoms.shop.shops.get().catch(() => null));
      }
      return _state;
    },
    onChange(cb) {
      _subs.add(cb);
      return () => {
        _subs.delete(cb);
      };
    },
    async onChangeNow(cb) {
      await _ensureStarted();
      if (_state) cb(_state);
      else {
        try {
          _recomputeFromRaw(await Atoms.shop.shops.get());
        } catch {
        }
        if (_state) cb(_state);
      }
      return this.onChange(cb);
    },
    onShopsChange(cb) {
      _shopsSubs.add(cb);
      return () => {
        _shopsSubs.delete(cb);
      };
    },
    async onShopsChangeNow(cb) {
      await _ensureStarted();
      try {
        cb(_coerceSnap(await Atoms.shop.shops.get()));
      } catch {
      }
      return this.onShopsChange(cb);
    },
    onPurchasesChange(cb) {
      _purchasesSubs.add(cb);
      return () => {
        _purchasesSubs.delete(cb);
      };
    },
    async onPurchasesChangeNow(cb) {
      await _ensureStarted();
      try {
        cb(_coercePurchases(await Atoms.shop.myShopPurchases.get()));
      } catch {
      }
      return this.onPurchasesChange(cb);
    },
    async getWeatherState() {
      await _ensureStarted();
      if (!_weatherState) _recomputeWeatherState();
      return _weatherState;
    },
    onWeatherChange(cb) {
      _weatherSubs.add(cb);
      return () => {
        _weatherSubs.delete(cb);
      };
    },
    async onWeatherChangeNow(cb) {
      await _ensureStarted();
      if (!_weatherState) _recomputeWeatherState();
      if (_weatherState) cb(_weatherState);
      return this.onWeatherChange(cb);
    },
    getWeatherNotify(id) {
      if (!id) return false;
      return !!_getWeatherPref(id).notify;
    },
    setWeatherNotify(id, enabled) {
      if (!id) return;
      _ensureWeatherPrefsLoaded();
      const pref = _getWeatherPref(id);
      const next = !!enabled;
      if (!!pref.notify === next) return;
      pref.notify = next;
      _weatherPrefs.set(id, pref);
      _saveWeatherPrefs();
      if (!next) {
        try {
          audio.stopLoop(id);
        } catch {
        }
      } else if (_currentWeatherId === id) {
        _triggerWeatherNotification(id);
      }
      _recomputeWeatherState();
    },
    getContextStopDefaults(context) {
      return _getContextStopDefaultsInternal(context);
    },
    setContextStopDefaults(context, conf) {
      if (context !== "shops" && context !== "weather") return;
      _ensureContextDefaultsLoaded();
      const current = _getContextStopDefaultsInternal(context);
      const loopRaw = Number(conf?.loopIntervalMs);
      const loopIntervalMs = Number.isFinite(loopRaw) ? Math.max(150, Math.floor(loopRaw)) : current.loopIntervalMs;
      const normalizedMode = conf.stopMode === "purchase" ? "purchase" : "manual";
      const normalized = {
        stopMode: context === "weather" ? "manual" : normalizedMode,
        stopRepeats: null,
        loopIntervalMs
      };
      _contextDefaults[context] = normalized;
      _saveContextDefaults();
    },
    // prefs (popup only)
    getPref(id) {
      if (id.startsWith("Tool:")) {
        const toolId = id.slice(5);
        if (_isToolCapReached(toolId)) {
          return { popup: false, followed: false };
        }
      }
      const bits = _getPrefBits(id);
      const popup = !!(bits & 1);
      return { popup, followed: popup };
    },
    setPopup(id, enabled) {
      if (enabled && id.startsWith("Tool:") && _isToolCapReached(id.slice(5))) {
        return;
      }
      const bits = _getPrefBits(id);
      const next = enabled ? bits | 1 : bits & ~1;
      _setPrefBits(id, next);
    },
    setPrefs(id, prefs2) {
      const bits = _getPrefBits(id);
      let next = bits;
      if (typeof prefs2.popup === "boolean") next = prefs2.popup ? next | 1 : next & ~1;
      _setPrefBits(id, next);
    },
    clearPrefs(id) {
      _setPrefBits(id, 0);
    },
    isIdCapped(id) {
      if (!id.startsWith("Tool:")) return false;
      return _isToolCapReached(id.slice(5));
    },
    // pure filter util (no side-effects)
    filterRows(rows, f) {
      let arr = rows.slice();
      const ft = f.type ?? "all";
      if (ft && ft !== "all") {
        arr = arr.filter((r) => r.type.toLowerCase() === ft);
      }
      const fr = f.rarity ?? "all";
      if (fr !== "all") {
        arr = arr.filter((r) => norm2(r.rarity) === fr);
      }
      return arr;
    },
    getRule(id) {
      if (!id) return null;
      _ensureRulesLoaded();
      const rule = _rules.get(id);
      if (!rule) return null;
      return {
        ...rule.sound ? { sound: rule.sound } : {},
        ...rule.volume != null ? { volume: rule.volume } : {},
        ...rule.playbackMode ? { playbackMode: rule.playbackMode } : {},
        ...rule.stopMode ? { stopMode: rule.stopMode } : {},
        ...rule.loopIntervalMs != null ? { loopIntervalMs: rule.loopIntervalMs } : {}
      };
    },
    getAllRules() {
      return _rulesSnapshot();
    },
    setRule(id, patch2) {
      if (!id || !patch2 || typeof patch2 !== "object") return;
      _ensureRulesLoaded();
      const prev = _rules.get(id);
      const next = _mergeRule(prev, patch2);
      if (_rulesEqual(prev, next)) return;
      if (next) _rules.set(id, next);
      else _rules.delete(id);
      _saveRules();
      _emitRules();
    },
    clearRule(id) {
      if (!id) return;
      _ensureRulesLoaded();
      const existed = _rules.delete(id);
      if (existed) {
        _saveRules();
        _emitRules();
      }
    },
    onRulesChange(cb) {
      _ensureRulesLoaded();
      _rulesSubs.add(cb);
      return () => {
        _rulesSubs.delete(cb);
      };
    },
    async onRulesChangeNow(cb) {
      await _ensureStarted();
      cb(_rulesSnapshot());
      return this.onRulesChange(cb);
    }
  };

  // src/utils/catalogIndex.ts
  function seedNameFromSpecies(species, cat = plantCatalog) {
    const e = cat?.[species];
    return e?.seed?.name ?? e?.plant?.name ?? e?.crop?.name ?? void 0;
  }
  function eggNameFromId(eggId, cat = eggCatalog) {
    return cat?.[eggId]?.name ?? void 0;
  }
  function toolNameFromId(toolId, cat = toolCatalog) {
    return cat?.[toolId]?.name ?? void 0;
  }
  function decorNameFromId(decorId, cat = decorCatalog) {
    return cat?.[decorId]?.name ?? void 0;
  }

  // src/utils/toolbarButton.ts
  var KNOWN_ARIA = ["Chat", "Leaderboard", "Stats", "Open Activity Log"];
  var TOOLBAR_FALLBACK_CLASS = "css-13izacw";
  var OWN_BTN_SEL = '[data-qws-btn="true"]';
  function startInjectGamePanelButton(opts) {
    const { onClick, iconUrl = "", ariaLabel = "" } = opts;
    let mountedBtn = null;
    let mountedWrap = null;
    let isMounting = false;
    let mounted = false;
    const esc = (v) => {
      try {
        return typeof CSS?.escape === "function" ? CSS.escape(v) : v.replace(/"/g, '\\"');
      } catch {
        return v;
      }
    };
    function findToolbarRoot() {
      const selector = KNOWN_ARIA.map((a) => `button[aria-label="${esc(a)}"]`).join(",");
      const knownBtn = document.querySelector(selector);
      if (knownBtn) {
        let parent = knownBtn.parentElement;
        while (parent && parent !== document.body) {
          const count = KNOWN_ARIA.reduce(
            (acc, a) => acc + parent.querySelectorAll(`button[aria-label="${esc(a)}"]`).length,
            0
          );
          if (count >= 2) return parent;
          parent = parent.parentElement;
        }
      }
      return document.querySelector(`.${TOOLBAR_FALLBACK_CLASS}`) ?? null;
    }
    function getReference(root) {
      const all = Array.from(
        root.querySelectorAll(`button:not(${OWN_BTN_SEL})`)
      );
      if (!all.length) return { refBtn: null, refWrapper: null };
      const filtered = all.filter(
        (b) => b.getAttribute("aria-label") !== ariaLabel
      );
      const list = filtered.length ? filtered : all;
      const idx = list.length >= 2 ? list.length - 2 : list.length - 1;
      const refBtn = list[idx];
      const parent = refBtn?.parentElement;
      const refWrapper = parent?.parentElement === root && parent.tagName === "DIV" ? parent : null;
      return { refBtn, refWrapper };
    }
    function cloneButton(ref) {
      const btn = ref.cloneNode(false);
      btn.type = "button";
      btn.setAttribute("aria-label", ariaLabel);
      btn.title = ariaLabel;
      btn.dataset.qwsBtn = "true";
      btn.style.pointerEvents = "auto";
      btn.removeAttribute("id");
      if (iconUrl) {
        const img = document.createElement("img");
        img.src = iconUrl;
        img.alt = "QWS";
        Object.assign(img.style, {
          pointerEvents: "none",
          userSelect: "none",
          width: "60%",
          height: "60%",
          objectFit: "contain",
          display: "block",
          margin: "auto"
        });
        btn.appendChild(img);
      }
      btn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        try {
          onClick();
        } catch {
        }
      });
      return btn;
    }
    function mount() {
      if (isMounting) return false;
      isMounting = true;
      try {
        const root = findToolbarRoot();
        if (!root) return false;
        const { refBtn, refWrapper } = getReference(root);
        if (!refBtn) return false;
        if (!mountedWrap) {
          mountedWrap = root.querySelector('div[data-qws-wrapper="true"]');
          if (!mountedWrap && refWrapper) {
            mountedWrap = refWrapper.cloneNode(false);
            mountedWrap.dataset.qwsWrapper = "true";
            mountedWrap.removeAttribute("id");
          }
        }
        if (!mountedBtn) {
          mountedBtn = mountedWrap?.querySelector('button[data-qws-btn="true"]') || null;
          if (!mountedBtn) {
            mountedBtn = cloneButton(refBtn);
            if (mountedWrap) {
              mountedWrap.appendChild(mountedBtn);
            } else {
              root.appendChild(mountedBtn);
            }
          }
        }
        if (mountedWrap && mountedWrap.parentElement !== root) {
          root.appendChild(mountedWrap);
        }
        const inDOM = document.contains(mountedBtn);
        if (inDOM && !mounted) {
          mounted = true;
          console.log("[ToolbarButton] Mounted:", ariaLabel);
          try {
            opts.onMounted?.(mountedBtn);
          } catch {
          }
        }
        return inDOM;
      } finally {
        isMounting = false;
      }
    }
    const host = document.getElementById("App") || document.body;
    let timer = null;
    const observer2 = new MutationObserver(() => {
      if (mounted && mountedBtn && document.contains(mountedBtn)) return;
      if (mountedBtn && !document.contains(mountedBtn)) {
        console.warn("[ToolbarButton] Removed from DOM, retrying:", ariaLabel);
        mounted = false;
        mountedBtn = null;
        mountedWrap = null;
      }
      if (timer !== null) return;
      timer = window.setTimeout(() => {
        timer = null;
        mount();
      }, 100);
    });
    const pollingInterval = window.setInterval(() => {
      if (mounted && mountedBtn && !document.contains(mountedBtn)) {
        console.warn("[ToolbarButton] Detected missing button (polling), remounting:", ariaLabel);
        mounted = false;
        mountedBtn = null;
        mountedWrap = null;
        mount();
      } else if (!mounted || !mountedBtn) {
        mount();
      }
    }, 2e3);
    mount();
    observer2.observe(host, { childList: true, subtree: true });
    return () => {
      observer2.disconnect();
      clearInterval(pollingInterval);
      mountedWrap?.remove();
      mountedBtn = null;
      mountedWrap = null;
    };
  }

  // src/ui/menus/notificationOverlay.ts
  var style = (el2, s) => Object.assign(el2.style, s);
  var setProps = (el2, props) => {
    for (const [k, v] of Object.entries(props)) el2.style.setProperty(k, v);
  };
  function iconOf(id, size = 24) {
    const wrap = document.createElement("div");
    Object.assign(wrap.style, {
      width: `${size}px`,
      height: `${size}px`,
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      flex: `0 0 ${size}px`
    });
    const [rawType] = id.split(":");
    const fallback = rawType === "Seed" ? "seed" : rawType === "Egg" ? "egg" : rawType === "Tool" ? "tool" : rawType === "Decor" ? "decor" : "item";
    const span = document.createElement("span");
    span.textContent = fallback;
    span.style.fontSize = `${Math.max(10, size - 2)}px`;
    span.setAttribute("aria-hidden", "true");
    wrap.appendChild(span);
    const categories = rawType === "Seed" ? ["seed"] : rawType === "Egg" ? ["pet"] : rawType === "Tool" ? ["item"] : rawType === "Decor" ? ["decor"] : null;
    if (categories) {
      const label2 = labelOf(id);
      const candidatesSet = /* @__PURE__ */ new Set();
      const addCandidate = (value) => {
        if (!value) return;
        const trimmed = value.trim();
        if (!trimmed) return;
        candidatesSet.add(trimmed);
        candidatesSet.add(trimmed.replace(/\s+/g, ""));
        const last = trimmed.split(/[./]/).pop();
        if (last && last !== trimmed) {
          candidatesSet.add(last);
          candidatesSet.add(last.replace(/\s+/g, ""));
        }
      };
      addCandidate(id.split(":")[1]);
      addCandidate(label2);
      if (rawType) addCandidate(rawType);
      const originals = Array.from(candidatesSet);
      const iconized = originals.map((value) => value.replace(/icon$/i, "")).filter(Boolean).map((value) => `${value}Icon`);
      const candidates = Array.from(/* @__PURE__ */ new Set([...originals, ...iconized])).filter(Boolean);
      if (candidates.length) {
        attachSpriteIcon(wrap, categories, candidates, size, "alerts-overlay");
      }
    }
    return wrap;
  }
  function labelOf(id) {
    const [type, raw] = id.split(":");
    switch (type) {
      case "Seed":
        return seedNameFromSpecies(raw) ?? raw;
      case "Egg":
        return eggNameFromId(raw) ?? raw;
      case "Tool":
        return toolNameFromId(raw) ?? raw;
      case "Decor":
        return decorNameFromId(raw) ?? raw;
      default:
        return raw;
    }
  }
  function purchasedCountForId(id, purchases) {
    if (!purchases) return 0;
    const [type, raw] = String(id).split(":");
    const sec = type === "Seed" ? purchases.seed : type === "Egg" ? purchases.egg : type === "Tool" ? purchases.tool : purchases.decor;
    if (!sec || !sec.purchases) return 0;
    const n = sec.purchases[raw];
    return typeof n === "number" && n > 0 ? n : 0;
  }
  var OverlayBarebone = class {
    constructor() {
      __publicField(this, "slot", document.createElement("div"));
      __publicField(this, "badge", document.createElement("span"));
      __publicField(this, "panel", document.createElement("div"));
      __publicField(this, "cleanupToolbarButton", null);
      __publicField(this, "lastShops", null);
      __publicField(this, "lastPurch", null);
      // Suivi des IDs visibles dans l'overlay (pour loops & diff)
      __publicField(this, "prevOverlayIds", /* @__PURE__ */ new Set());
      __publicField(this, "currentOverlayIds", /* @__PURE__ */ new Set());
      __publicField(this, "rulesById", /* @__PURE__ */ new Map());
      __publicField(this, "shopUpdates", 0);
      __publicField(this, "purchasesUpdates", 0);
      __publicField(this, "bootArmed", false);
      __publicField(this, "justRestocked", false);
      // Items  afficher dans l'overlay (dj filtrs)
      __publicField(this, "rows", []);
      __publicField(this, "lastPanelSig", null);
      this.slot = this.createSlot();
      this.slot.id = "qws-notifier-slot";
      globalThis.__qws_notifier_slot = this.slot;
      this.ensureBellCSS();
      this.badge = this.createBadge();
      this.panel = this.createPanel();
      this.installScrollGuards(this.panel);
      const bellSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/><path d="M13.73 21a2 2 0 0 1-3.46 0"/></svg>`;
      const bellDataUrl = `data:image/svg+xml;base64,${btoa(bellSvg)}`;
      let primedOnce = false;
      this.cleanupToolbarButton = startInjectGamePanelButton({
        onClick: async () => {
          if (!primedOnce) {
            primedOnce = true;
            try {
              await audio.prime();
            } catch {
            }
          }
          const on = this.panel.style.display !== "block";
          this.panel.style.display = on ? "block" : "none";
          if (on) {
            this.updatePanelPosition();
            this.renderPanel();
            this.updateBadgePosition();
          }
          this.updateBellWiggle();
        },
        iconUrl: bellDataUrl,
        ariaLabel: "Notifications"
      });
      this.slot.append(this.badge, this.panel);
      document.body.appendChild(this.slot);
      window.addEventListener("pointerdown", (e) => {
        if (this.panel.style.display !== "block") return;
        const t = e.target;
        if (!this.slot.contains(t) && !this.isClickOnToolbarButton(e.target)) {
          this.panel.style.display = "none";
        }
      });
      audio.setPurchaseChecker((itemId) => {
        if (!itemId) return false;
        if (this.currentOverlayIds.has(itemId)) return false;
        return purchasedCountForId(itemId, this.lastPurch) > 0;
      });
    }
    isClickOnToolbarButton(target) {
      let el2 = target;
      while (el2) {
        if (el2 instanceof HTMLButtonElement && el2.getAttribute("aria-label") === "Notifications") {
          return true;
        }
        el2 = el2.parentElement;
      }
      return false;
    }
    destroy() {
      if (this.cleanupToolbarButton) {
        try {
          this.cleanupToolbarButton();
        } catch {
        }
        this.cleanupToolbarButton = null;
      }
      try {
        this.slot.remove();
      } catch {
      }
      try {
        if (globalThis.__qws_notifier_slot === this.slot) {
          delete globalThis.__qws_notifier_slot;
        }
      } catch {
      }
      try {
        audio.stopAllLoops();
      } catch {
      }
    }
    ensureBellCSS() {
      if (document.getElementById("qws-bell-anim-css")) return;
      const style3 = document.createElement("style");
      style3.id = "qws-bell-anim-css";
      style3.textContent = `
@keyframes qwsBellShake {
  0% { transform: rotate(0deg); }
  10% { transform: rotate(-16deg); }
  20% { transform: rotate(12deg); }
  30% { transform: rotate(-10deg); }
  40% { transform: rotate(8deg); }
  50% { transform: rotate(-6deg); }
  60% { transform: rotate(4deg); }
  70% { transform: rotate(-2deg); }
  80% { transform: rotate(1deg); }
  100% { transform: rotate(0deg); }
}

/* Classe appliqu\xE9e sur le span cloche quand il y a des items dans l'overlay */
.qws-bell--wiggle {
  animation: qwsBellShake 1.2s ease-in-out infinite;
  transform-origin: 50% 0%;
  display: inline-block;
}

/* Respecte l'accessibilit\xE9 */
@media (prefers-reduced-motion: reduce) {
  .qws-bell--wiggle { animation: none !important; }
}
`;
      document.head.appendChild(style3);
    }
    /* ========= SETTERS (subs) ========= */
    setShops(s) {
      const prev = this.lastShops;
      this.lastShops = s;
      this.shopUpdates++;
      this.justRestocked = !!(prev && ((prev.seed?.secondsUntilRestock ?? 0) < (s.seed?.secondsUntilRestock ?? 0) || (prev.tool?.secondsUntilRestock ?? 0) < (s.tool?.secondsUntilRestock ?? 0) || (prev.egg?.secondsUntilRestock ?? 0) < (s.egg?.secondsUntilRestock ?? 0) || (prev.decor?.secondsUntilRestock ?? 0) < (s.decor?.secondsUntilRestock ?? 0)));
      this.recompute();
    }
    setPurchases(p) {
      this.lastPurch = p;
      this.purchasesUpdates++;
      this.recompute();
    }
    notifyStateUpdated() {
      void this.recompute();
    }
    setRules(rules) {
      this.rulesById.clear();
      for (const [id, rule] of Object.entries(rules)) {
        if (!id || !rule) continue;
        this.rulesById.set(id, { ...rule });
      }
      this.refreshActiveLoops();
    }
    /* ========= Core compute ========= */
    buildTriggerOverrides(rule) {
      if (!rule) return null;
      const overrides = {};
      if (rule.sound) overrides.sound = rule.sound;
      if (rule.volume != null && Number.isFinite(rule.volume)) {
        overrides.volume = Math.max(0, Math.min(1, Number(rule.volume)));
      }
      if (rule.playbackMode === "loop" || rule.playbackMode === "oneshot") {
        overrides.mode = rule.playbackMode;
      }
      if (rule.stopMode === "purchase") overrides.stop = { mode: "purchase" };
      else if (rule.stopMode === "manual") overrides.stop = { mode: "manual" };
      if (rule.loopIntervalMs != null && Number.isFinite(rule.loopIntervalMs)) {
        overrides.loopIntervalMs = Math.max(150, Math.floor(Number(rule.loopIntervalMs)));
      }
      return Object.keys(overrides).length ? overrides : null;
    }
    triggerMany(ids) {
      const entries = [];
      for (const id of ids) {
        const overrides = this.buildTriggerOverrides(this.rulesById.get(id)) ?? {};
        const mode = this.resolvePlaybackMode(id);
        const soundKeyBase = overrides.sound ? `sound:${overrides.sound.trim().toLowerCase()}` : "sound:__default__";
        const vol = overrides.volume;
        const volKey = vol != null ? `vol:${Math.round(Math.max(0, Math.min(1, vol)) * 1e3)}` : "vol:__default__";
        const soundKey = `${soundKeyBase}|${volKey}`;
        entries.push({ id, overrides, mode, soundKey });
      }
      if (!entries.length) return;
      const grouped = /* @__PURE__ */ new Map();
      for (const entry of entries) {
        const bucket = grouped.get(entry.soundKey) ?? { loops: [], oneshots: [] };
        if (entry.mode === "loop") bucket.loops.push(entry);
        else bucket.oneshots.push(entry);
        grouped.set(entry.soundKey, bucket);
      }
      for (const { loops, oneshots } of grouped.values()) {
        if (loops.length) {
          for (const entry of loops) {
            audio.trigger(entry.id, entry.overrides, "shops").catch(() => {
            });
          }
          continue;
        }
        if (oneshots.length) {
          const first = oneshots[0];
          audio.trigger(first.id, first.overrides, "shops").catch(() => {
          });
        }
      }
    }
    triggerWithRule(id) {
      this.triggerMany([id]);
    }
    resolvePlaybackMode(id) {
      const rule = this.rulesById.get(id);
      const baseMode = audio.getPlaybackMode("shops");
      if (!rule) return baseMode;
      if (rule.playbackMode === "loop") return "loop";
      if (rule.playbackMode === "oneshot") return "oneshot";
      if ((rule.stopMode || rule.loopIntervalMs != null) && baseMode === "loop") return "loop";
      return baseMode;
    }
    refreshActiveLoops() {
      if (!this.currentOverlayIds.size) return;
      const loopIds = [];
      for (const id of this.currentOverlayIds) {
        if (this.resolvePlaybackMode(id) === "loop") {
          audio.stopLoop(id);
          loopIds.push(id);
        }
      }
      if (loopIds.length) this.triggerMany(loopIds);
    }
    async recompute() {
      if (!this.lastShops || !this.lastPurch) return;
      const out = [];
      const consider = (id, initialStock) => {
        const pref = NotifierService.getPref?.(id) || {};
        if (!pref.popup) return;
        const bought = purchasedCountForId(id, this.lastPurch);
        const remaining = Math.max(initialStock - bought, 0);
        if (remaining > 0) out.push({ id, qty: remaining });
      };
      for (const it of this.lastShops.seed.inventory) consider(`Seed:${it.species}`, it.initialStock);
      for (const it of this.lastShops.tool.inventory) consider(`Tool:${it.toolId}`, it.initialStock);
      for (const it of this.lastShops.egg.inventory) consider(`Egg:${it.eggId}`, it.initialStock);
      for (const it of this.lastShops.decor.inventory) consider(`Decor:${it.decorId}`, it.initialStock);
      this.rows = out;
      this.renderBadge();
      if (this.panel.style.display === "block") this.renderPanel();
      this.updateBellWiggle();
      const overlayIds = new Set(out.map((r) => r.id));
      this.currentOverlayIds = overlayIds;
      const shopEmpty = (this.lastShops.seed?.inventory?.length ?? 0) + (this.lastShops.tool?.inventory?.length ?? 0) + (this.lastShops.egg?.inventory?.length ?? 0) + (this.lastShops.decor?.inventory?.length ?? 0) === 0;
      const ready2 = this.shopUpdates >= 3 && this.purchasesUpdates >= 2 && !shopEmpty;
      if (!this.bootArmed) {
        if (!ready2) {
          this.prevOverlayIds = overlayIds;
          return;
        }
        this.bootArmed = true;
        if (overlayIds.size > 0) {
          this.triggerMany(overlayIds);
        }
        this.prevOverlayIds = overlayIds;
        this.justRestocked = false;
        return;
      }
      if (overlayIds.size === 0) {
        audio.stopAllLoops();
        this.prevOverlayIds = overlayIds;
        this.justRestocked = false;
        return;
      }
      if (this.justRestocked) {
        this.triggerMany(overlayIds);
        for (const oldId of this.prevOverlayIds) {
          if (!overlayIds.has(oldId)) audio.stopLoop(oldId);
        }
        this.prevOverlayIds = overlayIds;
        this.justRestocked = false;
        return;
      }
      const newIds = [];
      for (const id of overlayIds) {
        if (!this.prevOverlayIds.has(id)) {
          newIds.push(id);
        }
      }
      if (newIds.length) this.triggerMany(newIds);
      for (const oldId of this.prevOverlayIds) {
        if (!overlayIds.has(oldId)) {
          audio.stopLoop(oldId);
        }
      }
      this.prevOverlayIds = overlayIds;
      this.justRestocked = false;
    }
    /* ========= Render ========= */
    renderBadge() {
      const n = this.rows.length;
      this.badge.textContent = n ? String(n) : "";
      style(this.badge, { display: n ? "inline-flex" : "none" });
      this.updateBadgePosition();
    }
    resolveShopItem(id) {
      if (!this.lastShops) return null;
      const [type, raw] = String(id).split(":");
      if (!type || !raw) return null;
      if (type === "Seed") {
        const item = this.lastShops.seed?.inventory?.find((it) => String(it.species) === raw);
        return item ? { kind: "seeds", item } : null;
      }
      if (type === "Tool") {
        const item = this.lastShops.tool?.inventory?.find((it) => String(it.toolId) === raw);
        return item ? { kind: "tools", item } : null;
      }
      if (type === "Egg") {
        const item = this.lastShops.egg?.inventory?.find((it) => String(it.eggId) === raw);
        return item ? { kind: "eggs", item } : null;
      }
      if (type === "Decor") {
        const item = this.lastShops.decor?.inventory?.find((it) => String(it.decorId) === raw);
        return item ? { kind: "decor", item } : null;
      }
      return null;
    }
    async handleBuyClick(id, btn) {
      const resolved = this.resolveShopItem(id);
      if (!resolved) {
        btn.disabled = true;
        return;
      }
      btn.disabled = true;
      const prevLabel = btn.textContent;
      btn.textContent = "Buying...";
      try {
        await Promise.resolve(ShopsService.buyOne(resolved.kind, resolved.item));
      } catch {
      } finally {
        btn.textContent = prevLabel || "Buy";
        btn.disabled = false;
      }
    }
    async handleBuyAllClick(id, btn) {
      const resolved = this.resolveShopItem(id);
      if (!resolved) {
        btn.disabled = true;
        return;
      }
      const available = this.rows.find((r) => r.id === id)?.qty ?? 0;
      if (available <= 0) {
        btn.disabled = true;
        return;
      }
      btn.disabled = true;
      const prevLabel = btn.textContent;
      btn.textContent = "Buying...";
      try {
        for (let i = 0; i < available; i++) {
          await Promise.resolve(ShopsService.buyOne(resolved.kind, resolved.item));
        }
      } catch {
      } finally {
        btn.textContent = prevLabel || "Buy all";
        btn.disabled = false;
      }
    }
    renderPanel() {
      const sig = JSON.stringify(this.rows.map((r) => [r.id, r.qty]));
      if (sig === this.lastPanelSig) return;
      this.lastPanelSig = sig;
      this.panel.replaceChildren();
      const head = document.createElement("div");
      head.textContent = "Tracked items available";
      style(head, {
        fontWeight: "700",
        opacity: "0.9",
        padding: "4px 2px",
        borderBottom: "1px solid var(--qws-border-2, #ffffff14)",
        marginBottom: "4px"
      });
      this.panel.appendChild(head);
      if (!this.rows.length) {
        const empty = document.createElement("div");
        empty.textContent = "No tracked items are available.";
        style(empty, { opacity: "0.75", padding: "8px 2px" });
        this.panel.appendChild(empty);
        return;
      }
      for (const r of this.rows) {
        const row = document.createElement("div");
        Object.assign(row.style, {
          display: "grid",
          gridTemplateColumns: "24px 1fr max-content max-content max-content",
          alignItems: "center",
          gap: "8px",
          padding: "6px 4px",
          borderBottom: "1px solid var(--qws-border-2, #ffffff14)"
        });
        const icon = iconOf(r.id, 24);
        const title = document.createElement("div");
        title.textContent = labelOf(r.id);
        Object.assign(title.style, {
          fontWeight: "600",
          fontSize: "12px",
          overflow: "hidden",
          textOverflow: "ellipsis",
          whiteSpace: "nowrap",
          color: "var(--qws-text, #e7eef7)"
        });
        const qty = document.createElement("div");
        qty.textContent = `\xD7${r.qty}`;
        Object.assign(qty.style, {
          fontVariantNumeric: "tabular-nums",
          opacity: "0.9",
          color: "var(--qws-text-dim, #b9c3cf)",
          textAlign: "right"
        });
        const buyBtn = document.createElement("button");
        buyBtn.type = "button";
        buyBtn.textContent = "Buy";
        Object.assign(buyBtn.style, {
          padding: "4px 10px",
          borderRadius: "10px",
          border: "1px solid var(--qws-border, #ffffff33)",
          background: "var(--qws-accent, #7aa2ff)",
          color: "#0b1017",
          fontWeight: "700",
          cursor: "pointer",
          fontSize: "12px",
          boxShadow: "var(--qws-shadow, 0 6px 18px rgba(0,0,0,.35))",
          transition: "filter 120ms ease, transform 120ms ease"
        });
        buyBtn.onmouseenter = () => {
          buyBtn.style.filter = "brightness(1.05)";
        };
        buyBtn.onmouseleave = () => {
          buyBtn.style.filter = "";
          buyBtn.style.transform = "";
        };
        buyBtn.onmousedown = () => {
          buyBtn.style.transform = "translateY(1px)";
        };
        buyBtn.onmouseup = () => {
          buyBtn.style.transform = "";
        };
        buyBtn.onclick = (e) => {
          e.stopPropagation();
          void this.handleBuyClick(r.id, buyBtn);
        };
        if (!this.resolveShopItem(r.id)) {
          buyBtn.disabled = true;
          buyBtn.style.opacity = "0.6";
          buyBtn.style.cursor = "not-allowed";
          buyBtn.title = "Unavailable";
        }
        const buyAllBtn = document.createElement("button");
        buyAllBtn.type = "button";
        buyAllBtn.textContent = "Buy all";
        Object.assign(buyAllBtn.style, {
          padding: "4px 10px",
          borderRadius: "10px",
          border: "1px solid var(--qws-border, #ffffff33)",
          background: "var(--qws-panel, #111823cc)",
          color: "var(--qws-text, #e7eef7)",
          fontWeight: "700",
          cursor: "pointer",
          fontSize: "12px",
          boxShadow: "var(--qws-shadow, 0 6px 18px rgba(0,0,0,.35))",
          transition: "filter 120ms ease, transform 120ms ease"
        });
        buyAllBtn.onmouseenter = () => {
          buyAllBtn.style.filter = "brightness(1.08)";
        };
        buyAllBtn.onmouseleave = () => {
          buyAllBtn.style.filter = "";
          buyAllBtn.style.transform = "";
        };
        buyAllBtn.onmousedown = () => {
          buyAllBtn.style.transform = "translateY(1px)";
        };
        buyAllBtn.onmouseup = () => {
          buyAllBtn.style.transform = "";
        };
        buyAllBtn.onclick = (e) => {
          e.stopPropagation();
          void this.handleBuyAllClick(r.id, buyAllBtn);
        };
        if (!this.resolveShopItem(r.id)) {
          buyAllBtn.disabled = true;
          buyAllBtn.style.opacity = "0.6";
          buyAllBtn.style.cursor = "not-allowed";
          buyAllBtn.title = "Unavailable";
        }
        row.append(icon, title, qty, buyBtn, buyAllBtn);
        this.panel.appendChild(row);
      }
    }
    /* ========= DOM bits ========= */
    createSlot() {
      const d = document.createElement("div");
      style(d, {
        position: "fixed",
        top: "0",
        right: "0",
        pointerEvents: "none",
        zIndex: "9999",
        fontFamily: "var(--chakra-fonts-body, GreyCliff CF), system-ui, sans-serif",
        color: "var(--chakra-colors-chakra-body-text, #e7eef7)",
        userSelect: "none"
      });
      setProps(d, {
        "-webkit-font-smoothing": "antialiased",
        "-webkit-text-size-adjust": "100%",
        "text-rendering": "optimizeLegibility"
      });
      return d;
    }
    updateBadgePosition() {
      const btn = document.querySelector('button[aria-label="Notifications"]');
      if (btn && this.badge) {
        const rect = btn.getBoundingClientRect();
        style(this.badge, {
          top: `${rect.top - 4}px`,
          right: `${window.innerWidth - rect.right - 4}px`
        });
      }
    }
    updatePanelPosition() {
      const btn = document.querySelector('button[aria-label="Notifications"]');
      if (btn && this.panel) {
        const rect = btn.getBoundingClientRect();
        style(this.panel, {
          position: "fixed",
          top: `${rect.bottom + 8}px`,
          right: `${window.innerWidth - rect.right}px`
        });
      }
    }
    updateBellWiggle() {
      const btn = document.querySelector('button[aria-label="Notifications"]');
      if (!btn) return;
      const icon = btn.querySelector("img");
      if (!icon) return;
      const shouldWiggle = this.rows.length > 0 && this.panel.style.display !== "block";
      if (shouldWiggle) {
        icon.style.animation = "qwsBellShake 1.2s ease-in-out infinite";
        icon.style.transformOrigin = "50% 0%";
      } else {
        icon.style.animation = "";
      }
    }
    createBadge() {
      const badge = document.createElement("span");
      style(badge, {
        position: "fixed",
        minWidth: "18px",
        height: "18px",
        padding: "0 6px",
        borderRadius: "999px",
        background: "var(--chakra-colors-Red-Magic, #D02128)",
        color: "var(--chakra-colors-Neutral-TrueWhite, #fff)",
        fontSize: "12px",
        fontWeight: "700",
        display: "none",
        alignItems: "center",
        justifyContent: "center",
        border: "1px solid rgba(0,0,0,.35)",
        lineHeight: "18px",
        pointerEvents: "none",
        zIndex: "10000"
      });
      return badge;
    }
    createPanel() {
      const panel = document.createElement("div");
      panel.setAttribute("role", "dialog");
      panel.setAttribute("aria-label", "Tracked items available");
      style(panel, {
        position: "fixed",
        width: "min(340px, 80vw)",
        //  largeur rduite (tait 360px)
        maxHeight: "50vh",
        overflow: "auto",
        overscrollBehavior: "contain",
        //  empche le scroll de "remonter" au jeu
        touchAction: "pan-y",
        //  gestes tactiles = scroll vertical, pas zoom/pan global
        borderRadius: "var(--chakra-radii-card, 12px)",
        border: "1px solid var(--qws-border, #ffffff22)",
        background: "var(--qws-panel, #111823cc)",
        backdropFilter: "blur(var(--qws-blur, 8px))",
        color: "var(--qws-text, #e7eef7)",
        boxShadow: "var(--qws-shadow, 0 10px 36px rgba(0,0,0,.45))",
        padding: "8px",
        display: "none",
        zIndex: "var(--chakra-zIndices-DialogModal, 7010)",
        pointerEvents: "auto"
      });
      setProps(panel, { "-webkit-backdrop-filter": "blur(var(--qws-blur, 8px))" });
      return panel;
    }
    installScrollGuards(el2) {
      const stop2 = (e) => {
        e.stopPropagation();
      };
      el2.addEventListener("wheel", stop2, { passive: true, capture: true });
      el2.addEventListener("mousewheel", stop2, { passive: true, capture: true });
      el2.addEventListener("DOMMouseScroll", stop2, { passive: true, capture: true });
      el2.addEventListener("touchmove", stop2, { passive: true, capture: true });
    }
  };
  async function renderOverlay() {
    const overlay = new OverlayBarebone();
    const unsubPurch = await NotifierService.onPurchasesChangeNow((p) => overlay.setPurchases(p));
    const unsubShops = await NotifierService.onShopsChangeNow((s) => overlay.setShops(s));
    const unsubState = await NotifierService.onChangeNow(() => overlay.notifyStateUpdated());
    const unsubRules = await NotifierService.onRulesChangeNow((rules) => overlay.setRules(rules));
    window.__qws_cleanup_notifier = () => {
      try {
        unsubShops();
      } catch {
      }
      try {
        unsubPurch();
      } catch {
      }
      try {
        unsubState();
      } catch {
      }
      try {
        unsubRules();
      } catch {
      }
      try {
        overlay.destroy();
      } catch {
      }
    };
  }

  // src/ui/menus/communityHub/shared.ts
  var style2 = (el2, s) => Object.assign(el2.style, s);
  var CH_EVENTS = {
    OPEN: "qws:community-hub-open",
    CLOSE: "qws:community-hub-close",
    FRIENDS_REFRESH: "qws:friends-refresh",
    FRIEND_REQUESTS_REFRESH: "qws:friend-requests-refresh",
    PRIVACY_UPDATED: "qws:privacy-updated",
    ROOM_CHANGED: "qws:room-changed",
    CONVERSATIONS_REFRESH: "qws:conversations-refresh",
    GROUPS_REFRESH: "qws:groups-refresh",
    OPEN_FRIEND_CHAT: "qws:open-friend-chat",
    OPEN_GROUP_CHAT: "qws:open-group-chat",
    PRESENCE_UPDATED: "qws:presence-updated"
  };
  var SHARED_STYLE_ID = "qws-ch-shared-css";
  function ensureSharedStyles() {
    if (document.getElementById(SHARED_STYLE_ID)) return;
    const st = document.createElement("style");
    st.id = SHARED_STYLE_ID;
    st.textContent = `
/* Standard scrollbar (8px, teal accent) */
.qws-ch-scrollable::-webkit-scrollbar { width: 8px; }
.qws-ch-scrollable::-webkit-scrollbar-track {
  background: rgba(255,255,255,0.03);
  border-radius: 4px;
}
.qws-ch-scrollable::-webkit-scrollbar-thumb {
  background: rgba(94,234,212,0.2);
  border-radius: 4px;
  transition: background 150ms ease;
}
.qws-ch-scrollable::-webkit-scrollbar-thumb:hover {
  background: rgba(94,234,212,0.35);
}
.qws-ch-scrollable {
  scrollbar-width: thin;
  scrollbar-color: rgba(94,234,212,0.2) rgba(255,255,255,0.03);
}
/* Narrow variant (6px, transparent track) */
.qws-ch-scrollable-narrow::-webkit-scrollbar { width: 6px; }
.qws-ch-scrollable-narrow::-webkit-scrollbar-track { background: transparent; }
.qws-ch-scrollable-narrow::-webkit-scrollbar-thumb {
  background: rgba(94,234,212,0.18);
  border-radius: 3px;
}
.qws-ch-scrollable-narrow::-webkit-scrollbar-thumb:hover {
  background: rgba(94,234,212,0.32);
}
.qws-ch-scrollable-narrow {
  scrollbar-width: thin;
  scrollbar-color: rgba(94,234,212,0.18) transparent;
}
/* Spinner */
@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}
/* Card bounce (triggered on click only) */
@keyframes qws-card-bounce {
  0%   { transform: translateY(0); }
  30%  { transform: translateY(-4px); }
  60%  { transform: translateY(1px); }
  100% { transform: translateY(0); }
}
/* Preview animations */
@keyframes qws-preview-slide-in {
  from { opacity: 0; transform: translateX(-50%) translateY(-10px); }
  to   { opacity: 1; transform: translateX(-50%) translateY(0); }
}
@keyframes qws-preview-pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}
`;
    document.head.appendChild(st);
  }
  function formatRelativeTime(isoOrDate) {
    try {
      const date = typeof isoOrDate === "string" ? new Date(isoOrDate) : isoOrDate;
      const diffMs = Date.now() - date.getTime();
      const mins = Math.floor(diffMs / 6e4);
      if (mins < 1) return "just now";
      if (mins < 60) return `${mins}m ago`;
      const hours = Math.floor(mins / 60);
      if (hours < 24) return `${hours}h ago`;
      const days = Math.floor(hours / 24);
      if (days < 7) return `${days}d ago`;
      return date.toLocaleDateString();
    } catch {
      return "a while ago";
    }
  }
  function formatRelativeTimeShort(iso) {
    try {
      const diff = Date.now() - new Date(iso).getTime();
      const mins = Math.floor(diff / 6e4);
      if (mins < 1) return "now";
      if (mins < 60) return `${mins}m`;
      const hours = Math.floor(mins / 60);
      if (hours < 24) return `${hours}h`;
      const days = Math.floor(hours / 24);
      return `${days}d`;
    } catch {
      return "";
    }
  }
  function formatMessageTime(iso) {
    try {
      return new Date(iso).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    } catch {
      return "";
    }
  }
  function formatTimestamp(date) {
    const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    const month = months[date.getMonth()];
    const day = date.getDate();
    let hours = date.getHours();
    const ampm = hours >= 12 ? "PM" : "AM";
    hours = hours % 12 || 12;
    const minutes = date.getMinutes().toString().padStart(2, "0");
    return `${month} ${day}, ${hours}:${minutes} ${ampm}`;
  }
  function createLoadingView(onBack) {
    ensureSharedStyles();
    const container = document.createElement("div");
    style2(container, { display: "flex", flexDirection: "column", height: "100%", gap: "16px" });
    const header = document.createElement("div");
    style2(header, { display: "flex", alignItems: "center", gap: "12px", paddingBottom: "12px", borderBottom: "1px solid rgba(255,255,255,0.08)" });
    const backButton = document.createElement("button");
    backButton.innerHTML = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" style="display:block;"><path d="M15 18L9 12L15 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
    style2(backButton, { padding: "8px", border: "1px solid rgba(255,255,255,0.08)", borderRadius: "8px", background: "rgba(255,255,255,0.03)", color: "#e7eef7", cursor: "pointer", display: "flex", alignItems: "center", justifyContent: "center", transition: "all 120ms ease" });
    backButton.onclick = onBack;
    const headerTitle = document.createElement("div");
    style2(headerTitle, { fontSize: "16px", fontWeight: "700", color: "#e7eef7" });
    headerTitle.textContent = "Loading...";
    header.append(backButton, headerTitle);
    const loadingContent = document.createElement("div");
    style2(loadingContent, { display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", flex: "1", gap: "16px" });
    const spinner = document.createElement("div");
    style2(spinner, { width: "40px", height: "40px", border: "4px solid rgba(255,255,255,0.1)", borderTop: "4px solid #5eead4", borderRadius: "50%", animation: "spin 1s linear infinite" });
    const loadingText = document.createElement("div");
    style2(loadingText, { fontSize: "14px", color: "rgba(226,232,240,0.7)" });
    loadingText.textContent = "Loading player details...";
    loadingContent.append(spinner, loadingText);
    container.append(header, loadingContent);
    return container;
  }
  function createErrorView(message, onBack) {
    const container = document.createElement("div");
    style2(container, { display: "flex", flexDirection: "column", height: "100%", gap: "16px" });
    const header = document.createElement("div");
    style2(header, { display: "flex", alignItems: "center", gap: "12px", paddingBottom: "12px", borderBottom: "1px solid rgba(255,255,255,0.08)" });
    const backButton = document.createElement("button");
    backButton.innerHTML = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" style="display:block;"><path d="M15 18L9 12L15 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
    style2(backButton, { padding: "8px", border: "1px solid rgba(255,255,255,0.08)", borderRadius: "8px", background: "rgba(255,255,255,0.03)", color: "#e7eef7", cursor: "pointer", display: "flex", alignItems: "center", justifyContent: "center", transition: "all 120ms ease" });
    backButton.onclick = onBack;
    const headerTitle = document.createElement("div");
    style2(headerTitle, { fontSize: "16px", fontWeight: "700", color: "#e7eef7" });
    headerTitle.textContent = "Error";
    header.append(backButton, headerTitle);
    const errorContent = document.createElement("div");
    style2(errorContent, { display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", flex: "1", gap: "16px" });
    const errorIcon = document.createElement("div");
    style2(errorIcon, { fontSize: "48px", color: "#ef4444" });
    errorIcon.textContent = "\u26A0";
    const errorText = document.createElement("div");
    style2(errorText, { fontSize: "14px", color: "rgba(226,232,240,0.7)", textAlign: "center" });
    errorText.textContent = message;
    errorContent.append(errorIcon, errorText);
    container.append(header, errorContent);
    return container;
  }
  var ROOM_SVG = `<svg width="10" height="10" viewBox="1 2 22 21" fill="none" style="display:block;flex-shrink:0;"><path d="M3 9.5L12 3l9 6.5V21a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V9.5z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M9 22V12h6v10" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
  var LOCK_SVG = `<svg width="10" height="10" viewBox="0 0 12 14" fill="none" style="display:block;flex-shrink:0;"><path d="M10 6H9V4C9 2.346 7.654 1 6 1C4.346 1 3 2.346 3 4V6H2C1.448 6 1 6.448 1 7V12C1 12.552 1.448 13 2 13H10C10.552 13 11 12.552 11 12V7C11 6.448 10.552 6 10 6ZM4 4C4 2.897 4.897 2 6 2C7.103 2 8 2.897 8 4V6H4V4Z" fill="currentColor"/></svg>`;
  function createRoomBadge(roomId) {
    const badge = document.createElement("span");
    style2(badge, {
      display: "inline-flex",
      alignItems: "center",
      gap: "4px",
      padding: "2px 8px",
      borderRadius: "6px",
      fontSize: "10px",
      fontWeight: "600",
      maxWidth: "100%",
      overflow: "hidden",
      whiteSpace: "nowrap",
      border: roomId ? "1px solid rgba(94,234,212,0.2)" : "1px solid rgba(226,232,240,0.15)",
      background: roomId ? "rgba(94,234,212,0.08)" : "rgba(226,232,240,0.05)",
      color: roomId ? "#5eead4" : "rgba(226,232,240,0.5)"
    });
    if (roomId) {
      const icon = document.createElement("span");
      icon.innerHTML = ROOM_SVG;
      style2(icon, { display: "inline-flex", alignItems: "center", flexShrink: "0", marginTop: "-1px" });
      const text = document.createElement("span");
      style2(text, { overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap", lineHeight: "1" });
      text.textContent = roomId;
      badge.append(icon, text);
    } else {
      const icon = document.createElement("span");
      icon.innerHTML = LOCK_SVG;
      style2(icon, { display: "inline-flex", alignItems: "center", flexShrink: "0" });
      const text = document.createElement("span");
      text.textContent = "Private";
      badge.append(icon, text);
    }
    return badge;
  }
  var HEART_SVG = `<svg width="9" height="9" viewBox="0 0 24 24" fill="currentColor" style="display:block;flex-shrink:0;"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>`;
  var CODE_SVG = `<svg width="9" height="9" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" style="display:block;flex-shrink:0;"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg>`;
  var BADGE_CONFIGS = {
    supporter: {
      label: "Supporter",
      svg: HEART_SVG,
      color: "#f472b6",
      border: "rgba(244,114,182,0.3)",
      bg: "rgba(244,114,182,0.1)"
    },
    mod_creator: {
      label: "Mod Creator",
      svg: CODE_SVG,
      color: "#a78bfa",
      border: "rgba(167,139,250,0.3)",
      bg: "rgba(167,139,250,0.1)"
    }
  };
  function createPlayerBadges(badges, iconOnly = false) {
    if (!badges || badges.length === 0) return null;
    const knownBadges = badges.filter((b) => b in BADGE_CONFIGS);
    if (knownBadges.length === 0) return null;
    const row = document.createElement("div");
    style2(row, {
      display: "flex",
      flexWrap: "wrap",
      justifyContent: "center",
      gap: "4px"
    });
    for (const badgeKey of knownBadges) {
      const cfg = BADGE_CONFIGS[badgeKey];
      const chip = document.createElement("span");
      style2(chip, {
        display: "inline-flex",
        alignItems: "center",
        gap: iconOnly ? "0px" : "3px",
        padding: iconOnly ? "3px" : "2px 6px",
        borderRadius: iconOnly ? "50%" : "6px",
        fontSize: "10px",
        fontWeight: "600",
        color: cfg.color,
        border: `1px solid ${cfg.border}`,
        background: cfg.bg
      });
      const icon = document.createElement("span");
      icon.innerHTML = cfg.svg;
      style2(icon, { display: "inline-flex", alignItems: "center" });
      chip.appendChild(icon);
      if (!iconOnly) {
        const label2 = document.createElement("span");
        label2.textContent = cfg.label;
        chip.appendChild(label2);
      } else {
        chip.title = cfg.label;
      }
      row.appendChild(chip);
    }
    return row;
  }
  function createKeyBlocker(shouldBlock) {
    const handler = (e) => {
      if (shouldBlock()) e.stopPropagation();
    };
    return {
      handler,
      attach() {
        window.addEventListener("keydown", handler, true);
        window.addEventListener("keyup", handler, true);
      },
      detach() {
        window.removeEventListener("keydown", handler, true);
        window.removeEventListener("keyup", handler, true);
      }
    };
  }

  // src/ariesModAPI/config.ts
  var API_BASE_URL = "https://ariesmod-api.ariedam.fr/";
  var API_ORIGIN = API_BASE_URL.replace(/\/$/, "");
  var SSE_RECONNECT_DELAY = 5e3;
  var LONG_POLL_TIMEOUT = 25e3;
  var LONG_POLL_BACKOFF_MAX = 3e4;
  var MAX_UNCHANGED_TICKS_BEFORE_FORCE_SEND = 5;
  var DEFAULT_HEARTBEAT_INTERVAL = 6e4;

  // src/ariesModAPI/client/http.ts
  function buildUrl(path, query) {
    const url = new URL(path, API_BASE_URL);
    if (query) {
      for (const [key2, value] of Object.entries(query)) {
        if (value === void 0) continue;
        url.searchParams.set(key2, String(value));
      }
    }
    return url.toString();
  }
  function gmRequest(method, url, body) {
    return new Promise((resolve2) => {
      const apiKey = getApiKey();
      const headers = {};
      if (apiKey) {
        headers["Authorization"] = `Bearer ${apiKey}`;
      }
      if (body !== void 0) {
        headers["Content-Type"] = "application/json";
      }
      GM_xmlhttpRequest({
        method,
        url,
        headers,
        data: body !== void 0 ? JSON.stringify(body) : void 0,
        onload: (res) => {
          if (res.status >= 200 && res.status < 300) {
            try {
              const parsed = res.responseText ? JSON.parse(res.responseText) : null;
              resolve2({ status: res.status, data: parsed });
            } catch {
              resolve2({ status: res.status, data: null });
            }
          } else {
            resolve2({ status: res.status, data: null });
          }
        },
        onerror: () => {
          resolve2({ status: 0, data: null });
        }
      });
    });
  }
  async function fetchRequest(method, url, body) {
    try {
      const apiKey = getApiKey();
      const headers = {};
      if (apiKey) {
        headers["Authorization"] = `Bearer ${apiKey}`;
      }
      const options = {
        method,
        headers,
        credentials: "omit"
      };
      if (body !== void 0) {
        headers["Content-Type"] = "application/json";
        options.body = JSON.stringify(body);
      }
      const res = await fetch(url, options);
      const text = await res.text();
      let parsed = null;
      if (text) {
        try {
          parsed = JSON.parse(text);
        } catch {
        }
      }
      return { status: res.status, data: parsed };
    } catch {
      return { status: 0, data: null };
    }
  }
  async function request(method, path, options) {
    return withDiscordPollPause(async () => {
      const url = buildUrl(path, options?.query);
      if (isDiscordActivityContext()) {
        return gmRequest(method, url, options?.body);
      }
      try {
        return await fetchRequest(method, url, options?.body);
      } catch {
        return gmRequest(method, url, options?.body);
      }
    });
  }
  async function httpGet(path, query) {
    return request("GET", path, { query });
  }
  async function httpPost(path, body) {
    return request("POST", path, { body });
  }
  async function httpPatch(path, body) {
    return request("PATCH", path, { body });
  }
  async function httpDelete(path, body) {
    return request("DELETE", path, { body });
  }

  // src/ariesModAPI/client/sse.ts
  var MIN_STABLE_STREAM_MS = 1e4;
  function openSSEStream(path, onEvent, onError) {
    let closed = false;
    let running = false;
    let wasConnected = false;
    let abortController = null;
    let reconnectTimer = null;
    let backoff = SSE_RECONNECT_DELAY;
    let knownServerSessionId = null;
    const url = buildUrl(path);
    const scheduleReconnect = () => {
      if (closed) return;
      if (reconnectTimer !== null) {
        clearTimeout(reconnectTimer);
      }
      reconnectTimer = setTimeout(startStream, backoff);
      backoff = Math.min(LONG_POLL_BACKOFF_MAX, Math.floor(backoff * 1.5));
    };
    const notifyDisconnect = () => {
      if (!wasConnected) return;
      wasConnected = false;
      onError?.();
    };
    const startStream = async () => {
      reconnectTimer = null;
      if (closed || running) return;
      running = true;
      const apiKey = getApiKey();
      const headers = {};
      if (apiKey) {
        headers["Authorization"] = `Bearer ${apiKey}`;
      }
      abortController = new AbortController();
      try {
        const response = await fetch(url, {
          headers,
          signal: abortController.signal
        });
        if (!response.ok || !response.body) {
          running = false;
          notifyDisconnect();
          scheduleReconnect();
          return;
        }
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";
        let currentEventType = "";
        let currentEventData = "";
        const streamStartedAt = Date.now();
        const processLine = (line) => {
          if (!line.trim()) {
            if (currentEventType && currentEventData) {
              wasConnected = true;
              if (currentEventType === "connected") {
                try {
                  const payload = JSON.parse(currentEventData);
                  if (payload.serverSessionId) {
                    if (knownServerSessionId !== null && payload.serverSessionId !== knownServerSessionId) {
                      console.log(
                        "[SSE] \u{1F504} Server restart detected! Session changed from",
                        knownServerSessionId,
                        "to",
                        payload.serverSessionId
                      );
                      knownServerSessionId = payload.serverSessionId;
                    } else if (knownServerSessionId === null) {
                      knownServerSessionId = payload.serverSessionId;
                    }
                  }
                } catch (e) {
                  console.error("[SSE] Error parsing connected event:", e);
                }
              }
              try {
                onEvent(currentEventType, currentEventData);
              } catch (e) {
                console.error(`[SSE] Handler error for "${currentEventType}":`, e);
              }
            }
            currentEventType = "";
            currentEventData = "";
            return;
          }
          if (line.startsWith("event:")) {
            currentEventType = line.substring(6).trim();
          } else if (line.startsWith("data:")) {
            const data = line.substring(5).trim();
            currentEventData += (currentEventData ? "\n" : "") + data;
          }
        };
        while (!closed) {
          const { done, value } = await reader.read();
          if (done || closed) break;
          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split("\n");
          buffer = lines.pop() || "";
          for (const line of lines) {
            processLine(line);
          }
        }
        running = false;
        if (wasConnected && Date.now() - streamStartedAt > MIN_STABLE_STREAM_MS) {
          backoff = SSE_RECONNECT_DELAY;
        }
        if (!closed) {
          notifyDisconnect();
          scheduleReconnect();
        }
      } catch (err) {
        running = false;
        if (!closed) {
          notifyDisconnect();
          scheduleReconnect();
        }
      }
    };
    startStream();
    return {
      close: () => {
        closed = true;
        running = false;
        wasConnected = false;
        if (reconnectTimer !== null) {
          clearTimeout(reconnectTimer);
          reconnectTimer = null;
        }
        try {
          abortController?.abort();
        } catch {
        }
        abortController = null;
      }
    };
  }

  // src/ariesModAPI/client/longPoll.ts
  function gmLongPoll(url) {
    let aborted = false;
    let req = null;
    const apiKey = getApiKey();
    const headers = {};
    if (apiKey) {
      headers["Authorization"] = `Bearer ${apiKey}`;
    }
    const promise2 = new Promise((resolve2) => {
      req = GM_xmlhttpRequest({
        method: "GET",
        url,
        headers,
        onload: (res) => {
          if (res.status >= 200 && res.status < 300) {
            try {
              const parsed = res.responseText ? JSON.parse(res.responseText) : null;
              resolve2({ status: res.status, data: parsed });
            } catch {
              resolve2({ status: res.status, data: null });
            }
          } else {
            resolve2({ status: res.status, data: null });
          }
        },
        onerror: () => {
          if (aborted) {
            resolve2({ status: 0, data: null, aborted: true });
            return;
          }
          resolve2({ status: 0, data: null });
        }
      });
    });
    return {
      abort: () => {
        aborted = true;
        try {
          req?.abort();
        } catch {
        }
      },
      promise: promise2
    };
  }
  function startLongPollStream(onEvent, onConnected, onError) {
    let closed = false;
    let paused = false;
    let running = false;
    let token = 0;
    let lastEventId = 0;
    let backoff = 1e3;
    let inFlight = null;
    let knownServerSessionId = null;
    const schedule = (delay4) => {
      if (closed || paused) return;
      setTimeout(poll, delay4);
    };
    const poll = async () => {
      if (closed || paused || running) return;
      running = true;
      const currentToken = ++token;
      const url = buildUrl("events/poll", {
        since: lastEventId,
        timeoutMs: LONG_POLL_TIMEOUT
      });
      const pollReq = gmLongPoll(url);
      inFlight = { abort: pollReq.abort };
      const { status, data, aborted } = await pollReq.promise;
      inFlight = null;
      running = false;
      if (closed || paused || aborted || currentToken !== token) return;
      if (status === 200 && data) {
        if (knownServerSessionId !== null && data.serverSessionId !== knownServerSessionId) {
          console.log(
            "[Long Poll] \u{1F504} Server restart detected! Session changed from",
            knownServerSessionId,
            "to",
            data.serverSessionId
          );
          lastEventId = 0;
          knownServerSessionId = data.serverSessionId;
          backoff = 1e3;
          schedule(0);
          return;
        }
        if (knownServerSessionId === null) {
          knownServerSessionId = data.serverSessionId;
        }
        const eventId = Number(data.lastEventId);
        if (Number.isFinite(eventId)) {
          lastEventId = eventId;
        }
        onConnected?.({
          playerId: data.playerId,
          lastEventId
        });
        if (Array.isArray(data.events)) {
          for (const evt of data.events) {
            if (!evt || typeof evt.type !== "string") continue;
            onEvent(evt);
          }
        }
        backoff = 1e3;
        schedule(0);
        return;
      }
      onError?.();
      schedule(backoff);
      backoff = Math.min(LONG_POLL_BACKOFF_MAX, Math.floor(backoff * 1.7));
    };
    poll();
    return {
      close: () => {
        closed = true;
        token += 1;
        running = false;
        inFlight?.abort();
      },
      getLastEventId: () => lastEventId,
      pause: () => {
        paused = true;
        token += 1;
        running = false;
        inFlight?.abort();
      },
      resume: () => {
        if (closed) return;
        paused = false;
        if (!running) {
          poll();
        }
      },
      kick: () => {
        if (closed || paused || running) return;
        poll();
      }
    };
  }

  // src/ariesModAPI/client/events.ts
  var _unifiedConnections = /* @__PURE__ */ new Map();
  function safeJsonParse(value) {
    if (value === null || value === void 0) return value;
    if (typeof value !== "string") return value;
    try {
      return JSON.parse(value);
    } catch {
      return value;
    }
  }
  function notifyConnected(conn, payload) {
    if (conn.connectedNotified) return;
    conn.connectedNotified = true;
    for (const sub of conn.subscribers) {
      sub.onConnected?.(payload);
    }
  }
  function dispatchUnifiedEvent(conn, eventName, data) {
    for (const sub of conn.subscribers) {
      sub.onEvent(eventName, data);
    }
  }
  function startUnifiedSSE(conn) {
    conn.handle = openSSEStream(
      "events/stream",
      (eventName, raw) => {
        const data = safeJsonParse(raw);
        if (eventName === "connected") {
          const payload = data && typeof data === "object" ? data : { playerId: conn.playerId };
          const lastId = Number(payload.lastEventId);
          if (Number.isFinite(lastId)) {
            conn.lastEventId = Math.max(conn.lastEventId, lastId);
          }
          notifyConnected(conn, {
            playerId: payload.playerId ?? conn.playerId,
            lastEventId: Number.isFinite(lastId) ? lastId : void 0
          });
          return;
        }
        dispatchUnifiedEvent(conn, eventName, data);
      },
      () => {
        conn.connectedNotified = false;
        for (const sub of conn.subscribers) {
          sub.onError?.(new Event("error"));
        }
      }
    );
  }
  function startUnifiedLongPoll(conn) {
    const pollHandle = startLongPollStream(
      (evt) => {
        dispatchUnifiedEvent(conn, evt.type, evt.data);
      },
      (payload) => {
        conn.lastEventId = payload.lastEventId;
        notifyConnected(conn, {
          playerId: payload.playerId,
          lastEventId: payload.lastEventId
        });
      },
      () => {
        for (const sub of conn.subscribers) {
          sub.onError?.(new Event("error"));
        }
      }
    );
    conn.handle = {
      close: () => {
        conn.closed = true;
        pollHandle.close();
      }
    };
    conn.pollAbort = () => pollHandle.pause();
    conn.pollKick = () => pollHandle.resume();
  }
  function openUnifiedEvents(playerId2, subscriber) {
    let conn = _unifiedConnections.get(playerId2);
    if (!conn) {
      const mode = isDiscordActivityContext() ? "poll" : "sse";
      conn = {
        playerId: playerId2,
        mode,
        subscribers: /* @__PURE__ */ new Set(),
        handle: null,
        lastEventId: 0,
        connectedNotified: false,
        closed: false,
        pollPaused: false,
        pollRunning: false,
        pollToken: 0
      };
      _unifiedConnections.set(playerId2, conn);
      if (conn.mode === "poll") {
        startUnifiedLongPoll(conn);
      } else {
        startUnifiedSSE(conn);
      }
    }
    conn.subscribers.add(subscriber);
    return {
      close: () => {
        conn.subscribers.delete(subscriber);
        if (conn.subscribers.size === 0) {
          conn.closed = true;
          conn.handle?.close();
          _unifiedConnections.delete(playerId2);
        }
      }
    };
  }
  var _pollPauseDepth = 0;
  function pauseDiscordLongPolls() {
    if (!isDiscordActivityContext()) return;
    _pollPauseDepth += 1;
    for (const conn of _unifiedConnections.values()) {
      if (conn.mode !== "poll") continue;
      conn.pollPaused = true;
      conn.pollToken += 1;
      conn.pollRunning = false;
      conn.pollAbort?.();
    }
  }
  function resumeDiscordLongPolls() {
    if (!isDiscordActivityContext()) return;
    _pollPauseDepth = Math.max(0, _pollPauseDepth - 1);
    if (_pollPauseDepth > 0) return;
    for (const conn of _unifiedConnections.values()) {
      if (conn.mode !== "poll") continue;
      conn.pollPaused = false;
      conn.pollKick?.();
    }
  }
  async function withDiscordPollPause(fn) {
    if (!isDiscordActivityContext()) return await fn();
    pauseDiscordLongPolls();
    try {
      return await fn();
    } finally {
      resumeDiscordLongPolls();
    }
  }

  // src/utils/discordCsp.ts
  function isDiscordActivityContext() {
    try {
      return window.location.hostname.endsWith("discordsays.com");
    } catch {
      return false;
    }
  }
  var _SAFE_IMG_HOSTS = ["cdn.discordapp.com", "media.discordapp.net"];
  var _gmImgCache = /* @__PURE__ */ new Map();
  var _gmImgPending = /* @__PURE__ */ new Map();
  var _extMimeMap = {
    png: "image/png",
    jpg: "image/jpeg",
    jpeg: "image/jpeg",
    gif: "image/gif",
    webp: "image/webp",
    svg: "image/svg+xml"
  };
  function _isImgUrlSafe(url) {
    if (!url || url.startsWith("blob:") || url.startsWith("data:") || url.startsWith("/")) return true;
    try {
      const { hostname } = new URL(url);
      return _SAFE_IMG_HOSTS.some((h) => hostname === h || hostname.endsWith("." + h));
    } catch {
      return true;
    }
  }
  function setImageSafe(img, url) {
    if (!url) return;
    if (!isDiscordActivityContext()) {
      img.src = url;
      return;
    }
    if (_isImgUrlSafe(url)) {
      img.src = url;
      return;
    }
    const cached = _gmImgCache.get(url);
    if (cached) {
      img.src = cached;
      return;
    }
    const pending = _gmImgPending.get(url);
    if (pending) {
      pending.push(img);
      return;
    }
    _gmImgPending.set(url, [img]);
    GM_xmlhttpRequest({
      method: "GET",
      url,
      headers: {},
      responseType: "arraybuffer",
      onload: (res) => {
        const imgs = _gmImgPending.get(url) ?? [];
        _gmImgPending.delete(url);
        if (!res.response) {
          for (const el2 of imgs) el2.src = url;
          return;
        }
        const ext = url.split(".").pop()?.toLowerCase().split("?")[0] ?? "png";
        const mime = _extMimeMap[ext] ?? "image/png";
        const blob = new Blob([res.response], { type: mime });
        const blobUrl = URL.createObjectURL(blob);
        _gmImgCache.set(url, blobUrl);
        for (const el2 of imgs) el2.src = blobUrl;
      },
      onerror: () => {
        const imgs = _gmImgPending.get(url) ?? [];
        _gmImgPending.delete(url);
        for (const el2 of imgs) el2.src = url;
      }
    });
  }
  var _gmAudioCache = /* @__PURE__ */ new Map();
  var _gmAudioPending = /* @__PURE__ */ new Map();
  function getAudioUrlSafe(url) {
    return new Promise((resolve2) => {
      if (!url) {
        resolve2(url);
        return;
      }
      if (!isDiscordActivityContext()) {
        resolve2(url);
        return;
      }
      const cached = _gmAudioCache.get(url);
      if (cached) {
        resolve2(cached);
        return;
      }
      const pending = _gmAudioPending.get(url);
      if (pending) {
        pending.push(resolve2);
        return;
      }
      _gmAudioPending.set(url, [resolve2]);
      GM_xmlhttpRequest({
        method: "GET",
        url,
        headers: {},
        responseType: "arraybuffer",
        onload: (res) => {
          const callbacks = _gmAudioPending.get(url) ?? [];
          _gmAudioPending.delete(url);
          if (!res.response) {
            for (const cb of callbacks) cb(url);
            return;
          }
          const ext = url.split(".").pop()?.toLowerCase().split("?")[0] ?? "mp3";
          const audioMimeMap = {
            mp3: "audio/mpeg",
            ogg: "audio/ogg",
            wav: "audio/wav",
            m4a: "audio/mp4"
          };
          const mime = audioMimeMap[ext] ?? "audio/mpeg";
          const blob = new Blob([res.response], { type: mime });
          const blobUrl = URL.createObjectURL(blob);
          _gmAudioCache.set(url, blobUrl);
          for (const cb of callbacks) cb(blobUrl);
        },
        onerror: () => {
          const callbacks = _gmAudioPending.get(url) ?? [];
          _gmAudioPending.delete(url);
          for (const cb of callbacks) cb(url);
        }
      });
    });
  }
  var EMOJI_DATA_CDN_PREFIX = "https://cdn.jsdelivr.net/npm/emoji-picker-element-data";
  var _emojiJson = null;
  var _emojiPending = [];
  var _emojiInterceptorInstalled = false;
  function _emojiMakeResponse(json, method) {
    if (method === "HEAD") {
      return new Response(null, {
        status: 200,
        headers: { "Content-Type": "application/json" }
      });
    }
    return new Response(json, {
      status: 200,
      headers: { "Content-Type": "application/json" }
    });
  }
  function installEmojiDataFetchInterceptor() {
    if (_emojiInterceptorInstalled) return;
    _emojiInterceptorInstalled = true;
    const _origFetch = window.fetch.bind(window);
    window.fetch = function(input, init2) {
      const url = typeof input === "string" ? input : input instanceof URL ? input.href : input.url;
      if (!url.startsWith(EMOJI_DATA_CDN_PREFIX)) {
        return _origFetch(input, init2);
      }
      const method = (init2?.method ?? (input instanceof Request ? input.method : "GET")).toUpperCase();
      if (_emojiJson) {
        return Promise.resolve(_emojiMakeResponse(_emojiJson, method));
      }
      return new Promise((resolve2) => {
        _emojiPending.push((json) => {
          resolve2(
            json ? _emojiMakeResponse(json, method) : new Response(null, { status: 503 })
          );
        });
      });
    };
    void withDiscordPollPause(async () => {
      return new Promise((resolve2) => {
        GM_xmlhttpRequest({
          method: "GET",
          url: `${EMOJI_DATA_CDN_PREFIX}@^1/en/emojibase/data.json`,
          headers: {},
          onload: (res) => {
            if (res.status >= 200 && res.status < 300 && res.responseText) {
              _emojiJson = res.responseText;
              for (const cb of _emojiPending) cb(_emojiJson);
            } else {
              console.error("[discordCsp] emoji fetch failed:", res.status);
              for (const cb of _emojiPending) cb(null);
            }
            _emojiPending = [];
            resolve2();
          },
          onerror: (err) => {
            console.error("[discordCsp] emoji fetch error:", err);
            for (const cb of _emojiPending) cb(null);
            _emojiPending = [];
            resolve2();
          }
        });
      });
    });
  }

  // src/ariesModAPI/auth/core.ts
  function requestApiKey() {
    return new Promise((resolve2) => {
      const authUrl = `${API_ORIGIN}/auth/discord/login`;
      const width = 600;
      const height = 700;
      const screenW = typeof screen !== "undefined" ? screen.width : window.innerWidth;
      const screenH = typeof screen !== "undefined" ? screen.height : window.innerHeight;
      const left = Math.max(0, Math.floor((screenW - width) / 2));
      const top = Math.max(0, Math.floor((screenH - height) / 2));
      const preferGmTab = isDiscordActivityContext();
      const popup = preferGmTab ? null : window.open(
        authUrl,
        "aries_discord_auth",
        `width=${width},height=${height},left=${left},top=${top},toolbar=no,location=no,status=no,menubar=no,scrollbars=yes,resizable=yes`
      );
      let openedWithGm = false;
      if (!popup) {
        if (typeof GM_openInTab === "function") {
          try {
            GM_openInTab(authUrl, { active: true, insert: true, setParent: true });
            openedWithGm = true;
            console.warn("[Auth] Popup blocked. Opened Discord auth in a new tab.");
          } catch (error) {
            console.warn("[Auth] GM_openInTab failed:", error);
          }
        }
        if (!openedWithGm) {
          console.error("Failed to open Discord auth popup - popup blocked?");
          resolve2(null);
          return;
        }
      }
      let done = false;
      const finish = (value) => {
        if (done) return;
        done = true;
        resolve2(value);
      };
      let checkClosed = null;
      let pollKey = null;
      const cleanup2 = () => {
        clearTimeout(timeout);
        if (checkClosed !== null) {
          clearInterval(checkClosed);
          checkClosed = null;
        }
        if (pollKey !== null) {
          clearInterval(pollKey);
          pollKey = null;
        }
        window.removeEventListener("message", handleMessage);
      };
      const timeout = window.setTimeout(() => {
        cleanup2();
        console.warn("Discord auth popup timed out");
        finish(null);
      }, 5 * 60 * 1e3);
      const handleMessage = (event) => {
        if (event.origin !== API_ORIGIN) return;
        const data = event.data;
        if (!data || data.type !== "aries_discord_auth" || !data.apiKey) return;
        cleanup2();
        const apiKey = String(data.apiKey);
        const discordId = data.discordId ? String(data.discordId) : "";
        const discordUsername = data.discordUsername ? String(data.discordUsername) : "";
        console.log(`[Auth] Successfully authenticated as ${discordUsername} (${discordId})`);
        setApiKey(apiKey);
        try {
          popup?.close();
        } catch {
        }
        finish(apiKey);
      };
      window.addEventListener("message", handleMessage);
      if (popup) {
        checkClosed = window.setInterval(() => {
          if (!popup.closed) return;
          cleanup2();
          finish(null);
        }, 500);
      } else if (openedWithGm) {
        pollKey = window.setInterval(() => {
          const key2 = getApiKey();
          if (!key2) return;
          cleanup2();
          finish(key2);
        }, 800);
      }
    });
  }

  // src/ariesModAPI/auth/bridge.ts
  function normalizeAuthPayload(data) {
    if (!data || data.type !== "aries_discord_auth" || !data.apiKey) return null;
    return {
      apiKey: String(data.apiKey),
      discordId: data.discordId ? String(data.discordId) : void 0,
      discordUsername: data.discordUsername ? String(data.discordUsername) : void 0
    };
  }
  function initAuthBridgeIfNeeded() {
    if (typeof window === "undefined") return false;
    if (window.location.origin !== API_ORIGIN) return false;
    const capture = (data) => {
      const payload = normalizeAuthPayload(data);
      if (!payload) return;
      setApiKey(payload.apiKey);
      setDeclinedApiAuth(false);
      try {
        window.close();
      } catch {
      }
    };
    try {
      if (!window.opener) {
        const fakeOpener = { postMessage: (data) => capture(data) };
        try {
          Object.defineProperty(window, "opener", {
            configurable: true,
            get: () => fakeOpener
          });
        } catch {
          try {
            window.opener = fakeOpener;
          } catch {
          }
        }
      }
    } catch {
    }
    window.addEventListener("message", (event) => {
      if (event.origin !== API_ORIGIN) return;
      capture(event.data);
    });
    try {
      const fromQuery = new URLSearchParams(window.location.search).get("apiKey");
      const fromHash = new URLSearchParams(window.location.hash.replace(/^#/, "")).get("apiKey");
      if (fromQuery) capture({ type: "aries_discord_auth", apiKey: fromQuery });
      if (fromHash) capture({ type: "aries_discord_auth", apiKey: fromHash });
    } catch {
    }
    return true;
  }

  // src/ariesModAPI/endpoints/state.ts
  init_atoms();
  init_page_context();

  // src/utils/version.ts
  var REPO_OWNER = "Ariedam64";
  var REPO_NAME = "MagicGarden-modMenu";
  var REPO_BRANCH = "main";
  var SCRIPT_FILE_PATH = "quinoa-ws.min.user.js";
  var RAW_BASE_URL = `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}`;
  var COMMITS_API_URL = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/commits/${REPO_BRANCH}`;
  async function fetchTextWithFetch(url, options) {
    const response = await fetch(url, { cache: "no-store", ...options });
    if (!response.ok) {
      throw new Error(`Failed to load remote resource: ${response.status} ${response.statusText}`);
    }
    return await response.text();
  }
  async function fetchTextWithGM(url, options) {
    return new Promise((resolve2, reject) => {
      const xhr = typeof GM_xmlhttpRequest === "function" ? GM_xmlhttpRequest : typeof GM !== "undefined" && typeof GM.xmlHttpRequest === "function" ? GM.xmlHttpRequest : null;
      if (!xhr) return reject(new Error("GM_xmlhttpRequest not available"));
      xhr({
        method: "GET",
        url,
        headers: options?.headers,
        onload: (res) => {
          if (res.status >= 200 && res.status < 300) resolve2(res.responseText);
          else reject(new Error(`GM_xhr failed: ${res.status}`));
        },
        onerror: (e) => reject(e)
      });
    });
  }
  async function fetchText(url, options) {
    const preferGM = isDiscordSurface();
    const hasGM = typeof GM_xmlhttpRequest === "function" || typeof GM !== "undefined" && typeof GM.xmlHttpRequest === "function";
    if (preferGM && hasGM) {
      return await fetchTextWithGM(url, options);
    }
    try {
      return await fetchTextWithFetch(url, options);
    } catch (error) {
      if (hasGM) {
        return await fetchTextWithGM(url, options);
      }
      throw error;
    }
  }
  async function fetchLatestCommitSha() {
    try {
      const responseText = await fetchText(COMMITS_API_URL, {
        headers: { Accept: "application/vnd.github+json" }
      });
      const data = JSON.parse(responseText);
      if (data && typeof data.sha === "string" && data.sha.trim().length > 0) {
        return data.sha.trim();
      }
    } catch (error) {
      console.warn("[MagicGarden] Failed to resolve latest commit SHA:", error);
    }
    return null;
  }
  async function fetchScriptSource() {
    const commitSha = await fetchLatestCommitSha();
    const scriptUrl = commitSha ? `${RAW_BASE_URL}/${commitSha}/${SCRIPT_FILE_PATH}` : `${RAW_BASE_URL}/refs/heads/${REPO_BRANCH}/${SCRIPT_FILE_PATH}?t=${Date.now()}`;
    return await fetchText(scriptUrl);
  }
  async function fetchRemoteVersion() {
    try {
      const scriptSource = await fetchScriptSource();
      const meta = extractUserscriptMetadata(scriptSource);
      if (!meta) {
        throw new Error("Metadata block not found in remote script");
      }
      const version = meta.get("version")?.[0];
      const download = meta.get("downloadurl")?.[0] ?? meta.get("updateurl")?.[0];
      return {
        version,
        download
      };
    } catch (error) {
      console.error("Unable to retrieve remote version:", error);
      return null;
    }
  }
  function extractUserscriptMetadata(source) {
    const headerMatch = source.match(/\/\/ ==UserScript==([\s\S]*?)\/\/ ==\/UserScript==/);
    if (!headerMatch) {
      return null;
    }
    const metaBlock = headerMatch[1];
    const entries = metaBlock.matchAll(/^\/\/\s*@([^\s]+)\s+(.+)$/gm);
    const meta = /* @__PURE__ */ new Map();
    for (const [, rawKey, rawValue] of entries) {
      const key2 = rawKey.trim().toLowerCase();
      const value = rawValue.trim();
      if (!key2) continue;
      const current = meta.get(key2);
      if (current) {
        current.push(value);
      } else {
        meta.set(key2, [value]);
      }
    }
    return meta;
  }
  function getLocalVersion() {
    if (typeof GM_info !== "undefined" && GM_info?.script?.version) {
      return GM_info.script.version;
    }
    return void 0;
  }

  // src/ariesModAPI/endpoints/state.ts
  function clampPlayers(n) {
    const value = Math.floor(Number(n));
    if (!Number.isFinite(value)) return 1;
    return Math.max(1, Math.min(6, value));
  }
  function findPlayersDeep(state3) {
    if (!state3 || typeof state3 !== "object") return [];
    const out = [];
    const seen = /* @__PURE__ */ new Set();
    const stack = [state3];
    while (stack.length) {
      const cur = stack.pop();
      if (!cur || typeof cur !== "object" || seen.has(cur)) continue;
      seen.add(cur);
      for (const key2 of Object.keys(cur)) {
        const value = cur[key2];
        if (Array.isArray(value) && value.length > 0 && value.every((item) => item && typeof item === "object")) {
          const looksLikePlayer = value.some((item) => "id" in item && "name" in item);
          if (looksLikePlayer && /player/i.test(key2)) {
            out.push(...value);
          }
        }
        if (value && typeof value === "object") {
          stack.push(value);
        }
      }
    }
    const byId = /* @__PURE__ */ new Map();
    for (const entry of out) {
      if (entry?.id) {
        byId.set(String(entry.id), entry);
      }
    }
    return [...byId.values()];
  }
  function getPlayersArray(state3) {
    const direct = state3?.fullState?.data?.players ?? state3?.data?.players ?? state3?.players;
    return Array.isArray(direct) ? direct : findPlayersDeep(state3);
  }
  function getSlotsArray(state3) {
    const raw = state3?.child?.data?.userSlots ?? state3?.fullState?.child?.data?.userSlots ?? state3?.data?.userSlots;
    if (Array.isArray(raw)) return raw;
    if (raw && typeof raw === "object") {
      const entries = Object.entries(raw);
      entries.sort((a, b) => {
        const ai = Number(a[0]);
        const bi = Number(b[0]);
        if (Number.isFinite(ai) && Number.isFinite(bi)) return ai - bi;
        return a[0].localeCompare(b[0]);
      });
      return entries.map(([, value]) => value);
    }
    return [];
  }
  function selectSlot(slots, options) {
    if (!Array.isArray(slots) || slots.length === 0) return null;
    const { slotIndex, playerId: playerId2 } = options;
    if (typeof slotIndex === "number" && Number.isInteger(slotIndex)) {
      const candidate = slots[slotIndex];
      if (candidate && typeof candidate === "object") return candidate;
    }
    const normalizedId = playerId2 != null ? String(playerId2) : null;
    if (normalizedId) {
      for (const slot of slots) {
        if (!slot || typeof slot !== "object") continue;
        if (String(
          slot.databaseUserId ?? slot.playerId ?? slot.data?.databaseUserId ?? slot.data?.playerId ?? ""
        ) === normalizedId) {
          return slot;
        }
      }
    }
    if (normalizedId) {
      return null;
    }
    for (const slot of slots) {
      if (!slot || typeof slot !== "object") continue;
      if (slot.playerId || slot.databaseUserId || slot.data) return slot;
    }
    return null;
  }
  function resolvePlayer(players, slot, options) {
    const candidate = options.playerId ?? slot?.playerId ?? slot?.databaseUserId ?? slot?.data?.playerId ?? slot?.data?.databaseUserId ?? null;
    const normalized = candidate != null ? String(candidate) : null;
    if (normalized) {
      for (const player2 of players) {
        if (!player2 || typeof player2 !== "object") continue;
        if (String(player2.id ?? "") === normalized) return player2;
        if (String(player2.databaseUserId ?? "") === normalized) return player2;
      }
    }
    return players[0] ?? null;
  }
  function normalizeActivityLog(slotData) {
    const logs = slotData?.activityLog ?? slotData?.activityLogs ?? slotData?.activitylog;
    return Array.isArray(logs) ? logs : null;
  }
  async function buildPlayerStatePayload(options = {}) {
    try {
      const state3 = await Atoms.root.state.get();
      if (!state3 || typeof state3 !== "object") return null;
      const players = getPlayersArray(state3);
      const normalizedPlayers = Array.isArray(players) ? players : [];
      const slots = getSlotsArray(state3).filter((slot2) => !!slot2);
      const coinsById = /* @__PURE__ */ new Map();
      for (const slot2 of slots) {
        const slotData2 = slot2?.data ?? slot2;
        const candidateId = slotData2?.databaseUserId ?? slot2?.databaseUserId ?? slotData2?.playerId ?? slot2?.playerId ?? null;
        if (candidateId == null) continue;
        const normalizedSlotId = String(candidateId);
        const coinCandidate2 = slotData2?.coinsCount ?? slotData2?.data?.coinsCount ?? slot2?.coinsCount ?? slot2?.data?.coinsCount ?? slotData2?.coins ?? slot2?.coins ?? null;
        const coinValue2 = Number(coinCandidate2);
        coinsById.set(normalizedSlotId, Number.isFinite(coinValue2) ? coinValue2 : null);
      }
      const userSlots = normalizedPlayers.map((player2) => {
        const playerDatabaseId = player2?.databaseUserId ?? player2?.playerId ?? player2?.id ?? null;
        const normalizedPlayerId = playerDatabaseId != null ? String(playerDatabaseId) : null;
        const slotId = normalizedPlayerId ?? (typeof player2?.id === "string" || typeof player2?.id === "number" ? String(player2.id) : null);
        const coins = slotId ? coinsById.get(slotId) ?? null : null;
        return {
          name: typeof player2?.name === "string" ? player2.name : null,
          discordAvatarUrl: typeof player2?.discordAvatarUrl === "string" ? player2.discordAvatarUrl : null,
          playerId: slotId,
          coins
        };
      });
      const myDatabaseUserId = await playerDatabaseUserId.get();
      if (slots.length === 0) return null;
      const slot = selectSlot(slots, {
        ...options,
        playerId: options.playerId ?? myDatabaseUserId ?? void 0
      });
      if (!slot || typeof slot !== "object") {
        return null;
      }
      const slotData = slot.data ?? slot;
      if (!slotData || typeof slotData !== "object") return null;
      const resolvedPlayer = resolvePlayer(normalizedPlayers, slot, options);
      const playerName = resolvedPlayer?.name ?? slotData?.name ?? slot?.name ?? null;
      const avatarRaw = resolvedPlayer?.cosmetic?.avatar ?? slotData?.cosmetic?.avatar ?? slot?.cosmetic?.avatar ?? null;
      const avatar2 = Array.isArray(avatarRaw) && avatarRaw.length > 0 ? avatarRaw.map((entry) => String(entry)) : null;
      const coinCandidate = slotData?.coinsCount ?? slot?.coinsCount ?? slotData?.coins ?? slot?.coins ?? null;
      const coinValue = Number(coinCandidate);
      const coinsRaw = Number.isFinite(coinValue) ? coinValue : null;
      const roomId = state3?.data?.roomId ?? state3?.fullState?.data?.roomId ?? state3?.roomId ?? null;
      let playersCount = normalizedPlayers.length > 0 ? normalizedPlayers.length : slots.length;
      try {
        const atomValue = await Atoms.server.numPlayers.get();
        playersCount = clampPlayers(atomValue);
      } catch {
      }
      const persistedActivityLog = readAriesPath("activityLog.history");
      const activityLog = Array.isArray(persistedActivityLog) ? persistedActivityLog : normalizeActivityLog(slotData);
      const journalEntry = slotData?.journal ?? slotData?.data?.journal ?? slot?.journal ?? slot?.data?.journal ?? null;
      const localVersion = getLocalVersion();
      const modVersion = localVersion ? `Arie's mod ${localVersion}` : null;
      const payload = {
        playerName: playerName ?? null,
        avatar: avatar2 ?? null,
        modVersion,
        coins: coinsRaw,
        room: {
          id: roomId,
          isPrivate: options.roomIsPrivate ?? null,
          playersCount,
          userSlots
        },
        state: {
          garden: slotData?.garden ?? null,
          inventory: slotData?.inventory ?? slot?.inventory ?? null,
          stats: typeof slotData?.stats === "object" && slotData?.stats ? slotData.stats : null,
          activityLog: activityLog ?? null,
          journal: journalEntry ?? null
        }
      };
      return payload;
    } catch (error) {
      console.error("[PlayerPayload] buildPlayerStatePayload failed", error);
      return null;
    }
  }
  async function logPlayerStatePayload(options) {
    return buildPlayerStatePayload(options);
  }
  shareGlobal("buildPlayerStatePayload", buildPlayerStatePayload);
  shareGlobal("logPlayerStatePayload", logPlayerStatePayload);
  function sanitizeActivityLogForCompare(log2) {
    if (!Array.isArray(log2)) return null;
    return log2.filter((entry) => entry?.action !== "feedPet");
  }
  function sanitizeStateForComparison(state3) {
    const sanitizedActivityLog = sanitizeActivityLogForCompare(state3.activityLog ?? null);
    if (sanitizedActivityLog === state3.activityLog) {
      return state3;
    }
    return {
      ...state3,
      activityLog: sanitizedActivityLog
    };
  }
  function snapshotPayloadForComparison(payload) {
    try {
      const sanitizedState = sanitizeStateForComparison(payload.state);
      const clone = {
        ...payload,
        state: sanitizedState
      };
      return JSON.stringify(clone);
    } catch (error) {
      console.error("[PlayerPayload] Failed to snapshot payload for comparison", error);
      return null;
    }
  }
  async function sendPlayerState(payload) {
    if (!payload) return false;
    const { playerId: playerId2, avatarUrl, ...cleanPayload } = payload;
    if (!hasApiKey()) {
      const myPlayerId = await playerDatabaseUserId.get();
      if (myPlayerId) {
        cleanPayload.playerId = String(myPlayerId);
      }
    }
    const { status } = await httpPost("collect-state", cleanPayload);
    if (status === 204) return true;
    if (status === 429) {
      console.error("[api] sendPlayerState rate-limited");
    } else if (status === 401) {
      console.error("[api] sendPlayerState unauthorized - invalid or missing API key");
    }
    return false;
  }
  var gameReadyWatcherInitialized = false;
  var gameReadyTriggered = false;
  var preferredReportingIntervalMs;
  async function tryInitializeReporting(state3) {
    if (gameReadyTriggered) return;
    const snapshot = state3 ?? await Atoms.root.state.get();
    const players = Array.isArray(snapshot?.data?.players) ? snapshot.data.players : [];
    if (players.length === 0) return;
    const myDatabaseUserId = await playerDatabaseUserId.get();
    if (myDatabaseUserId) {
      const slots = getSlotsArray(snapshot);
      const mySlotExists = slots.some((slot) => {
        const slotId = String(
          slot?.databaseUserId ?? slot?.data?.databaseUserId ?? slot?.playerId ?? slot?.data?.playerId ?? ""
        );
        return slotId === String(myDatabaseUserId);
      });
      if (!mySlotExists) {
        return;
      }
    }
    gameReadyTriggered = true;
    startPlayerStateReporting(preferredReportingIntervalMs);
  }
  function startPlayerStateReportingWhenGameReady(intervalMs) {
    if (gameReadyWatcherInitialized) return;
    gameReadyWatcherInitialized = true;
    preferredReportingIntervalMs = intervalMs;
    void tryInitializeReporting();
    void Atoms.root.state.onChange((next) => {
      void tryInitializeReporting(next);
    });
  }
  var payloadReportingTimer = null;
  var isPayloadReporting = false;
  var lastSentPayloadSnapshot = null;
  var unchangedSnapshotCount = 0;
  var initialSendRetries = 0;
  var MAX_INITIAL_RETRIES = 3;
  async function buildAndSendPlayerState() {
    if (isPayloadReporting) return;
    isPayloadReporting = true;
    try {
      const payload = await buildPlayerStatePayload();
      if (!payload || !payload.room.id) {
        if (initialSendRetries < MAX_INITIAL_RETRIES) {
          initialSendRetries += 1;
          setTimeout(() => void buildAndSendPlayerState(), 1e4);
        }
        return;
      }
      const snapshot = snapshotPayloadForComparison(payload);
      let mustSend = false;
      if (snapshot === null) {
        mustSend = true;
      } else if (lastSentPayloadSnapshot === null) {
        mustSend = true;
      } else if (snapshot !== lastSentPayloadSnapshot) {
        mustSend = true;
      } else if (unchangedSnapshotCount + 1 >= MAX_UNCHANGED_TICKS_BEFORE_FORCE_SEND) {
        mustSend = true;
      }
      if (!mustSend) {
        if (snapshot !== null) {
          unchangedSnapshotCount += 1;
        }
        return;
      }
      const ok = await sendPlayerState(payload);
      if (ok) {
        if (snapshot !== null) {
          lastSentPayloadSnapshot = snapshot;
          unchangedSnapshotCount = 0;
        }
      }
    } catch (error) {
      console.error("[PlayerPayload] Failed to send payload:", error);
    } finally {
      isPayloadReporting = false;
    }
  }
  function startPlayerStateReporting(intervalMs = DEFAULT_HEARTBEAT_INTERVAL) {
    if (payloadReportingTimer !== null) return;
    const normalizedMs = Number.isFinite(intervalMs) && intervalMs > 0 ? intervalMs : DEFAULT_HEARTBEAT_INTERVAL;
    void buildAndSendPlayerState();
    payloadReportingTimer = setInterval(() => {
      void buildAndSendPlayerState();
    }, normalizedMs);
  }
  async function triggerPlayerStateSyncNow(options = {}) {
    if (options.force) {
      lastSentPayloadSnapshot = null;
      unchangedSnapshotCount = 0;
    }
    await buildAndSendPlayerState();
  }
  window.addEventListener("qws-friend-overlay-auth-update", () => {
    if (hasApiKey()) {
      void triggerPlayerStateSyncNow({ force: true });
    }
  });

  // src/ariesModAPI/endpoints/rooms.ts
  async function fetchAvailableRooms(limit = 50) {
    const { data } = await httpGet("rooms", { limit });
    if (!data || !Array.isArray(data)) return [];
    return data.map((r) => ({
      id: r.id,
      isPrivate: r.is_private,
      playersCount: r.players_count ?? 0,
      lastUpdatedAt: r.last_updated_at,
      lastUpdatedByPlayerId: r.last_updated_by_player_id,
      userSlots: Array.isArray(r.user_slots) ? r.user_slots.map((slot) => ({
        name: slot.name,
        avatarUrl: slot.avatar_url ?? null
      })) : void 0
    }));
  }

  // src/ariesModAPI/endpoints/players.ts
  async function fetchPlayerDetailsComplete(playerId2) {
    if (!playerId2) return null;
    const { status, data } = await httpGet("get-player-view", {
      playerId: playerId2
    });
    if (status === 404) return null;
    return data;
  }

  // src/ariesModAPI/endpoints/leaderboard.ts
  async function fetchLeaderboardCoins(params) {
    const { query, limit = 15, offset = 0, myPlayerId } = params || {};
    const queryParams = { limit, offset };
    if (query && query.trim()) {
      queryParams.query = query.trim();
    }
    if (myPlayerId) {
      queryParams.myPlayerId = myPlayerId;
    }
    const { status, data } = await httpGet("leaderboard/coins", queryParams);
    if (status !== 200 || !data || !Array.isArray(data.rows)) return { rows: [], myRank: null };
    return { rows: data.rows, myRank: data.myRank ?? null };
  }
  async function fetchLeaderboardEggsHatched(params) {
    const { query, limit = 15, offset = 0, myPlayerId } = params || {};
    const queryParams = { limit, offset };
    if (query && query.trim()) {
      queryParams.query = query.trim();
    }
    if (myPlayerId) {
      queryParams.myPlayerId = myPlayerId;
    }
    const { status, data } = await httpGet(
      "leaderboard/eggs-hatched",
      queryParams
    );
    if (status !== 200 || !data || !Array.isArray(data.rows)) return { rows: [], myRank: null };
    return { rows: data.rows, myRank: data.myRank ?? null };
  }

  // src/ariesModAPI/endpoints/search.ts
  async function fetchModPlayers(options) {
    const { status, data } = await httpGet("list-mod-players", {
      query: options?.query,
      limit: options?.limit,
      offset: options?.offset
    });
    if (status !== 200 || !Array.isArray(data)) return [];
    return data;
  }

  // src/ariesModAPI/cache/friends.ts
  var cachedFriendsView = null;
  var cachedIncomingRequests = null;
  var cachedOutgoingRequests = null;
  function getCachedFriendsWithViews() {
    return cachedFriendsView ? [...cachedFriendsView] : [];
  }
  function getCachedIncomingRequestsWithViews() {
    return cachedIncomingRequests ? [...cachedIncomingRequests] : [];
  }
  function getCachedOutgoingRequests() {
    return cachedOutgoingRequests ? [...cachedOutgoingRequests] : [];
  }
  function updateFriendsViewCache(friends) {
    cachedFriendsView = friends;
  }
  function updateIncomingRequestsCache(requests) {
    cachedIncomingRequests = requests;
  }
  function updateOutgoingRequestsCache(requests) {
    cachedOutgoingRequests = requests;
  }
  function addFriendToCache(friend) {
    if (!cachedFriendsView) cachedFriendsView = [];
    const existingIdx = cachedFriendsView.findIndex((f) => f.playerId === friend.playerId);
    const playerView = {
      playerId: friend.playerId,
      playerName: friend.playerName,
      avatarUrl: friend.avatarUrl,
      avatar: friend.avatar,
      coins: null,
      room: friend.roomId,
      hasModInstalled: false,
      isOnline: friend.isOnline,
      lastEventAt: friend.lastEventAt,
      badges: friend.badges || null,
      privacy: {
        showGarden: true,
        showInventory: true,
        showCoins: true,
        showActivityLog: true,
        showJournal: true,
        hideRoomFromPublicList: false,
        showStats: true
      }
    };
    if (existingIdx !== -1) {
      cachedFriendsView = cachedFriendsView.map(
        (f, i) => i === existingIdx ? { ...f, ...playerView } : f
      );
      return;
    }
    cachedFriendsView = [...cachedFriendsView, playerView];
  }
  function removeFriendFromCache(playerId2) {
    if (cachedFriendsView) {
      cachedFriendsView = cachedFriendsView.filter((f) => f.playerId !== playerId2);
    }
  }
  function addIncomingRequestToCache(request2) {
    if (!cachedIncomingRequests) cachedIncomingRequests = [];
    const existingIdx = cachedIncomingRequests.findIndex((r) => r.playerId === request2.playerId);
    if (existingIdx !== -1) {
      cachedIncomingRequests = cachedIncomingRequests.map(
        (r, i) => i === existingIdx ? { ...r, ...request2 } : r
      );
      return;
    }
    cachedIncomingRequests = [...cachedIncomingRequests, request2];
  }
  function removeIncomingRequestFromCache(playerId2) {
    if (!cachedIncomingRequests) return;
    cachedIncomingRequests = cachedIncomingRequests.filter((r) => r.playerId !== playerId2);
  }
  function addOutgoingRequestToCache(request2) {
    if (!cachedOutgoingRequests) cachedOutgoingRequests = [];
    const existingIdx = cachedOutgoingRequests.findIndex((r) => r.toPlayerId === request2.toPlayerId);
    if (existingIdx !== -1) {
      cachedOutgoingRequests = cachedOutgoingRequests.map(
        (r, i) => i === existingIdx ? { ...r, ...request2 } : r
      );
      return;
    }
    cachedOutgoingRequests = [...cachedOutgoingRequests, request2];
  }
  function removeOutgoingRequestFromCache(toPlayerId) {
    if (!cachedOutgoingRequests) return;
    cachedOutgoingRequests = cachedOutgoingRequests.filter((r) => r.toPlayerId !== toPlayerId);
  }
  function updateFriendRoomInCache(playerId2, room) {
    if (!cachedFriendsView) return;
    cachedFriendsView = cachedFriendsView.map(
      (f) => f.playerId === playerId2 ? { ...f, room } : f
    );
  }
  function updateFriendPresenceInCache(playerId2, isOnline, lastEventAt, roomId) {
    if (!cachedFriendsView) return;
    cachedFriendsView = cachedFriendsView.map(
      (f) => f.playerId === playerId2 ? { ...f, isOnline, lastEventAt, ...roomId !== void 0 ? { room: roomId } : {} } : f
    );
  }
  function updateFriendPrivacyInCache(playerId2, privacy) {
    if (!cachedFriendsView) return;
    cachedFriendsView = cachedFriendsView.map(
      (f) => f.playerId === playerId2 ? { ...f, privacy } : f
    );
  }
  function getIncomingRequestsCount() {
    return cachedIncomingRequests ? cachedIncomingRequests.length : 0;
  }

  // src/ariesModAPI/optimistic.ts
  function dispatchEvents(events) {
    if (!events) return;
    for (const name of events) {
      window.dispatchEvent(new CustomEvent(name));
    }
  }
  function isFailure(value) {
    return value === null || value === false || value === void 0;
  }
  async function optimistic(opts) {
    const { apply, revert, request: request2, events, onError } = opts;
    apply();
    dispatchEvents(events);
    try {
      const result = await request2();
      if (isFailure(result)) {
        revert();
        dispatchEvents(events);
        if (onError) toastSimple("Error", onError, "error");
        return null;
      }
      return result;
    } catch (err) {
      console.error("[optimistic] request failed:", err);
      revert();
      dispatchEvents(events);
      if (onError) toastSimple("Error", onError, "error");
      return null;
    }
  }

  // src/ariesModAPI/endpoints/friends.ts
  async function sendFriendRequest(toPlayerId) {
    if (!toPlayerId) return false;
    const snapshot = getCachedOutgoingRequests();
    const result = await optimistic({
      apply: () => {
        addOutgoingRequestToCache({
          toPlayerId,
          otherPlayerId: toPlayerId,
          createdAt: (/* @__PURE__ */ new Date()).toISOString()
        });
      },
      revert: () => updateOutgoingRequestsCache(snapshot),
      request: async () => {
        const { status } = await httpPost("friend-request", { toPlayerId });
        if (status === 409) {
          console.warn("[api] friend-request conflict (already exists)");
          return true;
        }
        if (status === 204) return true;
        throw new Error(`sendFriendRequest failed: ${status}`);
      },
      events: [CH_EVENTS.FRIEND_REQUESTS_REFRESH],
      onError: "Failed to send friend request."
    });
    return result === true;
  }
  async function respondFriendRequest(params) {
    const { otherPlayerId, action: action2 } = params;
    if (!otherPlayerId) return false;
    const incomingSnapshot = getCachedIncomingRequestsWithViews();
    const friendsSnapshot = getCachedFriendsWithViews();
    const requestData = incomingSnapshot.find((r) => r.playerId === otherPlayerId);
    const events = [CH_EVENTS.FRIEND_REQUESTS_REFRESH];
    if (action2 === "accept") events.push(CH_EVENTS.FRIENDS_REFRESH);
    const result = await optimistic({
      apply: () => {
        removeIncomingRequestFromCache(otherPlayerId);
        if (action2 === "accept" && requestData) {
          addFriendToCache({
            playerId: otherPlayerId,
            playerName: requestData.playerName,
            avatarUrl: requestData.avatarUrl,
            avatar: requestData.avatar,
            lastEventAt: requestData.lastEventAt ?? null,
            isOnline: requestData.isOnline ?? false,
            roomId: requestData.room ?? null
          });
        }
      },
      revert: () => {
        updateIncomingRequestsCache(incomingSnapshot);
        updateFriendsViewCache(friendsSnapshot);
      },
      request: async () => {
        const { status } = await httpPost("friend-respond", { otherPlayerId, action: action2 });
        if (status === 204) return true;
        throw new Error(`respondFriendRequest failed: ${status}`);
      },
      events,
      onError: `Failed to ${action2} friend request.`
    });
    return result === true;
  }
  async function cancelFriendRequest(otherPlayerId) {
    if (!otherPlayerId) return false;
    const snapshot = getCachedOutgoingRequests();
    const result = await optimistic({
      apply: () => removeOutgoingRequestFromCache(otherPlayerId),
      revert: () => updateOutgoingRequestsCache(snapshot),
      request: async () => {
        const { status } = await httpPost("friend-cancel", { otherPlayerId });
        if (status === 204) return true;
        throw new Error(`cancelFriendRequest failed: ${status}`);
      },
      events: [CH_EVENTS.FRIEND_REQUESTS_REFRESH],
      onError: "Failed to cancel friend request."
    });
    return result === true;
  }
  async function removeFriend(otherPlayerId) {
    if (!otherPlayerId) return false;
    const snapshot = getCachedFriendsWithViews();
    const result = await optimistic({
      apply: () => removeFriendFromCache(otherPlayerId),
      revert: () => updateFriendsViewCache(snapshot),
      request: async () => {
        const { status } = await httpPost("friend-remove", { otherPlayerId });
        if (status === 204) return true;
        throw new Error(`removeFriend failed: ${status}`);
      },
      events: [CH_EVENTS.FRIENDS_REFRESH],
      onError: "Failed to remove friend."
    });
    return result === true;
  }

  // src/ariesModAPI/endpoints/messages.ts
  async function sendMessage(params) {
    const { toPlayerId, text } = params;
    if (!toPlayerId || !text) return null;
    const { status, data } = await httpPost("messages/send", {
      toPlayerId,
      text
    });
    if (status >= 200 && status < 300 && data) return data;
    if (status === 401)
      console.error("[api] sendMessage unauthorized - invalid or missing API key");
    return null;
  }
  async function markMessagesRead(params) {
    const { otherPlayerId, upToId } = params;
    if (!otherPlayerId || !upToId) return 0;
    const { status, data } = await httpPost("messages/read", {
      otherPlayerId,
      upToId
    });
    if (status !== 200 || !data) {
      if (status === 401) console.error("[api] markMessagesRead unauthorized");
      return 0;
    }
    return data.updated ?? 0;
  }

  // src/ariesModAPI/cache/welcome.ts
  var _welcomeCache = null;
  var _welcomeCallbacks = /* @__PURE__ */ new Set();
  function onWelcome(callback) {
    _welcomeCallbacks.add(callback);
    if (_welcomeCache) {
      try {
        callback(_welcomeCache);
      } catch {
      }
    }
    return () => _welcomeCallbacks.delete(callback);
  }
  function getWelcomeCache() {
    return _welcomeCache;
  }
  function notifyWelcome(data) {
    _welcomeCache = data;
    console.log("[Welcome] Received welcome event:", {
      friendsCount: data.friends?.length || 0,
      outgoingCount: data.friendRequests?.outgoing?.length || 0,
      incomingCount: data.friendRequests?.incoming?.length || 0,
      groupsCount: data.groups?.length || 0,
      publicGroupsCount: data.publicGroups?.length || 0,
      publicRoomsCount: data.publicRooms?.length || 0,
      modPlayersCount: data.modPlayers?.length || 0,
      hasModPlayersField: "modPlayers" in data,
      modPlayersValue: data.modPlayers
    });
    for (const cb of _welcomeCallbacks) {
      try {
        cb(data);
      } catch {
      }
    }
  }
  function getCachedPublicRooms() {
    return _welcomeCache?.publicRooms || null;
  }
  function getCachedModPlayers() {
    return _welcomeCache?.modPlayers || null;
  }
  function getCachedPublicGroups() {
    return _welcomeCache?.publicGroups || null;
  }
  function getCachedMyProfile() {
    return _welcomeCache?.myProfile || null;
  }
  function updateCachedMyProfilePrivacy(privacy) {
    if (_welcomeCache?.myProfile) {
      _welcomeCache.myProfile.privacy = privacy;
    }
  }
  function updateCachedGroups(groups2) {
    if (_welcomeCache) {
      _welcomeCache.groups = groups2;
    }
  }
  function updateCachedPublicGroups(publicGroups) {
    if (_welcomeCache) {
      _welcomeCache.publicGroups = publicGroups;
    }
  }
  function getCachedGroups() {
    return _welcomeCache?.groups ? [..._welcomeCache.groups] : [];
  }
  function removeGroupFromWelcomeCache(groupId) {
    if (!_welcomeCache?.groups) return;
    _welcomeCache.groups = _welcomeCache.groups.filter((g) => g.id !== groupId);
  }
  function addGroupToWelcomeCache(group) {
    if (!_welcomeCache) return;
    if (!_welcomeCache.groups) _welcomeCache.groups = [];
    if (_welcomeCache.groups.some((g) => g.id === group.id)) return;
    _welcomeCache.groups = [..._welcomeCache.groups, group];
  }
  function removePublicGroupFromWelcomeCache(groupId) {
    if (!_welcomeCache?.publicGroups) return;
    _welcomeCache.publicGroups = _welcomeCache.publicGroups.filter((g) => g.id !== groupId);
  }
  function updateGroupInWelcomeCache(groupId, updates) {
    if (!_welcomeCache?.groups) return;
    _welcomeCache.groups = _welcomeCache.groups.map(
      (g) => g.id === groupId ? { ...g, ...updates } : g
    );
  }
  var _cachedGroupMembers = null;
  function updateCachedGroupMembers(members) {
    _cachedGroupMembers = members;
  }
  function updateGroupMemberPresenceInCache(playerId2, isOnline, lastEventAt, roomId) {
    if (!_cachedGroupMembers) return;
    _cachedGroupMembers = _cachedGroupMembers.map(
      (m) => m.playerId === playerId2 ? { ...m, isOnline, lastEventAt, ...roomId !== void 0 ? { roomId } : {} } : m
    );
  }
  function updateGroupMemberRoomInCache(playerId2, roomId) {
    if (!_cachedGroupMembers) return;
    _cachedGroupMembers = _cachedGroupMembers.map(
      (m) => m.playerId === playerId2 ? { ...m, roomId } : m
    );
  }
  var _cachedLeaderboard = null;
  function getCachedLeaderboard() {
    return _cachedLeaderboard;
  }
  function updateLeaderboardCache(data) {
    _cachedLeaderboard = data;
  }

  // src/ariesModAPI/cache/conversations.ts
  var _cachedFriendConversations = null;
  function getCachedFriendConversations() {
    return _cachedFriendConversations ? [..._cachedFriendConversations] : [];
  }
  function updateFriendConversationsCache(convs) {
    _cachedFriendConversations = convs;
  }
  function getCachedFriendConversationMessages(conversationId) {
    if (!_cachedFriendConversations) return [];
    const conv = _cachedFriendConversations.find((c) => c.conversationId === conversationId);
    return conv ? [...conv.messages] : [];
  }
  function addMessageToFriendConversationCache(conversationId, msg, status = "sent") {
    if (!_cachedFriendConversations) return;
    const conv = _cachedFriendConversations.find((c) => c.conversationId === conversationId);
    if (!conv) return;
    const existingIndex = conv.messages.findIndex((m) => m.id === msg.id);
    if (existingIndex !== -1) {
      conv.messages[existingIndex] = { ...conv.messages[existingIndex], ...msg, _status: status };
      return;
    }
    const pendingIndex = conv.messages.findIndex(
      (m) => m.id < 0 && m.senderId === msg.senderId && m.body === msg.body
    );
    if (pendingIndex !== -1) {
      conv.messages[pendingIndex] = { ...msg, _status: status };
      return;
    }
    conv.messages.push({ ...msg, _status: status });
  }
  function removeFriendConversationFromCache(otherPlayerId) {
    if (!_cachedFriendConversations) return;
    _cachedFriendConversations = _cachedFriendConversations.filter(
      (c) => c.otherPlayerId !== otherPlayerId && c.conversationId !== otherPlayerId
    );
  }
  function updatePendingFriendMessage(conversationId, pendingId, newMsg) {
    if (!_cachedFriendConversations) return;
    const conv = _cachedFriendConversations.find((c) => c.conversationId === conversationId);
    if (!conv) return;
    const pendingIndex = conv.messages.findIndex((m) => m.id === pendingId);
    if (pendingIndex === -1) return;
    const realIndex = conv.messages.findIndex((m) => m.id === newMsg.id);
    if (realIndex !== -1 && realIndex !== pendingIndex) {
      conv.messages.splice(pendingIndex, 1);
    } else {
      conv.messages[pendingIndex] = { ...newMsg, _status: "sent" };
    }
  }
  function markFriendConversationAsRead(conversationId, upToId, readAt, currentPlayerId) {
    if (!_cachedFriendConversations) return;
    const conv = _cachedFriendConversations.find((c) => c.conversationId === conversationId);
    if (!conv) return;
    conv.unreadCount = 0;
    for (const msg of conv.messages) {
      if (msg.id <= upToId && !msg.readAt) {
        msg.readAt = readAt;
      }
    }
    let newestOutgoingReadId = 0;
    for (const msg of conv.messages) {
      if (msg.senderId === currentPlayerId && msg.id <= upToId && msg.id > newestOutgoingReadId) {
        newestOutgoingReadId = msg.id;
      }
    }
    if (newestOutgoingReadId > 0) {
      for (const msg of conv.messages) {
        if (msg.id === newestOutgoingReadId && msg._status === "sent") {
          msg._status = "read";
        }
      }
    }
  }
  var _cachedGroupConversations = null;
  function getCachedGroupConversations() {
    return _cachedGroupConversations ? [..._cachedGroupConversations] : [];
  }
  function updateGroupConversationsCache(convs) {
    _cachedGroupConversations = convs;
  }
  function getCachedGroupConversationMessages(groupId) {
    if (!_cachedGroupConversations) return [];
    const conv = _cachedGroupConversations.find((c) => c.groupId === groupId);
    return conv ? [...conv.messages] : [];
  }
  function ensureGroupConversationExists(groupId, groupName) {
    if (!_cachedGroupConversations) _cachedGroupConversations = [];
    const existing = _cachedGroupConversations.find((c) => c.groupId === groupId);
    if (existing) {
      if (groupName && !existing.groupName) existing.groupName = groupName;
      return;
    }
    _cachedGroupConversations.push({
      groupId,
      groupName: groupName || "",
      messages: [],
      unreadCount: 0
    });
  }
  function initGroupConversationFromEvent(groupId, groupName, messages, unreadCount) {
    if (!_cachedGroupConversations) _cachedGroupConversations = [];
    const existing = _cachedGroupConversations.find((c) => c.groupId === groupId);
    if (existing) {
      if (groupName) existing.groupName = groupName;
      if (existing.messages.length === 0) {
        existing.messages = messages.map((m) => ({ ...m, _status: "sent" }));
        existing.unreadCount = unreadCount;
      }
      return;
    }
    _cachedGroupConversations.push({
      groupId,
      groupName: groupName || "",
      messages: messages.map((m) => ({ ...m, _status: "sent" })),
      unreadCount
    });
  }
  function addMessageToGroupConversationCache(groupId, msg, status = "sent") {
    ensureGroupConversationExists(groupId);
    const conv = _cachedGroupConversations.find((c) => c.groupId === groupId);
    if (!conv) return;
    const existingIndex = conv.messages.findIndex((m) => m.id === msg.id);
    if (existingIndex !== -1) {
      conv.messages[existingIndex] = { ...conv.messages[existingIndex], ...msg, _status: status };
      return;
    }
    const pendingIndex = conv.messages.findIndex(
      (m) => m.id < 0 && m.senderId === msg.senderId && (m.body === msg.body || m.text === msg.body)
    );
    if (pendingIndex !== -1) {
      conv.messages[pendingIndex] = { ...msg, _status: status };
      return;
    }
    conv.messages.push({ ...msg, _status: status });
  }
  function updatePendingGroupMessage(groupId, pendingId, newMsg) {
    if (!_cachedGroupConversations) return;
    const conv = _cachedGroupConversations.find((c) => c.groupId === groupId);
    if (!conv) return;
    const pendingIndex = conv.messages.findIndex((m) => m.id === pendingId);
    if (pendingIndex === -1) return;
    const realIndex = conv.messages.findIndex((m) => m.id === newMsg.id);
    if (realIndex !== -1 && realIndex !== pendingIndex) {
      conv.messages.splice(pendingIndex, 1);
    } else {
      conv.messages[pendingIndex] = { ...newMsg, _status: "sent" };
    }
  }
  function markGroupConversationAsRead(groupId, readerId, messageId, currentPlayerId) {
    if (!_cachedGroupConversations) return;
    const conv = _cachedGroupConversations.find((c) => c.groupId === groupId);
    if (!conv) return;
    if (!readerId || !currentPlayerId) {
      conv.unreadCount = 0;
      return;
    }
    if (readerId === currentPlayerId) {
      conv.unreadCount = 0;
      return;
    }
    if (messageId) {
      for (const msg of conv.messages) {
        if (msg.senderId === currentPlayerId && msg.id <= messageId && msg._status === "sent") {
          msg._status = "read";
        }
      }
    }
  }
  function removeGroupConversationFromCache(groupId) {
    if (!_cachedGroupConversations) return;
    _cachedGroupConversations = _cachedGroupConversations.filter((c) => c.groupId !== groupId);
  }
  function incrementFriendConversationUnread(conversationId) {
    if (!_cachedFriendConversations) return;
    const conv = _cachedFriendConversations.find((c) => c.conversationId === conversationId);
    if (conv) {
      conv.unreadCount = (conv.unreadCount ?? 0) + 1;
    }
  }
  function incrementGroupConversationUnread(groupId) {
    if (!_cachedGroupConversations) return;
    const conv = _cachedGroupConversations.find((c) => c.groupId === groupId);
    if (conv) {
      conv.unreadCount = (conv.unreadCount ?? 0) + 1;
    }
  }
  function getTotalFriendUnreadCount() {
    if (!_cachedFriendConversations) return 0;
    return _cachedFriendConversations.reduce((sum, c) => sum + (c.unreadCount ?? 0), 0);
  }
  function getTotalGroupUnreadCount() {
    if (!_cachedGroupConversations) return 0;
    return _cachedGroupConversations.reduce((sum, c) => sum + (c.unreadCount ?? 0), 0);
  }

  // src/ariesModAPI/endpoints/groups.ts
  async function createGroup(params) {
    const { name, isPublic } = params;
    if (!name) return null;
    const { status, data } = await httpPost("groups", { name, isPublic });
    if (status >= 200 && status < 300 && data) return data;
    if (status === 401) console.error("[api] createGroup unauthorized");
    return null;
  }
  async function fetchGroups() {
    const { status, data } = await httpGet("groups");
    if (status !== 200 || !data) return [];
    if (Array.isArray(data)) return data;
    if (Array.isArray(data.groups)) return data.groups;
    return [];
  }
  async function fetchPublicGroups(options) {
    const { status, data } = await httpGet("groups/public", {
      search: options?.search,
      limit: options?.limit,
      offset: options?.offset
    });
    if (status !== 200 || !data) return [];
    if (Array.isArray(data.groups)) return data.groups;
    return [];
  }
  async function fetchGroupDetails(groupId) {
    if (!groupId) return null;
    const { status, data } = await httpGet(`groups/${groupId}`);
    if (status !== 200 || !data) return null;
    return data;
  }
  async function updateGroupName(params) {
    const { groupId, name } = params;
    if (!groupId || !name) return false;
    const groupsSnapshot = getCachedGroups();
    const result = await optimistic({
      apply: () => updateGroupInWelcomeCache(Number(groupId), { name }),
      revert: () => updateCachedGroups(groupsSnapshot),
      request: async () => {
        const { status } = await httpPatch(`groups/${groupId}`, { name });
        if (status >= 200 && status < 300) return true;
        throw new Error(`updateGroupName failed: ${status}`);
      },
      events: [CH_EVENTS.GROUPS_REFRESH],
      onError: "Failed to rename group."
    });
    return result === true;
  }
  async function updateGroupVisibility(params) {
    const { groupId, isPublic } = params;
    if (!groupId) return false;
    const groupsSnapshot = getCachedGroups();
    const result = await optimistic({
      apply: () => updateGroupInWelcomeCache(Number(groupId), {}),
      revert: () => updateCachedGroups(groupsSnapshot),
      request: async () => {
        const { status } = await httpPatch(`groups/${groupId}`, { isPublic });
        if (status >= 200 && status < 300) return true;
        throw new Error(`updateGroupVisibility failed: ${status}`);
      },
      events: [CH_EVENTS.GROUPS_REFRESH],
      onError: "Failed to update group visibility."
    });
    return result === true;
  }
  async function deleteGroup(params) {
    const { groupId } = params;
    if (!groupId) return false;
    const groupsSnapshot = getCachedGroups();
    const result = await optimistic({
      apply: () => {
        removeGroupFromWelcomeCache(Number(groupId));
        removeGroupConversationFromCache(Number(groupId));
      },
      revert: () => updateCachedGroups(groupsSnapshot),
      request: async () => {
        const { status } = await httpDelete(`groups/${groupId}`, {});
        if (status >= 200 && status < 300) return true;
        throw new Error(`deleteGroup failed: ${status}`);
      },
      events: [CH_EVENTS.GROUPS_REFRESH, CH_EVENTS.CONVERSATIONS_REFRESH],
      onError: "Failed to delete group."
    });
    return result === true;
  }
  async function addGroupMember(params) {
    const { groupId, memberId } = params;
    if (!groupId || !memberId) return false;
    const { status } = await httpPost(`groups/${groupId}/members`, { memberId });
    if (status === 401) console.error("[api] addGroupMember unauthorized");
    return status >= 200 && status < 300;
  }
  async function removeGroupMember(params) {
    const { groupId, memberId } = params;
    if (!groupId || !memberId) return false;
    const { status } = await httpDelete(`groups/${groupId}/members/${memberId}`, {});
    if (status === 401) console.error("[api] removeGroupMember unauthorized");
    return status >= 200 && status < 300;
  }
  async function leaveGroup(params) {
    const { groupId } = params;
    if (!groupId) return false;
    const groupsSnapshot = getCachedGroups();
    const result = await optimistic({
      apply: () => {
        removeGroupFromWelcomeCache(Number(groupId));
        removeGroupConversationFromCache(Number(groupId));
      },
      revert: () => updateCachedGroups(groupsSnapshot),
      request: async () => {
        const { status } = await httpPost(`groups/${groupId}/leave`, {});
        if (status >= 200 && status < 300) return true;
        throw new Error(`leaveGroup failed: ${status}`);
      },
      events: [CH_EVENTS.GROUPS_REFRESH, CH_EVENTS.CONVERSATIONS_REFRESH],
      onError: "Failed to leave group."
    });
    return result === true;
  }
  async function sendGroupMessage(params) {
    const { groupId, text } = params;
    if (!groupId || !text) return null;
    const { status, data } = await httpPost(`groups/${groupId}/messages`, {
      text
    });
    if (status >= 200 && status < 300 && data) return data;
    if (status === 401) console.error("[api] sendGroupMessage unauthorized");
    return null;
  }
  async function markGroupMessagesAsRead(params) {
    const { groupId, messageId } = params;
    if (!groupId || !messageId) return false;
    const { status } = await httpPost(`groups/${groupId}/messages/read`, {
      messageId
    });
    if (status === 401) console.error("[api] markGroupMessagesAsRead unauthorized");
    return status === 204 || status >= 200 && status < 300;
  }
  async function joinGroup(params) {
    const { groupId } = params;
    if (!groupId) return false;
    const groupsSnapshot = getCachedGroups();
    const publicGroupsSnapshot = getCachedPublicGroups() ?? [];
    const publicGroup = publicGroupsSnapshot.find((g) => g.id === Number(groupId));
    const result = await optimistic({
      apply: () => {
        removePublicGroupFromWelcomeCache(Number(groupId));
        if (publicGroup) {
          addGroupToWelcomeCache({
            id: publicGroup.id,
            name: publicGroup.name,
            ownerId: publicGroup.ownerId,
            role: "member",
            memberCount: (publicGroup.memberCount ?? 0) + 1,
            previewMembers: publicGroup.previewMembers ?? [],
            createdAt: publicGroup.createdAt,
            updatedAt: publicGroup.updatedAt
          });
        }
      },
      revert: () => {
        updateCachedGroups(groupsSnapshot);
        updateCachedPublicGroups(publicGroupsSnapshot);
      },
      request: async () => {
        const { status } = await httpPost(`groups/${groupId}/join`, {});
        if (status === 204 || status >= 200 && status < 300) return true;
        throw new Error(`joinGroup failed: ${status}`);
      },
      events: [CH_EVENTS.GROUPS_REFRESH],
      onError: "Failed to join group."
    });
    return result === true;
  }
  async function changeGroupMemberRole(params) {
    const { groupId, memberId, role } = params;
    if (!groupId || !memberId || !role) return null;
    if (role === "owner") {
      console.error("[api] changeGroupMemberRole - cannot set role to owner");
      return null;
    }
    const { status, data } = await httpPatch(`groups/${groupId}/members/${memberId}/role`, { role });
    if (status >= 200 && status < 300 && data) return data;
    if (status === 401) console.error("[api] changeGroupMemberRole unauthorized");
    if (status === 403) console.error("[api] changeGroupMemberRole forbidden - insufficient permissions");
    if (status === 409) console.error("[api] changeGroupMemberRole conflict - member already has this role");
    return null;
  }

  // src/ariesModAPI/endpoints/privacy.ts
  async function updatePrivacy(settings) {
    if (!settings || Object.keys(settings).length === 0) return null;
    const profile = getCachedMyProfile();
    const privacySnapshot = profile?.privacy ? { ...profile.privacy } : null;
    const optimisticPrivacy = {
      showGarden: true,
      showInventory: true,
      showCoins: true,
      showActivityLog: true,
      showJournal: true,
      showStats: true,
      hideRoomFromPublicList: false,
      ...privacySnapshot ?? {},
      ...settings
    };
    const result = await optimistic({
      apply: () => updateCachedMyProfilePrivacy(optimisticPrivacy),
      revert: () => {
        if (privacySnapshot) updateCachedMyProfilePrivacy(privacySnapshot);
      },
      request: async () => {
        const { status, data } = await httpPost("privacy", settings);
        if (status === 200 && data) return data;
        throw new Error(`updatePrivacy failed: ${status}`);
      },
      events: [CH_EVENTS.PRIVACY_UPDATED],
      onError: "Failed to update privacy settings."
    });
    if (result) {
      updateCachedMyProfilePrivacy(result);
    }
    return result;
  }

  // src/ariesModAPI/streams/messages.ts
  function safeJsonParse2(value) {
    if (value === null || value === void 0) return value;
    if (typeof value !== "string") return value;
    try {
      return JSON.parse(value);
    } catch {
      return value;
    }
  }
  function openMessagesStream(playerId2, handlers = {}) {
    if (!playerId2) return null;
    return openUnifiedEvents(playerId2, {
      onConnected: (payload) => {
        handlers.onConnected?.({ playerId: payload.playerId ?? playerId2 });
      },
      onError: (event) => {
        handlers.onError?.(event);
      },
      onEvent: (eventName, data) => {
        const parsed = safeJsonParse2(data);
        switch (eventName) {
          case "message":
            handlers.onMessage?.(parsed);
            break;
          case "read":
            handlers.onRead?.(parsed);
            break;
          default:
            break;
        }
      }
    });
  }

  // src/ariesModAPI/streams/groups.ts
  function safeJsonParse3(value) {
    if (value === null || value === void 0) return value;
    if (typeof value !== "string") return value;
    try {
      return JSON.parse(value);
    } catch {
      return value;
    }
  }
  var _refreshTimer = null;
  function scheduleGroupsRefresh() {
    if (_refreshTimer) clearTimeout(_refreshTimer);
    _refreshTimer = setTimeout(async () => {
      _refreshTimer = null;
      try {
        const groups2 = await fetchGroups();
        if (groups2) {
          updateCachedGroups(groups2);
        }
        window.dispatchEvent(new CustomEvent("qws:groups-refresh"));
      } catch (error) {
        console.error("[GroupsStream] Failed to refresh groups cache:", error);
      }
    }, 300);
  }
  function openGroupsStream(playerId2, handlers = {}) {
    if (!playerId2) return null;
    return openUnifiedEvents(playerId2, {
      onConnected: (payload) => {
        handlers.onConnected?.(payload);
      },
      onError: (event) => {
        handlers.onError?.(event);
      },
      onEvent: (eventName, data) => {
        const parsed = safeJsonParse3(data);
        switch (eventName) {
          case "group_message":
            handlers.onMessage?.(parsed);
            break;
          case "group_member_added":
            scheduleGroupsRefresh();
            handlers.onMemberAdded?.(parsed);
            break;
          case "group_member_removed": {
            const removedPlayerId = parsed.member?.playerId;
            const currentId = getCurrentPlayerId();
            if (parsed.groupId && removedPlayerId && currentId && removedPlayerId === currentId) {
              removeGroupConversationFromCache(Number(parsed.groupId));
              try {
                window.dispatchEvent(new CustomEvent("qws:conversations-refresh"));
              } catch {
              }
            }
            scheduleGroupsRefresh();
            handlers.onMemberRemoved?.(parsed);
            break;
          }
          case "group_updated":
            scheduleGroupsRefresh();
            handlers.onUpdated?.(parsed);
            break;
          case "group_deleted":
            if (parsed.groupId) {
              removeGroupConversationFromCache(Number(parsed.groupId));
              try {
                window.dispatchEvent(new CustomEvent("qws:conversations-refresh"));
              } catch {
              }
            }
            scheduleGroupsRefresh();
            handlers.onDeleted?.(parsed);
            break;
          case "group_role_changed":
            scheduleGroupsRefresh();
            handlers.onRoleChanged?.(parsed);
            break;
          case "group_read":
            handlers.onRead?.(parsed);
            break;
          default:
            break;
        }
      }
    });
  }

  // src/ariesModAPI/streams/presence.ts
  function safeJsonParse4(value) {
    if (value === null || value === void 0) return value;
    if (typeof value !== "string") return value;
    try {
      return JSON.parse(value);
    } catch {
      return value;
    }
  }
  function openPresenceStream(playerId2, onPresence) {
    if (!playerId2) return null;
    return openUnifiedEvents(playerId2, {
      onEvent: (eventName, data) => {
        if (eventName !== "presence") return;
        const parsed = safeJsonParse4(data);
        if (parsed.playerId) {
          updateFriendPresenceInCache(
            parsed.playerId,
            parsed.online ?? false,
            parsed.lastEventAt ?? null,
            parsed.roomId
          );
          updateGroupMemberPresenceInCache(
            parsed.playerId,
            parsed.online ?? false,
            parsed.lastEventAt ?? null,
            parsed.roomId
          );
          try {
            window.dispatchEvent(new CustomEvent("qws:friends-refresh"));
            window.dispatchEvent(new CustomEvent("qws:groups-refresh"));
            window.dispatchEvent(new CustomEvent("qws:presence-updated", { detail: parsed }));
          } catch {
          }
        }
        onPresence?.(parsed);
      }
    });
  }

  // src/ariesModAPI/init.ts
  var _manager = {
    handles: [],
    playerId: null,
    initialized: false
  };
  function startAllStreams() {
    if (_manager.initialized) {
      return;
    }
    const tempPlayerId = "auto";
    _manager.playerId = tempPlayerId;
    _manager.initialized = true;
    try {
      const friendHandle = openFriendRequestsStream(tempPlayerId);
      _manager.handles.push(friendHandle);
    } catch (error) {
      console.error("[AriesAPI] Failed to start friend requests stream:", error);
    }
    try {
      const messagesHandle = openMessagesStream(tempPlayerId);
      _manager.handles.push(messagesHandle);
    } catch (error) {
      console.error("[AriesAPI] Failed to start messages stream:", error);
    }
    try {
      const groupsHandle = openGroupsStream(tempPlayerId);
      _manager.handles.push(groupsHandle);
    } catch (error) {
      console.error("[AriesAPI] Failed to start groups stream:", error);
    }
    try {
      const presenceHandle = openPresenceStream(tempPlayerId);
      _manager.handles.push(presenceHandle);
    } catch (error) {
      console.error("[AriesAPI] Failed to start presence stream:", error);
    }
  }
  function stopAllStreams() {
    if (_manager.handles.length === 0) return;
    console.log(`[AriesAPI] Stopping ${_manager.handles.length} active streams`);
    for (const handle of _manager.handles) {
      try {
        handle.close();
      } catch (error) {
        console.error("[AriesAPI] Failed to close stream:", error);
      }
    }
    _manager.handles = [];
    _manager.playerId = null;
    _manager.initialized = false;
  }
  function initializeStreamsWhenReady() {
    if (!hasApiKey()) {
      return;
    }
    startAllStreams();
  }
  function getCurrentPlayerId() {
    return _manager.playerId;
  }
  function updateCurrentPlayerId(playerId2) {
    if (playerId2 && playerId2 !== "auto") {
      _manager.playerId = playerId2;
    }
  }
  window.addEventListener("qws-friend-overlay-auth-update", () => {
    if (hasApiKey() && !_manager.initialized) {
      initializeStreamsWhenReady();
    } else if (!hasApiKey() && _manager.initialized) {
      stopAllStreams();
    }
  });
  window.addEventListener("beforeunload", () => {
    stopAllStreams();
  });

  // src/ariesModAPI/streams/friends.ts
  function safeJsonParse5(value) {
    if (value === null || value === void 0) return value;
    if (typeof value !== "string") return value;
    try {
      return JSON.parse(value);
    } catch {
      return value;
    }
  }
  function openFriendRequestsStream(playerId2, handlers = {}) {
    if (!playerId2) return null;
    return openUnifiedEvents(playerId2, {
      onConnected: (payload) => {
        if (payload.playerId) {
          updateCurrentPlayerId(payload.playerId);
        }
        handlers.onConnected?.({ playerId: payload.playerId ?? playerId2 });
      },
      onError: (event) => {
        handlers.onError?.(event);
      },
      onEvent: (eventName, data) => {
        const parsed = safeJsonParse5(data);
        switch (eventName) {
          case "welcome": {
            notifyWelcome(parsed);
            const friends = (parsed.friends || []).map((f) => ({
              playerId: f.playerId,
              playerName: f.name || null,
              avatarUrl: f.avatarUrl || null,
              avatar: f.avatar || null,
              coins: null,
              room: f.roomId || null,
              hasModInstalled: false,
              isOnline: f.isOnline || false,
              lastEventAt: f.lastEventAt || null,
              badges: f.badges || null,
              privacy: {
                showGarden: true,
                showInventory: true,
                showCoins: true,
                showActivityLog: true,
                showJournal: true,
                hideRoomFromPublicList: false,
                showStats: true
              }
            }));
            updateFriendsViewCache(friends);
            const incomingRequests = (parsed.friendRequests?.incoming || []).map((r) => ({
              playerId: r.otherPlayerId,
              playerName: r.playerName || null,
              avatarUrl: r.avatarUrl || null,
              avatar: null,
              coins: null,
              room: null,
              hasModInstalled: false,
              isOnline: false,
              lastEventAt: null,
              badges: r.badges || null,
              privacy: {
                showGarden: true,
                showInventory: true,
                showCoins: true,
                showActivityLog: true,
                showJournal: true,
                hideRoomFromPublicList: false,
                showStats: true
              },
              createdAt: r.createdAt
            }));
            updateIncomingRequestsCache(incomingRequests);
            const outgoingRequests = (parsed.friendRequests?.outgoing || []).map((r) => ({
              toPlayerId: r.otherPlayerId,
              otherPlayerId: r.otherPlayerId,
              playerName: r.playerName || null,
              avatarUrl: r.avatarUrl || null,
              badges: r.badges || null,
              createdAt: r.createdAt
            }));
            updateOutgoingRequestsCache(outgoingRequests);
            const convData = parsed.conversations || {};
            const friendConvs = (convData.friends || []).map((c) => ({
              conversationId: c.conversationId,
              otherPlayerId: c.otherPlayerId,
              otherPlayerName: c.otherPlayerName || null,
              otherPlayerAvatarUrl: c.otherPlayerAvatarUrl || null,
              messages: (c.messages || []).map((m) => ({
                id: m.id,
                conversationId: c.conversationId,
                senderId: m.senderId,
                recipientId: m.recipientId,
                body: m.body,
                createdAt: m.createdAt,
                deliveredAt: m.deliveredAt || m.createdAt,
                readAt: m.readAt || null
              })),
              unreadCount: c.unreadCount ?? 0
            }));
            updateFriendConversationsCache(friendConvs);
            const groupConvs = (convData.groups || []).map((g) => ({
              groupId: Number(g.groupId),
              groupName: g.groupName || "",
              messages: (g.messages || []).map((m) => ({
                id: m.id,
                groupId: String(g.groupId),
                senderId: m.senderId,
                senderName: m.senderName || m.playerName || null,
                senderAvatarUrl: m.senderAvatarUrl || m.avatarUrl || m.discordAvatarUrl || null,
                body: m.body || m.text || "",
                createdAt: m.createdAt,
                readAt: m.readAt || null
              })),
              unreadCount: g.unreadCount ?? 0
            }));
            updateGroupConversationsCache(groupConvs);
            const groupMembers = (parsed.groupMembers || []).map((m) => ({
              playerId: m.playerId,
              name: m.name || null,
              avatarUrl: m.avatarUrl || null,
              avatar: m.avatar || null,
              badges: m.badges || null,
              lastEventAt: m.lastEventAt || null,
              roomId: m.roomId ?? null,
              isOnline: m.isOnline || false,
              groupIds: m.groupIds || []
            }));
            updateCachedGroupMembers(groupMembers);
            try {
              window.dispatchEvent(new CustomEvent("qws:friends-refresh"));
              window.dispatchEvent(new CustomEvent("qws:friend-requests-refresh"));
              window.dispatchEvent(new CustomEvent("qws:conversations-refresh"));
              window.dispatchEvent(new CustomEvent("qws:groups-refresh"));
            } catch {
            }
            break;
          }
          case "friend_request": {
            const req = parsed;
            const currentPlayerId = getCurrentPlayerId() || playerId2;
            if (req.targetId === currentPlayerId) {
              addIncomingRequestToCache({
                playerId: req.requesterId,
                playerName: req.requesterName || null,
                avatarUrl: req.requesterAvatarUrl || null,
                avatar: null,
                coins: null,
                room: null,
                hasModInstalled: false,
                isOnline: false,
                lastEventAt: null,
                badges: req.requesterBadges || null,
                privacy: {
                  showGarden: true,
                  showInventory: true,
                  showCoins: true,
                  showActivityLog: true,
                  showJournal: true,
                  hideRoomFromPublicList: false,
                  showStats: true
                },
                createdAt: req.createdAt
              });
            } else if (req.requesterId === currentPlayerId) {
              const existing = {
                toPlayerId: req.targetId,
                otherPlayerId: req.targetId,
                playerName: req.targetName || null,
                avatarUrl: req.targetAvatarUrl || null,
                badges: req.targetBadges || null,
                createdAt: req.createdAt
              };
              addOutgoingRequestToCache(existing);
            }
            try {
              window.dispatchEvent(new CustomEvent("qws:friend-requests-refresh"));
            } catch {
            }
            handlers.onRequest?.(req);
            break;
          }
          case "friend_response": {
            const resp = parsed;
            const currentPlayerId = getCurrentPlayerId() || playerId2;
            if (resp.requesterId === currentPlayerId) {
              removeOutgoingRequestFromCache(resp.responderId);
            } else if (resp.responderId === currentPlayerId) {
              removeIncomingRequestFromCache(resp.requesterId);
            }
            if (resp.action === "accept") {
              const isRequester = resp.requesterId === currentPlayerId;
              const otherId = isRequester ? resp.responderId : resp.requesterId;
              const otherName = isRequester ? resp.responderName : resp.requesterName;
              const otherAvatar = isRequester ? resp.responderAvatarUrl : resp.requesterAvatarUrl;
              const otherIsOnline = isRequester ? resp.responderIsOnline : resp.requesterIsOnline;
              const otherRoomId = isRequester ? resp.responderRoomId : resp.requesterRoomId;
              const otherBadges = isRequester ? resp.responderBadges : resp.requesterBadges;
              addFriendToCache({
                playerId: otherId,
                playerName: otherName || null,
                avatarUrl: otherAvatar || null,
                avatar: null,
                lastEventAt: resp.updatedAt,
                isOnline: otherIsOnline ?? false,
                roomId: otherRoomId ?? null,
                badges: otherBadges || null
              });
              try {
                window.dispatchEvent(new CustomEvent("qws:friends-refresh"));
              } catch {
              }
            }
            try {
              window.dispatchEvent(new CustomEvent("qws:friend-requests-refresh"));
            } catch {
            }
            handlers.onResponse?.(resp);
            if (resp.action === "accept") {
              handlers.onAccepted?.({
                requesterId: resp.requesterId,
                requesterName: resp.requesterName,
                requesterAvatarUrl: resp.requesterAvatarUrl,
                responderId: resp.responderId,
                responderName: resp.responderName,
                responderAvatarUrl: resp.responderAvatarUrl,
                updatedAt: resp.updatedAt
              });
            } else if (resp.action === "reject") {
              handlers.onRejected?.({
                requesterId: resp.requesterId,
                requesterName: resp.requesterName,
                requesterAvatarUrl: resp.requesterAvatarUrl,
                responderId: resp.responderId,
                responderName: resp.responderName,
                responderAvatarUrl: resp.responderAvatarUrl,
                updatedAt: resp.updatedAt
              });
            }
            break;
          }
          case "friend_cancelled": {
            const cancelled = parsed;
            const currentPlayerId = getCurrentPlayerId() || playerId2;
            if (cancelled.requesterId === currentPlayerId) {
              removeOutgoingRequestFromCache(cancelled.targetId);
            } else if (cancelled.targetId === currentPlayerId) {
              removeIncomingRequestFromCache(cancelled.requesterId);
            }
            try {
              window.dispatchEvent(new CustomEvent("qws:friend-requests-refresh"));
            } catch {
            }
            handlers.onCancelled?.(cancelled);
            break;
          }
          case "friend_removed": {
            const removed = parsed;
            const currentPlayerId = getCurrentPlayerId() || playerId2;
            const otherId = removed.removerId === currentPlayerId ? removed.removedId : removed.removerId;
            removeFriendFromCache(otherId);
            removeFriendConversationFromCache(otherId);
            try {
              window.dispatchEvent(new CustomEvent("qws:friends-refresh"));
              window.dispatchEvent(new CustomEvent("qws:conversations-refresh"));
            } catch {
            }
            handlers.onRemoved?.(removed);
            break;
          }
          case "privacy_updated": {
            if (parsed.playerId && parsed.privacy) {
              updateFriendPrivacyInCache(parsed.playerId, parsed.privacy);
            }
            if (parsed.playerId && parsed.privacy?.hideRoomFromPublicList) {
              updateGroupMemberRoomInCache(parsed.playerId, null);
            }
            try {
              window.dispatchEvent(new CustomEvent("qws:friends-refresh"));
              window.dispatchEvent(new CustomEvent("qws:groups-refresh"));
              window.dispatchEvent(
                new CustomEvent("qws:privacy-updated", { detail: parsed })
              );
            } catch {
            }
            break;
          }
          case "room_changed": {
            if (parsed.playerId) {
              updateFriendRoomInCache(parsed.playerId, parsed.roomId ?? null);
              updateGroupMemberRoomInCache(parsed.playerId, parsed.roomId ?? null);
            }
            try {
              window.dispatchEvent(new CustomEvent("qws:friends-refresh"));
              window.dispatchEvent(new CustomEvent("qws:groups-refresh"));
              window.dispatchEvent(
                new CustomEvent("qws:room-changed", { detail: parsed })
              );
            } catch {
            }
            break;
          }
          case "read": {
            if (parsed.conversationId && parsed.upToId) {
              const currentPlayerId = getCurrentPlayerId() || playerId2;
              markFriendConversationAsRead(parsed.conversationId, parsed.upToId, parsed.readAt, currentPlayerId);
            }
            try {
              window.dispatchEvent(new CustomEvent("qws:conversations-refresh"));
            } catch {
            }
            break;
          }
          case "group_read": {
            if (parsed.groupId) {
              const currentPlayerId = getCurrentPlayerId() || playerId2;
              markGroupConversationAsRead(
                Number(parsed.groupId),
                parsed.readerId,
                parsed.messageId,
                currentPlayerId
              );
            }
            try {
              window.dispatchEvent(new CustomEvent("qws:conversations-refresh"));
            } catch {
            }
            break;
          }
          case "message": {
            if (parsed.conversationId && parsed.id) {
              const currentPlayerId = getCurrentPlayerId() || playerId2;
              const msg = {
                id: parsed.id,
                conversationId: parsed.conversationId,
                senderId: parsed.senderId,
                recipientId: parsed.recipientId,
                body: parsed.body,
                createdAt: parsed.createdAt,
                deliveredAt: parsed.deliveredAt || parsed.createdAt,
                readAt: parsed.readAt || null
              };
              addMessageToFriendConversationCache(parsed.conversationId, msg);
              if (parsed.senderId !== currentPlayerId) {
                incrementFriendConversationUnread(parsed.conversationId);
              }
              try {
                window.dispatchEvent(new CustomEvent("qws:conversations-refresh"));
              } catch {
              }
            }
            break;
          }
          case "group_member_added": {
            if (parsed.groupId && parsed.conversation) {
              const messages = (parsed.conversation.messages || []).map((m) => ({
                id: m.id,
                groupId: String(parsed.groupId),
                senderId: m.senderId,
                senderName: m.senderName || m.playerName || null,
                senderAvatarUrl: m.senderAvatarUrl || m.avatarUrl || m.discordAvatarUrl || null,
                body: m.body || m.text || "",
                createdAt: m.createdAt,
                readAt: m.readAt || null
              }));
              initGroupConversationFromEvent(
                Number(parsed.groupId),
                parsed.groupName || "",
                messages,
                parsed.conversation.unreadCount ?? 0
              );
            }
            try {
              window.dispatchEvent(new CustomEvent("qws:conversations-refresh"));
              window.dispatchEvent(new CustomEvent("qws:groups-refresh"));
            } catch {
            }
            break;
          }
          case "group_message": {
            if (parsed.groupId && parsed.message) {
              const currentPlayerId = getCurrentPlayerId() || playerId2;
              const sender = parsed.message.sender;
              const msg = {
                id: parsed.message.id,
                groupId: String(parsed.groupId),
                senderId: parsed.message.senderId,
                senderName: sender?.name || parsed.message.senderName || parsed.message.playerName || null,
                senderAvatarUrl: sender?.avatarUrl || parsed.message.senderAvatarUrl || parsed.message.avatarUrl || null,
                body: parsed.message.body || parsed.message.text || "",
                createdAt: parsed.message.createdAt
              };
              addMessageToGroupConversationCache(Number(parsed.groupId), msg);
              if (parsed.message.senderId !== currentPlayerId) {
                incrementGroupConversationUnread(Number(parsed.groupId));
              }
              try {
                window.dispatchEvent(new CustomEvent("qws:conversations-refresh"));
              } catch {
              }
            }
            break;
          }
          case "presence": {
            break;
          }
          default:
            break;
        }
      }
    });
  }

  // src/ui/menus/communityHub/tabs/chatImporter.ts
  init_atoms();
  init_fakeModal();

  // src/utils/format.ts
  function formatPrice(val) {
    const n = typeof val === "number" ? val : Number(val);
    if (!Number.isFinite(n)) return n === Infinity ? "\u221E" : null;
    const abs = Math.abs(n);
    const fmt = (x) => Number.isInteger(x) ? String(x) : x.toFixed(2);
    if (abs >= 1e12) return `${fmt(n / 1e12)}T`;
    if (abs >= 1e9) return `${fmt(n / 1e9)}B`;
    if (abs >= 1e6) return `${fmt(n / 1e6)}M`;
    if (abs >= 1e3) return `${fmt(n / 1e3)}k`;
    return String(n);
  }

  // src/ui/menus/communityHub/tabs/chatImporter.ts
  var GEM_TOKEN_REGEX = /\{\{gem:([^|]+)\|([^|}]+)(?:\|([^|}]*))?(?:\|([^}]*))?\}\}/g;
  async function getCurrentRoomId() {
    try {
      const state3 = await Atoms.root.state.get();
      if (!state3 || typeof state3 !== "object") return null;
      const s = state3;
      const roomId = s.data?.roomId ?? s.fullState?.data?.roomId ?? s.roomId ?? null;
      return roomId || null;
    } catch {
      return null;
    }
  }
  function buildGemToken(type, id, label2, meta) {
    let token = `{{gem:${type}|${id}`;
    if (label2) token += `|${label2}`;
    if (meta) token += `|${meta}`;
    token += "}}";
    return token;
  }
  function parseGemTokens(body) {
    const tokens = [];
    let match;
    GEM_TOKEN_REGEX.lastIndex = 0;
    while ((match = GEM_TOKEN_REGEX.exec(body)) !== null) {
      tokens.push({
        type: match[1],
        id: match[2],
        label: match[3] || void 0,
        meta: match[4] || void 0,
        raw: match[0]
      });
    }
    const text = body.replace(GEM_TOKEN_REGEX, "").trim();
    return { text, tokens };
  }
  var SIMPLE_ITEM_TYPES = /* @__PURE__ */ new Set(["seed", "tool", "egg", "decor"]);
  var TOKEN_TO_SHOP_KIND = {
    seed: "seeds",
    tool: "tools",
    egg: "eggs",
    decor: "decor"
  };
  var TOKEN_TO_SPRITE_CATS = {
    seed: ["seed"],
    tool: ["item"],
    egg: ["pet"],
    decor: ["decor"]
  };
  function getItemDisplayName(tokenType, itemId) {
    const kind = TOKEN_TO_SHOP_KIND[tokenType];
    if (!kind) return itemId;
    const itemObj = {};
    if (tokenType === "seed") itemObj.species = itemId;
    else if (tokenType === "tool") itemObj.toolId = itemId;
    else if (tokenType === "egg") itemObj.eggId = itemId;
    else if (tokenType === "decor") itemObj.decorId = itemId;
    try {
      return ShopsService.identityFor(kind, itemObj);
    } catch {
      return itemId;
    }
  }
  function getProduceDisplayName(species) {
    const entry = plantCatalog[species];
    return entry?.crop?.name ?? species;
  }
  function getProduceSize(species, targetScale) {
    const catalog = plantCatalog;
    const entry = catalog[species];
    if (!entry?.crop) return null;
    const maxScale = Number(entry.crop.maxScale);
    if (!Number.isFinite(maxScale) || maxScale <= 1) return null;
    const SIZE_MIN2 = 50;
    const SIZE_MAX2 = 100;
    const SCALE_MIN2 = 1;
    const clampedScale = Math.max(SCALE_MIN2, Math.min(targetScale, maxScale));
    const normalized = (clampedScale - SCALE_MIN2) / (maxScale - SCALE_MIN2);
    const size = Math.round(SIZE_MIN2 + normalized * (SIZE_MAX2 - SIZE_MIN2));
    const maxSize = 100;
    return { size: Math.max(SIZE_MIN2, Math.min(size, maxSize)), maxSize };
  }
  function buildTeamToken(team, pets) {
    if (!team.id || !team.name) return null;
    const teamPets = [];
    for (const slotPetId of team.slots) {
      if (!slotPetId) {
        teamPets.push(null);
        continue;
      }
      const pet = pets.find((p) => String(p.id) === String(slotPetId));
      if (!pet) {
        teamPets.push(null);
        continue;
      }
      teamPets.push({
        species: String(pet.petSpecies ?? ""),
        name: String(pet.name ?? ""),
        mutations: Array.isArray(pet.mutations) ? pet.mutations : [],
        abilities: Array.isArray(pet.abilities) ? pet.abilities : [],
        xp: typeof pet.xp === "number" ? pet.xp : 0,
        targetScale: typeof pet.targetScale === "number" ? pet.targetScale : 1
      });
    }
    const metaB64 = btoa(JSON.stringify({ pets: teamPets }));
    const raw = buildGemToken("team", team.id, team.name, metaB64);
    return { type: "team", id: team.id, label: team.name, meta: metaB64, raw };
  }
  function buildItemToken(item) {
    const itemType = String(item.itemType ?? "");
    const qty = typeof item.quantity === "number" ? String(item.quantity) : "1";
    switch (itemType) {
      case "Seed": {
        const id = String(item.species ?? "");
        if (!id) return null;
        const raw = buildGemToken("seed", id, qty);
        return { type: "seed", id, label: qty, raw };
      }
      case "Tool": {
        const id = String(item.toolId ?? "");
        if (!id) return null;
        const raw = buildGemToken("tool", id, qty);
        return { type: "tool", id, label: qty, raw };
      }
      case "Egg": {
        const id = String(item.eggId ?? "");
        if (!id) return null;
        const raw = buildGemToken("egg", id, qty);
        return { type: "egg", id, label: qty, raw };
      }
      case "Decor": {
        const id = String(item.decorId ?? "");
        if (!id) return null;
        const raw = buildGemToken("decor", id, qty);
        return { type: "decor", id, label: qty, raw };
      }
      case "Produce": {
        const id = String(item.species ?? "");
        if (!id) return null;
        const value = typeof item.value === "number" ? String(item.value) : "0";
        const mutations = Array.isArray(item.mutations) ? item.mutations : [];
        const targetScale = typeof item.scale === "number" ? item.scale : 1;
        const metaB64 = btoa(JSON.stringify({
          mutations: mutations.length > 0 ? mutations : void 0,
          targetScale
        }));
        const raw = buildGemToken("produce", id, value, metaB64);
        return { type: "produce", id, label: value, meta: metaB64, raw };
      }
      case "Pet": {
        const species = String(item.petSpecies ?? "");
        if (!species) return null;
        const name = String(item.name ?? species);
        const mutations = Array.isArray(item.mutations) ? item.mutations : [];
        const abilities = Array.isArray(item.abilities) ? item.abilities : [];
        const xp = typeof item.xp === "number" ? item.xp : 0;
        const targetScale = typeof item.targetScale === "number" ? item.targetScale : 1;
        const metaB64 = btoa(JSON.stringify({ mutations, abilities, xp, targetScale }));
        const raw = buildGemToken("pet", species, name, metaB64);
        return { type: "pet", id: species, label: name, meta: metaB64, raw };
      }
      default:
        return null;
    }
  }
  function createTokenCard(token, isOutgoing) {
    if (SIMPLE_ITEM_TYPES.has(token.type)) {
      return createItemCard(token, isOutgoing);
    }
    switch (token.type) {
      case "room":
        return createRoomCard(token, isOutgoing);
      case "produce":
        return createProduceCard(token, isOutgoing);
      case "pet":
        return createPetCard(token, isOutgoing);
      case "team":
        return createTeamCard(token, isOutgoing);
      default:
        return createGenericCard(token, isOutgoing);
    }
  }
  function createRoomCard(token, isOutgoing) {
    const env = detectEnvironment();
    const isDiscord = env.surface === "discord";
    const card2 = document.createElement("div");
    style2(card2, {
      display: "flex",
      alignItems: "center",
      gap: "10px",
      padding: "10px 12px",
      borderRadius: "10px",
      background: isOutgoing ? "rgba(94,234,212,0.08)" : "rgba(255,255,255,0.04)",
      border: isOutgoing ? "1px solid rgba(94,234,212,0.18)" : "1px solid rgba(255,255,255,0.08)",
      cursor: isDiscord ? "default" : "pointer",
      transition: "background 120ms ease, border-color 120ms ease",
      maxWidth: "100%"
    });
    if (!isDiscord) {
      card2.onmouseenter = () => style2(card2, {
        background: isOutgoing ? "rgba(94,234,212,0.14)" : "rgba(255,255,255,0.08)",
        borderColor: isOutgoing ? "rgba(94,234,212,0.3)" : "rgba(255,255,255,0.14)"
      });
      card2.onmouseleave = () => style2(card2, {
        background: isOutgoing ? "rgba(94,234,212,0.08)" : "rgba(255,255,255,0.04)",
        borderColor: isOutgoing ? "rgba(94,234,212,0.18)" : "rgba(255,255,255,0.08)"
      });
    }
    const icon = document.createElement("div");
    style2(icon, {
      width: "32px",
      height: "32px",
      borderRadius: "8px",
      background: "linear-gradient(135deg, rgba(94,234,212,0.2), rgba(59,130,246,0.2))",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: "0"
    });
    icon.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="${isOutgoing ? "#5eead4" : "#94a3b8"}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>`;
    const info = document.createElement("div");
    style2(info, {
      display: "flex",
      flexDirection: "column",
      gap: "2px",
      minWidth: "0",
      flex: "1"
    });
    const labelEl = document.createElement("div");
    style2(labelEl, {
      fontSize: "11px",
      fontWeight: "600",
      color: isOutgoing ? "rgba(94,234,212,0.7)" : "rgba(226,232,240,0.5)",
      textTransform: "uppercase",
      letterSpacing: "0.5px"
    });
    labelEl.textContent = "Room";
    const roomIdEl = document.createElement("div");
    style2(roomIdEl, {
      fontSize: "13px",
      fontWeight: "500",
      color: isOutgoing ? "#d1fae5" : "#e7eef7",
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    });
    roomIdEl.textContent = token.id;
    info.append(labelEl, roomIdEl);
    if (isDiscord) {
      const disabledMsg = document.createElement("div");
      style2(disabledMsg, {
        fontSize: "10px",
        color: "rgba(226,232,240,0.35)",
        fontStyle: "italic",
        lineHeight: "1.3"
      });
      disabledMsg.textContent = "Unavailable on Discord";
      info.appendChild(disabledMsg);
      card2.append(icon, info);
    } else {
      const arrow = document.createElement("div");
      style2(arrow, {
        flexShrink: "0",
        color: isOutgoing ? "rgba(94,234,212,0.4)" : "rgba(226,232,240,0.3)"
      });
      arrow.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"/></svg>`;
      card2.append(icon, info, arrow);
      card2.onclick = () => {
        const roomUrl = `${env.origin}/r/${token.id}`;
        window.open(roomUrl, "_blank");
      };
    }
    return card2;
  }
  function createGenericCard(token, isOutgoing) {
    const card2 = document.createElement("div");
    style2(card2, {
      display: "flex",
      alignItems: "center",
      gap: "8px",
      padding: "8px 12px",
      borderRadius: "8px",
      background: isOutgoing ? "rgba(94,234,212,0.06)" : "rgba(255,255,255,0.03)",
      border: isOutgoing ? "1px solid rgba(94,234,212,0.15)" : "1px solid rgba(255,255,255,0.06)",
      fontSize: "12px",
      color: isOutgoing ? "#d1fae5" : "#e7eef7"
    });
    card2.textContent = `${token.type}: ${token.id}`;
    return card2;
  }
  function createItemCard(token, isOutgoing) {
    const card2 = document.createElement("div");
    style2(card2, {
      display: "flex",
      alignItems: "center",
      gap: "10px",
      padding: "8px 12px",
      borderRadius: "10px",
      background: isOutgoing ? "rgba(94,234,212,0.08)" : "rgba(255,255,255,0.04)",
      border: isOutgoing ? "1px solid rgba(94,234,212,0.18)" : "1px solid rgba(255,255,255,0.08)",
      maxWidth: "100%"
    });
    const spriteWrap = document.createElement("div");
    style2(spriteWrap, {
      width: "32px",
      height: "32px",
      borderRadius: "6px",
      background: "rgba(255,255,255,0.05)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: "0",
      overflow: "hidden"
    });
    const cats = TOKEN_TO_SPRITE_CATS[token.type] ?? [];
    if (cats.length) {
      attachSpriteIcon(spriteWrap, cats, [token.id], 32, "chat-item");
    }
    const info = document.createElement("div");
    style2(info, {
      display: "flex",
      flexDirection: "column",
      gap: "2px",
      minWidth: "0",
      flex: "1"
    });
    const typeLabel = document.createElement("div");
    style2(typeLabel, {
      fontSize: "10px",
      fontWeight: "600",
      color: isOutgoing ? "rgba(94,234,212,0.6)" : "rgba(226,232,240,0.4)",
      textTransform: "uppercase",
      letterSpacing: "0.5px"
    });
    typeLabel.textContent = token.type.charAt(0).toUpperCase() + token.type.slice(1);
    const nameEl = document.createElement("div");
    style2(nameEl, {
      fontSize: "13px",
      fontWeight: "500",
      color: isOutgoing ? "#d1fae5" : "#e7eef7",
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    });
    nameEl.textContent = getItemDisplayName(token.type, token.id);
    info.append(typeLabel, nameEl);
    const qty = parseInt(token.label ?? "1", 10);
    if (qty > 1) {
      const qtyBadge = document.createElement("div");
      style2(qtyBadge, {
        padding: "2px 8px",
        borderRadius: "6px",
        fontSize: "11px",
        fontWeight: "600",
        background: isOutgoing ? "rgba(94,234,212,0.15)" : "rgba(255,255,255,0.08)",
        color: isOutgoing ? "#5eead4" : "rgba(226,232,240,0.6)",
        flexShrink: "0"
      });
      qtyBadge.textContent = `x${qty}`;
      card2.append(spriteWrap, info, qtyBadge);
    } else {
      card2.append(spriteWrap, info);
    }
    return card2;
  }
  var PRODUCE_SPRITE_CATS = ["crop", "plant", "tallplant"];
  function createProduceCard(token, isOutgoing) {
    const card2 = document.createElement("div");
    style2(card2, {
      display: "flex",
      alignItems: "center",
      gap: "10px",
      padding: "8px 12px",
      borderRadius: "10px",
      background: isOutgoing ? "rgba(94,234,212,0.08)" : "rgba(255,255,255,0.04)",
      border: isOutgoing ? "1px solid rgba(94,234,212,0.18)" : "1px solid rgba(255,255,255,0.08)",
      maxWidth: "100%"
    });
    let mutations;
    let targetScale = 1;
    if (token.meta) {
      try {
        let parsed;
        try {
          parsed = JSON.parse(atob(token.meta));
        } catch {
          parsed = JSON.parse(token.meta);
        }
        if (typeof parsed === "object" && parsed !== null && !Array.isArray(parsed)) {
          const obj = parsed;
          if (Array.isArray(obj.mutations)) mutations = obj.mutations;
          if (typeof obj.targetScale === "number") targetScale = obj.targetScale;
        } else if (Array.isArray(parsed) && parsed.length > 0) {
          mutations = parsed;
        }
      } catch {
      }
    }
    const spriteWrap = document.createElement("div");
    style2(spriteWrap, {
      width: "32px",
      height: "32px",
      borderRadius: "6px",
      background: "rgba(255,255,255,0.05)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: "0",
      overflow: "hidden"
    });
    attachSpriteIcon(spriteWrap, PRODUCE_SPRITE_CATS, [token.id], 32, "chat-produce", {
      mutations
    });
    const info = document.createElement("div");
    style2(info, {
      display: "flex",
      flexDirection: "column",
      gap: "3px",
      minWidth: "0",
      flex: "1"
    });
    const typeLabelRow = document.createElement("div");
    style2(typeLabelRow, {
      display: "flex",
      alignItems: "center",
      gap: "6px"
    });
    const typeLabel = document.createElement("div");
    style2(typeLabel, {
      fontSize: "10px",
      fontWeight: "600",
      color: isOutgoing ? "rgba(94,234,212,0.6)" : "rgba(226,232,240,0.4)",
      textTransform: "uppercase",
      letterSpacing: "0.5px"
    });
    typeLabel.textContent = "Produce";
    typeLabelRow.appendChild(typeLabel);
    const sizeInfo = getProduceSize(token.id, targetScale);
    if (sizeInfo) {
      const { size } = sizeInfo;
      const sizeBadge = document.createElement("span");
      style2(sizeBadge, {
        display: "inline-flex",
        alignItems: "center",
        gap: "2px",
        padding: "1px 4px",
        borderRadius: "3px",
        fontSize: "9px",
        fontWeight: "700",
        lineHeight: "1",
        color: isOutgoing ? "rgba(94,234,212,0.7)" : "rgba(226,232,240,0.5)",
        backgroundColor: isOutgoing ? "rgba(94,234,212,0.12)" : "rgba(255,255,255,0.08)"
      });
      sizeBadge.textContent = `SIZE ${size}`;
      typeLabelRow.appendChild(sizeBadge);
    }
    const nameEl = document.createElement("div");
    style2(nameEl, {
      fontSize: "13px",
      fontWeight: "500",
      color: isOutgoing ? "#d1fae5" : "#e7eef7",
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    });
    nameEl.textContent = getProduceDisplayName(token.id);
    const valueEl = document.createElement("div");
    style2(valueEl, {
      fontSize: "11px",
      color: isOutgoing ? "rgba(94,234,212,0.65)" : "rgba(226,232,240,0.5)"
    });
    const coinVal = parseInt(token.label ?? "0", 10);
    const formatted = formatPrice(coinVal) ?? String(coinVal);
    valueEl.textContent = `${formatted} coins`;
    info.append(typeLabelRow, nameEl, valueEl);
    card2.append(spriteWrap, info);
    return card2;
  }
  function getAbilityChipColors(id) {
    const key2 = String(id || "");
    const base = (PetsService.getAbilityNameWithoutLevel?.(key2) || "").replace(/[\s\-_]+/g, "").toLowerCase();
    const is = (prefix) => key2.startsWith(prefix) || base === prefix.toLowerCase();
    if (is("MoonKisser")) return { bg: "rgba(250,166,35,0.9)", hover: "rgba(250,166,35,1)" };
    if (is("DawnKisser")) return { bg: "rgba(162,92,242,0.9)", hover: "rgba(162,92,242,1)" };
    if (is("ProduceScaleBoost") || is("SnowyCropSizeBoost")) return { bg: "rgba(34,139,34,0.9)", hover: "rgba(34,139,34,1)" };
    if (is("PlantGrowthBoost") || is("SnowyPlantGrowthBoost")) return { bg: "rgba(0,128,128,0.9)", hover: "rgba(0,128,128,1)" };
    if (is("EggGrowthBoost") || is("SnowyEggGrowthBoost")) return { bg: "rgba(180,90,240,0.9)", hover: "rgba(180,90,240,1)" };
    if (is("PetAgeBoost")) return { bg: "rgba(147,112,219,0.9)", hover: "rgba(147,112,219,1)" };
    if (is("PetHatchSizeBoost")) return { bg: "rgba(128,0,128,0.9)", hover: "rgba(128,0,128,1)" };
    if (is("PetXpBoost") || is("SnowyPetXpBoost")) return { bg: "rgba(30,144,255,0.9)", hover: "rgba(30,144,255,1)" };
    if (is("HungerBoost") || is("SnowyHungerBoost")) return { bg: "rgba(255,20,147,0.9)", hover: "rgba(255,20,147,1)" };
    if (is("HungerRestore") || is("SnowyHungerRestore")) return { bg: "rgba(255,105,180,0.9)", hover: "rgba(255,105,180,1)" };
    if (is("SellBoost")) return { bg: "rgba(220,20,60,0.9)", hover: "rgba(220,20,60,1)" };
    if (is("CoinFinder") || is("SnowyCoinFinder")) return { bg: "rgba(180,150,0,0.9)", hover: "rgba(180,150,0,1)" };
    if (is("SeedFinder")) return { bg: "rgba(168,102,38,0.9)", hover: "rgba(168,102,38,1)" };
    if (is("ProduceMutationBoost")) return { bg: "rgba(140,15,70,0.9)", hover: "rgba(140,15,70,1)" };
    if (is("PetMutationBoost")) return { bg: "rgba(160,50,100,0.9)", hover: "rgba(160,50,100,1)" };
    if (is("DoubleHarvest")) return { bg: "rgba(0,120,180,0.9)", hover: "rgba(0,120,180,1)" };
    if (is("DoubleHatch")) return { bg: "rgba(60,90,180,0.9)", hover: "rgba(60,90,180,1)" };
    if (is("ProduceEater")) return { bg: "rgba(255,69,0,0.9)", hover: "rgba(255,69,0,1)" };
    if (is("ProduceRefund")) return { bg: "rgba(255,99,71,0.9)", hover: "rgba(255,99,71,1)" };
    if (is("PetRefund")) return { bg: "rgba(0,80,120,0.9)", hover: "rgba(0,80,120,1)" };
    if (is("Copycat")) return { bg: "rgba(255,140,0,0.9)", hover: "rgba(255,140,0,1)" };
    if (is("GoldGranter")) return { bg: "linear-gradient(135deg, rgba(225,200,55,0.9) 0%, rgba(225,180,10,0.9) 40%, rgba(215,185,45,0.9) 70%, rgba(210,185,45,0.9) 100%)", hover: "linear-gradient(135deg, rgba(220,200,70,1) 0%, rgba(210,175,5,1) 40%, rgba(210,185,55,1) 70%, rgba(200,175,30,1) 100%)" };
    if (is("RainbowGranter")) return { bg: "linear-gradient(45deg, rgba(200,0,0,0.9), rgba(200,120,0,0.9), rgba(160,170,30,0.9), rgba(60,170,60,0.9), rgba(50,170,170,0.9), rgba(40,150,180,0.9), rgba(20,90,180,0.9), rgba(70,30,150,0.9))", hover: "linear-gradient(45deg, rgba(200,0,0,1), rgba(200,120,0,1), rgba(160,170,30,1), rgba(60,170,60,1), rgba(50,170,170,1), rgba(40,150,180,1), rgba(20,90,180,1), rgba(70,30,150,1))" };
    if (is("RainDance")) return { bg: "rgba(102,204,216,0.9)", hover: "rgba(102,204,216,1)" };
    if (is("SnowGranter")) return { bg: "rgba(175,215,235,0.9)", hover: "rgba(175,215,235,1)" };
    if (is("FrostGranter")) return { bg: "rgba(100,160,220,0.9)", hover: "rgba(100,160,220,1)" };
    return { bg: "rgba(100,100,100,0.9)", hover: "rgba(150,150,150,1)" };
  }
  function createAbilityBadge(abilities) {
    const wrap = document.createElement("span");
    style2(wrap, { display: "inline-flex", alignItems: "center", lineHeight: "1" });
    const ids = Array.isArray(abilities) ? abilities.filter(Boolean) : [];
    if (!ids.length) return wrap;
    for (let i = 0; i < ids.length; i++) {
      const chip = document.createElement("span");
      const { bg, hover } = getAbilityChipColors(ids[i]);
      chip.title = PetsService.getAbilityName(ids[i]) || ids[i];
      style2(chip, {
        display: "inline-block",
        width: "12px",
        height: "12px",
        borderRadius: "3px",
        marginRight: i === ids.length - 1 ? "0" : "8px",
        background: bg,
        transition: "transform 80ms ease, box-shadow 120ms ease, background 120ms ease",
        cursor: "default",
        boxShadow: "0 0 0 1px #0006 inset, 0 0 0 1px #ffffff1a"
      });
      chip.onmouseenter = () => {
        chip.style.background = hover;
        chip.style.transform = "scale(1.08)";
        chip.style.boxShadow = "0 0 0 1px #0006 inset, 0 0 0 1px #ffffff33";
      };
      chip.onmouseleave = () => {
        chip.style.background = bg;
        chip.style.transform = "none";
        chip.style.boxShadow = "0 0 0 1px #0006 inset, 0 0 0 1px #ffffff1a";
      };
      wrap.appendChild(chip);
    }
    return wrap;
  }
  function decodePetMeta(meta) {
    if (!meta) return { mutations: void 0, abilities: [], xp: 0, targetScale: 1 };
    try {
      const parsed = JSON.parse(atob(meta));
      if (parsed && typeof parsed === "object") {
        const mutations = Array.isArray(parsed.mutations) && parsed.mutations.length > 0 ? parsed.mutations : void 0;
        const abilities = Array.isArray(parsed.abilities) ? parsed.abilities : [];
        const xp = typeof parsed.xp === "number" ? parsed.xp : 0;
        const targetScale = typeof parsed.targetScale === "number" ? parsed.targetScale : 1;
        return { mutations, abilities, xp, targetScale };
      }
    } catch {
    }
    return { mutations: void 0, abilities: [], xp: 0, targetScale: 1 };
  }
  function getPetStrength2(species, xp, targetScale) {
    const catalog = petCatalog;
    const entry = catalog[species];
    if (!entry) return null;
    const maxScale = Number(entry.maxScale);
    const hoursToMature = Number(entry.hoursToMature);
    if (!Number.isFinite(maxScale) || maxScale <= 1) return null;
    if (!Number.isFinite(hoursToMature) || hoursToMature <= 0) return null;
    const safeXp = Math.max(0, xp);
    const xpDenominator = hoursToMature * 3600;
    const xpComponent = xpDenominator > 0 ? Math.min(Math.floor(safeXp / xpDenominator * 30), 30) : 0;
    const minScale = 1;
    const clampedScale = Math.max(minScale, Math.min(targetScale, maxScale));
    const scaleDenominator = maxScale - minScale;
    const scaleComponent = scaleDenominator > 0 ? Math.floor((clampedScale - minScale) / scaleDenominator * 20 + 80) : 80;
    const maxStrength = Math.max(0, Math.min(scaleComponent, 100));
    const combined = xpComponent + maxStrength - 30;
    const strength = Math.max(0, Math.min(combined, maxStrength));
    return { strength, maxStrength };
  }
  function createPetCard(token, isOutgoing) {
    const card2 = document.createElement("div");
    style2(card2, {
      display: "flex",
      alignItems: "center",
      gap: "10px",
      padding: "8px 12px",
      borderRadius: "10px",
      background: isOutgoing ? "rgba(94,234,212,0.08)" : "rgba(255,255,255,0.04)",
      border: isOutgoing ? "1px solid rgba(94,234,212,0.18)" : "1px solid rgba(255,255,255,0.08)",
      maxWidth: "100%"
    });
    const { mutations, abilities, xp, targetScale } = decodePetMeta(token.meta);
    const spriteWrap = document.createElement("div");
    style2(spriteWrap, {
      width: "32px",
      height: "32px",
      borderRadius: "6px",
      background: "rgba(255,255,255,0.05)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: "0",
      overflow: "hidden"
    });
    attachSpriteIcon(spriteWrap, ["pet"], [token.id], 32, "chat-pet", { mutations });
    const info = document.createElement("div");
    style2(info, {
      display: "flex",
      flexDirection: "column",
      gap: "3px",
      minWidth: "0",
      flex: "1"
    });
    const typeLabelRow = document.createElement("div");
    style2(typeLabelRow, {
      display: "flex",
      alignItems: "center",
      gap: "6px"
    });
    const typeLabel = document.createElement("div");
    style2(typeLabel, {
      fontSize: "10px",
      fontWeight: "600",
      color: isOutgoing ? "rgba(94,234,212,0.6)" : "rgba(226,232,240,0.4)",
      textTransform: "uppercase",
      letterSpacing: "0.5px"
    });
    typeLabel.textContent = "Pet";
    typeLabelRow.appendChild(typeLabel);
    const strInfo = getPetStrength2(token.id, xp, targetScale);
    if (strInfo) {
      const { strength, maxStrength } = strInfo;
      const isMax = strength >= maxStrength;
      const strBadge = document.createElement("span");
      style2(strBadge, {
        display: "inline-flex",
        alignItems: "center",
        gap: "2px",
        padding: "1px 4px",
        borderRadius: "3px",
        fontSize: "9px",
        fontWeight: "700",
        lineHeight: "1",
        color: isOutgoing ? "rgba(94,234,212,0.7)" : "rgba(226,232,240,0.5)",
        backgroundColor: isOutgoing ? "rgba(94,234,212,0.12)" : "rgba(255,255,255,0.08)"
      });
      strBadge.textContent = isMax ? `STR ${maxStrength} MAX` : `STR ${strength}/${maxStrength}`;
      typeLabelRow.appendChild(strBadge);
    }
    const nameEl = document.createElement("div");
    style2(nameEl, {
      fontSize: "13px",
      fontWeight: "500",
      color: isOutgoing ? "#d1fae5" : "#e7eef7",
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    });
    nameEl.textContent = token.label || token.id;
    info.append(typeLabelRow, nameEl);
    if (abilities.length > 0) {
      info.appendChild(createAbilityBadge(abilities));
    }
    card2.append(spriteWrap, info);
    return card2;
  }
  function createTeamCard(token, isOutgoing) {
    const card2 = document.createElement("div");
    style2(card2, {
      display: "flex",
      flexDirection: "column",
      gap: "10px",
      padding: "10px 12px",
      borderRadius: "10px",
      background: isOutgoing ? "rgba(94,234,212,0.08)" : "rgba(255,255,255,0.04)",
      border: isOutgoing ? "1px solid rgba(94,234,212,0.18)" : "1px solid rgba(255,255,255,0.08)",
      maxWidth: "100%"
    });
    let teamPets = [];
    if (token.meta) {
      try {
        const decoded = JSON.parse(atob(token.meta));
        if (decoded && Array.isArray(decoded.pets)) {
          teamPets = decoded.pets;
        }
      } catch {
      }
    }
    const headerRow = document.createElement("div");
    style2(headerRow, {
      display: "flex",
      flexDirection: "column",
      gap: "4px"
    });
    const typeLabel = document.createElement("div");
    style2(typeLabel, {
      fontSize: "10px",
      fontWeight: "600",
      color: isOutgoing ? "rgba(94,234,212,0.6)" : "rgba(226,232,240,0.4)",
      textTransform: "uppercase",
      letterSpacing: "0.5px"
    });
    typeLabel.textContent = "Team";
    const teamName = document.createElement("div");
    style2(teamName, {
      fontSize: "13px",
      fontWeight: "500",
      color: isOutgoing ? "#d1fae5" : "#e7eef7",
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    });
    teamName.textContent = token.label || token.id;
    headerRow.append(typeLabel, teamName);
    card2.appendChild(headerRow);
    const petsRow = document.createElement("div");
    style2(petsRow, {
      display: "flex",
      gap: "8px",
      flexWrap: "wrap"
    });
    for (const pet of teamPets) {
      if (!pet) continue;
      const petSlot = document.createElement("div");
      style2(petSlot, {
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        gap: "4px",
        flex: "1",
        minWidth: "80px"
      });
      const petNameEl = document.createElement("div");
      style2(petNameEl, {
        fontSize: "11px",
        fontWeight: "500",
        color: isOutgoing ? "#d1fae5" : "#e7eef7",
        textAlign: "center",
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap",
        maxWidth: "100%"
      });
      petNameEl.textContent = pet.name || pet.species;
      petSlot.appendChild(petNameEl);
      const strInfo = getPetStrength2(pet.species, pet.xp, pet.targetScale);
      if (strInfo) {
        const { strength, maxStrength } = strInfo;
        const isMax = strength >= maxStrength;
        const strBadge = document.createElement("span");
        style2(strBadge, {
          display: "inline-flex",
          alignItems: "center",
          gap: "2px",
          padding: "1px 4px",
          borderRadius: "3px",
          fontSize: "8px",
          fontWeight: "700",
          lineHeight: "1",
          color: isOutgoing ? "rgba(94,234,212,0.7)" : "rgba(226,232,240,0.5)",
          backgroundColor: isOutgoing ? "rgba(94,234,212,0.12)" : "rgba(255,255,255,0.08)"
        });
        strBadge.textContent = isMax ? `STR ${maxStrength} MAX` : `STR ${strength}/${maxStrength}`;
        petSlot.appendChild(strBadge);
      }
      const spriteWrap = document.createElement("div");
      style2(spriteWrap, {
        width: "40px",
        height: "40px",
        borderRadius: "8px",
        background: "rgba(255,255,255,0.05)",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        overflow: "hidden"
      });
      const muts = pet.mutations.length > 0 ? pet.mutations : void 0;
      attachSpriteIcon(spriteWrap, ["pet"], [pet.species], 40, "chat-team-pet", { mutations: muts });
      petSlot.appendChild(spriteWrap);
      if (pet.abilities.length > 0) {
        const abilityWrap = document.createElement("div");
        style2(abilityWrap, {
          display: "flex",
          justifyContent: "center"
        });
        abilityWrap.appendChild(createAbilityBadge(pet.abilities));
        petSlot.appendChild(abilityWrap);
      }
      petsRow.appendChild(petSlot);
    }
    card2.appendChild(petsRow);
    return card2;
  }
  function createTokenCardsContainer(tokens, isOutgoing) {
    const container = document.createElement("div");
    style2(container, {
      display: "flex",
      flexDirection: "column",
      gap: "4px",
      marginTop: "4px"
    });
    for (const token of tokens) {
      container.appendChild(createTokenCard(token, isOutgoing));
    }
    return container;
  }
  function createAttachmentState() {
    const pending = [];
    const bar = document.createElement("div");
    style2(bar, {
      display: "none",
      flexDirection: "row",
      gap: "6px",
      padding: "6px 12px",
      borderTop: "1px solid rgba(255,255,255,0.06)",
      flexShrink: "0",
      overflowX: "auto",
      overflowY: "hidden"
    });
    function render2() {
      bar.innerHTML = "";
      if (pending.length === 0) {
        style2(bar, { display: "none" });
        return;
      }
      style2(bar, { display: "flex" });
      for (let i = 0; i < pending.length; i++) {
        bar.appendChild(createAttachmentChip(pending[i], i));
      }
    }
    function createAttachmentChip(token, index) {
      const chip = document.createElement("div");
      style2(chip, {
        display: "flex",
        alignItems: "center",
        gap: "8px",
        padding: "6px 10px",
        borderRadius: "8px",
        background: "rgba(94,234,212,0.08)",
        border: "1px solid rgba(94,234,212,0.18)",
        flexShrink: "0",
        whiteSpace: "nowrap"
      });
      const typeIcon = document.createElement("div");
      style2(typeIcon, {
        width: "22px",
        height: "22px",
        borderRadius: "6px",
        background: "rgba(94,234,212,0.15)",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        flexShrink: "0",
        color: "#5eead4",
        overflow: "hidden"
      });
      if (SIMPLE_ITEM_TYPES.has(token.type)) {
        const spriteCats = TOKEN_TO_SPRITE_CATS[token.type] ?? [];
        if (spriteCats.length) {
          attachSpriteIcon(typeIcon, spriteCats, [token.id], 22, "chip-icon");
        }
      } else if (token.type === "produce") {
        let muts;
        if (token.meta) {
          try {
            let p;
            try {
              p = JSON.parse(atob(token.meta));
            } catch {
              p = JSON.parse(token.meta);
            }
            if (typeof p === "object" && p !== null && Array.isArray(p.mutations)) {
              muts = p.mutations;
            } else if (Array.isArray(p) && p.length) {
              muts = p;
            }
          } catch {
          }
        }
        attachSpriteIcon(typeIcon, PRODUCE_SPRITE_CATS, [token.id], 22, "chip-produce", {
          mutations: muts
        });
      } else if (token.type === "pet") {
        const { mutations: petMuts } = decodePetMeta(token.meta);
        attachSpriteIcon(typeIcon, ["pet"], [token.id], 22, "chip-pet", { mutations: petMuts });
      } else if (token.type === "team") {
        typeIcon.innerHTML = `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M19.0803 15.7203C18.4903 12.1903 15.1003 9.32031 11.5203 9.32031C7.63028 9.32031 4.21028 12.4703 3.88028 16.3503C3.75028 17.8503 4.23028 19.2703 5.22028 20.3403C6.20028 21.4103 7.58028 22.0003 9.08028 22.0003H13.7603C15.4503 22.0003 16.9303 21.3403 17.9403 20.1503C18.9503 18.9603 19.3503 17.3803 19.0803 15.7203Z" fill="currentColor"/><path d="M10.2796 7.86C11.8978 7.86 13.2096 6.54819 13.2096 4.93C13.2096 3.31181 11.8978 2 10.2796 2C8.66141 2 7.34961 3.31181 7.34961 4.93C7.34961 6.54819 8.66141 7.86 10.2796 7.86Z" fill="currentColor"/><path d="M16.94 9.02844C18.2876 9.02844 19.38 7.93601 19.38 6.58844C19.38 5.24086 18.2876 4.14844 16.94 4.14844C15.5924 4.14844 14.5 5.24086 14.5 6.58844C14.5 7.93601 15.5924 9.02844 16.94 9.02844Z" fill="currentColor"/><path d="M20.5496 12.9313C21.6266 12.9313 22.4996 12.0582 22.4996 10.9812C22.4996 9.90429 21.6266 9.03125 20.5496 9.03125C19.4727 9.03125 18.5996 9.90429 18.5996 10.9812C18.5996 12.0582 19.4727 12.9313 20.5496 12.9313Z" fill="currentColor"/><path d="M3.94 10.9816C5.28757 10.9816 6.38 9.88914 6.38 8.54156C6.38 7.19399 5.28757 6.10156 3.94 6.10156C2.59243 6.10156 1.5 7.19399 1.5 8.54156C1.5 9.88914 2.59243 10.9816 3.94 10.9816Z" fill="currentColor"/></svg>`;
      } else if (token.type === "room") {
        typeIcon.innerHTML = `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>`;
      }
      const labelEl = document.createElement("div");
      style2(labelEl, {
        fontSize: "12px",
        color: "#d1fae5",
        flex: "1",
        minWidth: "0",
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
      });
      let chipLabel;
      if (SIMPLE_ITEM_TYPES.has(token.type)) {
        const displayName = getItemDisplayName(token.type, token.id);
        const qty = parseInt(token.label ?? "1", 10);
        chipLabel = qty > 1 ? `${displayName} x${qty}` : displayName;
      } else if (token.type === "produce") {
        const displayName = getProduceDisplayName(token.id);
        const coinVal = parseInt(token.label ?? "0", 10);
        const valStr = formatPrice(coinVal) ?? String(coinVal);
        chipLabel = `${displayName} (${valStr})`;
      } else if (token.type === "pet") {
        chipLabel = token.label || token.id;
      } else if (token.type === "team") {
        chipLabel = token.label || token.id;
      } else {
        const typeName = token.type.charAt(0).toUpperCase() + token.type.slice(1);
        chipLabel = `${typeName}: ${token.id}`;
      }
      labelEl.textContent = chipLabel;
      const removeBtn = document.createElement("button");
      removeBtn.type = "button";
      style2(removeBtn, {
        width: "18px",
        height: "18px",
        borderRadius: "50%",
        border: "none",
        background: "rgba(255,255,255,0.08)",
        color: "rgba(226,232,240,0.5)",
        cursor: "pointer",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        fontSize: "12px",
        padding: "0",
        lineHeight: "1",
        flexShrink: "0",
        transition: "all 100ms ease"
      });
      removeBtn.textContent = "\xD7";
      removeBtn.onmouseenter = () => style2(removeBtn, { background: "rgba(239,68,68,0.3)", color: "#fca5a5" });
      removeBtn.onmouseleave = () => style2(removeBtn, { background: "rgba(255,255,255,0.08)", color: "rgba(226,232,240,0.5)" });
      removeBtn.onclick = (e) => {
        e.stopPropagation();
        pending.splice(index, 1);
        render2();
      };
      chip.append(typeIcon, labelEl, removeBtn);
      return chip;
    }
    return {
      barElement: bar,
      getTokens: () => [...pending],
      add: (token) => {
        pending.push(token);
        render2();
      },
      clear: () => {
        pending.length = 0;
        render2();
      },
      buildTokensString: () => {
        if (pending.length === 0) return "";
        return pending.map((t) => t.raw).join(" ");
      }
    };
  }
  async function buildConsolidatedInventory() {
    const [rawInv, rawPets] = await Promise.all([
      Atoms.inventory.myInventory.get(),
      Atoms.pets.myPetInfos.get()
    ]);
    const inv = rawInv && typeof rawInv === "object" ? rawInv : {};
    const mainItems = Array.isArray(inv.items) ? [...inv.items] : [];
    const storages = Array.isArray(inv.storages) ? inv.storages : [];
    const favoritedItemIds = Array.isArray(inv.favoritedItemIds) ? inv.favoritedItemIds : [];
    for (const storage of storages) {
      const storageItems = Array.isArray(storage.items) ? storage.items : [];
      mainItems.push(...storageItems);
    }
    const pets = Array.isArray(rawPets) ? rawPets : [];
    for (const pet of pets) {
      if (!pet || typeof pet !== "object") continue;
      const slot = pet.slot;
      if (!slot) continue;
      mainItems.push({
        id: slot.id,
        itemType: "Pet",
        petSpecies: slot.petSpecies,
        name: slot.name,
        xp: slot.xp,
        hunger: slot.hunger,
        mutations: slot.mutations,
        targetScale: slot.targetScale,
        abilities: slot.abilities
      });
    }
    return { items: mainItems, storages: [], favoritedItemIds };
  }
  async function waitForItemSelection(timeoutMs = 12e4) {
    const start2 = performance.now();
    try {
      await Atoms.inventory.myPossiblyNoLongerValidSelectedItemIndex.set(null);
    } catch {
    }
    try {
      await Atoms.inventory.myValidatedSelectedItemIndex.set(null);
    } catch {
    }
    try {
      await Atoms.inventory.mySelectedItemName.set(null);
    } catch {
    }
    while (performance.now() - start2 < timeoutMs) {
      try {
        const modalVal = await Atoms.ui.activeModal.get();
        if (!isInventoryOpen(modalVal)) return null;
      } catch {
        return null;
      }
      try {
        const idx = await Atoms.inventory.myPossiblyNoLongerValidSelectedItemIndex.get();
        if (typeof idx === "number" && Number.isInteger(idx) && idx >= 0) {
          return idx;
        }
      } catch {
      }
      await new Promise((r) => setTimeout(r, 80));
    }
    return null;
  }
  async function createTeamSelectionView(options) {
    const { onTeamSelected, onBack } = options;
    const teams = readAriesPath("pets.teams") ?? [];
    try {
      const win = window.unsafeWindow || window;
      const service = win?.__MG_SPRITE_SERVICE__;
      if (service?.list) {
        service.list("pet");
      }
      if (service?.ready && typeof service.ready.then === "function") {
        await service.ready;
      }
    } catch (err) {
      console.warn("[ChatImporter] Failed to initialize sprite service:", err);
    }
    const petItems = [];
    const rawPlacedPets = await Atoms.pets.myPetInfos.get();
    const placedPets = Array.isArray(rawPlacedPets) ? rawPlacedPets : [];
    console.log("[Team Selector] Placed pets from myPetInfos:", placedPets.length);
    for (const pet of placedPets) {
      if (!pet || typeof pet !== "object") continue;
      const slot = pet.slot;
      if (!slot || !slot.id) continue;
      petItems.push({
        id: slot.id,
        petSpecies: slot.petSpecies,
        name: slot.name,
        xp: slot.xp,
        mutations: slot.mutations,
        targetScale: slot.targetScale,
        abilities: slot.abilities
      });
    }
    const rawInventory = await Atoms.inventory.myInventory.get();
    if (rawInventory && typeof rawInventory === "object") {
      const inv = rawInventory;
      const items = inv.items;
      if (Array.isArray(items)) {
        const inventoryPets = items.filter((item) => item?.itemType === "Pet");
        console.log("[Team Selector] Inventory pets from myInventory:", inventoryPets.length);
        for (const pet of inventoryPets) {
          if (!pet || typeof pet !== "object") continue;
          const p = pet;
          if (!p.id) continue;
          petItems.push({
            id: p.id,
            petSpecies: p.petSpecies,
            name: p.name,
            xp: p.xp,
            mutations: p.mutations,
            targetScale: p.targetScale,
            abilities: p.abilities
          });
        }
      }
    }
    const rawHutchPets = await myPetHutchPetItems.get();
    const hutchPets = Array.isArray(rawHutchPets) ? rawHutchPets : [];
    console.log("[Team Selector] Hutch pets from myPetHutchPetItems:", hutchPets.length);
    for (const pet of hutchPets) {
      if (!pet || typeof pet !== "object") continue;
      const p = pet;
      if (!p.id || p.itemType !== "Pet") continue;
      petItems.push({
        id: p.id,
        petSpecies: p.petSpecies,
        name: p.name,
        xp: p.xp,
        mutations: p.mutations,
        targetScale: p.targetScale,
        abilities: p.abilities
      });
    }
    console.log("[Team Selector] Total pets collected:", petItems.length);
    console.log("[Team Selector] Pet IDs:", petItems.map((p) => p.id));
    const container = document.createElement("div");
    style2(container, {
      display: "flex",
      flexDirection: "column",
      height: "100%",
      overflow: "hidden"
    });
    const header = document.createElement("div");
    style2(header, {
      display: "flex",
      alignItems: "center",
      gap: "12px",
      paddingBottom: "12px",
      borderBottom: "1px solid rgba(255,255,255,0.08)",
      flexShrink: "0"
    });
    const backButton = document.createElement("button");
    backButton.innerHTML = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" style="display:block;"><path d="M15 18L9 12L15 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
    backButton.type = "button";
    style2(backButton, {
      padding: "8px",
      border: "1px solid rgba(255,255,255,0.08)",
      borderRadius: "8px",
      background: "rgba(255,255,255,0.03)",
      color: "#e7eef7",
      cursor: "pointer",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transition: "all 120ms ease"
    });
    backButton.onclick = onBack;
    const title = document.createElement("div");
    style2(title, {
      fontSize: "16px",
      fontWeight: "700",
      color: "#e7eef7"
    });
    title.textContent = "Select a Team";
    header.append(backButton, title);
    const list = document.createElement("div");
    style2(list, {
      flex: "1",
      overflowY: "auto",
      padding: "12px 0",
      display: "flex",
      flexDirection: "column",
      gap: "8px"
    });
    if (teams.length === 0) {
      const emptyMsg = document.createElement("div");
      style2(emptyMsg, {
        padding: "32px",
        textAlign: "center",
        color: "rgba(226,232,240,0.5)",
        fontSize: "14px"
      });
      emptyMsg.textContent = "No teams found";
      list.appendChild(emptyMsg);
    }
    console.log("[Team Selector] Teams:", teams);
    for (const team of teams) {
      console.log("[Team Selector] Processing team:", team.name, "slots:", team.slots);
      const teamItem = document.createElement("div");
      style2(teamItem, {
        padding: "12px",
        borderRadius: "10px",
        background: "rgba(255,255,255,0.02)",
        border: "1px solid rgba(255,255,255,0.06)",
        cursor: "pointer",
        transition: "all 120ms ease",
        display: "flex",
        alignItems: "center",
        gap: "12px"
      });
      teamItem.onmouseenter = () => style2(teamItem, {
        background: "rgba(94,234,212,0.08)",
        borderColor: "rgba(94,234,212,0.2)"
      });
      teamItem.onmouseleave = () => style2(teamItem, {
        background: "rgba(255,255,255,0.02)",
        borderColor: "rgba(255,255,255,0.06)"
      });
      teamItem.onclick = () => onTeamSelected(team, petItems);
      const teamNameEl = document.createElement("div");
      style2(teamNameEl, {
        fontSize: "14px",
        fontWeight: "500",
        color: "#e7eef7",
        flex: "1",
        minWidth: "0"
      });
      teamNameEl.textContent = team.name || team.id;
      const petsRow = document.createElement("div");
      style2(petsRow, {
        display: "flex",
        gap: "6px",
        flexShrink: "0"
      });
      for (const slotPetId of team.slots) {
        if (!slotPetId) {
          console.log("[Team Selector] Empty slot in team", team.name);
          const emptySlot = document.createElement("div");
          style2(emptySlot, {
            width: "32px",
            height: "32px",
            borderRadius: "6px",
            background: "rgba(255,255,255,0.02)",
            border: "1px dashed rgba(255,255,255,0.1)"
          });
          petsRow.appendChild(emptySlot);
          continue;
        }
        const pet = petItems.find((p) => String(p.id) === String(slotPetId));
        if (!pet) {
          console.log("[Team Selector] Pet not found for slot ID:", slotPetId);
          const emptySlot = document.createElement("div");
          style2(emptySlot, {
            width: "32px",
            height: "32px",
            borderRadius: "6px",
            background: "rgba(255,255,255,0.02)",
            border: "1px dashed rgba(255,255,255,0.1)"
          });
          petsRow.appendChild(emptySlot);
          continue;
        }
        const species = String(pet.petSpecies ?? "");
        const mutations = Array.isArray(pet.mutations) && pet.mutations.length > 0 ? pet.mutations : void 0;
        console.log("[Team Selector] Rendering sprite for:", species, "mutations:", mutations, "pet:", pet);
        const spriteWrap = document.createElement("div");
        style2(spriteWrap, {
          width: "32px",
          height: "32px",
          borderRadius: "6px",
          background: "rgba(255,255,255,0.05)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          overflow: "hidden"
        });
        attachSpriteIcon(spriteWrap, ["pet"], [species], 32, "team-select-pet", { mutations });
        petsRow.appendChild(spriteWrap);
      }
      teamItem.append(teamNameEl, petsRow);
      list.appendChild(teamItem);
    }
    container.append(header, list);
    return container;
  }
  async function openItemImportModal(onAttach) {
    try {
      const consolidated = await buildConsolidatedInventory();
      window.dispatchEvent(new CustomEvent(CH_EVENTS.CLOSE));
      await new Promise((r) => setTimeout(r, 250));
      await fakeInventoryShow(consolidated, { open: true });
      const selectedIndex = await waitForItemSelection();
      if (selectedIndex !== null && consolidated.items[selectedIndex]) {
        const selectedItem = consolidated.items[selectedIndex];
        const token = buildItemToken(selectedItem);
        if (token) {
          onAttach(token);
        }
      }
      try {
        await Atoms.inventory.myPossiblyNoLongerValidSelectedItemIndex.set(null);
      } catch {
      }
      try {
        await Atoms.inventory.myValidatedSelectedItemIndex.set(null);
      } catch {
      }
      try {
        await Atoms.inventory.mySelectedItemName.set(null);
      } catch {
      }
      await fakeInventoryHide();
      window.dispatchEvent(new CustomEvent(CH_EVENTS.OPEN));
    } catch (err) {
      console.error("[ChatImporter] Item import failed:", err);
      window.dispatchEvent(new CustomEvent(CH_EVENTS.OPEN));
    }
  }
  function createImportButton(options) {
    const { onAttach, onShowTeamSelection } = options;
    const wrap = document.createElement("div");
    style2(wrap, {
      position: "relative",
      flexShrink: "0"
    });
    const btn = document.createElement("button");
    btn.type = "button";
    btn.textContent = "+";
    style2(btn, {
      width: "34px",
      height: "34px",
      borderRadius: "10px",
      border: "1px solid rgba(255,255,255,0.1)",
      background: "rgba(255,255,255,0.04)",
      color: "#e7eef7",
      cursor: "pointer",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      fontSize: "18px",
      fontWeight: "400",
      opacity: "0.6",
      transition: "all 150ms ease",
      padding: "0",
      lineHeight: "1"
    });
    btn.onmouseenter = () => style2(btn, { opacity: "1", background: "rgba(94,234,212,0.1)", borderColor: "rgba(94,234,212,0.25)" });
    btn.onmouseleave = () => {
      if (!btn.dataset.active) {
        style2(btn, { opacity: "0.6", background: "rgba(255,255,255,0.04)", borderColor: "rgba(255,255,255,0.1)" });
      }
    };
    const menu = document.createElement("div");
    style2(menu, {
      position: "absolute",
      left: "0",
      bottom: "42px",
      zIndex: "10",
      display: "none",
      minWidth: "200px",
      padding: "6px",
      borderRadius: "12px",
      background: "#0f141e",
      border: "1px solid rgba(94,234,212,0.2)",
      boxShadow: "0 8px 32px rgba(0,0,0,0.5)"
    });
    const roomItem = createMenuItem(
      "Room",
      `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>`,
      "Share current room",
      () => {
        void getCurrentRoomId().then((roomId) => {
          if (!roomId) return;
          const raw = buildGemToken("room", roomId);
          onAttach({ type: "room", id: roomId, raw });
          closeMenu();
        });
      }
    );
    const teamImport = createMenuItem(
      "Team",
      `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M19.0803 15.7203C18.4903 12.1903 15.1003 9.32031 11.5203 9.32031C7.63028 9.32031 4.21028 12.4703 3.88028 16.3503C3.75028 17.8503 4.23028 19.2703 5.22028 20.3403C6.20028 21.4103 7.58028 22.0003 9.08028 22.0003H13.7603C15.4503 22.0003 16.9303 21.3403 17.9403 20.1503C18.9503 18.9603 19.3503 17.3803 19.0803 15.7203Z" fill="currentColor"/><path d="M10.2796 7.86C11.8978 7.86 13.2096 6.54819 13.2096 4.93C13.2096 3.31181 11.8978 2 10.2796 2C8.66141 2 7.34961 3.31181 7.34961 4.93C7.34961 6.54819 8.66141 7.86 10.2796 7.86Z" fill="currentColor"/><path d="M16.94 9.02844C18.2876 9.02844 19.38 7.93601 19.38 6.58844C19.38 5.24086 18.2876 4.14844 16.94 4.14844C15.5924 4.14844 14.5 5.24086 14.5 6.58844C14.5 7.93601 15.5924 9.02844 16.94 9.02844Z" fill="currentColor"/><path d="M20.5496 12.9313C21.6266 12.9313 22.4996 12.0582 22.4996 10.9812C22.4996 9.90429 21.6266 9.03125 20.5496 9.03125C19.4727 9.03125 18.5996 9.90429 18.5996 10.9812C18.5996 12.0582 19.4727 12.9313 20.5496 12.9313Z" fill="currentColor"/><path d="M3.94 10.9816C5.28757 10.9816 6.38 9.88914 6.38 8.54156C6.38 7.19399 5.28757 6.10156 3.94 6.10156C2.59243 6.10156 1.5 7.19399 1.5 8.54156C1.5 9.88914 2.59243 10.9816 3.94 10.9816Z" fill="currentColor"/></svg>`,
      "Share a pet team",
      () => {
        closeMenu();
        if (onShowTeamSelection) {
          onShowTeamSelection();
        }
      }
    );
    const itemImport = createMenuItem(
      "Item",
      `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/><polyline points="3.27 6.96 12 12.01 20.73 6.96"/><line x1="12" y1="22.08" x2="12" y2="12"/></svg>`,
      "Import from inventory",
      () => {
        closeMenu();
        void openItemImportModal(onAttach);
      }
    );
    menu.append(roomItem, teamImport, itemImport);
    function closeMenu() {
      style2(menu, { display: "none" });
      delete btn.dataset.active;
      style2(btn, {
        opacity: "0.6",
        background: "rgba(255,255,255,0.04)",
        borderColor: "rgba(255,255,255,0.1)"
      });
      document.removeEventListener("click", onClickOutside);
    }
    function onClickOutside(e) {
      if (!wrap.contains(e.target)) {
        closeMenu();
      }
    }
    btn.onclick = (e) => {
      e.stopPropagation();
      const isVisible3 = menu.style.display !== "none";
      if (isVisible3) {
        closeMenu();
      } else {
        style2(menu, { display: "block" });
        btn.dataset.active = "1";
        style2(btn, {
          opacity: "1",
          background: "rgba(94,234,212,0.1)",
          borderColor: "rgba(94,234,212,0.25)"
        });
        setTimeout(() => document.addEventListener("click", onClickOutside), 0);
      }
    };
    wrap.append(btn, menu);
    return {
      element: wrap,
      cleanup: () => {
        document.removeEventListener("click", onClickOutside);
      }
    };
  }
  function createMenuItem(label2, iconSvg, description, onClick) {
    const item = document.createElement("div");
    style2(item, {
      display: "flex",
      alignItems: "center",
      gap: "10px",
      padding: "8px 10px",
      borderRadius: "8px",
      cursor: "pointer",
      transition: "background 100ms ease"
    });
    item.onmouseenter = () => style2(item, { background: "rgba(94,234,212,0.1)" });
    item.onmouseleave = () => style2(item, { background: "transparent" });
    const iconEl = document.createElement("div");
    style2(iconEl, {
      width: "28px",
      height: "28px",
      borderRadius: "8px",
      background: "rgba(94,234,212,0.12)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: "0",
      color: "#5eead4"
    });
    iconEl.innerHTML = iconSvg;
    const textWrap = document.createElement("div");
    style2(textWrap, {
      display: "flex",
      flexDirection: "column",
      gap: "1px",
      minWidth: "0"
    });
    const nameEl = document.createElement("div");
    style2(nameEl, {
      fontSize: "13px",
      fontWeight: "500",
      color: "#e7eef7"
    });
    nameEl.textContent = label2;
    const descEl = document.createElement("div");
    style2(descEl, {
      fontSize: "10px",
      color: "rgba(226,232,240,0.45)",
      whiteSpace: "nowrap"
    });
    descEl.textContent = description;
    textWrap.append(nameEl, descEl);
    item.append(iconEl, textWrap);
    item.onclick = onClick;
    return item;
  }

  // src/ui/menus/communityHub/tabs/messagesTab.ts
  function createMessagesTab() {
    ensureSharedStyles();
    const root = document.createElement("div");
    style2(root, {
      display: "flex",
      flexDirection: "column",
      height: "100%",
      overflow: "hidden"
    });
    let activeSubTab = "friends";
    let selectedId = null;
    let currentDetailView = null;
    const tabsHeader = document.createElement("div");
    style2(tabsHeader, {
      display: "flex",
      gap: "8px",
      padding: "0 0 12px 0",
      borderBottom: "1px solid rgba(255,255,255,0.08)",
      marginBottom: "0",
      flexShrink: "0"
    });
    const friendsBtn = createSubTabButton("Friends", true);
    const groupsBtn = createSubTabButton("Groups", false);
    tabsHeader.append(friendsBtn, groupsBtn);
    const chatArea = document.createElement("div");
    style2(chatArea, {
      display: "grid",
      gridTemplateColumns: "220px 1fr",
      flex: "1",
      minHeight: "0",
      overflow: "hidden"
    });
    const listPanel = document.createElement("div");
    style2(listPanel, {
      display: "flex",
      flexDirection: "column",
      borderRight: "1px solid rgba(255,255,255,0.08)",
      overflow: "hidden"
    });
    const searchWrap = document.createElement("div");
    style2(searchWrap, {
      padding: "12px 10px 8px",
      flexShrink: "0"
    });
    const searchInput = document.createElement("input");
    searchInput.type = "text";
    searchInput.placeholder = "Search...";
    style2(searchInput, {
      width: "100%",
      padding: "8px 10px",
      border: "1px solid rgba(255,255,255,0.1)",
      borderRadius: "8px",
      background: "rgba(255,255,255,0.04)",
      color: "#e7eef7",
      fontSize: "12px",
      outline: "none",
      transition: "border-color 150ms ease"
    });
    searchInput.onfocus = () => style2(searchInput, { borderColor: "rgba(94,234,212,0.35)" });
    searchInput.onblur = () => style2(searchInput, { borderColor: "rgba(255,255,255,0.1)" });
    searchWrap.appendChild(searchInput);
    const convList = document.createElement("div");
    convList.className = "qws-ch-scrollable-narrow";
    style2(convList, {
      flex: "1",
      overflow: "auto",
      padding: "4px 6px",
      display: "flex",
      flexDirection: "column",
      gap: "2px"
    });
    listPanel.append(searchWrap, convList);
    const threadPanel = document.createElement("div");
    style2(threadPanel, {
      display: "flex",
      flexDirection: "column",
      overflow: "hidden",
      minHeight: "0"
    });
    const threadHeader = document.createElement("div");
    style2(threadHeader, {
      display: "flex",
      alignItems: "center",
      gap: "10px",
      padding: "12px 14px",
      borderBottom: "1px solid rgba(255,255,255,0.08)",
      flexShrink: "0",
      minHeight: "48px"
    });
    const threadAvatar = document.createElement("div");
    style2(threadAvatar, {
      width: "32px",
      height: "32px",
      borderRadius: "50%",
      background: "linear-gradient(135deg, rgba(94,234,212,0.25), rgba(59,130,246,0.25))",
      flexShrink: "0",
      display: "none",
      alignItems: "center",
      justifyContent: "center",
      fontSize: "13px",
      fontWeight: "700",
      color: "#dbe7f5"
    });
    const threadInfo = document.createElement("div");
    style2(threadInfo, {
      display: "flex",
      flexDirection: "column",
      gap: "1px",
      minWidth: "0"
    });
    const threadNameRow = document.createElement("div");
    style2(threadNameRow, { display: "flex", alignItems: "center", gap: "6px", minWidth: "0" });
    const threadName = document.createElement("div");
    style2(threadName, {
      fontSize: "13px",
      fontWeight: "600",
      color: "#e7eef7",
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    });
    threadName.textContent = "Select a conversation";
    const threadBadgesContainer = document.createElement("div");
    style2(threadBadgesContainer, { flexShrink: "0", display: "none" });
    threadNameRow.append(threadName, threadBadgesContainer);
    const threadStatus = document.createElement("div");
    style2(threadStatus, {
      fontSize: "11px",
      color: "rgba(226,232,240,0.5)"
    });
    threadInfo.append(threadNameRow, threadStatus);
    threadHeader.append(threadAvatar, threadInfo);
    const threadBody = document.createElement("div");
    threadBody.className = "qws-ch-scrollable-narrow";
    style2(threadBody, {
      flex: "1",
      overflow: "auto",
      padding: "14px",
      display: "flex",
      flexDirection: "column",
      gap: "6px",
      minHeight: "0"
    });
    const emptyState = document.createElement("div");
    style2(emptyState, {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center",
      flex: "1",
      gap: "12px",
      color: "rgba(226,232,240,0.4)"
    });
    const emptyIcon = document.createElement("div");
    style2(emptyIcon, { fontSize: "32px", opacity: "0.5" });
    emptyIcon.innerHTML = `<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>`;
    const emptyText = document.createElement("div");
    style2(emptyText, { fontSize: "13px" });
    emptyText.textContent = "Select a conversation to start chatting";
    emptyState.append(emptyIcon, emptyText);
    threadBody.appendChild(emptyState);
    const inputBar = document.createElement("div");
    style2(inputBar, {
      display: "flex",
      alignItems: "center",
      gap: "8px",
      padding: "10px 12px",
      borderTop: "1px solid rgba(255,255,255,0.08)",
      flexShrink: "0"
    });
    const inputWrapper = document.createElement("div");
    style2(inputWrapper, {
      flex: "1",
      position: "relative",
      display: "flex",
      alignItems: "center"
    });
    const msgInput = document.createElement("input");
    msgInput.type = "text";
    msgInput.placeholder = "Select a conversation...";
    msgInput.disabled = true;
    msgInput.maxLength = 1e3;
    style2(msgInput, {
      flex: "1",
      padding: "10px 40px 10px 12px",
      border: "1px solid rgba(255,255,255,0.1)",
      borderRadius: "10px",
      background: "rgba(255,255,255,0.04)",
      color: "#e7eef7",
      fontSize: "13px",
      outline: "none",
      opacity: "0.4",
      cursor: "not-allowed",
      transition: "border-color 150ms ease, opacity 150ms ease"
    });
    msgInput.onfocus = () => {
      if (!msgInput.disabled) style2(msgInput, { borderColor: "rgba(94,234,212,0.35)" });
    };
    msgInput.onblur = () => style2(msgInput, { borderColor: "rgba(255,255,255,0.1)" });
    const emojiWrap = document.createElement("div");
    style2(emojiWrap, {
      position: "absolute",
      right: "6px",
      top: "50%",
      transform: "translateY(-50%)",
      zIndex: "1"
    });
    const emojiBtn = document.createElement("button");
    emojiBtn.type = "button";
    emojiBtn.textContent = "\u{1F60A}";
    style2(emojiBtn, {
      width: "30px",
      height: "30px",
      borderRadius: "6px",
      border: "none",
      background: "transparent",
      color: "#e7eef7",
      cursor: "pointer",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      fontSize: "16px",
      opacity: "0.5",
      transition: "opacity 150ms ease, background 150ms ease",
      padding: "0"
    });
    emojiBtn.onmouseenter = () => {
      if (!msgInput.disabled) style2(emojiBtn, { opacity: "1" });
    };
    emojiBtn.onmouseleave = () => {
      if (!emojiBtn.dataset.active) style2(emojiBtn, { opacity: "0.5" });
    };
    const emojiPickerWrap = document.createElement("div");
    style2(emojiPickerWrap, {
      position: "absolute",
      right: "0",
      bottom: "38px",
      zIndex: "10",
      display: "none"
    });
    let emojiPickerInstance = null;
    async function loadEmojiPicker() {
      if (emojiPickerInstance) return;
      try {
        const { Picker } = await Promise.resolve().then(() => (init_emoji_picker_element(), emoji_picker_element_exports));
        const picker = new Picker({
          locale: "en",
          dataSource: "https://cdn.jsdelivr.net/npm/emoji-picker-element-data@^1/en/emojibase/data.json"
        });
        picker.style.cssText = `
        --background: #0f141e;
        --border-color: rgba(255,255,255,0.1);
        --indicator-color: #5eead4;
        --input-border-color: rgba(255,255,255,0.12);
        --input-font-color: #e7eef7;
        --input-placeholder-color: rgba(226,232,240,0.4);
        --outline-color: #5eead4;
        --category-emoji-size: 1.125rem;
        --emoji-size: 1.25rem;
        --num-columns: 8;
        --category-font-color: rgba(226,232,240,0.5);
        --button-active-background: rgba(94,234,212,0.15);
        --button-hover-background: rgba(94,234,212,0.1);
        --input-border-radius: 8px;
        --input-padding: 0.4rem 0.6rem;
        --category-font-size: 0.9rem;
        width: 320px;
        height: 350px;
        border-radius: 12px;
        border: 1px solid rgba(94,234,212,0.2);
        box-shadow: 0 8px 32px rgba(0,0,0,0.5);
      `;
        picker.addEventListener("emoji-click", (event) => {
          const detail = event.detail;
          const emoji = detail.unicode || detail.emoji?.unicode || "";
          if (!emoji) return;
          insertEmojiIntoInput(emoji);
          closeEmojiPicker();
        });
        emojiPickerInstance = picker;
        emojiPickerWrap.appendChild(picker);
      } catch (err) {
        console.error("[messagesTab] Failed to load emoji picker:", err);
      }
    }
    function insertEmojiIntoInput(emoji) {
      const start2 = msgInput.selectionStart || 0;
      const end = msgInput.selectionEnd || 0;
      const text = msgInput.value;
      msgInput.value = text.substring(0, start2) + emoji + text.substring(end);
      msgInput.selectionStart = msgInput.selectionEnd = start2 + emoji.length;
      msgInput.focus();
    }
    function closeEmojiPicker() {
      style2(emojiPickerWrap, { display: "none" });
      delete emojiBtn.dataset.active;
      style2(emojiBtn, { opacity: "0.5", background: "transparent" });
      document.removeEventListener("click", onClickOutsideEmoji);
    }
    function onClickOutsideEmoji(e) {
      if (!emojiWrap.contains(e.target)) {
        closeEmojiPicker();
      }
    }
    emojiBtn.onclick = (e) => {
      e.stopPropagation();
      if (msgInput.disabled) return;
      const isVisible3 = emojiPickerWrap.style.display !== "none";
      if (isVisible3) {
        closeEmojiPicker();
      } else {
        void loadEmojiPicker();
        style2(emojiPickerWrap, { display: "block" });
        emojiBtn.dataset.active = "1";
        style2(emojiBtn, { opacity: "1", background: "rgba(94,234,212,0.15)" });
        setTimeout(() => document.addEventListener("click", onClickOutsideEmoji), 0);
      }
    };
    emojiWrap.append(emojiBtn, emojiPickerWrap);
    inputWrapper.append(msgInput, emojiWrap);
    const attachments = createAttachmentState();
    const importBtn = createImportButton({
      onAttach: (token) => {
        if (msgInput.disabled) return;
        attachments.add(token);
        msgInput.focus();
      },
      onShowTeamSelection: async () => {
        style2(tabsHeader, { display: "none" });
        style2(chatArea, { display: "none" });
        const teamView = await createTeamSelectionView({
          onTeamSelected: (team, pets) => {
            const token = buildTeamToken(team, pets);
            if (token && !msgInput.disabled) {
              attachments.add(token);
              msgInput.focus();
            }
            if (currentDetailView) {
              currentDetailView.remove();
              currentDetailView = null;
            }
            style2(tabsHeader, { display: "flex" });
            style2(chatArea, { display: "grid" });
          },
          onBack: () => {
            if (currentDetailView) {
              currentDetailView.remove();
              currentDetailView = null;
            }
            style2(tabsHeader, { display: "flex" });
            style2(chatArea, { display: "grid" });
          }
        });
        currentDetailView = teamView;
        root.appendChild(teamView);
      }
    });
    const sendBtn = document.createElement("button");
    style2(sendBtn, {
      padding: "9px 16px",
      border: "1px solid rgba(94,234,212,0.35)",
      borderRadius: "10px",
      background: "rgba(94,234,212,0.15)",
      color: "#5eead4",
      fontSize: "12px",
      fontWeight: "600",
      cursor: "not-allowed",
      opacity: "0.4",
      flexShrink: "0",
      transition: "all 120ms ease"
    });
    sendBtn.textContent = "Send";
    let isSending = false;
    function setInputEnabled(enabled) {
      msgInput.disabled = !enabled;
      msgInput.placeholder = enabled ? "Type a message..." : "Select a conversation...";
      style2(msgInput, {
        opacity: enabled ? "1" : "0.4",
        cursor: enabled ? "text" : "not-allowed"
      });
      style2(sendBtn, {
        opacity: enabled ? "1" : "0.4",
        cursor: enabled ? "pointer" : "not-allowed",
        pointerEvents: enabled ? "auto" : "none"
      });
    }
    async function handleSend() {
      const rawText = msgInput.value.trim();
      const tokensSuffix = attachments.buildTokensString();
      const text = tokensSuffix ? rawText ? rawText + " " + tokensSuffix : tokensSuffix : rawText;
      if (!text || !selectedId || isSending) return;
      isSending = true;
      style2(sendBtn, { opacity: "0.5", pointerEvents: "none" });
      msgInput.value = "";
      attachments.clear();
      const currentPlayerId = getCurrentPlayerId();
      const tempId = -Date.now();
      try {
        if (activeSubTab === "friends") {
          const conv = getCachedFriendConversations().find((c) => c.conversationId === selectedId);
          if (!conv) return;
          const pendingMsg = {
            id: tempId,
            conversationId: selectedId,
            senderId: currentPlayerId || "",
            recipientId: conv.otherPlayerId,
            body: text,
            createdAt: (/* @__PURE__ */ new Date()).toISOString(),
            deliveredAt: (/* @__PURE__ */ new Date()).toISOString(),
            readAt: null
          };
          addMessageToFriendConversationCache(selectedId, pendingMsg, "pending");
          renderConversationList(searchInput.value);
          renderThread();
          const result = await sendMessage({ toPlayerId: conv.otherPlayerId, text });
          if (result) {
            updatePendingFriendMessage(selectedId, tempId, result);
          }
        } else {
          const groupId = Number(selectedId);
          const pendingMsg = {
            id: tempId,
            groupId: selectedId,
            senderId: currentPlayerId || "",
            body: text,
            createdAt: (/* @__PURE__ */ new Date()).toISOString()
          };
          addMessageToGroupConversationCache(groupId, pendingMsg, "pending");
          renderConversationList(searchInput.value);
          renderThread();
          const result = await sendGroupMessage({ groupId: selectedId, text });
          if (result) {
            const msg = result.message;
            const groupMsg = {
              id: msg?.id ?? (result.id || 0),
              groupId: selectedId,
              senderId: msg?.senderId ?? (result.senderId || ""),
              body: msg?.body ?? (result.body || result.text || ""),
              createdAt: msg?.createdAt ?? (result.createdAt || (/* @__PURE__ */ new Date()).toISOString())
            };
            updatePendingGroupMessage(groupId, tempId, groupMsg);
          }
        }
      } catch (err) {
        console.error("[messages] send failed:", err);
      } finally {
        isSending = false;
        if (selectedId) {
          style2(sendBtn, { opacity: "1", pointerEvents: "auto" });
        }
      }
    }
    sendBtn.onclick = () => void handleSend();
    inputBar.append(importBtn.element, inputWrapper, sendBtn);
    threadPanel.append(threadHeader, threadBody, attachments.barElement, inputBar);
    chatArea.append(listPanel, threadPanel);
    root.append(tabsHeader, chatArea);
    window.addEventListener("keydown", (e) => {
      if (document.activeElement === msgInput && e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        e.stopPropagation();
        void handleSend();
      }
    }, true);
    const keyBlocker = createKeyBlocker(
      () => document.activeElement === searchInput || document.activeElement === msgInput || emojiPickerInstance !== null && document.activeElement === emojiPickerInstance
    );
    keyBlocker.attach();
    function renderFriendConversationList(filter = "") {
      convList.innerHTML = "";
      const conversations = getCachedFriendConversations();
      const query = filter.toLowerCase();
      const filtered = query ? conversations.filter((c) => (c.otherPlayerName || "").toLowerCase().includes(query)) : conversations;
      if (filtered.length === 0) {
        convList.appendChild(createEmptyListItem(query));
        return;
      }
      filtered.sort(conversationSortComparator);
      for (const conv of filtered) {
        convList.appendChild(createFriendConversationRow(conv));
      }
    }
    function createFriendConversationRow(conv) {
      const row = document.createElement("div");
      const isActive = conv.conversationId === selectedId;
      const hasUnread = (conv.unreadCount ?? 0) > 0;
      const newest = getNewestMessage(conv.messages);
      applyRowStyle(row, isActive);
      row.onmouseenter = () => {
        if (conv.conversationId !== selectedId) style2(row, { background: "rgba(255,255,255,0.04)" });
      };
      row.onmouseleave = () => {
        if (conv.conversationId !== selectedId) style2(row, { background: "transparent", border: "1px solid transparent" });
      };
      const avatarEl = createAvatarEl(conv.otherPlayerAvatarUrl, conv.otherPlayerName, false);
      const meta = createRowMeta(
        conv.otherPlayerName || "Unknown",
        parseGemTokens(newest?.body ?? "").text || "Shared an attachment",
        newest?.createdAt,
        hasUnread,
        conv.unreadCount
      );
      row.append(avatarEl, meta);
      row.onclick = () => selectConversation(conv.conversationId);
      return row;
    }
    function renderFriendThread() {
      threadBody.innerHTML = "";
      if (!selectedId) {
        showEmptyThread();
        return;
      }
      const conv = getCachedFriendConversations().find((c) => c.conversationId === selectedId);
      if (!conv) return;
      const friendData = getCachedFriendsWithViews().find((f) => f.playerId === conv.otherPlayerId);
      updateThreadHeader(conv.otherPlayerAvatarUrl, conv.otherPlayerName || "Unknown", null, false, friendData?.badges);
      const messages = sortChronological(getCachedFriendConversationMessages(selectedId));
      const currentPlayerId = getCurrentPlayerId();
      if (messages.length === 0) {
        showNoMessages();
        return;
      }
      let lastOutgoingId = 0;
      for (const msg of messages) {
        if (msg.senderId === currentPlayerId && msg.id > lastOutgoingId) {
          lastOutgoingId = msg.id;
        }
      }
      const lastMessage = messages[messages.length - 1];
      const lastMessageIsIncoming = lastMessage && lastMessage.senderId !== currentPlayerId;
      let lastDateLabel = "";
      for (let i = 0; i < messages.length; i++) {
        const msg = messages[i];
        const dateLabel = formatDateLabel(msg.createdAt);
        const hasDateSep = dateLabel !== "" && dateLabel !== lastDateLabel;
        if (hasDateSep) {
          threadBody.appendChild(createDateSeparator(dateLabel));
          lastDateLabel = dateLabel;
        }
        const prev = i > 0 ? messages[i - 1] : null;
        const next = i < messages.length - 1 ? messages[i + 1] : null;
        const nextDateLabel = next ? formatDateLabel(next.createdAt) : "";
        const isFirstInGroup = !prev || hasDateSep || !isSameMessageGroup(prev, msg);
        const isLastInGroup = !next || nextDateLabel !== "" && nextDateLabel !== lastDateLabel || !isSameMessageGroup(msg, next);
        const isOutgoing = msg.senderId === currentPlayerId;
        const isLastOutgoing = isOutgoing && msg.id === lastOutgoingId;
        threadBody.appendChild(createFriendMessageBubble(msg, isOutgoing, isLastOutgoing, lastMessageIsIncoming, conv, isFirstInGroup, isLastInGroup));
      }
      scrollToBottom();
    }
    function createFriendMessageBubble(msg, isOutgoing, isLastOutgoing, lastMessageIsIncoming, conv, isFirstInGroup, isLastInGroup) {
      const wrapper = document.createElement("div");
      style2(wrapper, {
        display: "flex",
        gap: "8px",
        alignItems: "center",
        justifyContent: isOutgoing ? "flex-end" : "flex-start"
      });
      if (!isOutgoing) {
        if (isLastInGroup) {
          wrapper.appendChild(createSmallAvatar(conv.otherPlayerAvatarUrl, conv.otherPlayerName));
        } else {
          const spacer = document.createElement("div");
          style2(spacer, { width: "28px", flexShrink: "0" });
          wrapper.appendChild(spacer);
        }
      }
      let status = void 0;
      if (isLastOutgoing && !lastMessageIsIncoming) {
        if (msg._status) {
          status = msg._status;
        } else {
          status = msg.readAt ? "read" : "sent";
        }
      }
      const bubble = createBubbleContent(msg.body, msg.createdAt, isOutgoing, status, isLastInGroup);
      wrapper.appendChild(bubble);
      if (!isFirstInGroup) style2(wrapper, { marginTop: "-4px" });
      return wrapper;
    }
    function renderGroupConversationList(filter = "") {
      convList.innerHTML = "";
      const groups2 = getCachedGroupConversations();
      const query = filter.toLowerCase();
      const filtered = query ? groups2.filter((g) => (g.groupName || "").toLowerCase().includes(query)) : groups2;
      if (filtered.length === 0) {
        convList.appendChild(createEmptyListItem(query));
        return;
      }
      filtered.sort(conversationSortComparator);
      for (const g of filtered) {
        convList.appendChild(createGroupConversationRow(g));
      }
    }
    function createGroupConversationRow(group) {
      const row = document.createElement("div");
      const groupKey = String(group.groupId);
      const isActive = groupKey === selectedId;
      const hasUnread = (group.unreadCount ?? 0) > 0;
      const newest = getNewestMessage(group.messages);
      applyRowStyle(row, isActive);
      row.onmouseenter = () => {
        if (groupKey !== selectedId) style2(row, { background: "rgba(255,255,255,0.04)" });
      };
      row.onmouseleave = () => {
        if (groupKey !== selectedId) style2(row, { background: "transparent", border: "1px solid transparent" });
      };
      const welcome = getWelcomeCache();
      const fullGroup = welcome?.groups?.find((g) => String(g.id) === groupKey);
      const previewMembers = fullGroup?.previewMembers || [];
      const memberCount = fullGroup?.memberCount || 0;
      const container = document.createElement("div");
      style2(container, { display: "flex", flexDirection: "column", gap: "6px", flex: "1", minWidth: "0" });
      const topRow = document.createElement("div");
      style2(topRow, { display: "flex", alignItems: "center", justifyContent: "space-between", gap: "6px" });
      const nameEl = document.createElement("div");
      style2(nameEl, {
        fontSize: "13px",
        fontWeight: hasUnread ? "700" : "500",
        color: hasUnread ? "#ecfdf5" : "#e7eef7",
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap",
        flex: "1",
        minWidth: "0"
      });
      nameEl.textContent = group.groupName || "Group";
      const rightSection = document.createElement("div");
      style2(rightSection, { display: "flex", alignItems: "center", gap: "6px", flexShrink: "0" });
      const time = document.createElement("div");
      style2(time, {
        fontSize: "10px",
        color: hasUnread ? "#5eead4" : "rgba(226,232,240,0.4)",
        fontWeight: hasUnread ? "600" : "400"
      });
      if (newest?.createdAt) time.textContent = formatRelativeTimeShort(newest.createdAt);
      if (hasUnread && group.unreadCount > 0) {
        const badge = document.createElement("div");
        style2(badge, {
          minWidth: "18px",
          height: "18px",
          padding: "0 5px",
          borderRadius: "999px",
          background: "#ef4444",
          color: "#fff",
          fontSize: "10px",
          fontWeight: "700",
          display: "inline-flex",
          alignItems: "center",
          justifyContent: "center"
        });
        badge.textContent = String(group.unreadCount);
        rightSection.append(time, badge);
      } else {
        rightSection.appendChild(time);
      }
      topRow.append(nameEl, rightSection);
      const bottomRow = document.createElement("div");
      style2(bottomRow, { display: "flex", alignItems: "center", gap: "6px" });
      const avatarsContainer = document.createElement("div");
      style2(avatarsContainer, { display: "flex", marginLeft: "-4px" });
      for (let i = 0; i < Math.min(3, previewMembers.length); i++) {
        const member = previewMembers[i];
        const avatar2 = document.createElement("div");
        style2(avatar2, {
          width: "20px",
          height: "20px",
          borderRadius: "50%",
          background: member.discordAvatarUrl ? `url(${member.discordAvatarUrl}) center/cover` : "linear-gradient(135deg, rgba(94,234,212,0.3), rgba(59,130,246,0.3))",
          border: "1.5px solid #0f141e",
          marginLeft: i > 0 ? "-6px" : "0",
          flexShrink: "0"
        });
        avatarsContainer.appendChild(avatar2);
      }
      const memberCountEl = document.createElement("div");
      style2(memberCountEl, {
        fontSize: "10px",
        color: "rgba(226,232,240,0.45)",
        marginLeft: "4px"
      });
      memberCountEl.textContent = `${memberCount} member${memberCount !== 1 ? "s" : ""}`;
      if (previewMembers.length === 0) {
        const preview = document.createElement("div");
        style2(preview, {
          fontSize: "11px",
          color: "rgba(226,232,240,0.45)",
          overflow: "hidden",
          textOverflow: "ellipsis",
          whiteSpace: "nowrap",
          flex: "1"
        });
        preview.textContent = parseGemTokens((newest?.body || newest?.text) ?? "").text || "Shared an attachment";
        bottomRow.appendChild(preview);
      } else {
        bottomRow.append(avatarsContainer, memberCountEl);
      }
      container.append(topRow, bottomRow);
      row.appendChild(container);
      row.onclick = () => selectConversation(groupKey);
      return row;
    }
    function renderGroupThread() {
      threadBody.innerHTML = "";
      if (!selectedId) {
        showEmptyThread();
        return;
      }
      const groupId = Number(selectedId);
      const group = getCachedGroupConversations().find((g) => g.groupId === groupId);
      if (!group) return;
      updateThreadHeader(null, group.groupName || "Group", null, true);
      const allMessages = sortChronological(getCachedGroupConversationMessages(groupId));
      const currentPlayerId = getCurrentPlayerId();
      const seen = /* @__PURE__ */ new Set();
      const messages = allMessages.filter((msg) => {
        if (msg.id < 0) return true;
        if (seen.has(msg.id)) return false;
        seen.add(msg.id);
        return true;
      });
      if (messages.length === 0) {
        showNoMessages();
        return;
      }
      let lastOutgoingId = 0;
      for (const msg of messages) {
        if (msg.senderId === currentPlayerId && msg.id > lastOutgoingId) {
          lastOutgoingId = msg.id;
        }
      }
      const lastMessage = messages[messages.length - 1];
      const lastMessageIsIncoming = lastMessage && lastMessage.senderId !== currentPlayerId;
      let lastDateLabel = "";
      for (let i = 0; i < messages.length; i++) {
        const msg = messages[i];
        const dateLabel = formatDateLabel(msg.createdAt);
        const hasDateSep = dateLabel !== "" && dateLabel !== lastDateLabel;
        if (hasDateSep) {
          threadBody.appendChild(createDateSeparator(dateLabel));
          lastDateLabel = dateLabel;
        }
        const prev = i > 0 ? messages[i - 1] : null;
        const next = i < messages.length - 1 ? messages[i + 1] : null;
        const nextDateLabel = next ? formatDateLabel(next.createdAt) : "";
        const isFirstInGroup = !prev || hasDateSep || !isSameMessageGroup(prev, msg);
        const isLastInGroup = !next || nextDateLabel !== "" && nextDateLabel !== lastDateLabel || !isSameMessageGroup(msg, next);
        const isOutgoing = msg.senderId === currentPlayerId;
        const isLastOutgoing = isOutgoing && msg.id === lastOutgoingId;
        threadBody.appendChild(createGroupMessageBubble(msg, isOutgoing, isLastOutgoing, lastMessageIsIncoming, isFirstInGroup, isLastInGroup));
      }
      scrollToBottom();
    }
    function createGroupMessageBubble(msg, isOutgoing, isLastOutgoing, lastMessageIsIncoming, isFirstInGroup, isLastInGroup) {
      const senderName = msg.senderName || msg.senderId;
      const senderAvatarUrl = msg.senderAvatarUrl;
      const wrapper = document.createElement("div");
      style2(wrapper, {
        display: "flex",
        gap: "8px",
        alignItems: "center",
        justifyContent: isOutgoing ? "flex-end" : "flex-start"
      });
      if (!isOutgoing) {
        if (isLastInGroup) {
          wrapper.appendChild(createSmallAvatar(senderAvatarUrl, senderName));
        } else {
          const spacer = document.createElement("div");
          style2(spacer, { width: "28px", flexShrink: "0" });
          wrapper.appendChild(spacer);
        }
      }
      let status = void 0;
      if (isLastOutgoing && !lastMessageIsIncoming) {
        if (msg._status) {
          status = msg._status;
        } else {
          status = msg.readAt ? "read" : "sent";
        }
      }
      const bubble = createBubbleContent(msg.body || msg.text || "", msg.createdAt, isOutgoing, status, isLastInGroup);
      wrapper.appendChild(bubble);
      if (!isOutgoing && isFirstInGroup && senderName) {
        const container = document.createElement("div");
        style2(container, {
          display: "flex",
          flexDirection: "column",
          gap: "2px",
          alignItems: "flex-start"
        });
        const senderLabel = document.createElement("div");
        style2(senderLabel, {
          fontSize: "10px",
          color: "rgba(226,232,240,0.5)",
          fontWeight: "600",
          marginLeft: "36px"
        });
        senderLabel.textContent = senderName;
        container.append(senderLabel, wrapper);
        return container;
      }
      if (!isFirstInGroup) style2(wrapper, { marginTop: "-4px" });
      return wrapper;
    }
    function renderConversationList(filter = "") {
      if (activeSubTab === "friends") {
        renderFriendConversationList(filter);
      } else {
        renderGroupConversationList(filter);
      }
    }
    function renderThread() {
      if (activeSubTab === "friends") {
        renderFriendThread();
      } else {
        renderGroupThread();
      }
    }
    function selectConversation(id) {
      selectedId = id;
      setInputEnabled(true);
      renderConversationList(searchInput.value);
      renderThread();
      markConversationAsRead(id);
    }
    function markConversationAsRead(id) {
      const currentPlayerId = getCurrentPlayerId();
      if (activeSubTab === "friends") {
        const conv = getCachedFriendConversations().find((c) => c.conversationId === id);
        if (!conv || conv.messages.length === 0) return;
        const hasUnreadIncoming = conv.messages.some((m) => m.senderId !== currentPlayerId && !m.readAt);
        if (!hasUnreadIncoming && conv.unreadCount <= 0) return;
        const maxId = conv.messages.reduce((max, m) => Math.max(max, m.id), 0);
        markFriendConversationAsRead(id, maxId, (/* @__PURE__ */ new Date()).toISOString(), currentPlayerId || "");
        renderConversationList(searchInput.value);
        markMessagesRead({ otherPlayerId: conv.otherPlayerId, upToId: maxId });
      } else {
        const groupId = Number(id);
        const group = getCachedGroupConversations().find((g) => g.groupId === groupId);
        if (!group || group.unreadCount <= 0 || group.messages.length === 0) return;
        const maxId = group.messages.reduce((max, m) => Math.max(max, m.id), 0);
        markGroupConversationAsRead(groupId);
        renderConversationList(searchInput.value);
        markGroupMessagesAsRead({ groupId: id, messageId: maxId });
      }
    }
    function showEmptyThread() {
      threadBody.innerHTML = "";
      threadBody.appendChild(emptyState);
      style2(threadAvatar, { display: "none" });
      threadName.textContent = "Select a conversation";
      threadStatus.textContent = "";
      setInputEnabled(false);
    }
    function showNoMessages() {
      const noMsg = document.createElement("div");
      style2(noMsg, { margin: "auto", color: "rgba(226,232,240,0.4)", fontSize: "12px" });
      noMsg.textContent = "No messages yet";
      threadBody.appendChild(noMsg);
    }
    function scrollToBottom() {
      requestAnimationFrame(() => {
        threadBody.scrollTop = threadBody.scrollHeight;
      });
    }
    function updateThreadHeader(avatarUrl, displayName, statusText, isGroup, badges) {
      if (isGroup) {
        style2(threadAvatar, { display: "none" });
      } else if (avatarUrl) {
        style2(threadAvatar, { display: "flex", background: `url(${avatarUrl}) center/cover` });
        threadAvatar.textContent = "";
      } else {
        style2(threadAvatar, {
          display: "flex",
          background: "linear-gradient(135deg, rgba(94,234,212,0.25), rgba(59,130,246,0.25))"
        });
        threadAvatar.textContent = displayName.charAt(0).toUpperCase();
      }
      threadName.textContent = displayName;
      threadStatus.textContent = statusText || "";
      threadBadgesContainer.innerHTML = "";
      const badgesEl = badges && !isGroup ? createPlayerBadges(badges) : null;
      if (badgesEl) {
        threadBadgesContainer.appendChild(badgesEl);
        style2(threadBadgesContainer, { display: "block" });
      } else {
        style2(threadBadgesContainer, { display: "none" });
      }
    }
    function createEmptyListItem(query) {
      const empty = document.createElement("div");
      style2(empty, { padding: "24px 8px", textAlign: "center", color: "rgba(226,232,240,0.4)", fontSize: "12px" });
      empty.textContent = query ? "No conversations found" : "No conversations yet";
      return empty;
    }
    function applyRowStyle(row, isActive) {
      style2(row, {
        display: "flex",
        alignItems: "center",
        gap: "10px",
        padding: "10px 10px",
        borderRadius: "10px",
        cursor: "pointer",
        transition: "all 100ms ease",
        background: isActive ? "rgba(94,234,212,0.12)" : "transparent",
        border: isActive ? "1px solid rgba(94,234,212,0.25)" : "1px solid transparent"
      });
    }
    function createAvatarEl(avatarUrl, displayName, isGroup) {
      const wrap = document.createElement("div");
      style2(wrap, { position: "relative", flexShrink: "0" });
      const avatar2 = document.createElement("div");
      const fallbackGradient = isGroup ? "linear-gradient(135deg, rgba(251,191,36,0.3), rgba(234,88,12,0.3))" : "linear-gradient(135deg, rgba(94,234,212,0.25), rgba(59,130,246,0.25))";
      style2(avatar2, {
        width: "36px",
        height: "36px",
        borderRadius: "50%",
        background: avatarUrl ? `url(${avatarUrl}) center/cover` : fallbackGradient,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        fontSize: "14px",
        fontWeight: "600",
        color: "#dbe7f5",
        border: "1.5px solid rgba(255,255,255,0.08)"
      });
      if (!avatarUrl) {
        avatar2.textContent = isGroup ? "#" : (displayName || "?").charAt(0).toUpperCase();
      }
      wrap.appendChild(avatar2);
      return wrap;
    }
    function createRowMeta(name, previewText, lastDate, hasUnread, unreadCount) {
      const meta = document.createElement("div");
      style2(meta, { display: "flex", flexDirection: "column", gap: "2px", flex: "1", minWidth: "0", overflow: "hidden" });
      const topRow = document.createElement("div");
      style2(topRow, { display: "flex", alignItems: "center", justifyContent: "space-between", gap: "6px" });
      const nameEl = document.createElement("div");
      style2(nameEl, {
        fontSize: "13px",
        fontWeight: hasUnread ? "700" : "500",
        color: hasUnread ? "#ecfdf5" : "#e7eef7",
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap",
        flex: "1",
        minWidth: "0"
      });
      nameEl.textContent = name;
      const time = document.createElement("div");
      style2(time, { fontSize: "10px", color: hasUnread ? "#5eead4" : "rgba(226,232,240,0.4)", flexShrink: "0", fontWeight: hasUnread ? "600" : "400" });
      if (lastDate) time.textContent = formatRelativeTimeShort(lastDate);
      topRow.append(nameEl, time);
      const bottomRow = document.createElement("div");
      style2(bottomRow, { display: "flex", alignItems: "center", gap: "6px" });
      const preview = document.createElement("div");
      style2(preview, { fontSize: "11px", color: "rgba(226,232,240,0.45)", overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap", flex: "1", minWidth: "0" });
      preview.textContent = previewText;
      bottomRow.appendChild(preview);
      if (hasUnread && unreadCount > 0) {
        const badge = document.createElement("div");
        style2(badge, {
          minWidth: "18px",
          height: "18px",
          padding: "0 5px",
          borderRadius: "999px",
          background: "#ef4444",
          color: "#fff",
          fontSize: "10px",
          fontWeight: "700",
          display: "inline-flex",
          alignItems: "center",
          justifyContent: "center",
          flexShrink: "0"
        });
        badge.textContent = String(unreadCount);
        bottomRow.appendChild(badge);
      }
      meta.append(topRow, bottomRow);
      return meta;
    }
    function createSmallAvatar(avatarUrl, fallbackName) {
      const avatar2 = document.createElement("div");
      if (avatarUrl) {
        style2(avatar2, {
          width: "28px",
          height: "28px",
          borderRadius: "50%",
          background: `url(${avatarUrl}) center/cover`,
          flexShrink: "0",
          border: "1px solid rgba(255,255,255,0.06)"
        });
      } else {
        style2(avatar2, {
          width: "28px",
          height: "28px",
          borderRadius: "50%",
          background: "linear-gradient(135deg, rgba(94,234,212,0.2), rgba(59,130,246,0.2))",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          fontSize: "11px",
          fontWeight: "600",
          color: "#dbe7f5",
          flexShrink: "0",
          border: "1px solid rgba(255,255,255,0.06)"
        });
        avatar2.textContent = (fallbackName || "?").charAt(0).toUpperCase();
      }
      return avatar2;
    }
    const URL_RE = /https?:\/\/[^\s<>)"'\]]+/gi;
    function shortenUrl(raw) {
      try {
        const u = new URL(raw);
        const host = u.hostname.replace(/^www\./, "");
        const path = u.pathname === "/" ? "" : u.pathname;
        const short = host + path;
        return short.length > 40 ? short.slice(0, 37) + "..." : short;
      } catch {
        return raw.length > 40 ? raw.slice(0, 37) + "..." : raw;
      }
    }
    function openLink2(url) {
      if (isDiscordSurface() && typeof GM_openInTab === "function") {
        try {
          GM_openInTab(url, { active: true, insert: true });
          return;
        } catch {
        }
      }
      window.open(url, "_blank", "noopener,noreferrer");
    }
    function linkifyInto(text, container) {
      URL_RE.lastIndex = 0;
      let lastIdx = 0;
      let match;
      while ((match = URL_RE.exec(text)) !== null) {
        if (match.index > lastIdx) {
          container.appendChild(document.createTextNode(text.slice(lastIdx, match.index)));
        }
        const href = match[0];
        const link = document.createElement("a");
        link.textContent = shortenUrl(href);
        link.title = href;
        link.href = href;
        link.rel = "noopener noreferrer";
        link.target = "_blank";
        Object.assign(link.style, {
          color: "#5eead4",
          textDecoration: "underline",
          textDecorationColor: "rgba(94,234,212,0.4)",
          cursor: "pointer",
          wordBreak: "break-all"
        });
        link.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          openLink2(href);
        });
        container.appendChild(link);
        lastIdx = URL_RE.lastIndex;
      }
      if (lastIdx < text.length) {
        container.appendChild(document.createTextNode(text.slice(lastIdx)));
      }
    }
    function createBubbleContent(body, createdAt, isOutgoing, status, showMeta = true) {
      const bubble = document.createElement("div");
      style2(bubble, { maxWidth: "70%", display: "flex", flexDirection: "column", gap: showMeta ? "4px" : "0" });
      const { text: cleanText, tokens } = parseGemTokens(body);
      const content = document.createElement("div");
      style2(content, {
        padding: "8px 12px",
        borderRadius: isOutgoing ? "12px 12px 4px 12px" : "12px 12px 12px 4px",
        fontSize: "14px",
        lineHeight: "1.5",
        wordBreak: "break-word",
        whiteSpace: "pre-wrap",
        background: isOutgoing ? "rgba(94,234,212,0.14)" : "rgba(255,255,255,0.06)",
        border: isOutgoing ? "1px solid rgba(94,234,212,0.22)" : "1px solid rgba(255,255,255,0.06)",
        color: isOutgoing ? "#d1fae5" : "#e7eef7"
      });
      if (cleanText) {
        linkifyInto(cleanText, content);
        bubble.appendChild(content);
      } else if (tokens.length === 0) {
        linkifyInto(body, content);
        bubble.appendChild(content);
      }
      if (tokens.length > 0) {
        bubble.appendChild(createTokenCardsContainer(tokens, isOutgoing));
      }
      if (showMeta) {
        const timestampRow = document.createElement("div");
        style2(timestampRow, {
          display: "flex",
          alignItems: "center",
          gap: "4px",
          justifyContent: isOutgoing ? "flex-end" : "flex-start"
        });
        if (isOutgoing && status) {
          const statusIcon = document.createElement("span");
          style2(statusIcon, {
            fontSize: "11px",
            color: status === "read" ? "#5eead4" : "rgba(226,232,240,0.4)",
            lineHeight: "1"
          });
          if (status === "pending") {
            statusIcon.textContent = "\u25CB";
          } else if (status === "sent") {
            statusIcon.textContent = "\u2713";
          } else if (status === "read") {
            statusIcon.textContent = "\u2713\u2713";
          }
          timestampRow.appendChild(statusIcon);
        }
        const timestamp = document.createElement("div");
        style2(timestamp, {
          fontSize: "10px",
          color: "rgba(226,232,240,0.35)"
        });
        timestamp.textContent = formatMessageTime(createdAt);
        timestampRow.appendChild(timestamp);
        bubble.appendChild(timestampRow);
      }
      return bubble;
    }
    function switchSubTab(tab) {
      if (activeSubTab === tab) return;
      activeSubTab = tab;
      selectedId = null;
      setSubTabActive(friendsBtn, tab === "friends");
      setSubTabActive(groupsBtn, tab === "groups");
      searchInput.value = "";
      renderConversationList();
      renderThread();
    }
    friendsBtn.onclick = () => switchSubTab("friends");
    groupsBtn.onclick = () => switchSubTab("groups");
    searchInput.oninput = () => renderConversationList(searchInput.value);
    const onConversationsRefresh = () => {
      if (selectedId) {
        const stillExists = activeSubTab === "friends" ? getCachedFriendConversations().some((c) => c.conversationId === selectedId) : getCachedGroupConversations().some((g) => g.groupId === Number(selectedId));
        if (!stillExists) {
          selectedId = null;
          setInputEnabled(false);
        }
      }
      renderConversationList(searchInput.value);
      if (selectedId) {
        renderThread();
        autoMarkAsReadIfActive();
      } else {
        showEmptyThread();
      }
    };
    function isTabVisible() {
      if (root.style.display === "none") return false;
      const panel = root.closest(".qws-ch-panel");
      return panel ? panel.classList.contains("open") : false;
    }
    function autoMarkAsReadIfActive() {
      if (!selectedId || !isTabVisible()) return;
      const currentPlayerId = getCurrentPlayerId();
      if (activeSubTab === "friends") {
        const conv = getCachedFriendConversations().find((c) => c.conversationId === selectedId);
        if (!conv || conv.messages.length === 0) return;
        const unreadIncoming = conv.messages.filter(
          (m) => m.senderId !== currentPlayerId && !m.readAt
        );
        if (unreadIncoming.length > 0) {
          const maxId = Math.max(...unreadIncoming.map((m) => m.id));
          markFriendConversationAsRead(selectedId, maxId, (/* @__PURE__ */ new Date()).toISOString(), currentPlayerId || "");
          renderConversationList(searchInput.value);
          markMessagesRead({ otherPlayerId: conv.otherPlayerId, upToId: maxId });
        }
      } else {
        const groupId = Number(selectedId);
        const group = getCachedGroupConversations().find((g) => g.groupId === groupId);
        if (!group || group.messages.length === 0) return;
        if (group.unreadCount > 0) {
          const maxId = Math.max(...group.messages.map((m) => m.id));
          markGroupConversationAsRead(groupId);
          renderConversationList(searchInput.value);
          markGroupMessagesAsRead({ groupId: selectedId, messageId: maxId });
        }
      }
    }
    window.addEventListener(CH_EVENTS.CONVERSATIONS_REFRESH, onConversationsRefresh);
    const onOverlayOpen = () => {
      setTimeout(() => autoMarkAsReadIfActive(), 60);
    };
    window.addEventListener(CH_EVENTS.OPEN, onOverlayOpen);
    const onOpenFriendChat = (e) => {
      const customEvent = e;
      const { playerId: playerId2 } = customEvent.detail;
      if (activeSubTab !== "friends") {
        switchSubTab("friends");
      }
      const conversations = getCachedFriendConversations();
      const conversation = conversations.find((c) => c.otherPlayerId === playerId2);
      if (conversation) {
        selectConversation(conversation.conversationId);
      } else {
        const friends = getCachedFriendsWithViews();
        const friend = friends.find((f) => f.playerId === playerId2);
        if (friend) {
          const newConversation = {
            conversationId: playerId2,
            otherPlayerId: playerId2,
            otherPlayerName: friend.playerName,
            otherPlayerAvatarUrl: friend.avatarUrl,
            messages: [],
            unreadCount: 0
          };
          const updatedConversations = [...conversations, newConversation];
          updateFriendConversationsCache(updatedConversations);
          renderConversationList(searchInput.value);
          selectConversation(playerId2);
        } else {
          selectedId = null;
          setInputEnabled(false);
          renderConversationList(searchInput.value);
          threadBody.innerHTML = "";
          const errorState = document.createElement("div");
          style2(errorState, {
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "center",
            height: "100%",
            gap: "12px",
            color: "rgba(226,232,240,0.6)",
            fontSize: "13px",
            textAlign: "center",
            padding: "20px"
          });
          errorState.innerHTML = `
          <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" opacity="0.4">
            <circle cx="12" cy="12" r="10"/>
            <line x1="12" y1="8" x2="12" y2="12"/>
            <line x1="12" y1="16" x2="12.01" y2="16"/>
          </svg>
          <div>Unable to start conversation<br/>Friend not found</div>
        `;
          threadBody.appendChild(errorState);
        }
      }
    };
    window.addEventListener(CH_EVENTS.OPEN_FRIEND_CHAT, onOpenFriendChat);
    const onOpenGroupChat = (e) => {
      const customEvent = e;
      const { groupId, groupName } = customEvent.detail;
      if (activeSubTab !== "groups") {
        switchSubTab("groups");
      }
      const numericId = Number(groupId);
      const resolvedName = groupName || getWelcomeCache()?.groups?.find((g) => g.id === numericId)?.name || "Group";
      ensureGroupConversationExists(numericId, resolvedName);
      selectConversation(groupId);
    };
    window.addEventListener(CH_EVENTS.OPEN_GROUP_CHAT, onOpenGroupChat);
    const cacheExistedBeforeSubscribe = getCachedFriendConversations().length > 0 || getCachedGroupConversations().length > 0;
    let isFirstWelcomeCall = true;
    const unsubscribeWelcome = onWelcome(() => {
      if (isFirstWelcomeCall && cacheExistedBeforeSubscribe) {
        isFirstWelcomeCall = false;
        return;
      }
      isFirstWelcomeCall = false;
      onConversationsRefresh();
    });
    renderConversationList();
    return {
      id: "messages",
      root,
      show: () => {
        style2(root, { display: "flex" });
        setTimeout(() => autoMarkAsReadIfActive(), 0);
      },
      hide: () => style2(root, { display: "none" }),
      destroy: () => {
        window.removeEventListener(CH_EVENTS.CONVERSATIONS_REFRESH, onConversationsRefresh);
        window.removeEventListener(CH_EVENTS.OPEN, onOverlayOpen);
        window.removeEventListener(CH_EVENTS.OPEN_FRIEND_CHAT, onOpenFriendChat);
        window.removeEventListener(CH_EVENTS.OPEN_GROUP_CHAT, onOpenGroupChat);
        document.removeEventListener("click", onClickOutsideEmoji);
        importBtn.cleanup();
        unsubscribeWelcome();
        keyBlocker.detach();
        root.remove();
      },
      getTotalUnread: () => getTotalFriendUnreadCount() + getTotalGroupUnreadCount()
    };
  }
  function getNewestMessage(messages) {
    if (messages.length === 0) return void 0;
    return messages.reduce((best, m) => m.createdAt > best.createdAt ? m : best, messages[0]);
  }
  function sortChronological(messages) {
    return [...messages].sort((a, b) => a.createdAt.localeCompare(b.createdAt));
  }
  function conversationSortComparator(a, b) {
    const aUnread = (a.unreadCount ?? 0) > 0 ? 1 : 0;
    const bUnread = (b.unreadCount ?? 0) > 0 ? 1 : 0;
    if (aUnread !== bUnread) return bUnread - aUnread;
    const aNewest = getNewestMessage(a.messages)?.createdAt || "";
    const bNewest = getNewestMessage(b.messages)?.createdAt || "";
    return bNewest.localeCompare(aNewest);
  }
  function formatDateLabel(iso) {
    try {
      const date = new Date(iso);
      const today = /* @__PURE__ */ new Date();
      if (date.toDateString() === today.toDateString()) return "Today";
      const yesterday = new Date(today);
      yesterday.setDate(today.getDate() - 1);
      if (date.toDateString() === yesterday.toDateString()) return "Yesterday";
      return date.toLocaleDateString(void 0, { month: "short", day: "numeric" });
    } catch {
      return "";
    }
  }
  function createDateSeparator(label2) {
    const wrap = document.createElement("div");
    style2(wrap, {
      display: "flex",
      alignItems: "center",
      gap: "10px",
      margin: "10px 0 6px"
    });
    const line = () => {
      const el2 = document.createElement("div");
      style2(el2, { flex: "1", height: "1px", background: "rgba(255,255,255,0.08)" });
      return el2;
    };
    const text = document.createElement("div");
    style2(text, {
      fontSize: "10px",
      fontWeight: "600",
      color: "rgba(226,232,240,0.4)",
      whiteSpace: "nowrap",
      textTransform: "uppercase",
      letterSpacing: "0.5px"
    });
    text.textContent = label2;
    wrap.append(line(), text, line());
    return wrap;
  }
  var MSG_GROUP_THRESHOLD_MS = 2 * 60 * 1e3;
  function isSameMessageGroup(a, b) {
    if (a.senderId !== b.senderId) return false;
    try {
      return Math.abs(new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()) < MSG_GROUP_THRESHOLD_MS;
    } catch {
      return false;
    }
  }
  function createSubTabButton(label2, active) {
    const btn = document.createElement("button");
    btn.textContent = label2;
    style2(btn, {
      flex: "1",
      padding: "8px 16px",
      border: active ? "1px solid rgba(94,234,212,0.35)" : "1px solid rgba(255,255,255,0.08)",
      borderRadius: "8px",
      background: active ? "rgba(94,234,212,0.18)" : "transparent",
      color: active ? "#ecfdf5" : "#c9d4e6",
      fontSize: "12px",
      fontWeight: "600",
      cursor: "pointer",
      transition: "all 120ms ease"
    });
    btn.onmouseenter = () => {
      if (!btn.dataset.active) {
        style2(btn, { background: "rgba(94,234,212,0.08)", color: "#e7eef7" });
      }
    };
    btn.onmouseleave = () => {
      if (!btn.dataset.active) {
        style2(btn, { background: "transparent", color: "#c9d4e6" });
      }
    };
    if (active) btn.dataset.active = "1";
    return btn;
  }
  function setSubTabActive(btn, active) {
    if (active) {
      btn.dataset.active = "1";
      style2(btn, {
        background: "rgba(94,234,212,0.18)",
        borderColor: "rgba(94,234,212,0.35)",
        color: "#ecfdf5"
      });
    } else {
      delete btn.dataset.active;
      style2(btn, {
        background: "transparent",
        borderColor: "rgba(255,255,255,0.08)",
        color: "#c9d4e6"
      });
    }
  }

  // src/ui/menus/communityHub/tabs/playerViewActions.ts
  var currentPreviewModal = null;
  var currentPreviewType = null;
  function createPreviewModal(type, playerName, onStop) {
    ensureSharedStyles();
    const modal = document.createElement("div");
    modal.className = "qws-preview-modal";
    style2(modal, {
      position: "fixed",
      top: "80px",
      left: "50%",
      transform: "translateX(-50%)",
      zIndex: "10000",
      padding: "12px 20px",
      background: "rgba(15,17,21,0.95)",
      border: "1px solid rgba(94,234,212,0.3)",
      borderRadius: "12px",
      boxShadow: "0 4px 20px rgba(0,0,0,0.4), 0 0 0 1px rgba(94,234,212,0.1) inset",
      backdropFilter: "blur(10px)",
      display: "flex",
      alignItems: "center",
      gap: "16px",
      minWidth: "300px",
      animation: "qws-preview-slide-in 0.3s ease-out"
    });
    const iconLabel = document.createElement("div");
    style2(iconLabel, {
      display: "flex",
      alignItems: "center",
      gap: "10px",
      flex: "1"
    });
    const icon = document.createElement("div");
    style2(icon, {
      width: "8px",
      height: "8px",
      borderRadius: "50%",
      background: "#5eead4",
      boxShadow: "0 0 8px rgba(94,234,212,0.6)",
      animation: "qws-preview-pulse 2s ease-in-out infinite"
    });
    const label2 = document.createElement("div");
    style2(label2, {
      fontSize: "13px",
      fontWeight: "600",
      color: "#e7eef7"
    });
    const typeLabels = {
      garden: "Garden",
      inventory: "Inventory",
      stats: "Stats",
      activityLog: "Activity Log",
      journal: "Journal"
    };
    label2.textContent = `Previewing ${typeLabels[type]} \u2014 ${playerName}`;
    iconLabel.append(icon, label2);
    const stopButton = document.createElement("button");
    stopButton.textContent = "Stop";
    style2(stopButton, {
      padding: "6px 16px",
      border: "1px solid rgba(239,68,68,0.3)",
      borderRadius: "8px",
      background: "rgba(239,68,68,0.1)",
      color: "#ef4444",
      fontSize: "12px",
      fontWeight: "600",
      cursor: "pointer",
      transition: "all 120ms ease"
    });
    stopButton.onmouseenter = () => {
      style2(stopButton, {
        background: "rgba(239,68,68,0.2)",
        borderColor: "rgba(239,68,68,0.5)"
      });
    };
    stopButton.onmouseleave = () => {
      style2(stopButton, {
        background: "rgba(239,68,68,0.1)",
        borderColor: "rgba(239,68,68,0.3)"
      });
    };
    stopButton.onclick = onStop;
    modal.append(iconLabel, stopButton);
    return modal;
  }
  function showPreviewModal(type, playerName, onStop) {
    if (currentPreviewModal) {
      currentPreviewModal.remove();
      currentPreviewModal = null;
    }
    window.dispatchEvent(new CustomEvent(CH_EVENTS.CLOSE));
    currentPreviewType = type;
    currentPreviewModal = createPreviewModal(type, playerName, onStop);
    document.body.appendChild(currentPreviewModal);
  }
  function hidePreviewModal() {
    if (currentPreviewModal) {
      currentPreviewModal.remove();
      currentPreviewModal = null;
    }
    currentPreviewType = null;
    window.dispatchEvent(new CustomEvent(CH_EVENTS.OPEN));
  }
  async function viewGarden(player2) {
    const state3 = player2.state;
    if (!state3?.garden) {
      console.warn("[PlayerViewActions] No garden data available for player", player2.playerId);
      return;
    }
    const garden2 = state3.garden;
    const previewFn = window.qwsEditorPreviewFriendGarden;
    if (typeof previewFn !== "function") {
      console.error("[PlayerViewActions] qwsEditorPreviewFriendGarden not available");
      return;
    }
    try {
      const success = await previewFn(garden2);
      if (!success) {
        console.error("[PlayerViewActions] Failed to preview garden");
        return;
      }
      showPreviewModal("garden", player2.playerName || "Unknown", async () => {
        await stopViewGarden();
      });
    } catch (error) {
      console.error("[PlayerViewActions] Error previewing garden:", error);
    }
  }
  async function stopViewGarden() {
    const clearFn = window.qwsEditorClearFriendGardenPreview;
    if (typeof clearFn !== "function") {
      console.error("[PlayerViewActions] qwsEditorClearFriendGardenPreview not available");
      return;
    }
    try {
      await clearFn();
      hidePreviewModal();
    } catch (error) {
      console.error("[PlayerViewActions] Error stopping garden preview:", error);
    }
  }
  async function viewInventory(player2) {
    const state3 = player2.state;
    if (!state3?.inventory) {
      console.warn("[PlayerViewActions] No inventory data available for player", player2.playerId);
      return;
    }
    const {
      fakeInventoryShow: fakeInventoryShow2,
      waitInventoryPanelClosed: waitInventoryPanelClosed2,
      fakeInventoryHide: fakeInventoryHide2
    } = await Promise.resolve().then(() => (init_fakeModal(), fakeModal_exports));
    try {
      window.dispatchEvent(new CustomEvent(CH_EVENTS.CLOSE));
      await fakeInventoryShow2(state3.inventory, { open: true });
      await waitInventoryPanelClosed2();
      await fakeInventoryHide2();
      window.dispatchEvent(new CustomEvent(CH_EVENTS.OPEN));
    } catch (error) {
      console.error("[PlayerViewActions] Error viewing inventory:", error);
      window.dispatchEvent(new CustomEvent(CH_EVENTS.OPEN));
    }
  }
  async function viewStats(player2) {
    const state3 = player2.state;
    if (!state3?.stats) {
      console.warn("[PlayerViewActions] No stats data available for player", player2.playerId);
      return;
    }
    const {
      fakeStatsShow: fakeStatsShow2,
      waitStatsModalClosed: waitStatsModalClosed2,
      fakeStatsHide: fakeStatsHide2
    } = await Promise.resolve().then(() => (init_fakeModal(), fakeModal_exports));
    try {
      window.dispatchEvent(new CustomEvent(CH_EVENTS.CLOSE));
      await fakeStatsShow2(state3.stats, { open: true });
      await waitStatsModalClosed2();
      await fakeStatsHide2();
      window.dispatchEvent(new CustomEvent(CH_EVENTS.OPEN));
    } catch (error) {
      console.error("[PlayerViewActions] Error viewing stats:", error);
      window.dispatchEvent(new CustomEvent(CH_EVENTS.OPEN));
    }
  }
  async function viewActivityLog(player2) {
    const state3 = player2.state;
    if (!state3?.activityLog) {
      console.warn("[PlayerViewActions] No activity log data available for player", player2.playerId);
      return;
    }
    const {
      fakeActivityLogShow: fakeActivityLogShow2,
      waitActivityLogModalClosed: waitActivityLogModalClosed2,
      fakeActivityLogHide: fakeActivityLogHide2
    } = await Promise.resolve().then(() => (init_fakeModal(), fakeModal_exports));
    try {
      window.dispatchEvent(new CustomEvent(CH_EVENTS.CLOSE));
      await fakeActivityLogShow2(state3.activityLog, { open: true });
      await waitActivityLogModalClosed2();
      await fakeActivityLogHide2();
      window.dispatchEvent(new CustomEvent(CH_EVENTS.OPEN));
    } catch (error) {
      console.error("[PlayerViewActions] Error viewing activity log:", error);
      window.dispatchEvent(new CustomEvent(CH_EVENTS.OPEN));
    }
  }
  async function viewJournal(player2) {
    const state3 = player2.state;
    if (!state3?.journal) {
      console.warn("[PlayerViewActions] No journal data available for player", player2.playerId);
      return;
    }
    const {
      fakeJournalShow: fakeJournalShow2,
      waitJournalModalClosed: waitJournalModalClosed2,
      fakeJournalHide: fakeJournalHide2
    } = await Promise.resolve().then(() => (init_fakeModal(), fakeModal_exports));
    try {
      window.dispatchEvent(new CustomEvent(CH_EVENTS.CLOSE));
      await fakeJournalShow2(state3.journal, { open: true });
      await waitJournalModalClosed2();
      await fakeJournalHide2();
      window.dispatchEvent(new CustomEvent(CH_EVENTS.OPEN));
    } catch (error) {
      console.error("[PlayerViewActions] Error viewing journal:", error);
      window.dispatchEvent(new CustomEvent(CH_EVENTS.OPEN));
    }
  }
  async function stopAnyPreview() {
    if (currentPreviewType === "garden") {
      await stopViewGarden();
    }
    try {
      const {
        isInventoryPanelOpen: isInventoryPanelOpen2,
        fakeInventoryHide: fakeInventoryHide2,
        isJournalModalOpen: isJournalModalOpen2,
        fakeJournalHide: fakeJournalHide2,
        isStatsModalOpenAsync: isStatsModalOpenAsync2,
        fakeStatsHide: fakeStatsHide2,
        isActivityLogModalOpenAsync: isActivityLogModalOpenAsync2,
        fakeActivityLogHide: fakeActivityLogHide2
      } = await Promise.resolve().then(() => (init_fakeModal(), fakeModal_exports));
      if (await isInventoryPanelOpen2()) {
        await fakeInventoryHide2();
      }
      if (await isJournalModalOpen2()) {
        await fakeJournalHide2();
      }
      if (await isStatsModalOpenAsync2()) {
        await fakeStatsHide2();
      }
      if (await isActivityLogModalOpenAsync2()) {
        await fakeActivityLogHide2();
      }
    } catch (error) {
      console.error("[PlayerViewActions] Error stopping fake modal previews:", error);
    }
    hidePreviewModal();
  }

  // src/utils/mgCommon.ts
  var ORIGIN = "https://magicgarden.gg";
  var sleep3 = (ms) => new Promise((resolve2) => setTimeout(resolve2, ms));

  // src/utils/mgVersion.ts
  var VERSION_PATH = "/platform/v1/version";
  var VERSION_CACHE_TTL = 60 * 1e3;
  var pendingPromise = null;
  var cachedVersion = null;
  var cachedAt = 0;
  function nowMs() {
    return Date.now();
  }
  function setCachedVersion(version) {
    cachedVersion = version;
    cachedAt = nowMs();
  }
  function getCachedVersion() {
    if (!cachedVersion) return null;
    if (nowMs() - cachedAt < VERSION_CACHE_TTL) return cachedVersion;
    return null;
  }
  function readVersionFromGlobals() {
    const root = globalThis.unsafeWindow || globalThis;
    const gv = root?.gameVersion || root?.MG_gameVersion || root?.__MG_GAME_VERSION__;
    if (!gv) return null;
    try {
      if (typeof gv.getVersion === "function") {
        const v = gv.getVersion();
        return v ? String(v) : null;
      }
      if (typeof gv.get === "function") {
        const v = gv.get();
        return v ? String(v) : null;
      }
      if (typeof gv === "string") return gv;
    } catch {
      return null;
    }
    return null;
  }
  function readVersionFromDom(doc) {
    const d = doc ?? (typeof document !== "undefined" ? document : null);
    if (!d) return null;
    const scripts = d.scripts;
    for (let i = 0; i < scripts.length; i++) {
      const s = scripts.item(i);
      const src = s?.src;
      if (!src) continue;
      const m = src.match(/\/(?:r\/\d+\/)?version\/([^/]+)/);
      if (m && m[1]) return m[1];
    }
    const links = Array.from(d.querySelectorAll("link[href]"));
    for (const link of links) {
      const href = link.href;
      if (!href) continue;
      const m = href.match(/\/(?:r\/\d+\/)?version\/([^/]+)/);
      if (m && m[1]) return m[1];
    }
    return null;
  }
  function init(doc) {
    const cached = getCachedVersion();
    if (cached) return;
    const fromGlobals = readVersionFromGlobals();
    if (fromGlobals) {
      setCachedVersion(fromGlobals);
      return;
    }
    const fromDom = readVersionFromDom(doc);
    if (fromDom) {
      setCachedVersion(fromDom);
    }
  }
  function get2() {
    init(document);
    return getCachedVersion() ?? cachedVersion ?? null;
  }
  async function fetchGameVersion(options) {
    const cached = getCachedVersion();
    if (cached) return cached;
    if (pendingPromise) return pendingPromise;
    const origin = options?.origin || (typeof location !== "undefined" && location.origin ? location.origin : ORIGIN);
    pendingPromise = (async () => {
      try {
        const url = new URL(VERSION_PATH, origin).toString();
        const controller = typeof AbortController !== "undefined" ? new AbortController() : null;
        const timeoutId = controller ? setTimeout(() => controller.abort(), 8e3) : null;
        const res = await fetch(url, {
          headers: { "User-Agent": "MG-API/1.0" },
          signal: controller?.signal
        });
        if (timeoutId) clearTimeout(timeoutId);
        if (!res.ok) {
          throw new Error(`Version fetch failed (${res.status})`);
        }
        const data = await res.json();
        const version = typeof data?.version === "string" ? data.version.trim() : "";
        if (!version) {
          throw new Error("Version not found in response");
        }
        setCachedVersion(version);
        return version;
      } finally {
        pendingPromise = null;
      }
    })();
    return pendingPromise;
  }
  async function wait(timeoutMs = 15e3) {
    init(document);
    const cached = getCachedVersion();
    if (cached) return cached;
    const startedAt = nowMs();
    try {
      return await fetchGameVersion();
    } catch {
    }
    while (nowMs() - startedAt < timeoutMs) {
      init(document);
      const v = getCachedVersion() ?? cachedVersion;
      if (v) return v;
      await sleep3(50);
    }
    throw new Error("MGVersion timeout (gameVersion not found)");
  }
  function invalidateVersionCache() {
    cachedVersion = null;
    cachedAt = 0;
  }
  function prefetch() {
    void fetchGameVersion().catch(() => {
    });
  }
  var MGVersion = {
    init,
    get: get2,
    wait,
    fetchGameVersion,
    invalidateVersionCache,
    prefetch
  };

  // src/ui/menus/communityHub/tabs/playerAvatar.ts
  var avatarImageCache = /* @__PURE__ */ new Map();
  async function loadAvatarImage(url) {
    if (avatarImageCache.has(url)) {
      return avatarImageCache.get(url);
    }
    return withDiscordPollPause(async () => {
      return new Promise((resolve2, reject) => {
        const img = new Image();
        img.onload = () => {
          avatarImageCache.set(url, img);
          resolve2(img);
        };
        img.onerror = () => {
          reject(new Error(`Failed to load avatar image: ${url}`));
        };
        setImageSafe(img, url);
      });
    });
  }
  function buildAvatarUrl(cosmeticFileName) {
    const version = MGVersion.get();
    if (!version) {
      console.warn("[PlayerAvatar] Game version not available yet");
      return null;
    }
    const url = `https://magicgarden.gg/version/${version}/assets/cosmetic/${cosmeticFileName}`;
    return url;
  }
  async function createAvatarCanvas(cosmeticFiles, size = 128) {
    const canvas = document.createElement("canvas");
    canvas.width = size;
    canvas.height = size;
    const ctx2 = canvas.getContext("2d");
    if (!ctx2) {
      throw new Error("Failed to get 2D context");
    }
    ctx2.clearRect(0, 0, size, size);
    for (const fileName of cosmeticFiles) {
      try {
        const url = buildAvatarUrl(fileName);
        if (!url) continue;
        const img = await loadAvatarImage(url);
        ctx2.drawImage(img, 0, 0, size, size);
      } catch (error) {
        console.error(`[PlayerAvatar] Failed to load cosmetic ${fileName}:`, error);
      }
    }
    return canvas;
  }
  async function createAvatarElement(cosmeticFiles, size = 128) {
    const container = document.createElement("div");
    container.style.width = `${size}px`;
    container.style.height = `${size}px`;
    container.style.borderRadius = "12px";
    container.style.overflow = "hidden";
    container.style.flexShrink = "0";
    try {
      const zoomFactor = 2.2;
      const largerSize = Math.round(size * zoomFactor);
      const canvas = await createAvatarCanvas(cosmeticFiles, largerSize);
      canvas.style.display = "block";
      canvas.style.width = "100%";
      canvas.style.height = "100%";
      canvas.style.imageRendering = "crisp-edges";
      container.appendChild(canvas);
    } catch (error) {
      console.error("[PlayerAvatar] Failed to create avatar:", error);
      container.style.background = "rgba(255,255,255,0.05)";
      container.style.display = "flex";
      container.style.alignItems = "center";
      container.style.justifyContent = "center";
      container.style.color = "rgba(255,255,255,0.3)";
      container.style.fontSize = "12px";
      container.textContent = "?";
    }
    return container;
  }

  // src/ui/menus/communityHub/tabs/playerDetailView.ts
  var displayNumber = (n) => formatPrice(n) ?? String(n);
  async function createPlayerDetailView(options) {
    const { player: player2, onBack } = options;
    ensureSharedStyles();
    const container = document.createElement("div");
    container.className = "qws-ch-scrollable";
    style2(container, {
      display: "flex",
      flexDirection: "column",
      height: "100%",
      overflow: "auto",
      gap: "16px",
      paddingRight: "8px",
      paddingBottom: "16px"
    });
    const header = document.createElement("div");
    style2(header, {
      display: "flex",
      alignItems: "center",
      gap: "12px",
      paddingBottom: "12px",
      borderBottom: "1px solid rgba(255,255,255,0.08)"
    });
    const backButton = document.createElement("button");
    backButton.innerHTML = `
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" style="display: block;">
      <path d="M15 18L9 12L15 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
  `;
    style2(backButton, {
      padding: "8px",
      border: "1px solid rgba(255,255,255,0.08)",
      borderRadius: "8px",
      background: "rgba(255,255,255,0.03)",
      color: "#e7eef7",
      cursor: "pointer",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transition: "all 120ms ease"
    });
    backButton.onmouseenter = () => {
      style2(backButton, {
        background: "rgba(255,255,255,0.06)",
        borderColor: "rgba(94,234,212,0.25)"
      });
    };
    backButton.onmouseleave = () => {
      style2(backButton, {
        background: "rgba(255,255,255,0.03)",
        borderColor: "rgba(255,255,255,0.08)"
      });
    };
    backButton.onclick = onBack;
    const headerTitle = document.createElement("div");
    style2(headerTitle, {
      fontSize: "16px",
      fontWeight: "700",
      color: "#e7eef7",
      flex: "1"
    });
    headerTitle.textContent = "Player Details";
    const chatButton = document.createElement("button");
    chatButton.innerHTML = `
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" style="display: block;">
      <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
  `;
    style2(chatButton, {
      padding: "8px",
      border: "1px solid rgba(255,255,255,0.08)",
      borderRadius: "8px",
      background: "rgba(94,234,212,0.12)",
      color: "#5eead4",
      cursor: "pointer",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transition: "all 120ms ease"
    });
    chatButton.onmouseenter = () => {
      style2(chatButton, {
        background: "rgba(94,234,212,0.2)",
        borderColor: "rgba(94,234,212,0.35)"
      });
    };
    chatButton.onmouseleave = () => {
      style2(chatButton, {
        background: "rgba(94,234,212,0.12)",
        borderColor: "rgba(255,255,255,0.08)"
      });
    };
    chatButton.onclick = () => {
      window.dispatchEvent(
        new CustomEvent(CH_EVENTS.OPEN_FRIEND_CHAT, {
          detail: { playerId: player2.playerId }
        })
      );
    };
    const removeButton = document.createElement("button");
    removeButton.title = "Remove Friend";
    removeButton.innerHTML = `
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" style="display: block;">
      <path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      <circle cx="9" cy="7" r="4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      <line x1="17" y1="11" x2="23" y2="11" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
    </svg>
  `;
    style2(removeButton, {
      padding: "8px",
      border: "1px solid rgba(239,68,68,0.2)",
      borderRadius: "8px",
      background: "rgba(239,68,68,0.08)",
      color: "#ef4444",
      cursor: "pointer",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transition: "all 120ms ease"
    });
    removeButton.onmouseenter = () => {
      style2(removeButton, {
        background: "rgba(239,68,68,0.18)",
        borderColor: "rgba(239,68,68,0.4)"
      });
    };
    removeButton.onmouseleave = () => {
      style2(removeButton, {
        background: "rgba(239,68,68,0.08)",
        borderColor: "rgba(239,68,68,0.2)"
      });
    };
    removeButton.onclick = async () => {
      onBack();
      await removeFriend(player2.playerId);
    };
    header.append(backButton, headerTitle, chatButton, removeButton);
    let playerInfo = await createPlayerInfoSection(player2);
    let currentActionsSection = createActionsSection(player2);
    let statsSection = createStatsSection(player2);
    container.append(header, playerInfo, currentActionsSection, statsSection);
    let refetchTimer = null;
    const scheduleRefetch = () => {
      if (refetchTimer) clearTimeout(refetchTimer);
      refetchTimer = setTimeout(async () => {
        if (!container.isConnected) return;
        const fresh = await fetchPlayerDetailsComplete(player2.playerId);
        if (!fresh || !container.isConnected) return;
        const newPlayerInfo = await createPlayerInfoSection(fresh);
        const newActionsSection = createActionsSection(fresh);
        const newStatsSection = createStatsSection(fresh);
        playerInfo.replaceWith(newPlayerInfo);
        currentActionsSection.replaceWith(newActionsSection);
        statsSection.replaceWith(newStatsSection);
        playerInfo = newPlayerInfo;
        currentActionsSection = newActionsSection;
        statsSection = newStatsSection;
      }, 300);
    };
    const handlePlayerEvent = (e) => {
      const detail = e.detail;
      if (!detail || detail.playerId !== player2.playerId) return;
      if (!container.isConnected) {
        window.removeEventListener(CH_EVENTS.PRIVACY_UPDATED, handlePlayerEvent);
        window.removeEventListener(CH_EVENTS.ROOM_CHANGED, handlePlayerEvent);
        if (refetchTimer) clearTimeout(refetchTimer);
        return;
      }
      scheduleRefetch();
    };
    window.addEventListener(CH_EVENTS.PRIVACY_UPDATED, handlePlayerEvent);
    window.addEventListener(CH_EVENTS.ROOM_CHANGED, handlePlayerEvent);
    return container;
  }
  async function createPlayerInfoSection(player2) {
    const section = document.createElement("div");
    style2(section, {
      display: "flex",
      flexDirection: "column",
      gap: "16px",
      padding: "16px",
      border: "1px solid rgba(255,255,255,0.08)",
      borderRadius: "12px",
      background: "rgba(255,255,255,0.03)"
    });
    const topRow = document.createElement("div");
    style2(topRow, {
      display: "flex",
      gap: "16px",
      alignItems: "center"
    });
    const avatar2 = document.createElement("div");
    style2(avatar2, {
      width: "80px",
      height: "80px",
      borderRadius: "50%",
      background: player2.avatarUrl ? `url(${player2.avatarUrl}) center/cover` : "linear-gradient(135deg, rgba(94,234,212,0.3), rgba(59,130,246,0.3))",
      border: "3px solid rgba(255,255,255,0.1)",
      flexShrink: "0"
    });
    const infoColumn = document.createElement("div");
    style2(infoColumn, {
      display: "flex",
      flexDirection: "column",
      gap: "8px",
      flex: "1"
    });
    const nameRow = document.createElement("div");
    style2(nameRow, { display: "flex", alignItems: "center", gap: "8px" });
    const name = document.createElement("div");
    style2(name, {
      fontSize: "20px",
      fontWeight: "700",
      color: "#e7eef7"
    });
    name.textContent = player2.playerName || "Unknown Player";
    nameRow.appendChild(name);
    const badgesEl = createPlayerBadges(player2.badges);
    if (badgesEl) nameRow.appendChild(badgesEl);
    const playerId2 = document.createElement("div");
    style2(playerId2, {
      fontSize: "12px",
      color: "rgba(226,232,240,0.5)",
      fontFamily: "monospace"
    });
    playerId2.textContent = `ID: ${player2.playerId}`;
    const statusRow = document.createElement("div");
    style2(statusRow, {
      display: "flex",
      alignItems: "center",
      gap: "8px"
    });
    const statusIndicator = document.createElement("div");
    style2(statusIndicator, {
      width: "10px",
      height: "10px",
      borderRadius: "50%",
      background: player2.isOnline ? "#10b981" : "#ef4444",
      boxShadow: player2.isOnline ? "0 0 8px rgba(16,185,129,0.6)" : "0 0 6px rgba(239,68,68,0.4)"
    });
    const statusText = document.createElement("div");
    style2(statusText, {
      fontSize: "13px",
      color: player2.isOnline ? "#5eead4" : "rgba(226,232,240,0.5)",
      fontWeight: "500"
    });
    statusText.textContent = player2.isOnline ? "Online" : "Offline";
    statusRow.append(statusIndicator, statusText);
    infoColumn.append(nameRow, playerId2, statusRow);
    topRow.append(avatar2, infoColumn);
    const playerData = player2;
    if (playerData.avatar && Array.isArray(playerData.avatar) && playerData.avatar.length > 0) {
      const cosmetics = playerData.avatar;
      try {
        const gameAvatar = await createAvatarElement(cosmetics, 110);
        const avatarWrapper = document.createElement("div");
        Object.assign(avatarWrapper.style, {
          width: "80px",
          height: "80px",
          overflow: "hidden",
          position: "relative",
          flexShrink: "0",
          borderRadius: "12px"
        });
        Object.assign(gameAvatar.style, {
          position: "absolute",
          top: "62%",
          left: "50%",
          transform: "translate(-50%, -50%)"
        });
        avatarWrapper.appendChild(gameAvatar);
        topRow.appendChild(avatarWrapper);
      } catch (error) {
        console.error("[PlayerDetailView] Failed to create game avatar:", error);
        const avatarWrapper = document.createElement("div");
        Object.assign(avatarWrapper.style, {
          width: "80px",
          height: "80px",
          overflow: "hidden",
          position: "relative",
          flexShrink: "0",
          borderRadius: "12px",
          background: "rgba(255,255,255,0.05)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center"
        });
        const errorText = document.createElement("div");
        errorText.textContent = "?";
        errorText.style.color = "rgba(255,255,255,0.3)";
        errorText.style.fontSize = "12px";
        avatarWrapper.appendChild(errorText);
        topRow.appendChild(avatarWrapper);
      }
    } else {
      console.warn("[PlayerDetailView] No cosmetics found for player");
    }
    section.appendChild(topRow);
    const hasCoins = player2.coins !== null && player2.coins !== void 0;
    const hasMod = player2.hasModInstalled && player2.modVersion;
    if (hasCoins || hasMod) {
      const infoRow = document.createElement("div");
      style2(infoRow, {
        display: "flex",
        alignItems: "center",
        gap: "0",
        padding: "8px 12px",
        background: "rgba(255,255,255,0.02)",
        borderRadius: "8px"
      });
      if (hasCoins) {
        infoRow.appendChild(createInfoCell("Coins", displayNumber(player2.coins)));
      }
      if (hasCoins && hasMod) {
        infoRow.appendChild(createInfoSeparator());
      }
      if (hasMod) {
        infoRow.appendChild(createInfoCell("Mod Version", player2.modVersion));
      }
      section.appendChild(infoRow);
    }
    if (player2.room && typeof player2.room === "object" && "id" in player2.room) {
      const roomInfo = player2.room;
      const playersCount = Number(roomInfo.players_count) || 0;
      const maxPlayers = 6;
      section.appendChild(createRoomSection(roomInfo.id, playersCount, maxPlayers, roomInfo.user_slots || []));
    } else if (player2.room && typeof player2.room === "string") {
      const roomRow = createInfoRow("Room", player2.room);
      section.appendChild(roomRow);
    }
    return section;
  }
  function createInfoCell(label2, value) {
    const cell = document.createElement("div");
    style2(cell, {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap: "2px",
      flex: "1"
    });
    const labelEl = document.createElement("div");
    style2(labelEl, { fontSize: "10px", color: "rgba(226,232,240,0.5)", fontWeight: "500", textTransform: "uppercase", letterSpacing: "0.5px" });
    labelEl.textContent = label2;
    const valueEl = document.createElement("div");
    style2(valueEl, { fontSize: "13px", color: "#e7eef7", fontWeight: "600", overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap", maxWidth: "100%" });
    valueEl.textContent = value;
    cell.append(labelEl, valueEl);
    return cell;
  }
  function createInfoSeparator() {
    const sep = document.createElement("div");
    style2(sep, { width: "1px", height: "28px", background: "rgba(255,255,255,0.08)", flexShrink: "0" });
    return sep;
  }
  function createInfoRow(label2, value) {
    const row = document.createElement("div");
    style2(row, {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      padding: "8px 12px",
      background: "rgba(255,255,255,0.02)",
      borderRadius: "8px"
    });
    const labelEl = document.createElement("div");
    style2(labelEl, {
      fontSize: "12px",
      color: "rgba(226,232,240,0.6)",
      fontWeight: "500"
    });
    labelEl.textContent = label2;
    const valueEl = document.createElement("div");
    valueEl.setAttribute("data-value", "true");
    style2(valueEl, {
      fontSize: "13px",
      color: "#e7eef7",
      fontWeight: "600",
      display: "flex",
      alignItems: "center"
    });
    valueEl.textContent = value;
    row.append(labelEl, valueEl);
    return row;
  }
  function createRoomSection(roomId, playersCount, maxPlayers, players) {
    const section = document.createElement("div");
    style2(section, {
      padding: "14px",
      background: "rgba(255,255,255,0.02)",
      borderRadius: "10px",
      border: "1px solid rgba(255,255,255,0.06)",
      display: "flex",
      alignItems: "center",
      gap: "12px"
    });
    const roomName = document.createElement("div");
    style2(roomName, {
      fontSize: "14px",
      fontWeight: "600",
      color: "#e7eef7",
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      maxWidth: "120px",
      flexShrink: "1"
    });
    roomName.textContent = roomId;
    roomName.title = roomId;
    const avatarsContainer = document.createElement("div");
    style2(avatarsContainer, {
      display: "flex",
      gap: "4px",
      flex: "1"
    });
    for (let i = 0; i < maxPlayers; i++) {
      const avatarSlot = document.createElement("div");
      const playerData = players[i];
      if (playerData && playerData.avatar_url) {
        style2(avatarSlot, {
          width: "32px",
          height: "32px",
          borderRadius: "50%",
          background: `url(${playerData.avatar_url}) center/cover`,
          border: "2px solid rgba(94,234,212,0.3)",
          flexShrink: "0"
        });
      } else if (i < playersCount) {
        style2(avatarSlot, {
          width: "32px",
          height: "32px",
          borderRadius: "50%",
          background: "linear-gradient(135deg, rgba(94,234,212,0.2), rgba(59,130,246,0.2))",
          border: "2px solid rgba(94,234,212,0.3)",
          flexShrink: "0"
        });
      } else {
        style2(avatarSlot, {
          width: "32px",
          height: "32px",
          borderRadius: "50%",
          background: "rgba(255,255,255,0.03)",
          border: "2px dashed rgba(255,255,255,0.1)",
          flexShrink: "0"
        });
      }
      avatarsContainer.appendChild(avatarSlot);
    }
    const counter = document.createElement("div");
    style2(counter, {
      fontSize: "11px",
      color: "rgba(226,232,240,0.4)",
      fontWeight: "500",
      whiteSpace: "nowrap",
      flexShrink: "0"
    });
    counter.textContent = `${playersCount}/${maxPlayers}`;
    const joinButton = document.createElement("button");
    const isFull = playersCount >= maxPlayers;
    const isDiscord = detectEnvironment().surface === "discord";
    const isDisabled = isFull || isDiscord;
    if (isDiscord) {
      joinButton.textContent = "Unavailable";
    } else {
      joinButton.textContent = isFull ? "Full" : "Join";
    }
    joinButton.disabled = isDisabled;
    style2(joinButton, {
      padding: "6px 14px",
      border: isDisabled ? "1px solid rgba(255,255,255,0.1)" : "1px solid rgba(94,234,212,0.3)",
      borderRadius: "6px",
      background: isDisabled ? "rgba(255,255,255,0.03)" : "rgba(94,234,212,0.1)",
      color: isDisabled ? "rgba(226,232,240,0.4)" : "#5eead4",
      fontSize: "12px",
      fontWeight: "600",
      cursor: isDisabled ? "not-allowed" : "pointer",
      transition: "all 120ms ease",
      flexShrink: "0",
      opacity: isDisabled ? "0.5" : "1"
    });
    if (!isDisabled) {
      joinButton.onmouseenter = () => {
        style2(joinButton, {
          background: "rgba(94,234,212,0.2)",
          borderColor: "rgba(94,234,212,0.5)"
        });
      };
      joinButton.onmouseleave = () => {
        style2(joinButton, {
          background: "rgba(94,234,212,0.1)",
          borderColor: "rgba(94,234,212,0.3)"
        });
      };
      joinButton.onclick = () => {
        window.location.href = `${detectEnvironment().origin}/r/${roomId}`;
      };
    } else if (isDiscord && !isFull) {
      joinButton.title = "Room joining is not available on Discord";
    }
    section.append(roomName, avatarsContainer, counter, joinButton);
    return section;
  }
  function createStatsSection(player2) {
    const section = document.createElement("div");
    style2(section, {
      display: "flex",
      flexDirection: "column",
      gap: "12px"
    });
    const title = document.createElement("div");
    style2(title, {
      fontSize: "14px",
      fontWeight: "700",
      color: "#e7eef7",
      paddingLeft: "4px"
    });
    title.textContent = "Leaderboard";
    section.appendChild(title);
    const leaderboard = player2.leaderboard;
    if (!leaderboard) {
      const emptyState = document.createElement("div");
      style2(emptyState, {
        padding: "24px",
        textAlign: "center",
        color: "rgba(226,232,240,0.5)",
        fontSize: "13px",
        border: "1px solid rgba(255,255,255,0.08)",
        borderRadius: "12px",
        background: "rgba(255,255,255,0.02)"
      });
      emptyState.textContent = "No leaderboard data available";
      section.appendChild(emptyState);
      return section;
    }
    const statsGrid = document.createElement("div");
    style2(statsGrid, {
      display: "grid",
      gridTemplateColumns: "1fr 1fr",
      gap: "12px"
    });
    if (leaderboard.coins && leaderboard.coins.rank !== null) {
      const coinsTotal = leaderboard.coins.total ? displayNumber(leaderboard.coins.total) : "";
      statsGrid.appendChild(
        createStatCard("Coins Rank", `#${leaderboard.coins.rank}`, coinsTotal, leaderboard.coins.rankChange ?? null)
      );
    }
    if (leaderboard.eggsHatched && leaderboard.eggsHatched.rank !== null) {
      const eggsTotal = leaderboard.eggsHatched.total ? displayNumber(leaderboard.eggsHatched.total) : "";
      statsGrid.appendChild(
        createStatCard("Eggs Rank", `#${leaderboard.eggsHatched.rank}`, eggsTotal, leaderboard.eggsHatched.rankChange ?? null)
      );
    }
    if (statsGrid.children.length > 0) {
      section.appendChild(statsGrid);
    } else {
      const emptyState = document.createElement("div");
      style2(emptyState, {
        padding: "24px",
        textAlign: "center",
        color: "rgba(226,232,240,0.5)",
        fontSize: "13px",
        border: "1px solid rgba(255,255,255,0.08)",
        borderRadius: "12px",
        background: "rgba(255,255,255,0.02)"
      });
      emptyState.textContent = "No leaderboard data available";
      section.appendChild(emptyState);
    }
    return section;
  }
  function createStatCard(label2, rank, total, rankChange = null) {
    const card2 = document.createElement("div");
    style2(card2, {
      padding: "14px",
      border: "1px solid rgba(255,255,255,0.08)",
      borderRadius: "10px",
      background: "rgba(255,255,255,0.03)",
      display: "flex",
      flexDirection: "column",
      gap: "6px"
    });
    const labelEl = document.createElement("div");
    style2(labelEl, {
      fontSize: "11px",
      color: "rgba(226,232,240,0.6)",
      fontWeight: "500",
      textTransform: "uppercase",
      letterSpacing: "0.5px"
    });
    labelEl.textContent = label2;
    const valueRow = document.createElement("div");
    style2(valueRow, {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "baseline",
      gap: "8px"
    });
    const leftSide = document.createElement("div");
    style2(leftSide, {
      display: "flex",
      alignItems: "center",
      gap: "6px"
    });
    if (rankChange !== null && rankChange !== 0) {
      const rankChangeIndicator = document.createElement("div");
      style2(rankChangeIndicator, {
        display: "flex",
        alignItems: "center",
        gap: "2px",
        fontSize: "11px",
        fontWeight: "700",
        flexShrink: "0",
        lineHeight: "1"
      });
      if (rankChange > 0) {
        rankChangeIndicator.innerHTML = `
        <svg width="14" height="14" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" style="display: block; transform: translateY(-1px);">
          <path d="M8 3L8 13M8 3L4 7M8 3L12 7" stroke="#10b981" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        <span style="color: #10b981; line-height: 1;">${rankChange}</span>
      `;
      } else {
        rankChangeIndicator.innerHTML = `
        <svg width="14" height="14" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" style="display: block; transform: translateY(-1px);">
          <path d="M8 13L8 3M8 13L12 9M8 13L4 9" stroke="#ef4444" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        <span style="color: #ef4444; line-height: 1;">${Math.abs(rankChange)}</span>
      `;
      }
      leftSide.appendChild(rankChangeIndicator);
    }
    const rankEl = document.createElement("div");
    style2(rankEl, {
      fontSize: "20px",
      fontWeight: "700",
      color: "#5eead4"
    });
    rankEl.textContent = rank;
    leftSide.appendChild(rankEl);
    const totalEl = document.createElement("div");
    style2(totalEl, {
      fontSize: "12px",
      color: "rgba(226,232,240,0.5)",
      fontWeight: "500"
    });
    totalEl.textContent = total;
    valueRow.append(leftSide, totalEl);
    card2.append(labelEl, valueRow);
    return card2;
  }
  function createActionsSection(player2) {
    const section = document.createElement("div");
    style2(section, {
      display: "flex",
      flexDirection: "column",
      gap: "12px"
    });
    const title = document.createElement("div");
    style2(title, {
      fontSize: "14px",
      fontWeight: "700",
      color: "#e7eef7",
      paddingLeft: "4px"
    });
    title.textContent = "View";
    section.appendChild(title);
    const privacy = player2.privacy;
    const state3 = player2.state;
    const buttonsGrid = document.createElement("div");
    style2(buttonsGrid, {
      display: "grid",
      gridTemplateColumns: "1fr 1fr",
      gap: "10px"
    });
    const actionIcons = {
      garden: `<svg width="16" height="16" viewBox="0 -0.5 17 17" fill="none" style="display: inline-block; margin-right: 6px; vertical-align: middle;">
      <path d="M14.779,12.18 L11.795,8.501 C11.795,8.501 13.396,8.937 13.57,8.937 C14.035,8.937 13.765,8.42 13.57,8.223 L11.185,5.192 C11.185,5.192 12.333,4.918 12.75,4.918 C13.168,4.918 12.947,4.401 12.75,4.204 L9.4,0.061 C9.203,-0.136 8.883,-0.136 8.686,0.061 L5.291,4.161 C5.093,4.358 4.805,4.876 5.291,4.876 C5.777,4.876 6.913,5.192 6.913,5.192 L4.325,8.079 C4.127,8.276 3.768,8.793 4.325,8.793 C4.644,8.793 6.275,8.502 6.275,8.502 L3.317,12.189 C3.12,12.385 2.76,12.903 3.317,12.903 C3.874,12.903 8.008,11.896 8.008,11.896 L8.008,14.941 C8.008,15.478 8.444,15.914 8.983,15.914 C9.52,15.914 9.998,15.478 9.998,14.941 L9.998,11.896 C9.998,11.896 14.373,12.895 14.778,12.895 C15.183,12.895 14.976,12.376 14.779,12.18 L14.779,12.18 Z" fill="currentColor" opacity="0.8"/>
    </svg>`,
      inventory: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 6px; vertical-align: middle;">
      <rect x="3" y="3" width="7" height="7" rx="1" stroke="currentColor" stroke-width="2" fill="none"/>
      <rect x="14" y="3" width="7" height="7" rx="1" stroke="currentColor" stroke-width="2" fill="none"/>
      <rect x="3" y="14" width="7" height="7" rx="1" stroke="currentColor" stroke-width="2" fill="none"/>
      <rect x="14" y="14" width="7" height="7" rx="1" stroke="currentColor" stroke-width="2" fill="none"/>
    </svg>`,
      stats: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 6px; vertical-align: middle;">
      <path d="M3 13h4v8H3v-8zm6-8h4v16h-4V5zm6 4h4v12h-4V9z" fill="currentColor" opacity="0.7"/>
    </svg>`,
      activityLog: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 6px; vertical-align: middle;">
      <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2" fill="none"/>
      <path d="M12 6v6l4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
    </svg>`,
      journal: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" style="display: inline-block; margin-right: 6px; vertical-align: middle;">
      <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14z" fill="currentColor"/>
      <path d="M7 10h10M7 14h7" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" opacity="0.7"/>
    </svg>`
    };
    const actions = [
      { key: "garden", label: "Garden", available: privacy?.showGarden && state3?.garden },
      { key: "inventory", label: "Inventory", available: privacy?.showInventory && state3?.inventory },
      { key: "stats", label: "Stats", available: privacy?.showStats && state3?.stats },
      { key: "activityLog", label: "Activity", available: privacy?.showActivityLog && state3?.activityLog },
      { key: "journal", label: "Journal", available: privacy?.showJournal && state3?.journal }
    ];
    for (const action2 of actions) {
      if (!action2.available) continue;
      const button = document.createElement("button");
      button.innerHTML = actionIcons[action2.key] + action2.label;
      style2(button, {
        padding: "12px 16px",
        border: "1px solid rgba(255,255,255,0.08)",
        borderRadius: "10px",
        background: "rgba(255,255,255,0.03)",
        color: "#e7eef7",
        fontSize: "13px",
        fontWeight: "600",
        cursor: "pointer",
        transition: "all 120ms ease",
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      });
      button.onmouseenter = () => {
        style2(button, {
          background: "rgba(94,234,212,0.1)",
          borderColor: "rgba(94,234,212,0.3)",
          color: "#5eead4"
        });
      };
      button.onmouseleave = () => {
        style2(button, {
          background: "rgba(255,255,255,0.03)",
          borderColor: "rgba(255,255,255,0.08)",
          color: "#e7eef7"
        });
      };
      button.onclick = async () => {
        button.disabled = true;
        const originalText = button.innerHTML;
        button.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" style="display: inline-block; animation: spin 1s linear infinite; margin-right: 6px; vertical-align: middle;">
        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2" stroke-dasharray="15 5" fill="none"/>
      </svg>Loading...`;
        style2(button, {
          opacity: "0.6",
          cursor: "not-allowed"
        });
        try {
          switch (action2.key) {
            case "garden":
              await viewGarden(player2);
              break;
            case "inventory":
              await viewInventory(player2);
              break;
            case "stats":
              await viewStats(player2);
              break;
            case "activityLog":
              await viewActivityLog(player2);
              break;
            case "journal":
              await viewJournal(player2);
              break;
            default:
              console.warn(`[PlayerDetail] Unknown action: ${action2.key}`);
          }
          button.disabled = false;
          button.innerHTML = originalText;
          style2(button, {
            opacity: "1",
            cursor: "pointer"
          });
        } catch (error) {
          console.error(`[PlayerDetail] Error viewing ${action2.key}:`, error);
          button.disabled = false;
          button.innerHTML = originalText;
          style2(button, {
            opacity: "1",
            cursor: "pointer"
          });
        }
      };
      buttonsGrid.appendChild(button);
    }
    if (buttonsGrid.children.length > 0) {
      section.appendChild(buttonsGrid);
    } else {
      const emptyState = document.createElement("div");
      style2(emptyState, {
        padding: "24px",
        textAlign: "center",
        color: "rgba(226,232,240,0.5)",
        fontSize: "13px",
        border: "1px solid rgba(255,255,255,0.08)",
        borderRadius: "12px",
        background: "rgba(255,255,255,0.02)"
      });
      emptyState.textContent = "No sections available to view";
      section.appendChild(emptyState);
    }
    return section;
  }

  // src/ui/menus/communityHub/tabs/myFriendsSubTab.ts
  function createMyFriendsSubTab(showPlayerDetail) {
    ensureSharedStyles();
    const container = document.createElement("div");
    style2(container, { display: "flex", flexDirection: "column", height: "100%", gap: "12px" });
    const searchBar = document.createElement("input");
    searchBar.type = "text";
    searchBar.placeholder = "Search friends...";
    style2(searchBar, {
      padding: "10px 14px",
      border: "1px solid rgba(255,255,255,0.12)",
      borderRadius: "10px",
      background: "rgba(255,255,255,0.04)",
      color: "#e7eef7",
      fontSize: "13px",
      outline: "none",
      transition: "border-color 150ms ease"
    });
    const keyBlocker = createKeyBlocker(() => document.activeElement === searchBar);
    keyBlocker.attach();
    searchBar.onfocus = () => style2(searchBar, { borderColor: "rgba(94,234,212,0.35)" });
    searchBar.onblur = () => style2(searchBar, { borderColor: "rgba(255,255,255,0.12)" });
    const friendsList = document.createElement("div");
    friendsList.className = "qws-ch-scrollable";
    style2(friendsList, {
      flex: "1",
      overflow: "auto",
      display: "grid",
      gridTemplateColumns: "repeat(auto-fill, minmax(180px, 1fr))",
      gap: "10px",
      alignContent: "start",
      padding: "6px 8px 6px 6px"
      // Padding to prevent cards from being clipped during hover animations
    });
    const renderFriends = (filter = "") => {
      friendsList.innerHTML = "";
      const friends = getCachedFriendsWithViews();
      const filtered = filter ? friends.filter((f) => f.playerName?.toLowerCase().includes(filter.toLowerCase())) : friends;
      if (filtered.length === 0) {
        const empty = document.createElement("div");
        style2(empty, {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          height: "100%",
          color: "rgba(226,232,240,0.5)",
          fontSize: "13px"
        });
        empty.textContent = filter ? "No friends found" : "No friends yet";
        friendsList.appendChild(empty);
        return;
      }
      const sorted = [...filtered].sort((a, b) => {
        if (a.isOnline === b.isOnline) return 0;
        return a.isOnline ? -1 : 1;
      });
      for (const friend of sorted) {
        friendsList.appendChild(createFriendCard(friend, showPlayerDetail));
      }
    };
    renderFriends();
    searchBar.oninput = () => renderFriends(searchBar.value);
    const onFriendsRefresh = () => renderFriends(searchBar.value);
    window.addEventListener(CH_EVENTS.FRIENDS_REFRESH, onFriendsRefresh);
    container.append(searchBar, friendsList);
    return {
      root: container,
      destroy() {
        keyBlocker.detach();
        window.removeEventListener(CH_EVENTS.FRIENDS_REFRESH, onFriendsRefresh);
      }
    };
  }
  function createFriendCard(friend, onClick) {
    const card2 = document.createElement("div");
    style2(card2, {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap: "10px",
      padding: "14px",
      border: "1px solid rgba(255,255,255,0.08)",
      borderRadius: "12px",
      background: "rgba(255,255,255,0.03)",
      cursor: "pointer",
      transition: "all 120ms ease"
    });
    card2.onclick = () => onClick(friend);
    card2.onmouseenter = () => {
      style2(card2, { background: "rgba(255,255,255,0.06)", borderColor: "rgba(94,234,212,0.25)", transform: "translateY(-2px)" });
    };
    card2.onmouseleave = () => {
      style2(card2, { background: "rgba(255,255,255,0.03)", borderColor: "rgba(255,255,255,0.08)", transform: "translateY(0)" });
    };
    const avatarWrapper = document.createElement("div");
    style2(avatarWrapper, { position: "relative", flexShrink: "0" });
    const avatar2 = document.createElement("div");
    style2(avatar2, {
      width: "56px",
      height: "56px",
      borderRadius: "50%",
      background: friend.avatarUrl ? `url(${friend.avatarUrl}) center/cover` : "linear-gradient(135deg, rgba(94,234,212,0.3), rgba(59,130,246,0.3))",
      border: "2px solid rgba(255,255,255,0.1)"
    });
    const onlineIndicator = document.createElement("div");
    style2(onlineIndicator, {
      position: "absolute",
      bottom: "0px",
      right: "0px",
      width: "14px",
      height: "14px",
      borderRadius: "50%",
      background: friend.isOnline ? "#10b981" : "#ef4444",
      border: "2px solid #0f141e",
      boxShadow: friend.isOnline ? "0 0 8px rgba(16,185,129,0.6)" : "0 0 6px rgba(239,68,68,0.4)"
    });
    avatarWrapper.append(avatar2, onlineIndicator);
    const info = document.createElement("div");
    style2(info, { display: "flex", flexDirection: "column", gap: "2px", alignItems: "center", width: "100%" });
    const name = document.createElement("div");
    style2(name, {
      fontSize: "13px",
      fontWeight: "600",
      color: "#e7eef7",
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      maxWidth: "100%",
      textAlign: "center"
    });
    name.textContent = friend.playerName || "Unknown";
    const status = document.createElement("div");
    style2(status, {
      fontSize: "11px",
      color: friend.isOnline ? "#5eead4" : "rgba(226,232,240,0.5)",
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      maxWidth: "100%",
      textAlign: "center"
    });
    if (friend.isOnline) {
      status.appendChild(createRoomBadge(friend.room));
    } else {
      if (friend.lastEventAt) {
        status.textContent = `Last seen ${formatRelativeTime(friend.lastEventAt)}`;
      } else {
        status.textContent = "";
      }
    }
    info.append(name, status);
    const badgesEl = createPlayerBadges(friend.badges, true);
    if (badgesEl) {
      style2(badgesEl, {
        position: "absolute",
        top: "8px",
        right: "8px",
        flexDirection: "column",
        alignItems: "flex-end",
        justifyContent: "flex-start",
        gap: "3px"
      });
      card2.append(avatarWrapper, info, badgesEl);
    } else {
      card2.append(avatarWrapper, info);
    }
    return card2;
  }

  // src/ui/menus/communityHub/tabs/addFriendsSubTab.ts
  function createAddFriendsSubTab() {
    ensureSharedStyles();
    const container = document.createElement("div");
    style2(container, { display: "flex", flexDirection: "column", height: "100%", gap: "12px" });
    const searchContainer = document.createElement("div");
    style2(searchContainer, { display: "flex", gap: "8px", alignItems: "center" });
    const searchBar = document.createElement("input");
    searchBar.type = "text";
    searchBar.placeholder = "Search mod players...";
    style2(searchBar, {
      flex: "1",
      padding: "10px 14px",
      border: "1px solid rgba(255,255,255,0.12)",
      borderRadius: "10px",
      background: "rgba(255,255,255,0.04)",
      color: "#e7eef7",
      fontSize: "13px",
      outline: "none",
      transition: "border-color 150ms ease"
    });
    const keyBlocker = createKeyBlocker(() => document.activeElement === searchBar);
    keyBlocker.attach();
    searchBar.onfocus = () => style2(searchBar, { borderColor: "rgba(94,234,212,0.35)" });
    searchBar.onblur = () => style2(searchBar, { borderColor: "rgba(255,255,255,0.12)" });
    searchContainer.append(searchBar);
    const playersList = document.createElement("div");
    playersList.className = "qws-ch-scrollable";
    style2(playersList, {
      flex: "1",
      overflow: "auto",
      display: "grid",
      gridTemplateColumns: "repeat(auto-fill, minmax(180px, 1fr))",
      gap: "10px",
      alignContent: "start",
      padding: "6px 8px 6px 6px"
      // Padding to prevent cards from being clipped during hover animations
    });
    let isSearching = false;
    let debounceTimer = null;
    let searchResults = null;
    let lastSearchQuery = "";
    const getPlayerButtonState = (playerId2) => {
      const friends = getCachedFriendsWithViews();
      const incomingRequests = getCachedIncomingRequestsWithViews();
      const outgoingRequests = getCachedOutgoingRequests();
      if (friends.some((f) => f.playerId === playerId2)) return "remove";
      if (outgoingRequests.some((r) => r.toPlayerId === playerId2)) return "cancel";
      if (incomingRequests.some((r) => r.playerId === playerId2)) return "pending";
      return "add";
    };
    const renderPlayers = () => {
      playersList.innerHTML = "";
      let players;
      if (searchResults !== null) {
        players = searchResults;
      } else {
        const cachedModPlayers = getCachedModPlayers();
        const allPlayers = cachedModPlayers || [];
        const sorted = [...allPlayers].sort((a, b) => {
          const aOnline = a.isOnline ?? false;
          const bOnline = b.isOnline ?? false;
          if (aOnline === bOnline) return 0;
          return aOnline ? -1 : 1;
        });
        players = sorted.slice(0, 12);
      }
      if (players.length === 0) {
        const empty = document.createElement("div");
        style2(empty, {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          height: "100%",
          color: "rgba(226,232,240,0.5)",
          fontSize: "13px"
        });
        empty.textContent = isSearching ? "No players found" : "No mod players available";
        playersList.appendChild(empty);
        return;
      }
      for (const player2 of players) {
        playersList.appendChild(createAddFriendCard(player2, getPlayerButtonState));
      }
    };
    const performSearch = async () => {
      const query = searchBar.value.trim();
      if (!query) {
        if (lastSearchQuery) {
          isSearching = true;
          try {
            const players = await fetchModPlayers({ query: "", limit: 12 });
            searchResults = players;
            renderPlayers();
          } catch (error) {
            console.error("[AddFriends] Empty search failed:", error);
            searchResults = [];
            renderPlayers();
          } finally {
            isSearching = false;
          }
        } else {
          isSearching = false;
          renderPlayers();
        }
        return;
      }
      lastSearchQuery = query;
      isSearching = true;
      try {
        const players = await fetchModPlayers({ query, limit: 12 });
        searchResults = players;
        renderPlayers();
      } catch (error) {
        console.error("[AddFriends] Search failed:", error);
        searchResults = [];
        renderPlayers();
      } finally {
        isSearching = false;
      }
    };
    searchBar.oninput = () => {
      if (debounceTimer) clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => performSearch(), 300);
    };
    renderPlayers();
    let refreshTimer = null;
    const onRefresh = () => {
      if (refreshTimer) clearTimeout(refreshTimer);
      refreshTimer = setTimeout(() => {
        refreshTimer = null;
        renderPlayers();
      }, 80);
    };
    window.addEventListener(CH_EVENTS.FRIEND_REQUESTS_REFRESH, onRefresh);
    window.addEventListener(CH_EVENTS.FRIENDS_REFRESH, onRefresh);
    const unsubWelcome = onWelcome((data) => {
      if (data.modPlayers && data.modPlayers.length > 0) {
        renderPlayers();
      }
    });
    container.append(searchContainer, playersList);
    return {
      root: container,
      destroy() {
        keyBlocker.detach();
        if (debounceTimer) clearTimeout(debounceTimer);
        if (refreshTimer) clearTimeout(refreshTimer);
        window.removeEventListener(CH_EVENTS.FRIEND_REQUESTS_REFRESH, onRefresh);
        window.removeEventListener(CH_EVENTS.FRIENDS_REFRESH, onRefresh);
        unsubWelcome();
      }
    };
  }
  function createAddFriendCard(player2, getButtonState) {
    const card2 = document.createElement("div");
    style2(card2, {
      position: "relative",
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap: "10px",
      padding: "14px",
      border: "1px solid rgba(255,255,255,0.08)",
      borderRadius: "12px",
      background: "rgba(255,255,255,0.03)",
      transition: "all 120ms ease"
    });
    card2.onmouseenter = () => {
      style2(card2, { background: "rgba(255,255,255,0.06)", borderColor: "rgba(94,234,212,0.25)" });
    };
    card2.onmouseleave = () => {
      style2(card2, { background: "rgba(255,255,255,0.03)", borderColor: "rgba(255,255,255,0.08)" });
    };
    const isOnline = player2.isOnline ?? false;
    const avatarWrapper = document.createElement("div");
    style2(avatarWrapper, { position: "relative", flexShrink: "0" });
    const avatar2 = document.createElement("div");
    style2(avatar2, {
      width: "56px",
      height: "56px",
      borderRadius: "50%",
      background: player2.avatarUrl ? `url(${player2.avatarUrl}) center/cover` : "linear-gradient(135deg, rgba(94,234,212,0.3), rgba(59,130,246,0.3))",
      border: "2px solid rgba(255,255,255,0.1)"
    });
    const onlineIndicator = document.createElement("div");
    style2(onlineIndicator, {
      position: "absolute",
      bottom: "0px",
      right: "0px",
      width: "14px",
      height: "14px",
      borderRadius: "50%",
      background: isOnline ? "#10b981" : "#ef4444",
      border: "2px solid #0f141e",
      boxShadow: isOnline ? "0 0 8px rgba(16,185,129,0.6)" : "0 0 6px rgba(239,68,68,0.4)"
    });
    avatarWrapper.append(avatar2, onlineIndicator);
    const info = document.createElement("div");
    style2(info, { display: "flex", flexDirection: "column", gap: "2px", alignItems: "center", width: "100%" });
    const name = document.createElement("div");
    style2(name, {
      fontSize: "13px",
      fontWeight: "600",
      color: "#e7eef7",
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      maxWidth: "100%",
      textAlign: "center"
    });
    name.textContent = player2.playerName || "Unknown";
    info.append(name);
    const buttonState = getButtonState(player2.playerId);
    if (buttonState === "remove") {
      const friendsText = document.createElement("div");
      friendsText.innerHTML = `
      <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; vertical-align: middle; margin-right: 4px;">
        <polyline points="20 6 9 17 4 12"/>
      </svg>
      Already friends
    `;
      style2(friendsText, {
        padding: "6px 12px",
        borderRadius: "8px",
        background: "rgba(16,185,129,0.12)",
        color: "#10b981",
        fontSize: "12px",
        fontWeight: "600",
        textAlign: "center",
        width: "100%",
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      });
      card2.append(avatarWrapper, info, friendsText);
    } else if (buttonState === "cancel") {
      const requestSentText = document.createElement("div");
      requestSentText.innerHTML = `
      <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; vertical-align: middle; margin-right: 4px;">
        <circle cx="12" cy="12" r="10"/>
        <polyline points="12 6 12 12 16 14"/>
      </svg>
      Request sent
    `;
      style2(requestSentText, {
        padding: "6px 12px",
        borderRadius: "8px",
        background: "rgba(251,191,36,0.12)",
        color: "#fbbf24",
        fontSize: "12px",
        fontWeight: "600",
        textAlign: "center",
        width: "100%",
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      });
      card2.append(avatarWrapper, info, requestSentText);
    } else {
      const actionButton = document.createElement("button");
      if (buttonState === "add") {
        actionButton.textContent = "Add Friend";
        style2(actionButton, {
          padding: "6px 12px",
          border: "1px solid rgba(94,234,212,0.35)",
          borderRadius: "8px",
          background: "rgba(94,234,212,0.12)",
          color: "#5eead4",
          fontSize: "11px",
          fontWeight: "600",
          cursor: "pointer",
          transition: "all 120ms ease",
          width: "100%"
        });
        actionButton.onmouseenter = () => style2(actionButton, { background: "rgba(94,234,212,0.2)" });
        actionButton.onmouseleave = () => style2(actionButton, { background: "rgba(94,234,212,0.12)" });
      } else if (buttonState === "pending") {
        actionButton.textContent = "Pending Request";
        style2(actionButton, {
          padding: "6px 12px",
          border: "1px solid rgba(255,255,255,0.12)",
          borderRadius: "8px",
          background: "rgba(255,255,255,0.04)",
          color: "rgba(226,232,240,0.5)",
          fontSize: "11px",
          fontWeight: "600",
          cursor: "not-allowed",
          transition: "all 120ms ease",
          width: "100%"
        });
      }
      actionButton.onclick = async (e) => {
        e.stopPropagation();
        if (buttonState === "add") {
          card2.style.animation = "none";
          void card2.offsetWidth;
          card2.style.animation = "qws-card-bounce 250ms ease";
          actionButton.disabled = true;
          actionButton.textContent = "Sending...";
          style2(actionButton, { cursor: "not-allowed", opacity: "0.6" });
          const success = await sendFriendRequest(player2.playerId);
          if (!success) {
            console.error(`[AddFriends] Failed to send friend request to ${player2.playerName}`);
            actionButton.disabled = false;
            actionButton.textContent = "Add Friend";
            style2(actionButton, { cursor: "pointer", opacity: "1" });
          }
        }
      };
      card2.append(avatarWrapper, info, actionButton);
    }
    const badgesEl = createPlayerBadges(player2.badges, true);
    if (badgesEl) {
      style2(badgesEl, {
        position: "absolute",
        top: "8px",
        right: "8px",
        flexDirection: "column",
        alignItems: "flex-end",
        justifyContent: "flex-start",
        gap: "3px"
      });
      card2.appendChild(badgesEl);
    }
    return card2;
  }

  // src/ui/menus/communityHub/tabs/requestsSubTab.ts
  function createRequestsSubTab() {
    const container = document.createElement("div");
    style2(container, { display: "flex", flexDirection: "column", height: "100%", gap: "16px", overflow: "auto" });
    const incomingSection = document.createElement("div");
    style2(incomingSection, { display: "flex", flexDirection: "column", gap: "10px" });
    const incomingHeader = document.createElement("div");
    style2(incomingHeader, {
      fontSize: "14px",
      fontWeight: "700",
      color: "#e7eef7",
      paddingBottom: "4px",
      borderBottom: "1px solid rgba(255,255,255,0.08)"
    });
    incomingHeader.textContent = "Incoming Requests";
    const incomingList = document.createElement("div");
    style2(incomingList, { display: "flex", flexDirection: "column", gap: "8px" });
    const outgoingSection = document.createElement("div");
    style2(outgoingSection, { display: "flex", flexDirection: "column", gap: "10px" });
    const outgoingHeader = document.createElement("div");
    style2(outgoingHeader, {
      fontSize: "14px",
      fontWeight: "700",
      color: "#e7eef7",
      paddingBottom: "4px",
      borderBottom: "1px solid rgba(255,255,255,0.08)"
    });
    outgoingHeader.textContent = "Outgoing Requests";
    const outgoingList = document.createElement("div");
    style2(outgoingList, { display: "flex", flexDirection: "column", gap: "8px" });
    const renderRequests = () => {
      const incomingRequests = getCachedIncomingRequestsWithViews();
      const outgoingRequests = getCachedOutgoingRequests();
      incomingList.innerHTML = "";
      if (incomingRequests.length === 0) {
        const empty = document.createElement("div");
        style2(empty, { padding: "20px", textAlign: "center", color: "rgba(226,232,240,0.5)", fontSize: "12px" });
        empty.textContent = "No incoming requests";
        incomingList.appendChild(empty);
      } else {
        for (const request2 of incomingRequests) {
          incomingList.appendChild(createIncomingRequestCard(request2));
        }
      }
      outgoingList.innerHTML = "";
      if (outgoingRequests.length === 0) {
        const empty = document.createElement("div");
        style2(empty, { padding: "20px", textAlign: "center", color: "rgba(226,232,240,0.5)", fontSize: "12px" });
        empty.textContent = "No outgoing requests";
        outgoingList.appendChild(empty);
      } else {
        for (const request2 of outgoingRequests) {
          outgoingList.appendChild(createOutgoingRequestCard(request2));
        }
      }
    };
    const onRequestsRefresh = () => renderRequests();
    window.addEventListener(CH_EVENTS.FRIEND_REQUESTS_REFRESH, onRequestsRefresh);
    renderRequests();
    incomingSection.append(incomingHeader, incomingList);
    outgoingSection.append(outgoingHeader, outgoingList);
    container.append(incomingSection, outgoingSection);
    return {
      root: container,
      destroy() {
        window.removeEventListener(CH_EVENTS.FRIEND_REQUESTS_REFRESH, onRequestsRefresh);
      }
    };
  }
  function createIncomingRequestCard(request2) {
    const card2 = document.createElement("div");
    style2(card2, {
      display: "flex",
      alignItems: "center",
      gap: "12px",
      padding: "12px",
      border: "1px solid rgba(255,255,255,0.08)",
      borderRadius: "12px",
      background: "rgba(255,255,255,0.03)",
      transition: "all 120ms ease"
    });
    card2.onmouseenter = () => style2(card2, { background: "rgba(255,255,255,0.06)", borderColor: "rgba(94,234,212,0.25)" });
    card2.onmouseleave = () => style2(card2, { background: "rgba(255,255,255,0.03)", borderColor: "rgba(255,255,255,0.08)" });
    const avatar2 = document.createElement("div");
    style2(avatar2, {
      width: "48px",
      height: "48px",
      borderRadius: "50%",
      background: request2.avatarUrl ? `url(${request2.avatarUrl}) center/cover` : "linear-gradient(135deg, rgba(94,234,212,0.3), rgba(59,130,246,0.3))",
      border: "2px solid rgba(255,255,255,0.1)",
      flexShrink: "0"
    });
    const info = document.createElement("div");
    style2(info, { flex: "1", display: "flex", flexDirection: "column", gap: "4px", minWidth: "0" });
    const nameRow = document.createElement("div");
    style2(nameRow, { display: "flex", alignItems: "center", gap: "6px", minWidth: "0" });
    const name = document.createElement("div");
    style2(name, { fontSize: "13px", fontWeight: "600", color: "#e7eef7", overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" });
    name.textContent = request2.playerName || "Unknown";
    nameRow.appendChild(name);
    const badgesEl = createPlayerBadges(request2.badges, true);
    if (badgesEl) {
      style2(badgesEl, { flexShrink: "0" });
      nameRow.appendChild(badgesEl);
    }
    const time = document.createElement("div");
    style2(time, { fontSize: "11px", color: "rgba(226,232,240,0.5)" });
    time.textContent = formatRelativeTime(request2.createdAt);
    info.append(nameRow, time);
    const buttonsContainer = document.createElement("div");
    style2(buttonsContainer, { display: "flex", gap: "8px", flexShrink: "0" });
    const acceptButton = document.createElement("button");
    acceptButton.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>`;
    style2(acceptButton, {
      padding: "8px 12px",
      border: "1px solid rgba(16,185,129,0.35)",
      borderRadius: "8px",
      background: "rgba(16,185,129,0.12)",
      color: "#10b981",
      cursor: "pointer",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transition: "all 120ms ease"
    });
    acceptButton.onmouseenter = () => style2(acceptButton, { background: "rgba(16,185,129,0.2)", borderColor: "rgba(16,185,129,0.5)" });
    acceptButton.onmouseleave = () => style2(acceptButton, { background: "rgba(16,185,129,0.12)", borderColor: "rgba(16,185,129,0.35)" });
    const declineButton = document.createElement("button");
    declineButton.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>`;
    style2(declineButton, {
      padding: "8px 12px",
      border: "1px solid rgba(239,68,68,0.35)",
      borderRadius: "8px",
      background: "rgba(239,68,68,0.12)",
      color: "#ef4444",
      cursor: "pointer",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transition: "all 120ms ease"
    });
    declineButton.onmouseenter = () => style2(declineButton, { background: "rgba(239,68,68,0.2)", borderColor: "rgba(239,68,68,0.5)" });
    declineButton.onmouseleave = () => style2(declineButton, { background: "rgba(239,68,68,0.12)", borderColor: "rgba(239,68,68,0.35)" });
    acceptButton.onclick = async (e) => {
      e.stopPropagation();
      acceptButton.disabled = true;
      declineButton.disabled = true;
      style2(acceptButton, { cursor: "not-allowed", opacity: "0.6" });
      style2(declineButton, { cursor: "not-allowed", opacity: "0.6" });
      const success = await respondFriendRequest({ otherPlayerId: request2.playerId, action: "accept" });
      if (!success) {
        console.error(`[Requests] Failed to accept friend request from ${request2.playerName}`);
        acceptButton.disabled = false;
        declineButton.disabled = false;
        style2(acceptButton, { cursor: "pointer", opacity: "1" });
        style2(declineButton, { cursor: "pointer", opacity: "1" });
      }
    };
    declineButton.onclick = async (e) => {
      e.stopPropagation();
      acceptButton.disabled = true;
      declineButton.disabled = true;
      style2(acceptButton, { cursor: "not-allowed", opacity: "0.6" });
      style2(declineButton, { cursor: "not-allowed", opacity: "0.6" });
      const success = await respondFriendRequest({ otherPlayerId: request2.playerId, action: "reject" });
      if (!success) {
        console.error(`[Requests] Failed to decline friend request from ${request2.playerName}`);
        acceptButton.disabled = false;
        declineButton.disabled = false;
        style2(acceptButton, { cursor: "pointer", opacity: "1" });
        style2(declineButton, { cursor: "pointer", opacity: "1" });
      }
    };
    buttonsContainer.append(acceptButton, declineButton);
    card2.append(avatar2, info, buttonsContainer);
    return card2;
  }
  function createOutgoingRequestCard(request2) {
    const card2 = document.createElement("div");
    style2(card2, {
      display: "flex",
      alignItems: "center",
      gap: "12px",
      padding: "12px",
      border: "1px solid rgba(255,255,255,0.08)",
      borderRadius: "12px",
      background: "rgba(255,255,255,0.03)",
      transition: "all 120ms ease"
    });
    card2.onmouseenter = () => style2(card2, { background: "rgba(255,255,255,0.06)", borderColor: "rgba(94,234,212,0.25)" });
    card2.onmouseleave = () => style2(card2, { background: "rgba(255,255,255,0.03)", borderColor: "rgba(255,255,255,0.08)" });
    const avatar2 = document.createElement("div");
    style2(avatar2, {
      width: "48px",
      height: "48px",
      borderRadius: "50%",
      background: request2.avatarUrl ? `url(${request2.avatarUrl}) center/cover` : "linear-gradient(135deg, rgba(94,234,212,0.3), rgba(59,130,246,0.3))",
      border: "2px solid rgba(255,255,255,0.1)",
      flexShrink: "0"
    });
    const info = document.createElement("div");
    style2(info, { flex: "1", display: "flex", flexDirection: "column", gap: "4px", minWidth: "0" });
    const nameRow = document.createElement("div");
    style2(nameRow, { display: "flex", alignItems: "center", gap: "6px", minWidth: "0" });
    const name = document.createElement("div");
    style2(name, { fontSize: "13px", fontWeight: "600", color: "#e7eef7", overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" });
    name.textContent = request2.playerName || "Unknown";
    nameRow.appendChild(name);
    const outBadgesEl = createPlayerBadges(request2.badges, true);
    if (outBadgesEl) {
      style2(outBadgesEl, { flexShrink: "0" });
      nameRow.appendChild(outBadgesEl);
    }
    const time = document.createElement("div");
    style2(time, { fontSize: "11px", color: "rgba(226,232,240,0.5)" });
    time.textContent = formatRelativeTime(request2.createdAt);
    info.append(nameRow, time);
    const cancelButton = document.createElement("button");
    cancelButton.textContent = "Cancel";
    style2(cancelButton, {
      padding: "8px 16px",
      border: "1px solid rgba(251,191,36,0.35)",
      borderRadius: "8px",
      background: "rgba(251,191,36,0.12)",
      color: "#fbbf24",
      fontSize: "12px",
      fontWeight: "600",
      cursor: "pointer",
      flexShrink: "0",
      transition: "all 120ms ease"
    });
    cancelButton.onmouseenter = () => style2(cancelButton, { background: "rgba(251,191,36,0.2)", borderColor: "rgba(251,191,36,0.5)" });
    cancelButton.onmouseleave = () => style2(cancelButton, { background: "rgba(251,191,36,0.12)", borderColor: "rgba(251,191,36,0.35)" });
    cancelButton.onclick = async (e) => {
      e.stopPropagation();
      cancelButton.disabled = true;
      cancelButton.textContent = "Cancelling...";
      style2(cancelButton, { cursor: "not-allowed", opacity: "0.6" });
      const success = await cancelFriendRequest(request2.toPlayerId);
      if (!success) {
        console.error(`[Requests] Failed to cancel friend request to ${request2.playerName}`);
        cancelButton.disabled = false;
        cancelButton.textContent = "Cancel";
        style2(cancelButton, { cursor: "pointer", opacity: "1" });
      }
    };
    card2.append(avatar2, info, cancelButton);
    return card2;
  }

  // src/ui/menus/communityHub/tabs/communityTab.ts
  function createCommunityTab() {
    ensureSharedStyles();
    const root = document.createElement("div");
    style2(root, { display: "flex", flexDirection: "column", height: "100%", overflow: "hidden" });
    let currentDetailView = null;
    const showPlayerDetail = async (player2) => {
      style2(tabsHeader, { display: "none" });
      style2(tabContainer, { display: "none" });
      const loadingView = createLoadingView(async () => {
        await stopAnyPreview();
        if (currentDetailView) {
          currentDetailView.remove();
          currentDetailView = null;
        }
        style2(tabsHeader, { display: "flex" });
        style2(tabContainer, { display: "block" });
      });
      currentDetailView = loadingView;
      root.appendChild(loadingView);
      const playerDetails = await fetchPlayerDetailsComplete(player2.playerId);
      if (!playerDetails) {
        if (currentDetailView) {
          currentDetailView.remove();
          currentDetailView = null;
        }
        const errorView = createErrorView("Failed to load player details", async () => {
          await stopAnyPreview();
          if (currentDetailView) {
            currentDetailView.remove();
            currentDetailView = null;
          }
          style2(tabsHeader, { display: "flex" });
          style2(tabContainer, { display: "block" });
        });
        currentDetailView = errorView;
        root.appendChild(errorView);
        return;
      }
      const detailView = await createPlayerDetailView({
        player: playerDetails,
        onBack: async () => {
          await stopAnyPreview();
          if (currentDetailView) {
            currentDetailView.remove();
            currentDetailView = null;
          }
          style2(tabsHeader, { display: "flex" });
          style2(tabContainer, { display: "block" });
        }
      });
      if (currentDetailView) {
        currentDetailView.remove();
        currentDetailView = null;
      }
      currentDetailView = detailView;
      root.appendChild(currentDetailView);
    };
    const tabsHeader = document.createElement("div");
    style2(tabsHeader, {
      display: "flex",
      gap: "8px",
      padding: "0 0 12px 0",
      borderBottom: "1px solid rgba(255,255,255,0.08)",
      marginBottom: "12px"
    });
    const tabButtons = {
      "my-friends": createTabButton("My Friends", true),
      "add-friends": createTabButton("Add Friends", false),
      "requests": createTabButton("Requests", false)
    };
    const requestsBadge = createSubTabBadge();
    tabButtons["requests"].style.position = "relative";
    tabButtons["requests"].appendChild(requestsBadge);
    tabsHeader.append(tabButtons["my-friends"], tabButtons["add-friends"], tabButtons["requests"]);
    const myFriendsTab = createMyFriendsSubTab(showPlayerDetail);
    const addFriendsTab = createAddFriendsSubTab();
    const requestsTab = createRequestsSubTab();
    const tabContents = {
      "my-friends": myFriendsTab.root,
      "add-friends": addFriendsTab.root,
      "requests": requestsTab.root
    };
    const tabContainer = document.createElement("div");
    style2(tabContainer, { flex: "1", overflow: "hidden", position: "relative" });
    for (const [id, content] of Object.entries(tabContents)) {
      style2(content, { display: id === "my-friends" ? "flex" : "none", height: "100%" });
      tabContainer.appendChild(content);
    }
    root.append(tabsHeader, tabContainer);
    let activeTab = "my-friends";
    const switchTab = (tabId) => {
      if (activeTab === tabId) return;
      style2(tabContents[activeTab], { display: "none" });
      tabButtons[activeTab].classList.remove("active");
      style2(tabButtons[activeTab], { background: "transparent", color: "#c9d4e6" });
      activeTab = tabId;
      style2(tabContents[tabId], { display: "flex" });
      tabButtons[tabId].classList.add("active");
      style2(tabButtons[tabId], { background: "rgba(94,234,212,0.18)", color: "#ecfdf5" });
    };
    tabButtons["my-friends"].onclick = () => switchTab("my-friends");
    tabButtons["add-friends"].onclick = () => switchTab("add-friends");
    tabButtons["requests"].onclick = () => switchTab("requests");
    const updateRequestsBadge = () => {
      const count = getIncomingRequestsCount();
      if (count <= 0) {
        requestsBadge.style.display = "none";
        return;
      }
      requestsBadge.style.display = "inline-flex";
      requestsBadge.textContent = count > 99 ? "99+" : String(count);
    };
    const onRequestsRefresh = () => updateRequestsBadge();
    window.addEventListener(CH_EVENTS.FRIEND_REQUESTS_REFRESH, onRequestsRefresh);
    updateRequestsBadge();
    return {
      id: "community",
      root,
      show: () => style2(root, { display: "flex" }),
      hide: () => style2(root, { display: "none" }),
      destroy: () => {
        window.removeEventListener(CH_EVENTS.FRIEND_REQUESTS_REFRESH, onRequestsRefresh);
        myFriendsTab.destroy();
        addFriendsTab.destroy();
        requestsTab.destroy();
        root.remove();
      }
    };
  }
  function createTabButton(label2, active) {
    const btn = document.createElement("button");
    btn.textContent = label2;
    btn.className = active ? "active" : "";
    style2(btn, {
      flex: "1",
      padding: "8px 16px",
      border: "1px solid rgba(255,255,255,0.08)",
      borderRadius: "8px",
      background: active ? "rgba(94,234,212,0.18)" : "transparent",
      color: active ? "#ecfdf5" : "#c9d4e6",
      fontSize: "12px",
      fontWeight: "600",
      cursor: "pointer",
      transition: "all 120ms ease"
    });
    btn.onmouseenter = () => {
      if (!btn.classList.contains("active")) {
        style2(btn, { background: "rgba(94,234,212,0.08)", color: "#e7eef7" });
      }
    };
    btn.onmouseleave = () => {
      if (!btn.classList.contains("active")) {
        style2(btn, { background: "transparent", color: "#c9d4e6" });
      }
    };
    return btn;
  }
  function createSubTabBadge() {
    const badge = document.createElement("span");
    style2(badge, {
      position: "absolute",
      top: "50%",
      right: "8px",
      transform: "translateY(-50%)",
      minWidth: "18px",
      height: "18px",
      padding: "0 5px",
      borderRadius: "999px",
      background: "#ef4444",
      color: "#fff",
      fontSize: "10px",
      fontWeight: "700",
      display: "none",
      alignItems: "center",
      justifyContent: "center",
      lineHeight: "1"
    });
    return badge;
  }

  // src/ui/menus/communityHub/tabs/roomTab.ts
  function createRoomTab() {
    ensureSharedStyles();
    const root = document.createElement("div");
    style2(root, {
      display: "flex",
      flexDirection: "column",
      height: "100%",
      gap: "12px"
    });
    const controlsContainer = document.createElement("div");
    style2(controlsContainer, {
      display: "flex",
      gap: "8px",
      alignItems: "center"
    });
    const filterSelect = document.createElement("select");
    filterSelect.innerHTML = `
    <option value="5">5 Players</option>
    <option value="4">4 Players</option>
    <option value="3-1">3-1 Players</option>
    <option value="all">All Rooms</option>
  `;
    style2(filterSelect, {
      flex: "1",
      padding: "10px 14px",
      border: "1px solid rgba(255,255,255,0.12)",
      borderRadius: "10px",
      background: "rgba(255,255,255,0.04)",
      color: "#e7eef7",
      fontSize: "13px",
      outline: "none",
      cursor: "pointer",
      transition: "border-color 150ms ease"
    });
    const refreshButton = document.createElement("button");
    refreshButton.innerHTML = `
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="23 4 23 10 17 10"/>
      <polyline points="1 20 1 14 7 14"/>
      <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/>
    </svg>
  `;
    style2(refreshButton, {
      padding: "10px 16px",
      border: "1px solid rgba(255,255,255,0.12)",
      borderRadius: "10px",
      background: "rgba(94,234,212,0.12)",
      color: "#5eead4",
      cursor: "pointer",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transition: "all 120ms ease"
    });
    refreshButton.onmouseenter = () => {
      style2(refreshButton, {
        background: "rgba(94,234,212,0.2)",
        borderColor: "rgba(94,234,212,0.35)"
      });
    };
    refreshButton.onmouseleave = () => {
      style2(refreshButton, {
        background: "rgba(94,234,212,0.12)",
        borderColor: "rgba(255,255,255,0.12)"
      });
    };
    controlsContainer.append(filterSelect, refreshButton);
    let allRooms = [];
    let isLoading = false;
    let lastRefreshTime = null;
    let hasLoadedInitial = false;
    const truncateRoomId = (roomId) => {
      if (roomId.length <= 30) return roomId;
      return roomId.substring(0, 27) + "...";
    };
    const footer = document.createElement("div");
    style2(footer, {
      padding: "8px 12px",
      borderTop: "1px solid rgba(255,255,255,0.06)",
      fontSize: "11px",
      color: "rgba(226,232,240,0.4)",
      textAlign: "center"
    });
    const updateFooterTimestamp = () => {
      if (lastRefreshTime) {
        footer.textContent = formatTimestamp(lastRefreshTime);
      } else {
        footer.textContent = "\u2014";
      }
    };
    updateFooterTimestamp();
    const roomsList = document.createElement("div");
    roomsList.className = "qws-ch-scrollable";
    style2(roomsList, {
      flex: "1",
      overflow: "auto",
      display: "flex",
      flexDirection: "column",
      gap: "8px",
      paddingRight: "8px"
    });
    const filterRooms = (rooms, filter) => {
      if (filter === "all") return rooms;
      if (filter === "5") {
        return rooms.filter((r) => r.playersCount === 5);
      }
      if (filter === "4") {
        return rooms.filter((r) => r.playersCount === 4);
      }
      if (filter === "3-1") {
        return rooms.filter((r) => r.playersCount >= 1 && r.playersCount <= 3);
      }
      return rooms;
    };
    const renderRooms = (rooms) => {
      roomsList.innerHTML = "";
      if (isLoading) {
        const loading = document.createElement("div");
        style2(loading, {
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          justifyContent: "center",
          height: "100%",
          gap: "12px",
          color: "rgba(226,232,240,0.5)",
          fontSize: "13px"
        });
        loading.innerHTML = `
        <svg width="32" height="32" viewBox="0 0 24 24" fill="none" style="animation: spin 1s linear infinite;">
          <circle cx="12" cy="12" r="10" stroke="rgba(94,234,212,0.5)" stroke-width="2" stroke-dasharray="15 5" fill="none"/>
        </svg>
        <div>Loading rooms...</div>
      `;
        roomsList.appendChild(loading);
        return;
      }
      if (rooms.length === 0) {
        const empty = document.createElement("div");
        style2(empty, {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          height: "100%",
          color: "rgba(226,232,240,0.5)",
          fontSize: "13px"
        });
        empty.textContent = "No rooms found";
        roomsList.appendChild(empty);
        return;
      }
      for (const room of rooms) {
        roomsList.appendChild(createRoomCard2(room));
      }
    };
    const createRoomCard2 = (room) => {
      const card2 = document.createElement("div");
      style2(card2, {
        padding: "12px",
        background: "rgba(255,255,255,0.02)",
        borderRadius: "10px",
        border: "1px solid rgba(255,255,255,0.06)",
        display: "flex",
        alignItems: "center",
        gap: "12px",
        transition: "all 120ms ease"
      });
      card2.onmouseenter = () => {
        style2(card2, {
          background: "rgba(255,255,255,0.04)",
          borderColor: "rgba(94,234,212,0.15)"
        });
      };
      card2.onmouseleave = () => {
        style2(card2, {
          background: "rgba(255,255,255,0.02)",
          borderColor: "rgba(255,255,255,0.06)"
        });
      };
      const leftWrapper = document.createElement("div");
      style2(leftWrapper, {
        display: "flex",
        gap: "8px",
        flex: "1",
        alignItems: "center"
      });
      const roomId = document.createElement("div");
      style2(roomId, {
        fontSize: "12px",
        fontWeight: "600",
        color: "#e7eef7",
        whiteSpace: "nowrap"
      });
      roomId.textContent = truncateRoomId(room.id);
      roomId.title = room.id;
      const avatarsContainer = document.createElement("div");
      style2(avatarsContainer, {
        display: "flex",
        gap: "4px",
        flex: "1"
      });
      const maxSlots = 6;
      const userSlots = room.userSlots || [];
      for (let i = 0; i < maxSlots; i++) {
        const avatarSlot = document.createElement("div");
        const slotData = userSlots[i];
        const avatarUrl = slotData?.avatarUrl || slotData?.avatar_url;
        if (slotData && avatarUrl) {
          style2(avatarSlot, {
            width: "28px",
            height: "28px",
            borderRadius: "50%",
            background: `url(${avatarUrl}) center/cover`,
            border: "2px solid rgba(94,234,212,0.3)",
            flexShrink: "0"
          });
          avatarSlot.title = slotData.name || "Player";
        } else if (i < room.playersCount) {
          style2(avatarSlot, {
            width: "28px",
            height: "28px",
            borderRadius: "50%",
            background: "linear-gradient(135deg, rgba(94,234,212,0.2), rgba(59,130,246,0.2))",
            border: "2px solid rgba(94,234,212,0.3)",
            flexShrink: "0"
          });
        } else {
          style2(avatarSlot, {
            width: "28px",
            height: "28px",
            borderRadius: "50%",
            background: "rgba(255,255,255,0.03)",
            border: "2px dashed rgba(255,255,255,0.1)",
            flexShrink: "0"
          });
        }
        avatarsContainer.appendChild(avatarSlot);
      }
      leftWrapper.append(roomId, avatarsContainer);
      const counter = document.createElement("div");
      style2(counter, {
        fontSize: "11px",
        color: "rgba(226,232,240,0.5)",
        fontWeight: "500",
        whiteSpace: "nowrap",
        minWidth: "40px",
        textAlign: "right"
      });
      counter.textContent = `${room.playersCount}/6`;
      const joinButton = document.createElement("button");
      const isFull = room.playersCount >= 6;
      joinButton.textContent = isFull ? "Full" : "Join";
      joinButton.disabled = isFull;
      style2(joinButton, {
        padding: "6px 14px",
        border: isFull ? "1px solid rgba(255,255,255,0.1)" : "1px solid rgba(94,234,212,0.3)",
        borderRadius: "6px",
        background: isFull ? "rgba(255,255,255,0.03)" : "rgba(94,234,212,0.1)",
        color: isFull ? "rgba(226,232,240,0.4)" : "#5eead4",
        fontSize: "12px",
        fontWeight: "600",
        cursor: isFull ? "not-allowed" : "pointer",
        transition: "all 120ms ease",
        flexShrink: "0",
        opacity: isFull ? "0.5" : "1"
      });
      if (!isFull) {
        joinButton.onmouseenter = () => {
          style2(joinButton, {
            background: "rgba(94,234,212,0.2)",
            borderColor: "rgba(94,234,212,0.5)"
          });
        };
        joinButton.onmouseleave = () => {
          style2(joinButton, {
            background: "rgba(94,234,212,0.1)",
            borderColor: "rgba(94,234,212,0.3)"
          });
        };
        joinButton.onclick = (e) => {
          e.stopPropagation();
          window.location.href = `https://magicgarden.gg/r/${room.id}`;
        };
      }
      card2.append(leftWrapper, counter, joinButton);
      return card2;
    };
    const loadRooms = async (forceRefresh = false) => {
      isLoading = true;
      renderRooms([]);
      try {
        let rooms;
        if (!forceRefresh) {
          const cachedRooms = getCachedPublicRooms();
          if (cachedRooms && cachedRooms.length > 0) {
            rooms = cachedRooms;
          } else {
            rooms = await fetchAvailableRooms(500);
          }
        } else {
          rooms = await fetchAvailableRooms(500);
        }
        allRooms = rooms;
        const filter = filterSelect.value;
        const filtered = filterRooms(rooms, filter);
        isLoading = false;
        lastRefreshTime = /* @__PURE__ */ new Date();
        updateFooterTimestamp();
        renderRooms(filtered);
      } catch (error) {
        console.error("[Rooms] Failed to load rooms:", error);
        isLoading = false;
        renderRooms([]);
      }
    };
    refreshButton.onclick = () => {
      loadRooms(true);
    };
    filterSelect.onchange = () => {
      const filter = filterSelect.value;
      const filtered = filterRooms(allRooms, filter);
      renderRooms(filtered);
    };
    const unsubscribeWelcome = onWelcome((data) => {
      if (!hasLoadedInitial && data.publicRooms && data.publicRooms.length > 0) {
        hasLoadedInitial = true;
        allRooms = data.publicRooms;
        const filter = filterSelect.value;
        const filtered = filterRooms(data.publicRooms, filter);
        lastRefreshTime = /* @__PURE__ */ new Date();
        updateFooterTimestamp();
        renderRooms(filtered);
      } else if (!hasLoadedInitial) {
        hasLoadedInitial = true;
        loadRooms(false);
      }
    });
    root.append(controlsContainer, roomsList, footer);
    return {
      id: "room",
      root,
      show: () => style2(root, { display: "flex" }),
      hide: () => style2(root, { display: "none" }),
      destroy: () => {
        unsubscribeWelcome();
        root.remove();
      }
    };
  }

  // src/ui/menus/communityHub/tabs/myGroupsSubTab.ts
  function createMyGroupsSubTab(showGroupDetail, showGroupCreate) {
    ensureSharedStyles();
    const container = document.createElement("div");
    style2(container, { display: "flex", flexDirection: "column", height: "100%", gap: "12px" });
    const searchBar = document.createElement("input");
    searchBar.type = "text";
    searchBar.placeholder = "Search my groups...";
    style2(searchBar, {
      padding: "10px 14px",
      border: "1px solid rgba(255,255,255,0.12)",
      borderRadius: "10px",
      background: "rgba(255,255,255,0.04)",
      color: "#e7eef7",
      fontSize: "13px",
      outline: "none",
      transition: "border-color 150ms ease"
    });
    const keyBlocker = createKeyBlocker(() => document.activeElement === searchBar);
    keyBlocker.attach();
    searchBar.onfocus = () => style2(searchBar, { borderColor: "rgba(94,234,212,0.35)" });
    searchBar.onblur = () => style2(searchBar, { borderColor: "rgba(255,255,255,0.12)" });
    const groupsList = document.createElement("div");
    groupsList.className = "qws-ch-scrollable";
    style2(groupsList, {
      flex: "1",
      overflow: "auto",
      display: "grid",
      gridTemplateColumns: "repeat(auto-fill, minmax(200px, 1fr))",
      gap: "10px",
      alignContent: "start",
      padding: "6px 8px 6px 6px"
      // Padding to prevent cards from being clipped during hover animations
    });
    const renderGroups = (filter = "") => {
      groupsList.innerHTML = "";
      const welcome = getWelcomeCache();
      const groups2 = welcome?.groups || [];
      const filtered = filter ? groups2.filter((g) => g.name?.toLowerCase().includes(filter.toLowerCase())) : groups2;
      if (!filter) {
        groupsList.appendChild(createGroupCreateCard(showGroupCreate));
      }
      if (filtered.length === 0 && filter) {
        const empty = document.createElement("div");
        style2(empty, {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          height: "100%",
          color: "rgba(226,232,240,0.5)",
          fontSize: "13px",
          gridColumn: "1 / -1"
        });
        empty.textContent = "No groups found";
        groupsList.appendChild(empty);
        return;
      }
      const sorted = [...filtered].sort((a, b) => {
        const aTime = a.updatedAt ? new Date(a.updatedAt).getTime() : 0;
        const bTime = b.updatedAt ? new Date(b.updatedAt).getTime() : 0;
        return bTime - aTime;
      });
      for (const group of sorted) {
        const groupSummary = {
          ...group,
          id: String(group.id),
          role: group.role
        };
        groupsList.appendChild(createGroupCard(groupSummary, showGroupDetail));
      }
    };
    renderGroups();
    searchBar.oninput = () => renderGroups(searchBar.value);
    const onGroupsRefresh = () => renderGroups(searchBar.value);
    window.addEventListener(CH_EVENTS.GROUPS_REFRESH, onGroupsRefresh);
    container.append(searchBar, groupsList);
    return {
      root: container,
      destroy() {
        keyBlocker.detach();
        window.removeEventListener(CH_EVENTS.GROUPS_REFRESH, onGroupsRefresh);
      }
    };
  }
  function createGroupCard(group, onClick) {
    const card2 = document.createElement("div");
    style2(card2, {
      display: "flex",
      flexDirection: "column",
      gap: "12px",
      padding: "14px",
      border: "1px solid rgba(255,255,255,0.08)",
      borderRadius: "12px",
      background: "rgba(255,255,255,0.03)",
      cursor: "pointer",
      transition: "all 120ms ease"
    });
    card2.onclick = () => onClick(group);
    card2.onmouseenter = () => {
      style2(card2, { background: "rgba(255,255,255,0.06)", borderColor: "rgba(94,234,212,0.25)", transform: "translateY(-2px)" });
    };
    card2.onmouseleave = () => {
      style2(card2, { background: "rgba(255,255,255,0.03)", borderColor: "rgba(255,255,255,0.08)", transform: "translateY(0)" });
    };
    const header = document.createElement("div");
    style2(header, { display: "flex", alignItems: "center", gap: "8px" });
    const visibilityIcon = document.createElement("div");
    style2(visibilityIcon, {
      flexShrink: "0",
      display: "flex",
      alignItems: "center",
      color: "rgba(226,232,240,0.5)"
    });
    if (group.isPublic) {
      visibilityIcon.innerHTML = `
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="10"/>
        <path d="M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
      </svg>
    `;
    } else {
      visibilityIcon.innerHTML = `
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
        <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
      </svg>
    `;
    }
    const name = document.createElement("div");
    style2(name, {
      fontSize: "13px",
      fontWeight: "600",
      color: "#e7eef7",
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      flex: "1"
    });
    name.textContent = group.name || "Unnamed Group";
    const roleBadge = document.createElement("div");
    style2(roleBadge, {
      padding: "2px 8px",
      borderRadius: "6px",
      fontSize: "10px",
      fontWeight: "600",
      textTransform: "uppercase",
      flexShrink: "0"
    });
    if (group.role === "owner") {
      style2(roleBadge, { background: "rgba(251,191,36,0.2)", color: "#fbbf24" });
      roleBadge.textContent = "Owner";
    } else if (group.role === "admin") {
      style2(roleBadge, { background: "rgba(139,92,246,0.2)", color: "#a78bfa" });
      roleBadge.textContent = "Admin";
    } else {
      style2(roleBadge, { background: "rgba(94,234,212,0.2)", color: "#5eead4" });
      roleBadge.textContent = "Member";
    }
    header.append(visibilityIcon, name, roleBadge);
    const avatarsRow = document.createElement("div");
    style2(avatarsRow, { display: "flex", alignItems: "center", gap: "6px" });
    const previewMembers = group.previewMembers || [];
    const avatarsContainer = document.createElement("div");
    style2(avatarsContainer, { display: "flex", marginLeft: "-4px" });
    for (let i = 0; i < Math.min(3, previewMembers.length); i++) {
      const member = previewMembers[i];
      const avatar2 = document.createElement("div");
      style2(avatar2, {
        width: "28px",
        height: "28px",
        borderRadius: "50%",
        background: member.avatarUrl || member.discordAvatarUrl ? `url(${member.avatarUrl || member.discordAvatarUrl}) center/cover` : "linear-gradient(135deg, rgba(94,234,212,0.3), rgba(59,130,246,0.3))",
        border: "2px solid #0f141e",
        marginLeft: i > 0 ? "-8px" : "0"
      });
      avatarsContainer.appendChild(avatar2);
    }
    const memberCount = document.createElement("div");
    style2(memberCount, {
      fontSize: "11px",
      color: "rgba(226,232,240,0.6)",
      marginLeft: "auto"
    });
    const count = group.memberCount || group.membersCount || 0;
    memberCount.textContent = `${count} member${count !== 1 ? "s" : ""}`;
    avatarsRow.append(avatarsContainer, memberCount);
    card2.append(header, avatarsRow);
    return card2;
  }
  function createGroupCreateCard(onClick) {
    const card2 = document.createElement("div");
    style2(card2, {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center",
      gap: "6px",
      padding: "14px",
      border: "2px dashed rgba(94,234,212,0.3)",
      borderRadius: "12px",
      background: "rgba(94,234,212,0.05)",
      cursor: "pointer",
      transition: "all 120ms ease"
    });
    card2.onclick = onClick;
    card2.onmouseenter = () => {
      style2(card2, { background: "rgba(94,234,212,0.12)", borderColor: "rgba(94,234,212,0.5)", transform: "translateY(-2px)" });
    };
    card2.onmouseleave = () => {
      style2(card2, { background: "rgba(94,234,212,0.05)", borderColor: "rgba(94,234,212,0.3)", transform: "translateY(0)" });
    };
    const icon = document.createElement("div");
    style2(icon, {
      width: "32px",
      height: "32px",
      borderRadius: "50%",
      background: "rgba(94,234,212,0.15)",
      display: "grid",
      placeItems: "center",
      color: "#5eead4",
      fontSize: "20px",
      fontWeight: "300"
    });
    icon.textContent = "+";
    const label2 = document.createElement("div");
    style2(label2, {
      fontSize: "13px",
      fontWeight: "600",
      color: "#5eead4"
    });
    label2.textContent = "Create Group";
    card2.append(icon, label2);
    return card2;
  }

  // src/ui/menus/communityHub/tabs/publicGroupsSubTab.ts
  function createPublicGroupsSubTab(showGroupDetail) {
    ensureSharedStyles();
    const container = document.createElement("div");
    style2(container, { display: "flex", flexDirection: "column", height: "100%", gap: "12px" });
    let isLoading = false;
    let lastRefreshTime = null;
    const controlsContainer = document.createElement("div");
    style2(controlsContainer, {
      display: "flex",
      gap: "8px",
      alignItems: "center"
    });
    const searchBar = document.createElement("input");
    searchBar.type = "text";
    searchBar.placeholder = "Search public groups...";
    style2(searchBar, {
      flex: "1",
      padding: "10px 14px",
      border: "1px solid rgba(255,255,255,0.12)",
      borderRadius: "10px",
      background: "rgba(255,255,255,0.04)",
      color: "#e7eef7",
      fontSize: "13px",
      outline: "none",
      transition: "border-color 150ms ease"
    });
    const keyBlocker = createKeyBlocker(() => document.activeElement === searchBar);
    keyBlocker.attach();
    searchBar.onfocus = () => style2(searchBar, { borderColor: "rgba(94,234,212,0.35)" });
    searchBar.onblur = () => style2(searchBar, { borderColor: "rgba(255,255,255,0.12)" });
    const refreshButton = document.createElement("button");
    refreshButton.innerHTML = `
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="23 4 23 10 17 10"/>
      <polyline points="1 20 1 14 7 14"/>
      <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/>
    </svg>
  `;
    style2(refreshButton, {
      padding: "10px 16px",
      border: "1px solid rgba(255,255,255,0.12)",
      borderRadius: "10px",
      background: "rgba(94,234,212,0.12)",
      color: "#5eead4",
      cursor: "pointer",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transition: "all 120ms ease"
    });
    refreshButton.onmouseenter = () => {
      style2(refreshButton, {
        background: "rgba(94,234,212,0.2)",
        borderColor: "rgba(94,234,212,0.35)"
      });
    };
    refreshButton.onmouseleave = () => {
      style2(refreshButton, {
        background: "rgba(94,234,212,0.12)",
        borderColor: "rgba(255,255,255,0.12)"
      });
    };
    controlsContainer.append(searchBar, refreshButton);
    const footer = document.createElement("div");
    style2(footer, {
      padding: "8px 12px",
      borderTop: "1px solid rgba(255,255,255,0.06)",
      fontSize: "11px",
      color: "rgba(226,232,240,0.4)",
      textAlign: "center"
    });
    const updateFooterTimestamp = () => {
      if (lastRefreshTime) {
        footer.textContent = formatTimestamp(lastRefreshTime);
      } else {
        footer.textContent = "\u2014";
      }
    };
    updateFooterTimestamp();
    const groupsList = document.createElement("div");
    groupsList.className = "qws-ch-scrollable";
    style2(groupsList, {
      flex: "1",
      overflow: "auto",
      display: "grid",
      gridTemplateColumns: "repeat(auto-fill, minmax(200px, 1fr))",
      gap: "10px",
      alignContent: "start",
      padding: "6px 8px 6px 6px",
      // Padding to prevent cards from being clipped during hover animations
      position: "relative"
    });
    const renderGroups = (filter = "") => {
      groupsList.innerHTML = "";
      if (isLoading) {
        const loading = document.createElement("div");
        style2(loading, {
          position: "absolute",
          top: "0",
          left: "0",
          right: "0",
          bottom: "0",
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          justifyContent: "center",
          gap: "12px",
          color: "rgba(226,232,240,0.5)",
          fontSize: "13px"
        });
        loading.innerHTML = `
        <svg width="32" height="32" viewBox="0 0 24 24" fill="none" style="animation: spin 1s linear infinite;">
          <circle cx="12" cy="12" r="10" stroke="rgba(94,234,212,0.5)" stroke-width="2" stroke-dasharray="15 5" fill="none"/>
        </svg>
        <div>Loading public groups...</div>
      `;
        groupsList.appendChild(loading);
        return;
      }
      const publicGroups = getCachedPublicGroups() || [];
      const filtered = filter ? publicGroups.filter((g) => g.name?.toLowerCase().includes(filter.toLowerCase())) : publicGroups;
      if (filtered.length === 0) {
        const empty = document.createElement("div");
        style2(empty, {
          position: "absolute",
          top: "0",
          left: "0",
          right: "0",
          bottom: "0",
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          justifyContent: "center",
          color: "rgba(226,232,240,0.5)",
          fontSize: "13px",
          gap: "8px"
        });
        const icon = document.createElement("div");
        icon.innerHTML = `
        <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" opacity="0.3">
          <circle cx="12" cy="12" r="10"/>
          <path d="M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
        </svg>
      `;
        const text = document.createElement("div");
        text.textContent = filter ? "No public groups found" : "No public groups available";
        empty.append(icon, text);
        groupsList.appendChild(empty);
        return;
      }
      const sorted = [...filtered].sort((a, b) => {
        const aTime = a.updatedAt ? new Date(a.updatedAt).getTime() : 0;
        const bTime = b.updatedAt ? new Date(b.updatedAt).getTime() : 0;
        return bTime - aTime;
      });
      for (const group of sorted) {
        const groupSummary = {
          ...group,
          id: String(group.id),
          isPublic: true
        };
        groupsList.appendChild(createPublicGroupCard(groupSummary, showGroupDetail));
      }
    };
    const loadPublicGroups = async () => {
      isLoading = true;
      renderGroups(searchBar.value);
      try {
        const publicGroups = await fetchPublicGroups();
        updateCachedPublicGroups(publicGroups);
        lastRefreshTime = /* @__PURE__ */ new Date();
        updateFooterTimestamp();
        window.dispatchEvent(new CustomEvent(CH_EVENTS.GROUPS_REFRESH));
        isLoading = false;
        renderGroups(searchBar.value);
      } catch (error) {
        console.error("[PublicGroups] Failed to load public groups:", error);
        isLoading = false;
        renderGroups(searchBar.value);
      }
    };
    renderGroups();
    refreshButton.onclick = () => {
      loadPublicGroups();
    };
    searchBar.oninput = () => renderGroups(searchBar.value);
    const onGroupsRefresh = () => renderGroups(searchBar.value);
    window.addEventListener(CH_EVENTS.GROUPS_REFRESH, onGroupsRefresh);
    const unsubscribeWelcome = onWelcome((data) => {
      if (data.publicGroups !== void 0) {
        lastRefreshTime = /* @__PURE__ */ new Date();
        updateFooterTimestamp();
      }
    });
    container.append(controlsContainer, groupsList, footer);
    return {
      root: container,
      destroy() {
        keyBlocker.detach();
        window.removeEventListener(CH_EVENTS.GROUPS_REFRESH, onGroupsRefresh);
        unsubscribeWelcome();
      }
    };
  }
  function createPublicGroupCard(group, onClick) {
    const card2 = document.createElement("div");
    style2(card2, {
      display: "flex",
      flexDirection: "column",
      gap: "12px",
      padding: "14px",
      border: "1px solid rgba(255,255,255,0.08)",
      borderRadius: "12px",
      background: "rgba(255,255,255,0.03)",
      cursor: "pointer",
      transition: "all 120ms ease"
    });
    card2.onclick = () => onClick(group);
    card2.onmouseenter = () => {
      style2(card2, { background: "rgba(255,255,255,0.06)", borderColor: "rgba(94,234,212,0.25)", transform: "translateY(-2px)" });
    };
    card2.onmouseleave = () => {
      style2(card2, { background: "rgba(255,255,255,0.03)", borderColor: "rgba(255,255,255,0.08)", transform: "translateY(0)" });
    };
    const header = document.createElement("div");
    style2(header, { display: "flex", alignItems: "center", justifyContent: "space-between", gap: "8px" });
    const name = document.createElement("div");
    style2(name, {
      fontSize: "13px",
      fontWeight: "600",
      color: "#e7eef7",
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      flex: "1"
    });
    name.textContent = group.name || "Unnamed Group";
    const publicBadge = document.createElement("div");
    style2(publicBadge, {
      padding: "2px 8px",
      borderRadius: "6px",
      fontSize: "10px",
      fontWeight: "600",
      textTransform: "uppercase",
      flexShrink: "0",
      background: "rgba(94,234,212,0.2)",
      color: "#5eead4"
    });
    publicBadge.textContent = "Public";
    header.append(name, publicBadge);
    const avatarsRow = document.createElement("div");
    style2(avatarsRow, { display: "flex", alignItems: "center", gap: "6px" });
    const previewMembers = group.previewMembers || [];
    const avatarsContainer = document.createElement("div");
    style2(avatarsContainer, { display: "flex", marginLeft: "-4px" });
    for (let i = 0; i < Math.min(3, previewMembers.length); i++) {
      const member = previewMembers[i];
      const avatar2 = document.createElement("div");
      style2(avatar2, {
        width: "28px",
        height: "28px",
        borderRadius: "50%",
        background: member.discordAvatarUrl ? `url(${member.discordAvatarUrl}) center/cover` : "linear-gradient(135deg, rgba(94,234,212,0.3), rgba(59,130,246,0.3))",
        border: "2px solid #0f141e",
        marginLeft: i > 0 ? "-8px" : "0",
        flexShrink: "0"
      });
      avatarsContainer.appendChild(avatar2);
    }
    const memberCount = document.createElement("div");
    style2(memberCount, {
      fontSize: "11px",
      color: "rgba(226,232,240,0.6)",
      marginLeft: "auto"
    });
    const count = group.memberCount || 0;
    memberCount.textContent = `${count} member${count !== 1 ? "s" : ""}`;
    avatarsRow.append(avatarsContainer, memberCount);
    card2.append(header, avatarsRow);
    return card2;
  }

  // src/ui/menus/communityHub/tabs/groupDetailView.ts
  var ROLE_ORDER = { owner: 0, admin: 1, member: 2 };
  var ROLE_ICON_SVG = {
    // Crown
    owner: `<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M2.5 19h19v2h-19v-2zm19.57-9.36c-.21-.8-1.04-1.28-1.84-1.06L14.98 10l-2.1-5.08c-.31-.77-1.18-1.14-1.95-.83-.53.22-.88.68-.98 1.2L8.78 10l-5.25-1.42c-.8-.22-1.63.26-1.84 1.06-.12.46 0 .93.3 1.27l5.28 5.83h10.46l5.28-5.83c.3-.34.42-.81.3-1.27z"/></svg>`,
    // Shield with star
    admin: `<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm0 4l1.45 2.94L16.5 8.5l-2.12 2.06.5 2.94L12 12l-2.88 1.5.5-2.94L7.5 8.5l3.05-.56L12 5z"/></svg>`,
    // User
    member: `<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>`
  };
  var ROLE_COLORS = {
    owner: { bg: "rgba(251,191,36,0.15)", color: "#fbbf24" },
    admin: { bg: "rgba(139,92,246,0.15)", color: "#a78bfa" },
    member: { bg: "rgba(94,234,212,0.15)", color: "#5eead4" }
  };
  function createRoleBadge(role) {
    const badge = document.createElement("div");
    const colors = ROLE_COLORS[role] || ROLE_COLORS.member;
    const icon = ROLE_ICON_SVG[role] || ROLE_ICON_SVG.member;
    style2(badge, {
      width: "28px",
      height: "28px",
      borderRadius: "50%",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: "0",
      background: colors.bg,
      color: colors.color
    });
    badge.innerHTML = icon;
    badge.title = role.charAt(0).toUpperCase() + role.slice(1);
    return badge;
  }
  var ICON_BACK = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" style="display:block"><path d="M15 18L9 12L15 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
  var ICON_ADD_MEMBER = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" style="display:block"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><circle cx="9" cy="7" r="4" stroke="currentColor" stroke-width="2"/><line x1="19" y1="8" x2="19" y2="14" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><line x1="22" y1="11" x2="16" y2="11" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>`;
  var ICON_GLOBE = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" style="display:inline-block;vertical-align:middle;margin-right:4px"><circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"/><path d="M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10A15.3 15.3 0 0 1 12 2z" stroke="currentColor" stroke-width="2"/></svg>`;
  var ICON_LOCK = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" style="display:inline-block;vertical-align:middle;margin-right:4px"><rect x="3" y="11" width="18" height="11" rx="2" stroke="currentColor" stroke-width="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>`;
  var ICON_CLOSE = `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" style="display:block"><path d="M18 6L6 18M6 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
  var ICON_DISSOLVE = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" style="display:block"><path d="M3 6h18M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2m3 0v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6h14" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
  var ICON_LEAVE = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" style="display:block"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4M16 17l5-5-5-5M21 12H9" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
  var ICON_JOIN = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" style="display:block"><path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4M10 17l5-5-5-5M15 12H3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
  var ICON_CHAT = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" style="display:block"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
  async function createGroupDetailView(params) {
    ensureSharedStyles();
    const { group, onBack } = params;
    const groupId = String(group.id);
    const myPlayerId = getCurrentPlayerId() || "";
    const isMember = !!group.role;
    const myRole = group.role || "member";
    const root = document.createElement("div");
    root.className = "qws-ch-scrollable";
    style2(root, {
      display: "flex",
      flexDirection: "column",
      height: "100%",
      overflow: "auto",
      gap: "16px",
      paddingRight: "8px",
      paddingBottom: "16px",
      position: "relative"
    });
    let currentMembers = [];
    let modalCleanup = null;
    const memberRefs = /* @__PURE__ */ new Map();
    const updateMemberInPlace = (playerId2, updates) => {
      const entry = memberRefs.get(playerId2);
      if (!entry) return;
      if (updates.isOnline !== void 0) entry.member.isOnline = updates.isOnline;
      if (updates.roomId !== void 0) entry.member.roomId = updates.roomId;
      if (updates.lastEventAt !== void 0) entry.member.lastEventAt = updates.lastEventAt;
      const isOnline = entry.member.isOnline ?? false;
      style2(entry.onlineDot, { background: isOnline ? "#10b981" : "#6b7280" });
      entry.meta.innerHTML = "";
      style2(entry.meta, { color: isOnline ? "#5eead4" : "rgba(226,232,240,0.5)" });
      if (isOnline) {
        entry.meta.appendChild(createRoomBadge(entry.member.roomId));
      } else {
        entry.meta.textContent = entry.member.lastEventAt ? `Last seen ${formatRelativeTime(entry.member.lastEventAt)}` : "";
      }
    };
    const showAddMemberModal = () => {
      const memberIds = new Set(currentMembers.map((m) => m.playerId));
      const scrollTop = root.scrollTop;
      const closeModal2 = () => {
        if (modalCleanup) {
          modalCleanup();
          modalCleanup = null;
        }
        overlay.remove();
        root.style.overflow = "auto";
      };
      const { overlay, cleanup: cleanup2 } = buildAddMemberModal(groupId, memberIds, closeModal2);
      modalCleanup = cleanup2;
      style2(overlay, { top: scrollTop + "px", height: root.clientHeight + "px" });
      root.style.overflow = "hidden";
      root.appendChild(overlay);
    };
    let currentIsMember = isMember;
    const rebuildHeader = () => {
      const newHeader = buildHeader(onBack, showAddMemberModal, currentIsMember ? myRole : void 0, groupId, currentIsMember, onJoinSuccess, group.name);
      header.replaceWith(newHeader);
      header = newHeader;
    };
    const onJoinSuccess = () => {
      currentIsMember = true;
      group.role = "member";
      rebuildHeader();
      refreshContent();
      window.dispatchEvent(new CustomEvent(CH_EVENTS.GROUPS_REFRESH));
    };
    let header = buildHeader(onBack, showAddMemberModal, myRole, groupId, isMember, onJoinSuccess, group.name);
    root.appendChild(header);
    const contentZone = document.createElement("div");
    style2(contentZone, { display: "flex", flexDirection: "column", flex: "1", gap: "16px", overflow: "hidden" });
    root.appendChild(contentZone);
    let currentKeyBlockerCleanup = null;
    let searchFilter = "";
    const refreshContent = async () => {
      if (!root.isConnected) return;
      const details = await fetchGroupDetails(groupId);
      if (!root.isConnected) return;
      if (currentKeyBlockerCleanup) {
        currentKeyBlockerCleanup();
        currentKeyBlockerCleanup = null;
      }
      contentZone.innerHTML = "";
      if (!details || !details.group) {
        contentZone.appendChild(buildErrorView("Failed to load group details", onBack));
        return;
      }
      const members = details.members || [];
      currentMembers = members;
      contentZone.appendChild(buildInfoCard(details, myRole, members));
      memberRefs.clear();
      const { section: membersSection, keyBlockerCleanup } = buildMembersSection(
        details,
        members,
        myRole,
        myPlayerId,
        groupId,
        searchFilter,
        (newFilter) => {
          searchFilter = newFilter;
        },
        memberRefs
      );
      currentKeyBlockerCleanup = keyBlockerCleanup;
      contentZone.appendChild(membersSection);
    };
    const loadingView = buildLoadingView();
    contentZone.appendChild(loadingView);
    const initialDetails = await fetchGroupDetails(groupId);
    loadingView.remove();
    if (!initialDetails || !initialDetails.group) {
      contentZone.appendChild(buildErrorView("Failed to load group details", onBack));
    } else {
      const members = initialDetails.members || [];
      currentMembers = members;
      contentZone.appendChild(buildInfoCard(initialDetails, myRole, members));
      memberRefs.clear();
      const { section: membersSection, keyBlockerCleanup } = buildMembersSection(
        initialDetails,
        members,
        myRole,
        myPlayerId,
        groupId,
        searchFilter,
        (newFilter) => {
          searchFilter = newFilter;
        },
        memberRefs
      );
      currentKeyBlockerCleanup = keyBlockerCleanup;
      contentZone.appendChild(membersSection);
    }
    let refreshTimer = null;
    const onGroupsRefresh = () => {
      if (refreshTimer) clearTimeout(refreshTimer);
      refreshTimer = setTimeout(() => {
        refreshTimer = null;
        refreshContent();
      }, 500);
    };
    window.addEventListener(CH_EVENTS.GROUPS_REFRESH, onGroupsRefresh);
    const onPresenceUpdated = (e) => {
      const d = e.detail;
      if (d?.playerId) {
        updateMemberInPlace(d.playerId, {
          isOnline: d.online ?? false,
          roomId: d.roomId ?? null,
          lastEventAt: d.lastEventAt ?? null
        });
      }
    };
    window.addEventListener(CH_EVENTS.PRESENCE_UPDATED, onPresenceUpdated);
    const onRoomChanged = (e) => {
      const d = e.detail;
      if (d?.playerId) {
        updateMemberInPlace(d.playerId, { roomId: d.roomId ?? null });
      }
    };
    window.addEventListener(CH_EVENTS.ROOM_CHANGED, onRoomChanged);
    const onPrivacyUpdated = (e) => {
      const d = e.detail;
      if (d?.playerId && d?.privacy?.hideRoomFromPublicList) {
        updateMemberInPlace(d.playerId, { roomId: null });
      }
    };
    window.addEventListener(CH_EVENTS.PRIVACY_UPDATED, onPrivacyUpdated);
    root.__cleanup = () => {
      window.removeEventListener(CH_EVENTS.GROUPS_REFRESH, onGroupsRefresh);
      window.removeEventListener(CH_EVENTS.PRESENCE_UPDATED, onPresenceUpdated);
      window.removeEventListener(CH_EVENTS.ROOM_CHANGED, onRoomChanged);
      window.removeEventListener(CH_EVENTS.PRIVACY_UPDATED, onPrivacyUpdated);
      if (refreshTimer) {
        clearTimeout(refreshTimer);
        refreshTimer = null;
      }
      if (currentKeyBlockerCleanup) {
        currentKeyBlockerCleanup();
        currentKeyBlockerCleanup = null;
      }
      if (modalCleanup) {
        modalCleanup();
        modalCleanup = null;
      }
    };
    return root;
  }
  function buildHeader(onBack, onAddMember, myRole, groupId, isMember, onJoinSuccess, groupName) {
    const header = document.createElement("div");
    style2(header, {
      display: "flex",
      alignItems: "center",
      gap: "12px",
      paddingBottom: "12px",
      borderBottom: "1px solid rgba(255,255,255,0.08)"
    });
    const backBtn = document.createElement("button");
    backBtn.innerHTML = ICON_BACK;
    style2(backBtn, {
      padding: "8px",
      border: "1px solid rgba(255,255,255,0.08)",
      borderRadius: "8px",
      background: "rgba(255,255,255,0.03)",
      color: "#e7eef7",
      cursor: "pointer",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transition: "all 120ms ease"
    });
    backBtn.onmouseenter = () => style2(backBtn, { background: "rgba(255,255,255,0.06)", borderColor: "rgba(94,234,212,0.25)" });
    backBtn.onmouseleave = () => style2(backBtn, { background: "rgba(255,255,255,0.03)", borderColor: "rgba(255,255,255,0.08)" });
    backBtn.onclick = onBack;
    const title = document.createElement("div");
    style2(title, { fontSize: "16px", fontWeight: "700", color: "#e7eef7", flex: "1" });
    title.textContent = "Group Details";
    header.append(backBtn, title);
    if (isMember) {
      const chatBtn = document.createElement("button");
      chatBtn.innerHTML = ICON_CHAT;
      chatBtn.title = "Group Chat";
      style2(chatBtn, {
        padding: "8px",
        border: "1px solid rgba(255,255,255,0.08)",
        borderRadius: "8px",
        background: "rgba(94,234,212,0.12)",
        color: "#5eead4",
        cursor: "pointer",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        transition: "all 120ms ease"
      });
      chatBtn.onmouseenter = () => style2(chatBtn, { background: "rgba(94,234,212,0.2)", borderColor: "rgba(94,234,212,0.35)" });
      chatBtn.onmouseleave = () => style2(chatBtn, { background: "rgba(94,234,212,0.12)", borderColor: "rgba(255,255,255,0.08)" });
      chatBtn.onclick = () => {
        window.dispatchEvent(
          new CustomEvent(CH_EVENTS.OPEN_GROUP_CHAT, {
            detail: { groupId, groupName }
          })
        );
      };
      header.appendChild(chatBtn);
      const addBtn = document.createElement("button");
      addBtn.innerHTML = ICON_ADD_MEMBER;
      addBtn.title = "Add Member";
      style2(addBtn, {
        padding: "8px",
        border: "1px solid rgba(255,255,255,0.08)",
        borderRadius: "8px",
        background: "rgba(94,234,212,0.12)",
        color: "#5eead4",
        cursor: "pointer",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        transition: "all 120ms ease"
      });
      addBtn.onmouseenter = () => style2(addBtn, { background: "rgba(94,234,212,0.2)", borderColor: "rgba(94,234,212,0.35)" });
      addBtn.onmouseleave = () => style2(addBtn, { background: "rgba(94,234,212,0.12)", borderColor: "rgba(255,255,255,0.08)" });
      addBtn.onclick = () => onAddMember?.();
      header.appendChild(addBtn);
      if (groupId) {
        const isOwner = myRole === "owner";
        const actionBtn = document.createElement("button");
        actionBtn.innerHTML = isOwner ? ICON_DISSOLVE : ICON_LEAVE;
        actionBtn.title = isOwner ? "Dissolve Group" : "Leave Group";
        style2(actionBtn, {
          padding: "8px",
          border: "1px solid rgba(239,68,68,0.2)",
          borderRadius: "8px",
          background: "rgba(239,68,68,0.08)",
          color: "#ef4444",
          cursor: "pointer",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          transition: "all 120ms ease"
        });
        actionBtn.onmouseenter = () => style2(actionBtn, { background: "rgba(239,68,68,0.2)", borderColor: "rgba(239,68,68,0.4)" });
        actionBtn.onmouseleave = () => style2(actionBtn, { background: "rgba(239,68,68,0.08)", borderColor: "rgba(239,68,68,0.2)" });
        actionBtn.onclick = async () => {
          onBack();
          if (isOwner) {
            await deleteGroup({ groupId });
          } else {
            await leaveGroup({ groupId });
          }
        };
        header.appendChild(actionBtn);
      }
    } else if (groupId) {
      const joinBtn = document.createElement("button");
      joinBtn.innerHTML = ICON_JOIN;
      joinBtn.title = "Join Group";
      style2(joinBtn, {
        padding: "8px",
        border: "1px solid rgba(94,234,212,0.2)",
        borderRadius: "8px",
        background: "rgba(94,234,212,0.12)",
        color: "#5eead4",
        cursor: "pointer",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        transition: "all 120ms ease"
      });
      joinBtn.onmouseenter = () => style2(joinBtn, { background: "rgba(94,234,212,0.2)", borderColor: "rgba(94,234,212,0.4)" });
      joinBtn.onmouseleave = () => style2(joinBtn, { background: "rgba(94,234,212,0.12)", borderColor: "rgba(94,234,212,0.2)" });
      joinBtn.onclick = async () => {
        const success = await joinGroup({ groupId });
        if (success) {
          onJoinSuccess?.();
        }
      };
      header.appendChild(joinBtn);
    }
    return header;
  }
  function buildInfoCard(details, myRole, members) {
    const card2 = document.createElement("div");
    style2(card2, {
      display: "flex",
      flexDirection: "column",
      gap: "16px",
      padding: "16px",
      border: "1px solid rgba(255,255,255,0.08)",
      borderRadius: "12px",
      background: "rgba(255,255,255,0.03)"
    });
    const nameRow = document.createElement("div");
    style2(nameRow, { display: "flex", alignItems: "center", gap: "8px" });
    const nameEl = document.createElement("div");
    style2(nameEl, {
      fontSize: "20px",
      fontWeight: "700",
      color: "#e7eef7",
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      flex: "1"
    });
    nameEl.textContent = details.group?.name || "Unnamed Group";
    nameRow.appendChild(nameEl);
    if (myRole === "owner") {
      const groupId2 = String(details.group?.id || "");
      nameRow.appendChild(buildRenameButton(nameEl, groupId2));
    }
    const infoRow = document.createElement("div");
    style2(infoRow, {
      display: "flex",
      alignItems: "center",
      gap: "0",
      padding: "8px 12px",
      background: "rgba(255,255,255,0.02)",
      borderRadius: "8px"
    });
    const ownerMember = members.find((m) => m.role === "owner");
    infoRow.appendChild(buildInfoCell("Owner", ownerMember?.name || details.group?.ownerId || "Unknown"));
    infoRow.appendChild(buildInfoSeparator());
    infoRow.appendChild(buildInfoCell("Members", String(members.length)));
    infoRow.appendChild(buildInfoSeparator());
    const groupId = String(details.group?.id || "");
    const isPublic = details.group?.isPublic ?? false;
    infoRow.appendChild(buildVisibilityCell(isPublic, myRole === "owner", groupId));
    card2.append(nameRow, infoRow);
    return card2;
  }
  var ICON_EDIT = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>`;
  var ICON_CHECK = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>`;
  function buildRenameButton(nameEl, groupId) {
    const btn = document.createElement("button");
    btn.innerHTML = ICON_EDIT;
    const btnBaseStyle = {
      padding: "6px",
      border: "1px solid rgba(255,255,255,0.08)",
      borderRadius: "6px",
      background: "rgba(255,255,255,0.03)",
      color: "rgba(226,232,240,0.6)",
      cursor: "pointer",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transition: "all 120ms ease",
      flexShrink: "0"
    };
    style2(btn, btnBaseStyle);
    const setEditMode = () => {
      btn.innerHTML = ICON_CHECK;
      style2(btn, { background: "rgba(94,234,212,0.15)", borderColor: "rgba(94,234,212,0.35)", color: "#5eead4" });
      btn.onmouseenter = () => style2(btn, { background: "rgba(94,234,212,0.25)", borderColor: "rgba(94,234,212,0.5)" });
      btn.onmouseleave = () => style2(btn, { background: "rgba(94,234,212,0.15)", borderColor: "rgba(94,234,212,0.35)" });
    };
    const setNormalMode = () => {
      btn.innerHTML = ICON_EDIT;
      style2(btn, btnBaseStyle);
      btn.onmouseenter = () => style2(btn, { background: "rgba(94,234,212,0.1)", borderColor: "rgba(94,234,212,0.3)", color: "#5eead4" });
      btn.onmouseleave = () => style2(btn, btnBaseStyle);
    };
    btn.onmouseenter = () => style2(btn, { background: "rgba(94,234,212,0.1)", borderColor: "rgba(94,234,212,0.3)", color: "#5eead4" });
    btn.onmouseleave = () => style2(btn, btnBaseStyle);
    let editing = false;
    let activeInput = null;
    const finishEdit = async (save) => {
      if (!editing || !activeInput) return;
      const input = activeInput;
      activeInput = null;
      editing = false;
      input.onkeydown = null;
      input.onblur = null;
      setNormalMode();
      const currentName = input.getAttribute("data-original") || "";
      const newName = input.value.trim();
      if (save && newName && newName !== currentName) {
        nameEl.textContent = newName;
        input.replaceWith(nameEl);
        await updateGroupName({ groupId, name: newName });
      } else {
        input.replaceWith(nameEl);
      }
    };
    btn.onclick = () => {
      if (editing) {
        finishEdit(true);
        return;
      }
      editing = true;
      setEditMode();
      const currentName = nameEl.textContent || "";
      const input = document.createElement("input");
      input.type = "text";
      input.value = currentName;
      input.setAttribute("data-original", currentName);
      activeInput = input;
      style2(input, {
        fontSize: "20px",
        fontWeight: "700",
        color: "#e7eef7",
        background: "rgba(255,255,255,0.05)",
        border: "1px solid rgba(94,234,212,0.35)",
        borderRadius: "6px",
        padding: "2px 8px",
        outline: "none",
        width: "100%",
        fontFamily: "inherit"
      });
      const blockHandler = (e) => {
        if (document.activeElement !== input) return;
        if (e.key === "Enter" || e.key === "Escape") return;
        e.stopPropagation();
      };
      window.addEventListener("keydown", blockHandler, true);
      window.addEventListener("keyup", blockHandler, true);
      const cleanup2 = () => {
        window.removeEventListener("keydown", blockHandler, true);
        window.removeEventListener("keyup", blockHandler, true);
      };
      const origFinish = finishEdit;
      const wrappedFinish = async (save) => {
        cleanup2();
        await origFinish(save);
      };
      input.onkeydown = (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          wrappedFinish(true);
        }
        if (e.key === "Escape") {
          e.preventDefault();
          wrappedFinish(false);
        }
      };
      input.onblur = () => wrappedFinish(true);
      nameEl.replaceWith(input);
      input.focus();
      input.select();
    };
    return btn;
  }
  function buildInfoCell(label2, value) {
    const cell = document.createElement("div");
    style2(cell, {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap: "2px",
      flex: "1"
    });
    const labelEl = document.createElement("div");
    style2(labelEl, { fontSize: "10px", color: "rgba(226,232,240,0.5)", fontWeight: "500", textTransform: "uppercase", letterSpacing: "0.5px" });
    labelEl.textContent = label2;
    const valueEl = document.createElement("div");
    style2(valueEl, { fontSize: "13px", color: "#e7eef7", fontWeight: "600", overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap", maxWidth: "100%" });
    valueEl.textContent = value;
    cell.append(labelEl, valueEl);
    return cell;
  }
  function buildInfoSeparator() {
    const sep = document.createElement("div");
    style2(sep, { width: "1px", height: "28px", background: "rgba(255,255,255,0.08)", flexShrink: "0" });
    return sep;
  }
  function buildVisibilityCell(isPublic, isOwner, groupId) {
    const cell = document.createElement("div");
    style2(cell, {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap: "2px",
      flex: "1"
    });
    const labelEl = document.createElement("div");
    style2(labelEl, { fontSize: "10px", color: "rgba(226,232,240,0.5)", fontWeight: "500", textTransform: "uppercase", letterSpacing: "0.5px" });
    labelEl.textContent = "Visibility";
    const toggle = document.createElement("div");
    style2(toggle, {
      display: "flex",
      borderRadius: "5px",
      overflow: "hidden",
      border: "1px solid rgba(255,255,255,0.1)"
    });
    const publicBtn = document.createElement("button");
    const privateBtn = document.createElement("button");
    const applyToggleStyles = (currentIsPublic) => {
      const activeStyle = { background: "rgba(94,234,212,0.15)", color: "#5eead4" };
      const inactiveStyle = { background: "rgba(255,255,255,0.02)", color: "rgba(226,232,240,0.4)" };
      Object.assign(publicBtn.style, currentIsPublic ? activeStyle : inactiveStyle);
      Object.assign(privateBtn.style, !currentIsPublic ? activeStyle : inactiveStyle);
    };
    const btnBase = {
      padding: "3px 8px",
      border: "none",
      fontSize: "10px",
      fontWeight: "600",
      cursor: isOwner ? "pointer" : "default",
      transition: "all 120ms ease",
      display: "flex",
      alignItems: "center",
      gap: "3px"
    };
    publicBtn.innerHTML = `${ICON_GLOBE} Public`;
    style2(publicBtn, btnBase);
    privateBtn.innerHTML = `${ICON_LOCK} Private`;
    style2(privateBtn, { ...btnBase, borderLeft: "1px solid rgba(255,255,255,0.1)" });
    applyToggleStyles(isPublic);
    if (isOwner) {
      let currentState = isPublic;
      publicBtn.onclick = async () => {
        if (currentState) return;
        currentState = true;
        applyToggleStyles(true);
        const ok = await updateGroupVisibility({ groupId, isPublic: true });
        if (!ok) {
          currentState = false;
          applyToggleStyles(false);
        }
      };
      privateBtn.onclick = async () => {
        if (!currentState) return;
        currentState = false;
        applyToggleStyles(false);
        const ok = await updateGroupVisibility({ groupId, isPublic: false });
        if (!ok) {
          currentState = true;
          applyToggleStyles(true);
        }
      };
    } else {
      publicBtn.style.opacity = "0.6";
      privateBtn.style.opacity = "0.6";
    }
    toggle.append(publicBtn, privateBtn);
    cell.append(labelEl, toggle);
    return cell;
  }
  function buildMembersSection(details, members, myRole, myPlayerId, groupId, initialFilter, onFilterChange, memberRefs) {
    const section = document.createElement("div");
    style2(section, { flex: "1", display: "flex", flexDirection: "column", gap: "10px", overflow: "hidden" });
    const titleEl = document.createElement("div");
    style2(titleEl, { fontSize: "14px", fontWeight: "700", color: "#e7eef7", paddingLeft: "4px" });
    titleEl.textContent = "Members";
    const searchInput = document.createElement("input");
    searchInput.type = "text";
    searchInput.placeholder = "Search members...";
    searchInput.value = initialFilter;
    style2(searchInput, {
      width: "100%",
      padding: "8px 12px",
      border: "1px solid rgba(255,255,255,0.1)",
      borderRadius: "8px",
      background: "rgba(255,255,255,0.04)",
      color: "#e7eef7",
      fontSize: "12px",
      outline: "none",
      boxSizing: "border-box",
      transition: "border-color 120ms ease"
    });
    searchInput.onfocus = () => style2(searchInput, { borderColor: "rgba(94,234,212,0.4)" });
    searchInput.onblur = () => style2(searchInput, { borderColor: "rgba(255,255,255,0.1)" });
    const keyBlocker = createKeyBlocker(() => document.activeElement === searchInput);
    keyBlocker.attach();
    const listContainer = document.createElement("div");
    listContainer.className = "qws-ch-scrollable";
    style2(listContainer, {
      flex: "1",
      overflow: "auto",
      display: "flex",
      flexDirection: "column",
      gap: "6px",
      paddingRight: "4px"
    });
    const sortedMembers = [...members].sort((a, b) => {
      const onlineA = a.isOnline ? 0 : 1;
      const onlineB = b.isOnline ? 0 : 1;
      if (onlineA !== onlineB) return onlineA - onlineB;
      return (ROLE_ORDER[a.role || "member"] ?? 2) - (ROLE_ORDER[b.role || "member"] ?? 2);
    });
    const renderMembers = (filter) => {
      listContainer.innerHTML = "";
      memberRefs?.clear();
      const query = filter.toLowerCase().trim();
      for (const member of sortedMembers) {
        if (query && !(member.name || "").toLowerCase().includes(query)) continue;
        listContainer.appendChild(buildMemberRow(member, myRole, myPlayerId, groupId, memberRefs));
      }
      if (listContainer.children.length === 0) {
        const empty = document.createElement("div");
        style2(empty, { padding: "24px", textAlign: "center", color: "rgba(226,232,240,0.4)", fontSize: "12px" });
        empty.textContent = query ? "No members match your search" : "No members";
        listContainer.appendChild(empty);
      }
    };
    searchInput.oninput = () => {
      onFilterChange(searchInput.value);
      renderMembers(searchInput.value);
    };
    renderMembers(initialFilter);
    section.append(titleEl, searchInput, listContainer);
    return { section, keyBlockerCleanup: () => keyBlocker.detach() };
  }
  function buildMemberRow(member, myRole, myPlayerId, groupId, memberRefs) {
    const row = document.createElement("div");
    style2(row, {
      display: "flex",
      alignItems: "center",
      gap: "10px",
      padding: "10px",
      border: "1px solid rgba(255,255,255,0.08)",
      borderRadius: "10px",
      background: "rgba(255,255,255,0.03)",
      transition: "background 120ms ease"
    });
    row.onmouseenter = () => style2(row, { background: "rgba(255,255,255,0.05)" });
    row.onmouseleave = () => style2(row, { background: "rgba(255,255,255,0.03)" });
    const isOnline = member.isOnline ?? false;
    const avatarWrapper = document.createElement("div");
    style2(avatarWrapper, { position: "relative", flexShrink: "0" });
    const avatar2 = document.createElement("div");
    style2(avatar2, {
      width: "40px",
      height: "40px",
      borderRadius: "50%",
      background: member.avatarUrl ? `url(${member.avatarUrl}) center/cover` : "linear-gradient(135deg, rgba(94,234,212,0.3), rgba(59,130,246,0.3))",
      border: "2px solid rgba(255,255,255,0.1)"
    });
    const onlineDot = document.createElement("div");
    style2(onlineDot, {
      position: "absolute",
      bottom: "0",
      right: "0",
      width: "12px",
      height: "12px",
      borderRadius: "50%",
      background: isOnline ? "#10b981" : "#6b7280",
      border: "2px solid #0f141e"
    });
    avatarWrapper.append(avatar2, onlineDot);
    const info = document.createElement("div");
    style2(info, { flex: "1", display: "flex", flexDirection: "column", gap: "2px", overflow: "hidden" });
    const nameEl = document.createElement("div");
    style2(nameEl, {
      fontSize: "13px",
      fontWeight: "600",
      color: "#e7eef7",
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    });
    nameEl.textContent = member.name || "Unknown";
    const meta = document.createElement("div");
    style2(meta, {
      fontSize: "11px",
      color: isOnline ? "#5eead4" : "rgba(226,232,240,0.5)",
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    });
    if (isOnline) {
      meta.appendChild(createRoomBadge(member.roomId));
    } else {
      meta.textContent = member.lastEventAt ? `Last seen ${formatRelativeTime(member.lastEventAt)}` : "";
    }
    const nameRow = document.createElement("div");
    style2(nameRow, { display: "flex", alignItems: "center", gap: "6px", overflow: "hidden" });
    nameRow.appendChild(nameEl);
    const badgesEl = createPlayerBadges(member.badges, true);
    if (badgesEl) {
      style2(badgesEl, { flexShrink: "0" });
      nameRow.appendChild(badgesEl);
    }
    info.append(nameRow, meta);
    memberRefs?.set(member.playerId, { onlineDot, meta, member });
    const roleBadge = createRoleBadge(member.role || "member");
    row.append(roleBadge, avatarWrapper, info);
    const isMe = member.playerId === myPlayerId;
    if (!isMe) {
      const actions = buildMemberActions(member, myRole, groupId, row, roleBadge);
      if (actions) row.appendChild(actions);
    }
    return row;
  }
  var ICON_PROMOTE = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19V5"/><path d="M5 12l7-7 7 7"/></svg>`;
  var ICON_DEMOTE = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14"/><path d="M19 12l-7 7-7-7"/></svg>`;
  var ICON_KICK = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><line x1="18" y1="8" x2="23" y2="13"/><line x1="23" y1="8" x2="18" y2="13"/></svg>`;
  function buildMemberActions(member, myRole, groupId, row, roleBadge) {
    const memberRole = member.role || "member";
    const actions = document.createElement("div");
    style2(actions, { display: "flex", gap: "6px", flexShrink: "0" });
    let hasButtons = false;
    if (myRole === "owner" && memberRole !== "owner") {
      const isAdmin = memberRole === "admin";
      const promoteBtn = buildIconActionBtn(
        isAdmin ? ICON_DEMOTE : ICON_PROMOTE,
        isAdmin ? "Demote to member" : "Promote to admin",
        isAdmin ? "rgba(94,234,212," : "rgba(139,92,246,",
        isAdmin ? "#5eead4" : "#a78bfa",
        async () => {
          const newRole = isAdmin ? "member" : "admin";
          const willBeAdmin = newRole === "admin";
          const newBadge = createRoleBadge(newRole);
          roleBadge.replaceWith(newBadge);
          const oldIcon = promoteBtn.innerHTML;
          const oldTitle = promoteBtn.title;
          const oldColorBase = isAdmin ? "rgba(94,234,212," : "rgba(139,92,246,";
          const oldIconColor = isAdmin ? "#5eead4" : "#a78bfa";
          const newColorBase = willBeAdmin ? "rgba(94,234,212," : "rgba(139,92,246,";
          const newIconColor = willBeAdmin ? "#5eead4" : "#a78bfa";
          promoteBtn.innerHTML = willBeAdmin ? ICON_DEMOTE : ICON_PROMOTE;
          promoteBtn.title = willBeAdmin ? "Demote to member" : "Promote to admin";
          style2(promoteBtn, { border: `1px solid ${newColorBase}0.2)`, background: `${newColorBase}0.08)`, color: newIconColor });
          promoteBtn.onmouseenter = () => style2(promoteBtn, { background: `${newColorBase}0.2)`, borderColor: `${newColorBase}0.4)`, transform: "scale(1.1)" });
          promoteBtn.onmouseleave = () => style2(promoteBtn, { background: `${newColorBase}0.08)`, borderColor: `${newColorBase}0.2)`, transform: "scale(1)" });
          promoteBtn.style.pointerEvents = "none";
          const success = await changeGroupMemberRole({ groupId, memberId: member.playerId, role: newRole });
          promoteBtn.style.pointerEvents = "auto";
          if (!success) {
            newBadge.replaceWith(roleBadge);
            promoteBtn.innerHTML = oldIcon;
            promoteBtn.title = oldTitle;
            style2(promoteBtn, { border: `1px solid ${oldColorBase}0.2)`, background: `${oldColorBase}0.08)`, color: oldIconColor });
            promoteBtn.onmouseenter = () => style2(promoteBtn, { background: `${oldColorBase}0.2)`, borderColor: `${oldColorBase}0.4)`, transform: "scale(1.1)" });
            promoteBtn.onmouseleave = () => style2(promoteBtn, { background: `${oldColorBase}0.08)`, borderColor: `${oldColorBase}0.2)`, transform: "scale(1)" });
            toastSimple(`Failed to ${isAdmin ? "demote" : "promote"} member.`, "", "error");
          }
        }
      );
      actions.appendChild(promoteBtn);
      hasButtons = true;
      const kickBtn = buildIconActionBtn(ICON_KICK, "Kick from group", "rgba(239,68,68,", "#ef4444", async () => {
        row.style.display = "none";
        const success = await removeGroupMember({ groupId, memberId: member.playerId });
        if (!success) {
          row.style.display = "flex";
          toastSimple("Failed to remove member.", "", "error");
        }
      });
      actions.appendChild(kickBtn);
      hasButtons = true;
    } else if (myRole === "admin" && memberRole === "member") {
      const kickBtn = buildIconActionBtn(ICON_KICK, "Kick from group", "rgba(239,68,68,", "#ef4444", async () => {
        row.style.display = "none";
        const success = await removeGroupMember({ groupId, memberId: member.playerId });
        if (!success) {
          row.style.display = "flex";
          toastSimple("Failed to remove member.", "", "error");
        }
      });
      actions.appendChild(kickBtn);
      hasButtons = true;
    }
    return hasButtons ? actions : null;
  }
  function buildIconActionBtn(icon, tooltip, colorBase, iconColor, onClick) {
    const btn = document.createElement("button");
    btn.innerHTML = icon;
    btn.title = tooltip;
    style2(btn, {
      width: "28px",
      height: "28px",
      borderRadius: "50%",
      border: `1px solid ${colorBase}0.2)`,
      background: `${colorBase}0.08)`,
      color: iconColor,
      cursor: "pointer",
      transition: "all 120ms ease",
      flexShrink: "0",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      padding: "0"
    });
    btn.onmouseenter = () => style2(btn, { background: `${colorBase}0.2)`, borderColor: `${colorBase}0.4)`, transform: "scale(1.1)" });
    btn.onmouseleave = () => style2(btn, { background: `${colorBase}0.08)`, borderColor: `${colorBase}0.2)`, transform: "scale(1)" });
    btn.onclick = onClick;
    return btn;
  }
  function buildLoadingView() {
    const view = document.createElement("div");
    style2(view, {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      height: "100%",
      color: "rgba(226,232,240,0.7)",
      fontSize: "13px"
    });
    view.textContent = "Loading group details...";
    return view;
  }
  function buildErrorView(message, onBack) {
    const view = document.createElement("div");
    style2(view, {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center",
      height: "100%",
      gap: "12px"
    });
    const text = document.createElement("div");
    style2(text, { fontSize: "13px", color: "rgba(226,232,240,0.7)" });
    text.textContent = message;
    const backBtn = document.createElement("button");
    style2(backBtn, {
      padding: "8px 16px",
      borderRadius: "8px",
      border: "1px solid rgba(94,234,212,0.3)",
      background: "rgba(94,234,212,0.1)",
      color: "#5eead4",
      fontSize: "12px",
      fontWeight: "600",
      cursor: "pointer"
    });
    backBtn.textContent = "Go Back";
    backBtn.onclick = onBack;
    view.append(text, backBtn);
    return view;
  }
  function buildAddMemberModal(groupId, memberIds, onClose) {
    const invitedIds = /* @__PURE__ */ new Set();
    const overlay = document.createElement("div");
    style2(overlay, {
      position: "absolute",
      left: "0",
      right: "0",
      background: "rgba(0,0,0,0.6)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      zIndex: "10",
      padding: "20px",
      boxSizing: "border-box"
    });
    overlay.onclick = (e) => {
      if (e.target === overlay) onClose();
    };
    const modal = document.createElement("div");
    style2(modal, {
      width: "100%",
      maxHeight: "100%",
      display: "flex",
      flexDirection: "column",
      background: "#1a1f2e",
      border: "1px solid rgba(255,255,255,0.12)",
      borderRadius: "16px",
      overflow: "hidden"
    });
    const header = document.createElement("div");
    style2(header, {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      padding: "14px 16px",
      borderBottom: "1px solid rgba(255,255,255,0.08)",
      flexShrink: "0"
    });
    const title = document.createElement("div");
    style2(title, { fontSize: "15px", fontWeight: "700", color: "#e7eef7" });
    title.textContent = "Add Member";
    const closeBtn = document.createElement("button");
    closeBtn.innerHTML = ICON_CLOSE;
    style2(closeBtn, {
      padding: "6px",
      border: "1px solid rgba(255,255,255,0.08)",
      borderRadius: "6px",
      background: "rgba(255,255,255,0.03)",
      color: "#e7eef7",
      cursor: "pointer",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transition: "all 120ms ease"
    });
    closeBtn.onmouseenter = () => style2(closeBtn, { background: "rgba(255,255,255,0.06)", borderColor: "rgba(255,255,255,0.15)" });
    closeBtn.onmouseleave = () => style2(closeBtn, { background: "rgba(255,255,255,0.03)", borderColor: "rgba(255,255,255,0.08)" });
    closeBtn.onclick = onClose;
    header.append(title, closeBtn);
    const searchWrapper = document.createElement("div");
    style2(searchWrapper, {
      padding: "12px 16px",
      borderBottom: "1px solid rgba(255,255,255,0.05)",
      flexShrink: "0"
    });
    const searchInput = document.createElement("input");
    searchInput.type = "text";
    searchInput.placeholder = "Search friends...";
    style2(searchInput, {
      width: "100%",
      padding: "8px 12px",
      border: "1px solid rgba(255,255,255,0.1)",
      borderRadius: "8px",
      background: "rgba(255,255,255,0.04)",
      color: "#e7eef7",
      fontSize: "12px",
      outline: "none",
      boxSizing: "border-box",
      transition: "border-color 120ms ease"
    });
    searchInput.onfocus = () => style2(searchInput, { borderColor: "rgba(94,234,212,0.4)" });
    searchInput.onblur = () => style2(searchInput, { borderColor: "rgba(255,255,255,0.1)" });
    const keyBlocker = createKeyBlocker(() => document.activeElement === searchInput);
    keyBlocker.attach();
    searchWrapper.appendChild(searchInput);
    const list = document.createElement("div");
    list.className = "qws-ch-scrollable";
    style2(list, {
      flex: "1",
      overflow: "auto",
      display: "flex",
      flexDirection: "column",
      gap: "4px",
      padding: "12px 16px"
    });
    const renderFriends = (filter) => {
      list.innerHTML = "";
      const friends = getCachedFriendsWithViews();
      const query = filter.toLowerCase().trim();
      const filtered = friends.filter(
        (f) => !query || (f.playerName || "").toLowerCase().includes(query)
      );
      if (filtered.length === 0) {
        const empty = document.createElement("div");
        style2(empty, {
          padding: "24px",
          textAlign: "center",
          color: "rgba(226,232,240,0.4)",
          fontSize: "12px"
        });
        empty.textContent = query ? "No friends match your search" : "No friends yet";
        list.appendChild(empty);
        return;
      }
      for (const friend of filtered) {
        const isMember = memberIds.has(friend.playerId);
        const isInvited = invitedIds.has(friend.playerId);
        list.appendChild(
          buildFriendInviteRow(
            friend,
            isMember,
            isInvited,
            groupId,
            invitedIds,
            () => renderFriends(searchInput.value)
          )
        );
      }
    };
    searchInput.oninput = () => renderFriends(searchInput.value);
    renderFriends("");
    modal.append(header, searchWrapper, list);
    overlay.appendChild(modal);
    return { overlay, cleanup: () => keyBlocker.detach() };
  }
  function buildFriendInviteRow(friend, isMember, isInvited, groupId, invitedIds, reRender) {
    const row = document.createElement("div");
    style2(row, {
      display: "flex",
      alignItems: "center",
      gap: "10px",
      padding: "8px 10px",
      borderRadius: "8px",
      transition: "background 120ms ease"
    });
    row.onmouseenter = () => style2(row, { background: "rgba(255,255,255,0.04)" });
    row.onmouseleave = () => style2(row, { background: "transparent" });
    const avatarWrapper = document.createElement("div");
    style2(avatarWrapper, { position: "relative", flexShrink: "0" });
    const avatar2 = document.createElement("div");
    style2(avatar2, {
      width: "36px",
      height: "36px",
      borderRadius: "50%",
      background: friend.avatarUrl ? `url(${friend.avatarUrl}) center/cover` : "linear-gradient(135deg, rgba(94,234,212,0.3), rgba(59,130,246,0.3))",
      border: "2px solid rgba(255,255,255,0.1)"
    });
    const onlineDot = document.createElement("div");
    style2(onlineDot, {
      position: "absolute",
      bottom: "0",
      right: "0",
      width: "10px",
      height: "10px",
      borderRadius: "50%",
      background: friend.isOnline ? "#10b981" : "#6b7280",
      border: "2px solid #1a1f2e"
    });
    avatarWrapper.append(avatar2, onlineDot);
    const name = document.createElement("div");
    style2(name, {
      flex: "1",
      fontSize: "13px",
      fontWeight: "600",
      color: "#e7eef7",
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    });
    name.textContent = friend.playerName || "Unknown";
    row.append(avatarWrapper, name);
    if (isMember) {
      const badge = document.createElement("div");
      style2(badge, {
        padding: "4px 10px",
        borderRadius: "6px",
        fontSize: "11px",
        fontWeight: "600",
        background: "rgba(255,255,255,0.06)",
        color: "rgba(226,232,240,0.4)",
        flexShrink: "0"
      });
      badge.textContent = "In group";
      row.appendChild(badge);
    } else if (isInvited) {
      const badge = document.createElement("div");
      style2(badge, {
        padding: "4px 10px",
        borderRadius: "6px",
        fontSize: "11px",
        fontWeight: "600",
        background: "rgba(16,185,129,0.12)",
        color: "#10b981",
        flexShrink: "0"
      });
      badge.textContent = "Invited";
      row.appendChild(badge);
    } else {
      const btn = document.createElement("button");
      btn.textContent = "Invite";
      style2(btn, {
        padding: "4px 12px",
        borderRadius: "6px",
        border: "1px solid rgba(94,234,212,0.3)",
        background: "rgba(94,234,212,0.1)",
        color: "#5eead4",
        fontSize: "11px",
        fontWeight: "600",
        cursor: "pointer",
        transition: "all 120ms ease",
        flexShrink: "0"
      });
      btn.onmouseenter = () => style2(btn, { background: "rgba(94,234,212,0.2)", borderColor: "rgba(94,234,212,0.5)" });
      btn.onmouseleave = () => style2(btn, { background: "rgba(94,234,212,0.1)", borderColor: "rgba(94,234,212,0.3)" });
      btn.onclick = async () => {
        invitedIds.add(friend.playerId);
        reRender();
        const success = await addGroupMember({ groupId, memberId: friend.playerId });
        if (!success) {
          invitedIds.delete(friend.playerId);
          reRender();
          toastSimple("Failed to invite member", "", "error");
        }
      };
      row.appendChild(btn);
    }
    return row;
  }

  // src/ui/menus/communityHub/tabs/groupCreateView.ts
  function createGroupCreateView(params) {
    ensureSharedStyles();
    const { onBack, onCreate } = params;
    const root = document.createElement("div");
    style2(root, { display: "flex", flexDirection: "column", height: "100%", overflow: "hidden" });
    const header = document.createElement("div");
    style2(header, {
      display: "flex",
      alignItems: "center",
      gap: "12px",
      paddingBottom: "12px",
      borderBottom: "1px solid rgba(255,255,255,0.08)",
      marginBottom: "16px"
    });
    const backBtn = document.createElement("button");
    style2(backBtn, {
      width: "32px",
      height: "32px",
      borderRadius: "8px",
      border: "1px solid rgba(255,255,255,0.12)",
      background: "rgba(255,255,255,0.04)",
      color: "#e7eef7",
      display: "grid",
      placeItems: "center",
      cursor: "pointer",
      transition: "all 120ms ease",
      flexShrink: "0"
    });
    backBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>`;
    backBtn.onclick = onBack;
    backBtn.onmouseenter = () => {
      style2(backBtn, { background: "rgba(255,255,255,0.08)", borderColor: "rgba(94,234,212,0.35)" });
    };
    backBtn.onmouseleave = () => {
      style2(backBtn, { background: "rgba(255,255,255,0.04)", borderColor: "rgba(255,255,255,0.12)" });
    };
    const title = document.createElement("div");
    style2(title, {
      fontSize: "15px",
      fontWeight: "700",
      color: "#e7eef7"
    });
    title.textContent = "Create New Group";
    header.append(backBtn, title);
    const formContainer = document.createElement("div");
    style2(formContainer, {
      flex: "1",
      display: "flex",
      flexDirection: "column",
      gap: "20px",
      overflow: "auto",
      paddingRight: "8px"
    });
    formContainer.className = "qws-ch-scrollable";
    const nameField = createFormField("Group Name", "Enter group name...", "text");
    const nameInput = nameField.input;
    const keyBlocker = createKeyBlocker(() => document.activeElement === nameInput);
    keyBlocker.attach();
    const visibilitySection = document.createElement("div");
    style2(visibilitySection, { display: "flex", flexDirection: "column", gap: "10px" });
    const visibilityLabel = document.createElement("div");
    style2(visibilityLabel, {
      fontSize: "12px",
      fontWeight: "600",
      color: "#e7eef7"
    });
    visibilityLabel.textContent = "Visibility";
    const visibilityOptions = document.createElement("div");
    style2(visibilityOptions, { display: "flex", gap: "10px" });
    let isPublic = false;
    const privateOption = createVisibilityOption(
      "Private",
      "Only invited members can join",
      true,
      () => {
        isPublic = false;
        privateOption.classList.add("active");
        publicOption.classList.remove("active");
        style2(privateOption, {
          borderColor: "rgba(94,234,212,0.35)",
          background: "rgba(94,234,212,0.12)"
        });
        style2(publicOption, {
          borderColor: "rgba(255,255,255,0.08)",
          background: "rgba(255,255,255,0.03)"
        });
      }
    );
    const publicOption = createVisibilityOption(
      "Public",
      "Anyone can join",
      false,
      () => {
        isPublic = true;
        publicOption.classList.add("active");
        privateOption.classList.remove("active");
        style2(publicOption, {
          borderColor: "rgba(94,234,212,0.35)",
          background: "rgba(94,234,212,0.12)"
        });
        style2(privateOption, {
          borderColor: "rgba(255,255,255,0.08)",
          background: "rgba(255,255,255,0.03)"
        });
      }
    );
    visibilityOptions.append(privateOption, publicOption);
    visibilitySection.append(visibilityLabel, visibilityOptions);
    const infoBox = document.createElement("div");
    style2(infoBox, {
      padding: "12px",
      borderRadius: "10px",
      background: "rgba(94,234,212,0.08)",
      border: "1px solid rgba(94,234,212,0.2)",
      fontSize: "12px",
      color: "rgba(226,232,240,0.8)",
      lineHeight: "1.5"
    });
    infoBox.innerHTML = `
    <div style="font-weight: 600; color: #5eead4; margin-bottom: 6px;">\u{1F4CB} Group Info</div>
    <ul style="margin: 0; padding-left: 18px;">
      <li>You will be the owner of this group</li>
      <li>Maximum 100 members per group</li>
      <li>You can rename or delete the group later</li>
    </ul>
  `;
    formContainer.append(nameField.container, visibilitySection, infoBox);
    const actions = document.createElement("div");
    style2(actions, {
      display: "flex",
      gap: "10px",
      padding: "12px 0",
      // Padding top and bottom to prevent buttons from being stuck to edges
      borderTop: "1px solid rgba(255,255,255,0.08)"
    });
    const cancelBtn = document.createElement("button");
    style2(cancelBtn, {
      flex: "1",
      padding: "10px 16px",
      borderRadius: "8px",
      border: "1px solid rgba(255,255,255,0.12)",
      background: "rgba(255,255,255,0.04)",
      color: "#e7eef7",
      fontSize: "13px",
      fontWeight: "600",
      cursor: "pointer",
      transition: "all 120ms ease"
    });
    cancelBtn.textContent = "Cancel";
    cancelBtn.onclick = onBack;
    cancelBtn.onmouseenter = () => {
      style2(cancelBtn, { background: "rgba(255,255,255,0.08)", borderColor: "rgba(255,255,255,0.2)" });
    };
    cancelBtn.onmouseleave = () => {
      style2(cancelBtn, { background: "rgba(255,255,255,0.04)", borderColor: "rgba(255,255,255,0.12)" });
    };
    const createBtn = document.createElement("button");
    style2(createBtn, {
      flex: "1",
      padding: "10px 16px",
      borderRadius: "8px",
      border: "1px solid rgba(94,234,212,0.3)",
      background: "rgba(94,234,212,0.18)",
      color: "#5eead4",
      fontSize: "13px",
      fontWeight: "600",
      cursor: "pointer",
      transition: "all 120ms ease"
    });
    createBtn.textContent = "Create Group";
    createBtn.onclick = async () => {
      const name = nameInput.value.trim();
      if (!name) {
        nameField.container.style.animation = "none";
        setTimeout(() => {
          nameField.container.style.animation = "shake 0.3s ease";
        }, 10);
        nameInput.focus();
        return;
      }
      createBtn.disabled = true;
      style2(createBtn, { opacity: "0.5", cursor: "not-allowed" });
      const originalText = createBtn.textContent;
      createBtn.textContent = "Creating...";
      try {
        await onCreate(name, isPublic);
      } finally {
        createBtn.disabled = false;
        style2(createBtn, { opacity: "1", cursor: "pointer" });
        createBtn.textContent = originalText || "Create Group";
      }
    };
    createBtn.onmouseenter = () => {
      style2(createBtn, { background: "rgba(94,234,212,0.25)", borderColor: "rgba(94,234,212,0.5)" });
    };
    createBtn.onmouseleave = () => {
      style2(createBtn, { background: "rgba(94,234,212,0.18)", borderColor: "rgba(94,234,212,0.3)" });
    };
    actions.append(cancelBtn, createBtn);
    root.append(header, formContainer, actions);
    if (!document.getElementById("group-create-shake-animation")) {
      const style3 = document.createElement("style");
      style3.id = "group-create-shake-animation";
      style3.textContent = `
      @keyframes shake {
        0%, 100% { transform: translateX(0); }
        25% { transform: translateX(-5px); }
        75% { transform: translateX(5px); }
      }
    `;
      document.head.appendChild(style3);
    }
    root.__cleanup = () => {
      keyBlocker.detach();
    };
    return root;
  }
  function createFormField(label2, placeholder, type = "text") {
    const container = document.createElement("div");
    style2(container, { display: "flex", flexDirection: "column", gap: "8px" });
    const labelEl = document.createElement("label");
    style2(labelEl, {
      fontSize: "12px",
      fontWeight: "600",
      color: "#e7eef7"
    });
    labelEl.textContent = label2;
    const input = document.createElement("input");
    input.type = type;
    input.placeholder = placeholder;
    input.maxLength = 40;
    style2(input, {
      padding: "10px 14px",
      border: "1px solid rgba(255,255,255,0.12)",
      borderRadius: "10px",
      background: "rgba(255,255,255,0.04)",
      color: "#e7eef7",
      fontSize: "13px",
      outline: "none",
      transition: "border-color 150ms ease"
    });
    input.onfocus = () => style2(input, { borderColor: "rgba(94,234,212,0.35)" });
    input.onblur = () => style2(input, { borderColor: "rgba(255,255,255,0.12)" });
    const counter = document.createElement("div");
    style2(counter, {
      fontSize: "11px",
      color: "rgba(226,232,240,0.5)",
      textAlign: "right"
    });
    counter.textContent = `0 / 40`;
    input.oninput = () => {
      const length = input.value.length;
      counter.textContent = `${length} / 40`;
      style2(counter, { color: length > 35 ? "#fbbf24" : "rgba(226,232,240,0.5)" });
    };
    container.append(labelEl, input, counter);
    return { container, input };
  }
  function createVisibilityOption(title, description, active, onClick) {
    const option = document.createElement("div");
    style2(option, {
      flex: "1",
      padding: "12px",
      borderRadius: "10px",
      border: "1px solid rgba(255,255,255,0.08)",
      background: "rgba(255,255,255,0.03)",
      cursor: "pointer",
      transition: "all 120ms ease"
    });
    if (active) {
      option.classList.add("active");
      style2(option, {
        borderColor: "rgba(94,234,212,0.35)",
        background: "rgba(94,234,212,0.12)"
      });
    }
    const titleEl = document.createElement("div");
    style2(titleEl, {
      fontSize: "13px",
      fontWeight: "600",
      color: "#e7eef7",
      marginBottom: "4px"
    });
    titleEl.textContent = title;
    const descEl = document.createElement("div");
    style2(descEl, {
      fontSize: "11px",
      color: "rgba(226,232,240,0.6)",
      lineHeight: "1.4"
    });
    descEl.textContent = description;
    option.append(titleEl, descEl);
    option.onclick = onClick;
    option.onmouseenter = () => {
      if (!option.classList.contains("active")) {
        style2(option, { background: "rgba(255,255,255,0.06)", borderColor: "rgba(94,234,212,0.15)" });
      }
    };
    option.onmouseleave = () => {
      if (!option.classList.contains("active")) {
        style2(option, { background: "rgba(255,255,255,0.03)", borderColor: "rgba(255,255,255,0.08)" });
      }
    };
    return option;
  }

  // src/ui/menus/communityHub/tabs/groupsTab.ts
  function createGroupsTab() {
    ensureSharedStyles();
    const root = document.createElement("div");
    style2(root, { display: "flex", flexDirection: "column", height: "100%", overflow: "hidden" });
    let currentDetailView = null;
    const showGroupDetail = async (group) => {
      style2(tabsHeader, { display: "none" });
      style2(tabContainer, { display: "none" });
      const loadingView = createLoadingView2(async () => {
        if (currentDetailView) {
          currentDetailView.remove();
          currentDetailView = null;
        }
        style2(tabsHeader, { display: "flex" });
        style2(tabContainer, { display: "block" });
      });
      currentDetailView = loadingView;
      root.appendChild(loadingView);
      const detailView = await createGroupDetailView({
        group,
        onBack: async () => {
          if (currentDetailView) {
            const cleanup2 = currentDetailView.__cleanup;
            if (typeof cleanup2 === "function") cleanup2();
            currentDetailView.remove();
            currentDetailView = null;
          }
          style2(tabsHeader, { display: "flex" });
          style2(tabContainer, { display: "block" });
        }
      });
      if (currentDetailView) {
        currentDetailView.remove();
        currentDetailView = null;
      }
      currentDetailView = detailView;
      root.appendChild(currentDetailView);
    };
    const showGroupCreate = () => {
      style2(tabsHeader, { display: "none" });
      style2(tabContainer, { display: "none" });
      const createView = createGroupCreateView({
        onBack: () => {
          if (currentDetailView) {
            const cleanup2 = currentDetailView.__cleanup;
            if (typeof cleanup2 === "function") cleanup2();
            currentDetailView.remove();
            currentDetailView = null;
          }
          style2(tabsHeader, { display: "flex" });
          style2(tabContainer, { display: "block" });
        },
        onCreate: async (name, isPublic) => {
          const loadingView = createLoadingView2(() => {
            if (currentDetailView) {
              const cleanup2 = currentDetailView.__cleanup;
              if (typeof cleanup2 === "function") cleanup2();
              currentDetailView.remove();
              currentDetailView = null;
            }
            style2(tabsHeader, { display: "flex" });
            style2(tabContainer, { display: "block" });
          });
          if (currentDetailView) {
            const cleanup2 = currentDetailView.__cleanup;
            if (typeof cleanup2 === "function") cleanup2();
            currentDetailView.remove();
          }
          currentDetailView = loadingView;
          root.appendChild(loadingView);
          const loadingText = loadingView.querySelector("div:nth-child(2)");
          if (loadingText) loadingText.textContent = "Creating group...";
          const result = await createGroup({ name, isPublic });
          if (currentDetailView) {
            currentDetailView.remove();
            currentDetailView = null;
          }
          if (result) {
            const [myGroups, publicGroups] = await Promise.all([
              fetchGroups(),
              isPublic ? fetchPublicGroups() : Promise.resolve([])
            ]);
            updateCachedGroups(myGroups);
            if (isPublic && publicGroups.length > 0) {
              updateCachedPublicGroups(publicGroups);
            }
            window.dispatchEvent(new CustomEvent(CH_EVENTS.GROUPS_REFRESH));
            style2(tabsHeader, { display: "flex" });
            style2(tabContainer, { display: "block" });
          } else {
            console.error("[groups] Failed to create group");
            style2(tabsHeader, { display: "flex" });
            style2(tabContainer, { display: "block" });
          }
        }
      });
      currentDetailView = createView;
      root.appendChild(createView);
    };
    const tabsHeader = document.createElement("div");
    style2(tabsHeader, {
      display: "flex",
      gap: "8px",
      padding: "0 0 12px 0",
      borderBottom: "1px solid rgba(255,255,255,0.08)",
      marginBottom: "12px"
    });
    const tabButtons = {
      "my-groups": createTabButton2("My Groups", true),
      "public-groups": createTabButton2("Public Groups", false)
    };
    tabsHeader.append(tabButtons["my-groups"], tabButtons["public-groups"]);
    const myGroupsTab = createMyGroupsSubTab(showGroupDetail, showGroupCreate);
    const publicGroupsTab = createPublicGroupsSubTab(showGroupDetail);
    const tabContents = {
      "my-groups": myGroupsTab.root,
      "public-groups": publicGroupsTab.root
    };
    const tabContainer = document.createElement("div");
    style2(tabContainer, { flex: "1", overflow: "hidden", position: "relative" });
    for (const [id, content] of Object.entries(tabContents)) {
      style2(content, { display: id === "my-groups" ? "flex" : "none", height: "100%" });
      tabContainer.appendChild(content);
    }
    root.append(tabsHeader, tabContainer);
    let activeTab = "my-groups";
    const switchTab = (tabId) => {
      if (activeTab === tabId) return;
      style2(tabContents[activeTab], { display: "none" });
      tabButtons[activeTab].classList.remove("active");
      style2(tabButtons[activeTab], { background: "transparent", color: "#c9d4e6" });
      activeTab = tabId;
      style2(tabContents[tabId], { display: "flex" });
      tabButtons[tabId].classList.add("active");
      style2(tabButtons[tabId], { background: "rgba(94,234,212,0.18)", color: "#ecfdf5" });
    };
    tabButtons["my-groups"].onclick = () => switchTab("my-groups");
    tabButtons["public-groups"].onclick = () => switchTab("public-groups");
    return {
      id: "groups",
      root,
      show: () => style2(root, { display: "flex" }),
      hide: () => style2(root, { display: "none" }),
      destroy: () => {
        myGroupsTab.destroy?.();
        publicGroupsTab.destroy?.();
        root.remove();
      }
    };
  }
  function createTabButton2(label2, active) {
    const btn = document.createElement("button");
    btn.textContent = label2;
    btn.className = active ? "active" : "";
    style2(btn, {
      flex: "1",
      padding: "8px 16px",
      border: "1px solid rgba(255,255,255,0.08)",
      borderRadius: "8px",
      background: active ? "rgba(94,234,212,0.18)" : "transparent",
      color: active ? "#ecfdf5" : "#c9d4e6",
      fontSize: "12px",
      fontWeight: "600",
      cursor: "pointer",
      transition: "all 120ms ease"
    });
    btn.onmouseenter = () => {
      if (!btn.classList.contains("active")) {
        style2(btn, { background: "rgba(94,234,212,0.08)", color: "#e7eef7" });
      }
    };
    btn.onmouseleave = () => {
      if (!btn.classList.contains("active")) {
        style2(btn, { background: "transparent", color: "#c9d4e6" });
      }
    };
    return btn;
  }
  function createLoadingView2(onBack) {
    const view = document.createElement("div");
    style2(view, {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center",
      height: "100%",
      gap: "16px"
    });
    const spinner = document.createElement("div");
    style2(spinner, {
      width: "32px",
      height: "32px",
      border: "3px solid rgba(94,234,212,0.2)",
      borderTop: "3px solid #5eead4",
      borderRadius: "50%",
      animation: "spin 0.8s linear infinite"
    });
    const text = document.createElement("div");
    style2(text, {
      fontSize: "13px",
      color: "rgba(226,232,240,0.7)"
    });
    text.textContent = "Loading group...";
    const backBtn = document.createElement("button");
    style2(backBtn, {
      padding: "8px 16px",
      borderRadius: "8px",
      border: "1px solid rgba(255,255,255,0.12)",
      background: "rgba(255,255,255,0.04)",
      color: "#e7eef7",
      fontSize: "12px",
      fontWeight: "600",
      cursor: "pointer"
    });
    backBtn.textContent = "Cancel";
    backBtn.onclick = onBack;
    view.append(spinner, text, backBtn);
    return view;
  }

  // src/ui/menus/communityHub/tabs/leaderboardTab.ts
  function createLeaderboardTab() {
    ensureSharedStyles();
    const root = document.createElement("div");
    style2(root, {
      display: "flex",
      flexDirection: "column",
      height: "100%",
      gap: "12px"
    });
    let activeCategory = "coins";
    let isLoading = false;
    let debounceTimer = null;
    const tabsContainer = document.createElement("div");
    style2(tabsContainer, {
      display: "flex",
      gap: "6px",
      borderBottom: "1px solid rgba(255,255,255,0.08)",
      paddingBottom: "8px"
    });
    const coinsTab = createCategoryTab("Coins", "coins");
    const eggsTab = createCategoryTab("Eggs Hatched", "eggsHatched");
    function createCategoryTab(label2, category) {
      const tab = document.createElement("button");
      tab.textContent = label2;
      style2(tab, {
        flex: "1",
        padding: "8px 16px",
        border: "none",
        borderRadius: "8px",
        background: "transparent",
        color: "rgba(226,232,240,0.6)",
        fontSize: "13px",
        fontWeight: "600",
        cursor: "pointer",
        transition: "all 120ms ease"
      });
      const updateTabStyle = () => {
        if (activeCategory === category) {
          style2(tab, {
            background: "rgba(94,234,212,0.15)",
            color: "#5eead4"
          });
        } else {
          style2(tab, {
            background: "transparent",
            color: "rgba(226,232,240,0.6)"
          });
        }
      };
      tab.onmouseenter = () => {
        if (activeCategory !== category) {
          style2(tab, { background: "rgba(255,255,255,0.05)" });
        }
      };
      tab.onmouseleave = () => {
        updateTabStyle();
      };
      tab.onclick = () => {
        if (activeCategory !== category) {
          activeCategory = category;
          updateTabStyle();
          updateCategoryTab(coinsTab, "coins");
          updateCategoryTab(eggsTab, "eggsHatched");
          searchBar.value = "";
          renderLeaderboard();
        }
      };
      updateTabStyle();
      return tab;
    }
    function updateCategoryTab(tab, category) {
      if (activeCategory === category) {
        style2(tab, {
          background: "rgba(94,234,212,0.15)",
          color: "#5eead4"
        });
      } else {
        style2(tab, {
          background: "transparent",
          color: "rgba(226,232,240,0.6)"
        });
      }
    }
    tabsContainer.append(coinsTab, eggsTab);
    const controlsContainer = document.createElement("div");
    style2(controlsContainer, {
      display: "flex",
      gap: "8px",
      alignItems: "center"
    });
    const searchBar = document.createElement("input");
    searchBar.type = "text";
    searchBar.placeholder = "Search player...";
    style2(searchBar, {
      flex: "1",
      padding: "10px 14px",
      border: "1px solid rgba(255,255,255,0.12)",
      borderRadius: "10px",
      background: "rgba(255,255,255,0.04)",
      color: "#e7eef7",
      fontSize: "13px",
      outline: "none",
      transition: "border-color 150ms ease"
    });
    const keyBlocker = createKeyBlocker(() => document.activeElement === searchBar);
    keyBlocker.attach();
    searchBar.onfocus = () => style2(searchBar, { borderColor: "rgba(94,234,212,0.35)" });
    searchBar.onblur = () => style2(searchBar, { borderColor: "rgba(255,255,255,0.12)" });
    const refreshButton = document.createElement("button");
    refreshButton.innerHTML = `
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="23 4 23 10 17 10"/>
      <polyline points="1 20 1 14 7 14"/>
      <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/>
    </svg>
  `;
    style2(refreshButton, {
      padding: "10px 16px",
      border: "1px solid rgba(255,255,255,0.12)",
      borderRadius: "10px",
      background: "rgba(94,234,212,0.12)",
      color: "#5eead4",
      cursor: "pointer",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transition: "all 120ms ease"
    });
    refreshButton.onmouseenter = () => {
      style2(refreshButton, {
        background: "rgba(94,234,212,0.2)",
        borderColor: "rgba(94,234,212,0.35)"
      });
    };
    refreshButton.onmouseleave = () => {
      style2(refreshButton, {
        background: "rgba(94,234,212,0.12)",
        borderColor: "rgba(255,255,255,0.12)"
      });
    };
    refreshButton.onclick = async () => {
      await performRefresh();
    };
    controlsContainer.append(searchBar, refreshButton);
    const leaderboardList = document.createElement("div");
    leaderboardList.className = "qws-ch-scrollable";
    style2(leaderboardList, {
      flex: "1",
      overflow: "auto",
      display: "flex",
      flexDirection: "column",
      gap: "6px",
      paddingRight: "8px"
    });
    const footer = document.createElement("div");
    style2(footer, {
      padding: "12px",
      borderTop: "1px solid rgba(255,255,255,0.06)",
      fontSize: "12px",
      color: "rgba(226,232,240,0.7)",
      display: "none"
    });
    const performRefresh = async () => {
      if (isLoading) return;
      isLoading = true;
      renderLeaderboard();
      const query = searchBar.value.trim();
      const myPlayerId = getCachedMyProfile()?.playerId;
      try {
        let rows = [];
        let myRank = null;
        if (activeCategory === "coins") {
          const result = await fetchLeaderboardCoins({
            query: query || void 0,
            limit: 15,
            myPlayerId
          });
          rows = result.rows;
          myRank = result.myRank;
        } else {
          const result = await fetchLeaderboardEggsHatched({
            query: query || void 0,
            limit: 15,
            myPlayerId
          });
          rows = result.rows;
          myRank = result.myRank;
        }
        const cachedData = getCachedLeaderboard();
        if (cachedData) {
          const updatedData = {
            coins: activeCategory === "coins" ? { top: rows, myRank: myRank ?? cachedData.coins.myRank } : cachedData.coins,
            eggsHatched: activeCategory === "eggsHatched" ? { top: rows, myRank: myRank ?? cachedData.eggsHatched.myRank } : cachedData.eggsHatched
          };
          updateLeaderboardCache(updatedData);
        }
        isLoading = false;
        renderLeaderboard();
      } catch (error) {
        console.error("[Leaderboard] Refresh failed:", error);
        isLoading = false;
        renderLeaderboard();
      }
    };
    const performSearch = async () => {
      const query = searchBar.value.trim();
      if (!query) {
        renderLeaderboard();
        return;
      }
      if (isLoading) return;
      isLoading = true;
      renderLeaderboard();
      try {
        let rows = [];
        if (activeCategory === "coins") {
          const result = await fetchLeaderboardCoins({ query, limit: 15 });
          rows = result.rows;
        } else {
          const result = await fetchLeaderboardEggsHatched({ query, limit: 15 });
          rows = result.rows;
        }
        isLoading = false;
        renderLeaderboard(rows);
      } catch (error) {
        console.error("[Leaderboard] Search failed:", error);
        isLoading = false;
        renderLeaderboard([]);
      }
    };
    searchBar.oninput = () => {
      if (debounceTimer) clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => performSearch(), 300);
    };
    const renderLeaderboard = (searchResults) => {
      leaderboardList.innerHTML = "";
      footer.style.display = "none";
      if (isLoading) {
        const loading = document.createElement("div");
        style2(loading, {
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          justifyContent: "center",
          height: "100%",
          gap: "12px",
          color: "rgba(226,232,240,0.5)",
          fontSize: "13px"
        });
        loading.innerHTML = `
        <svg width="32" height="32" viewBox="0 0 24 24" fill="none" style="animation: spin 1s linear infinite;">
          <circle cx="12" cy="12" r="10" stroke="rgba(94,234,212,0.5)" stroke-width="2" stroke-dasharray="15 5" fill="none"/>
        </svg>
        <div>Loading...</div>
      `;
        leaderboardList.appendChild(loading);
        return;
      }
      const cachedData = getCachedLeaderboard();
      let rows = [];
      let myRank = null;
      if (searchResults !== void 0) {
        rows = searchResults;
      } else {
        if (cachedData) {
          const categoryData = activeCategory === "coins" ? cachedData.coins : cachedData.eggsHatched;
          rows = categoryData.top || [];
          myRank = categoryData.myRank;
        }
      }
      if (rows.length === 0) {
        const empty = document.createElement("div");
        style2(empty, {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          height: "100%",
          color: "rgba(226,232,240,0.5)",
          fontSize: "13px"
        });
        empty.textContent = "No players ranked yet";
        leaderboardList.appendChild(empty);
        return;
      }
      for (const row of rows) {
        leaderboardList.appendChild(createLeaderboardRow(row, activeCategory));
      }
      if (myRank && searchResults === void 0) {
        const myProfile = getCachedMyProfile();
        const myPlayerId = myProfile?.playerId;
        const isInTop15 = rows.some((r) => r.playerId === myPlayerId);
        if (!isInTop15) {
          footer.innerHTML = "";
          footer.appendChild(createLeaderboardRow(myRank, activeCategory, true));
          footer.style.display = "block";
        }
      }
    };
    function createLeaderboardRow(row, category, isMyRank = false) {
      const card2 = document.createElement("div");
      style2(card2, {
        padding: "10px 12px",
        background: isMyRank ? "rgba(94,234,212,0.08)" : "rgba(255,255,255,0.02)",
        borderRadius: "10px",
        border: isMyRank ? "1px solid rgba(94,234,212,0.25)" : "1px solid rgba(255,255,255,0.06)",
        display: "flex",
        alignItems: "center",
        gap: "12px",
        transition: "all 120ms ease"
      });
      if (!isMyRank) {
        card2.onmouseenter = () => {
          style2(card2, {
            background: "rgba(255,255,255,0.05)",
            borderColor: "rgba(94,234,212,0.15)"
          });
        };
        card2.onmouseleave = () => {
          style2(card2, {
            background: "rgba(255,255,255,0.02)",
            borderColor: "rgba(255,255,255,0.06)"
          });
        };
      }
      const rankChange = row.rankChange;
      let rankChangeIndicator = null;
      if (rankChange !== null && rankChange !== 0) {
        rankChangeIndicator = document.createElement("div");
        style2(rankChangeIndicator, {
          display: "flex",
          alignItems: "center",
          gap: "2px",
          fontSize: "13px",
          fontWeight: "700",
          marginRight: "4px",
          marginTop: "2px",
          flexShrink: "0",
          lineHeight: "1"
        });
        if (rankChange > 0) {
          rankChangeIndicator.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" style="display: block; transform: translateY(-2px);">
            <path d="M8 3L8 13M8 3L4 7M8 3L12 7" stroke="#10b981" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          <span style="color: #10b981; line-height: 1;">${rankChange}</span>
        `;
        } else {
          rankChangeIndicator.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" style="display: block; transform: translateY(-2px);">
            <path d="M8 13L8 3M8 13L12 9M8 13L4 9" stroke="#ef4444" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          <span style="color: #ef4444; line-height: 1;">${Math.abs(rankChange)}</span>
        `;
        }
      }
      const rankBadge = document.createElement("div");
      style2(rankBadge, {
        fontSize: "15px",
        fontWeight: "700",
        color: row.rank === 1 ? "#fbbf24" : row.rank === 2 ? "#d1d5db" : row.rank === 3 ? "#d97706" : "#5eead4",
        flexShrink: "0",
        marginTop: "2px"
      });
      rankBadge.textContent = `#${row.rank}`;
      const avatar2 = document.createElement("div");
      const isAnonymous = row.playerId === "null" || row.playerName === "anonymous";
      style2(avatar2, {
        width: "36px",
        height: "36px",
        borderRadius: "50%",
        background: isAnonymous ? "linear-gradient(135deg, #64748b, #475569)" : row.avatarUrl ? `url(${row.avatarUrl}) center/cover` : "linear-gradient(135deg, rgba(94,234,212,0.3), rgba(59,130,246,0.3))",
        border: "2px solid rgba(255,255,255,0.1)",
        flexShrink: "0",
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      });
      if (isAnonymous) {
        avatar2.innerHTML = `
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
          <circle cx="12" cy="7" r="4"/>
        </svg>
      `;
      }
      const name = document.createElement("div");
      style2(name, {
        flex: "1",
        fontSize: "13px",
        fontWeight: "600",
        color: isAnonymous ? "rgba(226,232,240,0.4)" : "#e7eef7",
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
      });
      name.textContent = isAnonymous ? "Anonymous" : row.playerName || "Unknown";
      const total = document.createElement("div");
      style2(total, {
        fontSize: "13px",
        fontWeight: "700",
        color: "#5eead4",
        flexShrink: "0"
      });
      total.textContent = formatPrice(row.total) ?? String(row.total);
      if (rankChangeIndicator) {
        card2.append(rankChangeIndicator, rankBadge, avatar2, name, total);
      } else {
        card2.append(rankBadge, avatar2, name, total);
      }
      return card2;
    }
    renderLeaderboard();
    const unsubWelcome = onWelcome((data) => {
      if (data.leaderboard) {
        const leaderboardData = {
          coins: data.leaderboard.coins || { top: [], myRank: null },
          eggsHatched: data.leaderboard.eggsHatched || { top: [], myRank: null }
        };
        updateLeaderboardCache(leaderboardData);
        renderLeaderboard();
      }
    });
    root.append(tabsContainer, controlsContainer, leaderboardList, footer);
    return {
      id: "leaderboard",
      root,
      show: () => style2(root, { display: "flex" }),
      hide: () => style2(root, { display: "none" }),
      destroy: () => {
        keyBlocker.detach();
        if (debounceTimer) clearTimeout(debounceTimer);
        unsubWelcome();
        root.remove();
      }
    };
  }

  // src/ui/menus/communityHub/notificationSound.ts
  var NOTIFICATION_SOUND_URL = "https://cdn.pixabay.com/audio/2025/09/09/audio_3023b9bde2.mp3";
  var NOTIFICATION_VOLUME = 0.2;
  var STORAGE_PATH = "notifications.soundEnabled";
  var audioElement = null;
  var audioUrlSafe = null;
  var audioReady = false;
  var lastFriendUnreadCount = 0;
  var lastGroupUnreadCount = 0;
  var lastRequestsCount = 0;
  async function initNotificationSound() {
    lastFriendUnreadCount = getTotalFriendUnreadCount();
    lastGroupUnreadCount = getTotalGroupUnreadCount();
    lastRequestsCount = getIncomingRequestsCount();
    const initialTotal = lastFriendUnreadCount + lastGroupUnreadCount + lastRequestsCount;
    try {
      audioUrlSafe = await getAudioUrlSafe(NOTIFICATION_SOUND_URL);
      audioElement = new Audio();
      audioElement.volume = NOTIFICATION_VOLUME;
      audioElement.preload = "auto";
      audioElement.src = audioUrlSafe;
      audioReady = true;
      if (initialTotal > 0) {
        playNotificationSound();
      }
    } catch (error) {
      console.error("[NotificationSound] Failed to initialize:", error);
    }
  }
  function isNotificationSoundEnabled() {
    const value = readAriesPath(STORAGE_PATH, true);
    return value === true;
  }
  function setNotificationSoundEnabled(enabled) {
    writeAriesPath(STORAGE_PATH, enabled);
  }
  function playNotificationSound() {
    const enabled = isNotificationSoundEnabled();
    if (!enabled) {
      return;
    }
    if (!audioReady || !audioElement || !audioUrlSafe) {
      console.warn("[NotificationSound] Audio not ready yet");
      return;
    }
    try {
      audioElement.currentTime = 0;
      const playPromise = audioElement.play();
      if (playPromise !== void 0) {
        playPromise.catch((error) => {
          console.warn("[NotificationSound] Play failed (autoplay restriction?):", error);
        });
      }
    } catch (error) {
      console.error("[NotificationSound] Failed to play:", error);
    }
  }
  function checkAndPlayNotificationSound(friendUnread, groupUnread, requestsCount) {
    const currentTotal = friendUnread + groupUnread + requestsCount;
    const lastTotal = lastFriendUnreadCount + lastGroupUnreadCount + lastRequestsCount;
    if (currentTotal > lastTotal) {
      playNotificationSound();
    }
    lastFriendUnreadCount = friendUnread;
    lastGroupUnreadCount = groupUnread;
    lastRequestsCount = requestsCount;
  }
  function resetNotificationCounts() {
    lastFriendUnreadCount = 0;
    lastGroupUnreadCount = 0;
    lastRequestsCount = 0;
  }
  function cleanupNotificationSound() {
    if (audioElement) {
      audioElement.pause();
      audioElement.src = "";
      audioElement = null;
    }
    audioUrlSafe = null;
    audioReady = false;
    resetNotificationCounts();
  }

  // src/ui/menus/communityHub/tabs/myProfileTab.ts
  var ICON_GLOBE2 = `<svg width="13" height="13" viewBox="0 0 24 24" fill="none" style="display:inline-block;vertical-align:middle;margin-right:4px"><circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"/><path d="M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10A15.3 15.3 0 0 1 12 2z" stroke="currentColor" stroke-width="2"/></svg>`;
  var ICON_LOCK2 = `<svg width="13" height="13" viewBox="0 0 24 24" fill="none" style="display:inline-block;vertical-align:middle;margin-right:4px"><rect x="3" y="11" width="18" height="11" rx="2" stroke="currentColor" stroke-width="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>`;
  function createMyProfileTab() {
    const container = document.createElement("div");
    style2(container, {
      display: "flex",
      flexDirection: "column",
      gap: "16px",
      padding: "16px",
      height: "100%",
      overflow: "auto"
    });
    const createProfileHeader = async () => {
      const myProfile = getCachedMyProfile();
      if (!myProfile) {
        const placeholder = document.createElement("div");
        style2(placeholder, {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          padding: "24px",
          color: "rgba(226,232,240,0.5)",
          fontSize: "13px"
        });
        placeholder.textContent = "Profile not loaded yet...";
        return placeholder;
      }
      const header = document.createElement("div");
      style2(header, {
        display: "flex",
        flexDirection: "column",
        gap: "16px",
        padding: "16px",
        background: "rgba(255,255,255,0.02)",
        border: "1px solid rgba(255,255,255,0.08)",
        borderRadius: "12px"
      });
      const topRow = document.createElement("div");
      style2(topRow, {
        display: "flex",
        gap: "12px",
        alignItems: "center"
      });
      const discordAvatar = document.createElement("div");
      style2(discordAvatar, {
        width: "64px",
        height: "64px",
        borderRadius: "50%",
        background: myProfile.avatarUrl ? `url(${myProfile.avatarUrl}) center/cover` : "rgba(255,255,255,0.05)",
        flexShrink: "0"
      });
      const infoColumn = document.createElement("div");
      style2(infoColumn, {
        display: "flex",
        flexDirection: "column",
        gap: "4px",
        flex: "1"
      });
      const nameRow = document.createElement("div");
      style2(nameRow, { display: "flex", alignItems: "center", gap: "8px" });
      const name = document.createElement("div");
      style2(name, {
        fontSize: "18px",
        fontWeight: "700",
        color: "#e7eef7"
      });
      name.textContent = myProfile.name;
      nameRow.appendChild(name);
      const badgesEl = createPlayerBadges(myProfile.badges);
      if (badgesEl) {
        style2(badgesEl, { flexShrink: "0" });
        nameRow.appendChild(badgesEl);
      }
      const playerId2 = document.createElement("div");
      style2(playerId2, {
        fontSize: "11px",
        color: "rgba(226,232,240,0.4)",
        fontFamily: "monospace"
      });
      playerId2.textContent = myProfile.playerId;
      infoColumn.append(nameRow, playerId2);
      topRow.append(discordAvatar, infoColumn);
      if (myProfile.avatar && Array.isArray(myProfile.avatar) && myProfile.avatar.length > 0) {
        try {
          const gameAvatar = await createAvatarElement(myProfile.avatar, 110);
          const avatarWrapper = document.createElement("div");
          Object.assign(avatarWrapper.style, {
            width: "80px",
            height: "80px",
            overflow: "hidden",
            position: "relative",
            flexShrink: "0",
            borderRadius: "12px"
          });
          Object.assign(gameAvatar.style, {
            position: "absolute",
            top: "62%",
            left: "50%",
            transform: "translate(-50%, -50%)"
          });
          avatarWrapper.appendChild(gameAvatar);
          topRow.appendChild(avatarWrapper);
        } catch (error) {
          console.error("[MyProfile] Failed to create game avatar:", error);
        }
      }
      header.appendChild(topRow);
      return header;
    };
    const createNotificationsSection = () => {
      const section = document.createElement("div");
      style2(section, {
        display: "flex",
        flexDirection: "column",
        gap: "16px",
        padding: "16px",
        background: "rgba(255,255,255,0.02)",
        border: "1px solid rgba(255,255,255,0.08)",
        borderRadius: "12px"
      });
      const title = document.createElement("div");
      style2(title, {
        fontSize: "16px",
        fontWeight: "700",
        color: "#e7eef7"
      });
      title.textContent = "Notifications";
      const description = document.createElement("div");
      style2(description, {
        fontSize: "12px",
        color: "rgba(226,232,240,0.6)",
        lineHeight: "1.5"
      });
      description.textContent = "Configure how you receive notifications when new messages or friend requests arrive.";
      const settingsList = document.createElement("div");
      style2(settingsList, {
        display: "flex",
        flexDirection: "column",
        gap: "12px"
      });
      const soundRow = createNotificationSoundSetting();
      settingsList.appendChild(soundRow);
      section.append(title, description, settingsList);
      return section;
    };
    const createNotificationSoundSetting = () => {
      const row = document.createElement("div");
      style2(row, {
        display: "flex",
        alignItems: "center",
        gap: "12px",
        padding: "12px",
        background: "rgba(255,255,255,0.02)",
        border: "1px solid rgba(255,255,255,0.06)",
        borderRadius: "8px",
        transition: "all 120ms ease"
      });
      row.onmouseenter = () => {
        style2(row, {
          background: "rgba(255,255,255,0.04)",
          borderColor: "rgba(94,234,212,0.15)"
        });
      };
      row.onmouseleave = () => {
        style2(row, {
          background: "rgba(255,255,255,0.02)",
          borderColor: "rgba(255,255,255,0.06)"
        });
      };
      const labelEl = document.createElement("div");
      style2(labelEl, {
        flex: "1",
        fontSize: "13px",
        fontWeight: "600",
        color: "#e7eef7"
      });
      labelEl.textContent = "Notification Sound";
      const toggle = createToggleSwitch(isNotificationSoundEnabled(), (newValue) => {
        setNotificationSoundEnabled(newValue);
      });
      row.append(labelEl, toggle);
      return row;
    };
    const createPrivacySection = () => {
      const myProfile = getCachedMyProfile();
      if (!myProfile) return document.createElement("div");
      const section = document.createElement("div");
      style2(section, {
        display: "flex",
        flexDirection: "column",
        gap: "16px",
        padding: "16px",
        background: "rgba(255,255,255,0.02)",
        border: "1px solid rgba(255,255,255,0.08)",
        borderRadius: "12px"
      });
      const title = document.createElement("div");
      style2(title, {
        fontSize: "16px",
        fontWeight: "700",
        color: "#e7eef7"
      });
      title.textContent = "Privacy Settings";
      const description = document.createElement("div");
      style2(description, {
        fontSize: "12px",
        color: "rgba(226,232,240,0.6)",
        lineHeight: "1.5"
      });
      description.textContent = "Control what your friends can see on your profile and whether you appear in public leaderboards.";
      const settingsList = document.createElement("div");
      style2(settingsList, {
        display: "flex",
        flexDirection: "column",
        gap: "12px"
      });
      settingsList.appendChild(createRoomVisibilitySetting(myProfile.privacy.hideRoomFromPublicList));
      const privacySettings = [
        { key: "showGarden", label: "Garden" },
        { key: "showInventory", label: "Inventory" },
        { key: "showCoins", label: "Coins" },
        { key: "showActivityLog", label: "Activity Log" },
        { key: "showJournal", label: "Journal" },
        { key: "showStats", label: "Stats" }
      ];
      for (const setting of privacySettings) {
        const settingRow = createPrivacySetting(
          setting.label,
          myProfile.privacy[setting.key],
          setting.key
        );
        settingsList.appendChild(settingRow);
      }
      section.append(title, description, settingsList);
      return section;
    };
    const createPrivacySetting = (label2, initialValue, key2) => {
      const row = document.createElement("div");
      style2(row, {
        display: "flex",
        alignItems: "center",
        gap: "12px",
        padding: "12px",
        background: "rgba(255,255,255,0.02)",
        border: "1px solid rgba(255,255,255,0.06)",
        borderRadius: "8px",
        transition: "all 120ms ease"
      });
      row.onmouseenter = () => {
        style2(row, {
          background: "rgba(255,255,255,0.04)",
          borderColor: "rgba(94,234,212,0.15)"
        });
      };
      row.onmouseleave = () => {
        style2(row, {
          background: "rgba(255,255,255,0.02)",
          borderColor: "rgba(255,255,255,0.06)"
        });
      };
      const labelEl = document.createElement("div");
      style2(labelEl, {
        flex: "1",
        fontSize: "13px",
        fontWeight: "600",
        color: "#e7eef7"
      });
      labelEl.textContent = label2;
      const toggle = createToggleSwitch(initialValue, async (newValue) => {
        const result = await updatePrivacy({
          [key2]: newValue
        });
        if (result) {
          updateCachedMyProfilePrivacy(result);
        }
      });
      row.append(labelEl, toggle);
      return row;
    };
    const createToggleSwitch = (initialValue, onChange) => {
      let isOn = initialValue;
      const container2 = document.createElement("div");
      style2(container2, {
        position: "relative",
        width: "44px",
        height: "24px",
        borderRadius: "12px",
        background: isOn ? "rgba(94,234,212,0.3)" : "rgba(255,255,255,0.1)",
        border: isOn ? "1px solid rgba(94,234,212,0.5)" : "1px solid rgba(255,255,255,0.15)",
        cursor: "pointer",
        transition: "all 200ms ease",
        flexShrink: "0"
      });
      const knob = document.createElement("div");
      style2(knob, {
        position: "absolute",
        top: "2px",
        left: isOn ? "22px" : "2px",
        width: "18px",
        height: "18px",
        borderRadius: "50%",
        background: isOn ? "#5eead4" : "rgba(255,255,255,0.6)",
        transition: "all 200ms ease"
      });
      container2.appendChild(knob);
      const updateVisuals = () => {
        style2(container2, {
          background: isOn ? "rgba(94,234,212,0.3)" : "rgba(255,255,255,0.1)",
          borderColor: isOn ? "rgba(94,234,212,0.5)" : "rgba(255,255,255,0.15)"
        });
        style2(knob, {
          left: isOn ? "22px" : "2px",
          background: isOn ? "#5eead4" : "rgba(255,255,255,0.6)"
        });
      };
      container2.onclick = () => {
        isOn = !isOn;
        updateVisuals();
        onChange(isOn);
      };
      return container2;
    };
    const createRoomVisibilitySetting = (initialIsHidden) => {
      const row = document.createElement("div");
      style2(row, {
        display: "flex",
        alignItems: "center",
        gap: "12px",
        padding: "12px",
        background: "rgba(255,255,255,0.02)",
        border: "1px solid rgba(255,255,255,0.06)",
        borderRadius: "8px",
        transition: "all 120ms ease"
      });
      row.onmouseenter = () => style2(row, { background: "rgba(255,255,255,0.04)", borderColor: "rgba(94,234,212,0.15)" });
      row.onmouseleave = () => style2(row, { background: "rgba(255,255,255,0.02)", borderColor: "rgba(255,255,255,0.06)" });
      const labelEl = document.createElement("div");
      style2(labelEl, { flex: "1", fontSize: "13px", fontWeight: "600", color: "#e7eef7" });
      labelEl.textContent = "Room Visibility";
      const toggle = document.createElement("div");
      style2(toggle, {
        display: "flex",
        borderRadius: "6px",
        overflow: "hidden",
        border: "1px solid rgba(255,255,255,0.1)",
        flexShrink: "0"
      });
      const publicBtn = document.createElement("button");
      const privateBtn = document.createElement("button");
      const ACTIVE = { background: "rgba(94,234,212,0.15)", color: "#5eead4" };
      const INACTIVE = { background: "rgba(255,255,255,0.02)", color: "rgba(226,232,240,0.4)" };
      const applyStyles3 = (isHidden) => {
        style2(publicBtn, isHidden ? INACTIVE : ACTIVE);
        style2(privateBtn, isHidden ? ACTIVE : INACTIVE);
      };
      const BASE_BTN = {
        padding: "5px 10px",
        border: "none",
        fontSize: "11px",
        fontWeight: "600",
        cursor: "pointer",
        transition: "all 120ms ease",
        display: "flex",
        alignItems: "center"
      };
      publicBtn.innerHTML = `${ICON_GLOBE2}Public`;
      style2(publicBtn, BASE_BTN);
      privateBtn.innerHTML = `${ICON_LOCK2}Private`;
      style2(privateBtn, { ...BASE_BTN, borderLeft: "1px solid rgba(255,255,255,0.1)" });
      let currentIsHidden = initialIsHidden;
      applyStyles3(currentIsHidden);
      publicBtn.onclick = async () => {
        if (!currentIsHidden) return;
        currentIsHidden = false;
        applyStyles3(false);
        const result = await updatePrivacy({ hideRoomFromPublicList: false });
        if (result) {
          updateCachedMyProfilePrivacy(result);
        } else {
          currentIsHidden = true;
          applyStyles3(true);
        }
      };
      privateBtn.onclick = async () => {
        if (currentIsHidden) return;
        currentIsHidden = true;
        applyStyles3(true);
        const result = await updatePrivacy({ hideRoomFromPublicList: true });
        if (result) {
          updateCachedMyProfilePrivacy(result);
        } else {
          currentIsHidden = false;
          applyStyles3(false);
        }
      };
      toggle.append(publicBtn, privateBtn);
      row.append(labelEl, toggle);
      return row;
    };
    let renderCount = 0;
    const render2 = async () => {
      renderCount++;
      console.log(`[MyProfile] render() called (count: ${renderCount})`);
      container.innerHTML = "";
      const header = await createProfileHeader();
      const notificationsSection = createNotificationsSection();
      const privacySection = createPrivacySection();
      container.append(header, notificationsSection, privacySection);
    };
    const cacheExistedBeforeSubscribe = !!getCachedMyProfile();
    render2();
    let isFirstCall = true;
    const unsubscribeWelcome = onWelcome(() => {
      if (isFirstCall && cacheExistedBeforeSubscribe) {
        isFirstCall = false;
        return;
      }
      isFirstCall = false;
      render2();
    });
    return {
      id: "myProfile",
      root: container,
      show: () => style2(container, { display: "flex" }),
      hide: () => style2(container, { display: "none" }),
      destroy: () => {
        unsubscribeWelcome();
        container.remove();
      }
    };
  }

  // src/ui/menus/communityHub/authGate.ts
  function createListItem(text, iconSvg) {
    const item = document.createElement("div");
    style2(item, {
      display: "flex",
      alignItems: "center",
      gap: "8px"
    });
    const bullet = document.createElement("span");
    style2(bullet, {
      width: "18px",
      height: "18px",
      borderRadius: "6px",
      display: "grid",
      placeItems: "center",
      background: "rgba(56,189,248,0.12)",
      border: "1px solid rgba(56,189,248,0.35)",
      color: "#7dd3fc",
      flexShrink: "0"
    });
    bullet.innerHTML = iconSvg;
    const label2 = document.createElement("span");
    style2(label2, {
      fontSize: "12.5px",
      color: "rgba(226,232,240,0.82)"
    });
    label2.textContent = text;
    item.append(bullet, label2);
    return item;
  }
  function createAuthGate() {
    const container = document.createElement("div");
    style2(container, {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center",
      height: "100%",
      padding: "32px",
      overflow: "auto"
    });
    const card2 = document.createElement("div");
    style2(card2, {
      width: "min(520px, 100%)",
      background: "radial-gradient(140% 140% at 0% 0%, rgba(28,36,56,0.98), rgba(12,16,26,0.98))",
      border: "1px solid rgba(148,163,184,0.22)",
      borderRadius: "18px",
      padding: "18px 20px 16px",
      color: "#e2e8f0",
      boxShadow: "0 24px 50px rgba(0,0,0,0.55), inset 0 1px 0 rgba(255,255,255,0.06)",
      display: "flex",
      flexDirection: "column",
      gap: "12px"
    });
    const header = document.createElement("div");
    style2(header, {
      display: "flex",
      alignItems: "center",
      gap: "12px"
    });
    const icon = document.createElement("div");
    style2(icon, {
      width: "38px",
      height: "38px",
      borderRadius: "12px",
      display: "grid",
      placeItems: "center",
      background: "rgba(59,130,246,0.18)",
      border: "1px solid rgba(59,130,246,0.55)",
      color: "#dbeafe",
      flexShrink: "0"
    });
    icon.innerHTML = '<svg viewBox="0 0.5 24 24" style="width:22px;height:22px;display:block;" aria-hidden="true" focusable="false" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_537_21)"><path d="M20.317 4.54101C18.7873 3.82774 17.147 3.30224 15.4319 3.00126C15.4007 2.99545 15.3695 3.00997 15.3534 3.039C15.1424 3.4203 14.9087 3.91774 14.7451 4.30873C12.9004 4.02808 11.0652 4.02808 9.25832 4.30873C9.09465 3.90905 8.85248 3.4203 8.64057 3.039C8.62448 3.01094 8.59328 2.99642 8.56205 3.00126C6.84791 3.30128 5.20756 3.82678 3.67693 4.54101C3.66368 4.54681 3.65233 4.5565 3.64479 4.56907C0.533392 9.29283 -0.31895 13.9005 0.0991801 18.451C0.101072 18.4733 0.11337 18.4946 0.130398 18.5081C2.18321 20.0401 4.17171 20.9701 6.12328 21.5866C6.15451 21.5963 6.18761 21.5847 6.20748 21.5585C6.66913 20.9179 7.08064 20.2424 7.43348 19.532C7.4543 19.4904 7.43442 19.441 7.39186 19.4246C6.73913 19.173 6.1176 18.8662 5.51973 18.5178C5.47244 18.4897 5.46865 18.421 5.51216 18.3881C5.63797 18.2923 5.76382 18.1926 5.88396 18.0919C5.90569 18.0736 5.93598 18.0697 5.96153 18.0813C9.88928 19.9036 14.1415 19.9036 18.023 18.0813C18.0485 18.0687 18.0788 18.0726 18.1015 18.091C18.2216 18.1916 18.3475 18.2923 18.4742 18.3881C18.5177 18.421 18.5149 18.4897 18.4676 18.5178C17.8697 18.8729 17.2482 19.173 16.5945 19.4236C16.552 19.4401 16.533 19.4904 16.5538 19.532C16.9143 20.2414 17.3258 20.9169 17.7789 21.5576C17.7978 21.5847 17.8319 21.5963 17.8631 21.5866C19.8241 20.9701 21.8126 20.0401 23.8654 18.5081C23.8834 18.4946 23.8948 18.4742 23.8967 18.452C24.3971 13.1911 23.0585 8.6212 20.3482 4.57004C20.3416 4.5565 20.3303 4.54681 20.317 4.54101ZM8.02002 15.6802C6.8375 15.6802 5.86313 14.577 5.86313 13.222C5.86313 11.8671 6.8186 10.7639 8.02002 10.7639C9.23087 10.7639 10.1958 11.8768 10.1769 13.222C10.1769 14.577 9.22141 15.6802 8.02002 15.6802ZM15.9947 15.6802C14.8123 15.6802 13.8379 14.577 13.8379 13.222C13.8379 11.8671 14.7933 10.7639 15.9947 10.7639C17.2056 10.7639 18.1705 11.8768 18.1516 13.222C18.1516 14.577 17.2056 15.6802 15.9947 15.6802Z" fill="#758CA3"/></g><defs><clipPath id="clip0_537_21"><rect width="24" height="24" fill="white"/></clipPath></defs></svg>';
    const titleWrap = document.createElement("div");
    const title = document.createElement("div");
    style2(title, {
      fontSize: "16px",
      fontWeight: "700",
      color: "#f8fafc"
    });
    title.textContent = "Connect Discord to use Community Hub";
    const subtitle = document.createElement("div");
    style2(subtitle, {
      fontSize: "12.5px",
      color: "rgba(226,232,240,0.7)"
    });
    subtitle.textContent = "Optional. Skipping will disable social features.";
    titleWrap.append(title, subtitle);
    const brand = document.createElement("span");
    style2(brand, {
      fontSize: "11px",
      fontWeight: "700",
      textTransform: "uppercase",
      letterSpacing: "0.12em",
      padding: "4px 12px",
      borderRadius: "999px",
      border: "1px solid rgba(56,189,248,0.4)",
      background: "rgba(56,189,248,0.12)",
      color: "#bae6fd",
      marginLeft: "auto",
      whiteSpace: "nowrap"
    });
    brand.textContent = "ARIE'S MOD";
    header.append(icon, titleWrap, brand);
    const dividerTop = document.createElement("div");
    style2(dividerTop, {
      height: "1px",
      background: "linear-gradient(90deg, rgba(148,163,184,0.08), rgba(148,163,184,0.3), rgba(148,163,184,0.08))"
    });
    const iconCheck = '<svg viewBox="0 0 24 24" style="width:12px;height:12px;display:block;" aria-hidden="true" focusable="false"><path d="M5 12.5l4 4 10-10" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>';
    const iconBox = '<svg viewBox="0 0 24 24" style="width:12px;height:12px;display:block;" aria-hidden="true" focusable="false"><path d="M3.5 7.5 12 3l8.5 4.5-8.5 4.5Z" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linejoin="round"/><path d="M3.5 7.5V16.5L12 21l8.5-4.5V7.5" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linejoin="round"/><path d="M12 12v9" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round"/></svg>';
    const whySection = document.createElement("div");
    style2(whySection, {
      display: "flex",
      flexDirection: "column",
      gap: "8px"
    });
    const whyTitle = document.createElement("div");
    style2(whyTitle, {
      fontSize: "12px",
      fontWeight: "600",
      color: "#93c5fd",
      letterSpacing: "0.02em"
    });
    whyTitle.textContent = "Why this is needed";
    const whyList = document.createElement("div");
    style2(whyList, {
      display: "grid",
      gap: "6px"
    });
    whyList.append(
      createListItem("Prevent impersonation and abuse", iconCheck),
      createListItem("Protect leaderboards and community stats from manipulation", iconCheck),
      createListItem("Protect against message interception", iconCheck)
    );
    whySection.append(whyTitle, whyList);
    const dividerMid = document.createElement("div");
    style2(dividerMid, {
      height: "1px",
      background: "linear-gradient(90deg, rgba(148,163,184,0.08), rgba(148,163,184,0.3), rgba(148,163,184,0.08))"
    });
    const useSection = document.createElement("div");
    style2(useSection, {
      display: "flex",
      flexDirection: "column",
      gap: "8px"
    });
    const useTitle = document.createElement("div");
    style2(useTitle, {
      fontSize: "12px",
      fontWeight: "600",
      color: "#93c5fd",
      letterSpacing: "0.02em"
    });
    useTitle.textContent = "What Arie's Mod uses";
    const useList = document.createElement("div");
    style2(useList, {
      display: "grid",
      gap: "6px"
    });
    useList.append(
      createListItem(
        "In-game player information used by Community Hub (stats, garden, inventory, etc.)",
        iconBox
      )
    );
    useSection.append(useTitle, useList);
    const dividerBottom = document.createElement("div");
    style2(dividerBottom, {
      height: "1px",
      background: "linear-gradient(90deg, rgba(148,163,184,0.08), rgba(148,163,184,0.3), rgba(148,163,184,0.08))"
    });
    const unlocks = document.createElement("div");
    style2(unlocks, {
      fontSize: "12.5px",
      color: "rgba(226,232,240,0.82)"
    });
    unlocks.innerHTML = "<strong style='color:#f8fafc;font-weight:600;'>Unlocks</strong> Public rooms / Friends / Messages / Groups / Leaderboards";
    const isDiscord = isDiscordActivityContext();
    let manualInput = null;
    let manualRow = null;
    let manualMode = false;
    const status = document.createElement("div");
    style2(status, {
      fontSize: "12px",
      color: "rgba(251,191,36,0.9)",
      minHeight: "16px"
    });
    status.textContent = "";
    const actions = document.createElement("div");
    style2(actions, {
      display: "flex",
      justifyContent: "flex-end",
      gap: "10px",
      flexWrap: "wrap"
    });
    const refuseBtn = document.createElement("button");
    refuseBtn.type = "button";
    style2(refuseBtn, {
      borderRadius: "10px",
      border: "1px solid rgba(248,250,252,0.2)",
      background: "rgba(148,163,184,0.12)",
      color: "#f8fafc",
      fontWeight: "600",
      padding: "9px 14px",
      cursor: "pointer",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      gap: "6px",
      minWidth: "180px",
      flex: "1 1 180px",
      transition: "background 140ms ease, border 140ms ease"
    });
    refuseBtn.textContent = "Continue without Discord";
    const inputRow = document.createElement("div");
    style2(inputRow, {
      display: "none",
      flexDirection: "column",
      gap: "6px"
    });
    const inputLabel = document.createElement("div");
    style2(inputLabel, {
      fontSize: "12px",
      color: "rgba(226,232,240,0.72)"
    });
    inputLabel.textContent = isDiscord ? "Discord Activity cannot open popups. Paste your API key here." : "If automatic detection didn't work, paste your API key here.";
    const input = document.createElement("input");
    style2(input, {
      width: "100%",
      borderRadius: "10px",
      border: "1px solid rgba(255,255,255,0.16)",
      background: "rgba(8,12,20,0.75)",
      color: "#f8fafc",
      padding: "9px 12px",
      fontSize: "12.5px",
      outline: "none"
    });
    input.type = "text";
    input.placeholder = "Paste your API key";
    input.onfocus = () => {
      input.style.borderColor = "rgba(56,189,248,0.5)";
    };
    input.onblur = () => {
      input.style.borderColor = "rgba(255,255,255,0.16)";
    };
    manualInput = input;
    inputRow.append(inputLabel, input);
    manualRow = inputRow;
    const authBtn = document.createElement("button");
    authBtn.type = "button";
    style2(authBtn, {
      borderRadius: "10px",
      border: "1px solid transparent",
      background: "linear-gradient(135deg, #2dd4bf 0%, #38bdf8 100%)",
      color: "#0b1020",
      fontWeight: "600",
      padding: "9px 14px",
      cursor: "pointer",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      gap: "6px",
      minWidth: "180px",
      flex: "1 1 180px",
      transition: "background 140ms ease, transform 140ms ease"
    });
    authBtn.textContent = "Authenticate with Discord";
    actions.append(refuseBtn, authBtn);
    const cardNodes = [
      header,
      dividerTop,
      whySection,
      dividerMid,
      useSection,
      dividerBottom,
      unlocks
    ];
    if (manualRow) cardNodes.push(manualRow);
    cardNodes.push(status, actions);
    card2.append(...cardNodes);
    container.appendChild(card2);
    refuseBtn.addEventListener("click", () => {
      setDeclinedApiAuth(true);
      window.dispatchEvent(new CustomEvent("gemini:ch-close-after-decline"));
    });
    authBtn.addEventListener("click", async () => {
      status.textContent = "";
      if (manualMode) {
        const key2 = (manualInput?.value ?? "").trim();
        if (!key2) {
          status.textContent = "Please paste your API key.";
          return;
        }
        setApiKey(key2);
        setDeclinedApiAuth(false);
        await triggerPlayerStateSyncNow({ force: true });
        window.dispatchEvent(new CustomEvent("qws-friend-overlay-auth-update"));
        return;
      }
      if (!manualMode) {
        manualMode = true;
        if (manualRow) manualRow.style.display = "flex";
        authBtn.textContent = "Save API key";
        manualInput?.focus();
        if (isDiscord) {
          status.textContent = "After logging in, paste your API key below.";
        } else {
          status.textContent = "If automatic detection didn't work, paste your API key below.";
        }
        requestApiKey().then(async (apiKey) => {
          if (apiKey) {
            setDeclinedApiAuth(false);
            await triggerPlayerStateSyncNow({ force: true });
            window.dispatchEvent(new CustomEvent("qws-friend-overlay-auth-update"));
          } else {
            status.textContent = isDiscord ? "After logging in, paste your API key below." : "Automatic detection failed. Please paste your API key below.";
          }
        }).catch(() => {
          status.textContent = isDiscord ? "After logging in, paste your API key below." : "Authentication failed. Please paste your API key below.";
        });
        return;
      }
    });
    if (manualInput) {
      manualInput.addEventListener("keydown", (event) => {
        if (event.key !== "Enter") return;
        authBtn?.click();
      });
    }
    return container;
  }

  // src/ui/menus/communityHub/roomPrivacyNotice.ts
  var INFO_ICON_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg>`;
  function createRoomPrivacyNotice(onDismiss) {
    const overlay = document.createElement("div");
    style2(overlay, {
      position: "absolute",
      top: "0",
      right: "0",
      bottom: "0",
      left: "0",
      zIndex: "10",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      background: "rgba(8,12,18,0.82)",
      backdropFilter: "blur(4px)",
      borderRadius: "18px"
    });
    const card2 = document.createElement("div");
    style2(card2, {
      width: "min(460px, 88%)",
      background: "linear-gradient(160deg, rgba(20,28,42,0.99) 0%, rgba(12,18,28,0.99) 100%)",
      border: "1px solid rgba(94,234,212,0.22)",
      borderRadius: "14px",
      padding: "26px 26px 22px",
      display: "flex",
      flexDirection: "column",
      gap: "14px",
      boxShadow: "0 8px 36px rgba(0,0,0,0.6), 0 0 0 1px rgba(255,255,255,0.04) inset"
    });
    const header = document.createElement("div");
    style2(header, {
      display: "flex",
      alignItems: "center",
      gap: "10px"
    });
    const iconWrap = document.createElement("span");
    iconWrap.innerHTML = INFO_ICON_SVG;
    style2(iconWrap, { color: "#5eead4", flexShrink: "0", display: "flex" });
    const title = document.createElement("span");
    title.textContent = "Your room is visible to other mod users";
    style2(title, { fontWeight: "700", fontSize: "14px", color: "#e7eef7", lineHeight: "1.3" });
    header.append(iconWrap, title);
    const body = document.createElement("p");
    body.textContent = "By default, your room is set to Public. This is intentional, it's what keeps the Rooms tab alive and lets players discover each other. If you're fine with that, no action needed.";
    style2(body, {
      margin: "0",
      fontSize: "13px",
      color: "rgba(231,238,247,0.72)",
      lineHeight: "1.6"
    });
    const stepsLabel = document.createElement("p");
    stepsLabel.textContent = "If you want to play privately with friends only:";
    style2(stepsLabel, {
      margin: "0",
      fontSize: "13px",
      fontWeight: "600",
      color: "#e7eef7"
    });
    const stepsList = document.createElement("div");
    style2(stepsList, {
      margin: "0",
      display: "flex",
      flexDirection: "column",
      gap: "7px"
    });
    const STEPS = [
      ["Go to ", "My Profile \u2192 Room Visibility", " and toggle it to Private"],
      ["Make sure ", "every mod user in your room", " does the same. One Public player is enough to make the whole room visible"]
    ];
    for (const [before, bold, after] of STEPS) {
      const p = document.createElement("p");
      style2(p, { margin: "0", fontSize: "13px", color: "rgba(231,238,247,0.72)", lineHeight: "1.5" });
      const bSpan = document.createElement("strong");
      bSpan.textContent = bold;
      bSpan.style.color = "#e7eef7";
      p.append(before, bSpan, after);
      stepsList.appendChild(p);
    }
    const tip = document.createElement("p");
    const tipEm = document.createElement("em");
    tipEm.textContent = "Already left a room but people keep joining? Someone still in the room has it set to Public.";
    tip.appendChild(tipEm);
    style2(tip, {
      margin: "0",
      fontSize: "12px",
      color: "rgba(231,238,247,0.48)",
      lineHeight: "1.5",
      borderLeft: "2px solid rgba(94,234,212,0.28)",
      paddingLeft: "10px"
    });
    const dismissBtn = document.createElement("button");
    dismissBtn.textContent = "Got it, don't show again";
    style2(dismissBtn, {
      marginTop: "2px",
      padding: "9px 18px",
      background: "rgba(94,234,212,0.1)",
      border: "1px solid rgba(94,234,212,0.28)",
      borderRadius: "8px",
      color: "#5eead4",
      fontSize: "13px",
      fontWeight: "600",
      cursor: "pointer",
      transition: "background 150ms ease, border-color 150ms ease",
      alignSelf: "flex-end"
    });
    dismissBtn.addEventListener("mouseenter", () => {
      dismissBtn.style.background = "rgba(94,234,212,0.18)";
      dismissBtn.style.borderColor = "rgba(94,234,212,0.48)";
    });
    dismissBtn.addEventListener("mouseleave", () => {
      dismissBtn.style.background = "rgba(94,234,212,0.1)";
      dismissBtn.style.borderColor = "rgba(94,234,212,0.28)";
    });
    dismissBtn.addEventListener("click", () => {
      markRoomPrivacyNoticeSeen();
      onDismiss();
    });
    card2.append(header, body, stepsLabel, stepsList, tip, dismissBtn);
    overlay.appendChild(card2);
    return overlay;
  }

  // src/ui/menus/communityHub/index.ts
  var STYLE_ID = "qws-community-hub-css";
  function ensureCommunityHubStyle() {
    if (document.getElementById(STYLE_ID)) return;
    const st = document.createElement("style");
    st.id = STYLE_ID;
    st.textContent = `
.qws-ch-panel{
  position:fixed;
  top:50%;
  left:50%;
  width:min(980px, 95vw);
  height:min(78vh, 640px);
  max-height:78vh;
  display:none;
  border-radius:18px;
  border:1px solid rgba(255,255,255,0.14);
  background:linear-gradient(160deg, rgba(15,20,30,0.95) 0%, rgba(10,14,20,0.95) 60%, rgba(8,12,18,0.96) 100%);
  backdrop-filter:blur(10px);
  color:#e7eef7;
  box-shadow:0 18px 44px rgba(0,0,0,.45);
  overflow:hidden;
  z-index:var(--chakra-zIndices-DialogModal, 7010);
  opacity:0;
  transform:translate(-50%, calc(-50% + 6px));
  pointer-events:none;
  transition:opacity 180ms ease, transform 180ms ease;
}
.qws-ch-panel.open{
  opacity:1;
  transform:translate(-50%, -50%);
  pointer-events:auto;
}
.qws-ch-panel *{ box-sizing:border-box; }
.qws-ch-head{
  padding:12px 16px;
  font-weight:700;
  letter-spacing:0.01em;
  border-bottom:1px solid rgba(255,255,255,0.08);
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  background:linear-gradient(120deg, rgba(22,28,40,0.9), rgba(12,17,26,0.92));
  user-select:none;
}
.qws-ch-title{
  display:flex;
  align-items:center;
  gap:10px;
  font-size:14px;
}
.qws-ch-body{
  display:grid;
  grid-template-columns:180px 1fr;
  height:calc(100% - 48px);
  min-height:0;
}
.qws-ch-nav{
  border-right:1px solid rgba(255,255,255,0.08);
  padding:12px 10px;
  display:flex;
  flex-direction:column;
  gap:6px;
  background:rgba(10,14,20,0.7);
}
.qws-ch-nav-btn{
  border:none;
  background:transparent;
  color:#c9d4e6;
  padding:10px 12px;
  border-radius:12px;
  display:flex;
  align-items:center;
  gap:10px;
  cursor:pointer;
  font-size:12px;
  transition:background 120ms ease, color 120ms ease, border 120ms ease;
  border:1px solid transparent;
  position:relative;
}
.qws-ch-nav-btn:hover{
  background:rgba(94,234,212,0.08);
  color:#e7eef7;
}
.qws-ch-nav-btn.active{
  background:rgba(94,234,212,0.18);
  border-color:rgba(94,234,212,0.35);
  color:#ecfdf5;
}
.qws-ch-nav-icon{
  width:20px;
  height:20px;
  border-radius:8px;
  display:grid;
  place-items:center;
  background:rgba(255,255,255,0.08);
  font-size:12px;
  color:#dbe7f5;
}
.qws-ch-nav-icon svg{
  width:14px;
  height:14px;
  display:block;
}
.qws-ch-content{
  position:relative;
  overflow:hidden;
  padding:12px;
}
.qws-ch-close{
  width:32px;
  height:32px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,0.12);
  background:rgba(255,255,255,0.06);
  color:#e7eef7;
  display:grid;
  place-items:center;
  cursor:pointer;
  transition:background 120ms ease, border 120ms ease;
  flex-shrink:0;
}
.qws-ch-close:hover{
  background:rgba(239,68,68,0.16);
  border-color:rgba(239,68,68,0.35);
}
.qws-ch-close svg{
  width:16px;
  height:16px;
  display:block;
}
@media (max-width: 768px){
  .qws-ch-body{
    grid-template-columns:1fr;
  }
  .qws-ch-nav{
    flex-direction:row;
    overflow:auto;
    border-right:none;
    border-bottom:1px solid rgba(255,255,255,0.08);
  }
  .qws-ch-nav-btn{ flex:1 0 auto; }
}
`;
    document.head.appendChild(st);
  }
  var CommunityHub = class {
    constructor() {
      __publicField(this, "slot", document.createElement("div"));
      __publicField(this, "badge", document.createElement("span"));
      __publicField(this, "panel", document.createElement("div"));
      __publicField(this, "nav", document.createElement("div"));
      __publicField(this, "content", document.createElement("div"));
      __publicField(this, "authGate", null);
      __publicField(this, "roomPrivacyNotice", null);
      __publicField(this, "tabs", /* @__PURE__ */ new Map());
      __publicField(this, "tabButtons", /* @__PURE__ */ new Map());
      __publicField(this, "navBadges", /* @__PURE__ */ new Map());
      __publicField(this, "activeTab", "community");
      __publicField(this, "panelOpen", false);
      __publicField(this, "cleanupToolbarButton", null);
      __publicField(this, "handleConversationsRefresh", () => this.updateAllBadges());
      __publicField(this, "handleFriendRequestsRefresh", () => this.updateAllBadges());
      __publicField(this, "handleOverlayOpen", () => this.setOpen(true));
      __publicField(this, "handleOverlayClose", () => this.setOpen(false));
      __publicField(this, "handleOpenFriendChat", () => {
        if (!this.panelOpen) {
          this.setOpen(true);
        }
        this.switchTab("messages");
      });
      __publicField(this, "handleOpenGroupChat", () => {
        if (!this.panelOpen) {
          this.setOpen(true);
        }
        this.switchTab("messages");
      });
      __publicField(this, "handleAuthUpdate", () => {
        if (hasApiKey()) {
          console.log("[CommunityHub] Auth successful, showing tabs");
          this.updateContentVisibility();
        }
      });
      __publicField(this, "handleCloseAfterDecline", () => {
        this.setOpen(false);
      });
      __publicField(this, "handlePointerDown", (e) => {
        if (!this.panelOpen) return;
        const t = e.target;
        if (!this.slot.contains(t) && !this.isClickOnToolbarButton(e.target)) {
          this.setOpen(false);
        }
      });
      ensureCommunityHubStyle();
      ensureSharedStyles();
      this.slot = this.createSlot();
      this.badge = this.createBadge();
      void initNotificationSound();
      const lastTab = window.__qws_community_hub_last_tab;
      if (lastTab === "community" || lastTab === "room" || lastTab === "messages" || lastTab === "groups" || lastTab === "leaderboard" || lastTab === "myProfile") {
        this.activeTab = lastTab;
      }
      this.panel = this.createPanel();
      const iconSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>`;
      const iconDataUrl = `data:image/svg+xml;base64,${btoa(iconSvg)}`;
      this.cleanupToolbarButton = startInjectGamePanelButton({
        onClick: () => {
          const next = !this.panelOpen;
          this.setOpen(next);
        },
        iconUrl: iconDataUrl,
        ariaLabel: "Community Hub",
        onMounted: (btn) => {
          btn.style.position = "relative";
          btn.style.overflow = "visible";
          btn.appendChild(this.badge);
          this.updateAllBadges();
        }
      });
      this.slot.append(this.panel);
      document.body.appendChild(this.slot);
      window.addEventListener("pointerdown", this.handlePointerDown);
      window.addEventListener(CH_EVENTS.OPEN, this.handleOverlayOpen);
      window.addEventListener(CH_EVENTS.CLOSE, this.handleOverlayClose);
      window.addEventListener(CH_EVENTS.CONVERSATIONS_REFRESH, this.handleConversationsRefresh);
      window.addEventListener(CH_EVENTS.FRIEND_REQUESTS_REFRESH, this.handleFriendRequestsRefresh);
      window.addEventListener(CH_EVENTS.OPEN_FRIEND_CHAT, this.handleOpenFriendChat);
      window.addEventListener(CH_EVENTS.OPEN_GROUP_CHAT, this.handleOpenGroupChat);
      window.addEventListener("qws-friend-overlay-auth-update", this.handleAuthUpdate);
      window.addEventListener("gemini:ch-close-after-decline", this.handleCloseAfterDecline);
      this.updateAllBadges();
    }
    isClickOnToolbarButton(target) {
      let el2 = target;
      while (el2) {
        if (el2 instanceof HTMLButtonElement && el2.getAttribute("aria-label") === "Community Hub") {
          return true;
        }
        el2 = el2.parentElement;
      }
      return false;
    }
    createSlot() {
      const el2 = document.createElement("div");
      el2.className = "qws-ch-slot";
      style2(el2, {
        position: "fixed",
        top: "0",
        right: "0",
        pointerEvents: "none",
        zIndex: "9999"
      });
      return el2;
    }
    createBadge() {
      const el2 = document.createElement("span");
      style2(el2, {
        position: "absolute",
        top: "-4px",
        right: "-4px",
        minWidth: "18px",
        height: "18px",
        padding: "0 5px",
        borderRadius: "999px",
        background: "#ef4444",
        color: "#fff",
        fontSize: "10px",
        fontWeight: "700",
        display: "none",
        alignItems: "center",
        justifyContent: "center",
        pointerEvents: "none",
        zIndex: "1",
        lineHeight: "1"
      });
      return el2;
    }
    updateAllBadges() {
      const friendUnread = getTotalFriendUnreadCount();
      const groupUnread = getTotalGroupUnreadCount();
      const messagesUnread = friendUnread + groupUnread;
      const requestsUnread = getIncomingRequestsCount();
      const total = messagesUnread + requestsUnread;
      checkAndPlayNotificationSound(friendUnread, groupUnread, requestsUnread);
      const msgNavBadge = this.navBadges.get("messages");
      if (msgNavBadge) {
        this.setBadgeCount(msgNavBadge, messagesUnread);
      }
      const friendsNavBadge = this.navBadges.get("community");
      if (friendsNavBadge) {
        this.setBadgeCount(friendsNavBadge, requestsUnread);
      }
      this.setBadgeCount(this.badge, total);
    }
    setBadgeCount(badge, count) {
      if (count <= 0) {
        badge.style.display = "none";
        return;
      }
      badge.style.display = "inline-flex";
      badge.textContent = count > 99 ? "99+" : String(count);
    }
    createNavBadge() {
      const badge = document.createElement("span");
      style2(badge, {
        position: "absolute",
        top: "50%",
        right: "8px",
        transform: "translateY(-50%)",
        minWidth: "18px",
        height: "18px",
        padding: "0 5px",
        borderRadius: "999px",
        background: "#ef4444",
        color: "#fff",
        fontSize: "10px",
        fontWeight: "700",
        display: "none",
        alignItems: "center",
        justifyContent: "center",
        lineHeight: "1",
        pointerEvents: "none"
      });
      return badge;
    }
    createPanel() {
      const el2 = document.createElement("div");
      el2.className = "qws-ch-panel";
      const head = document.createElement("div");
      head.className = "qws-ch-head";
      const title = document.createElement("div");
      title.className = "qws-ch-title";
      title.textContent = "Community Hub";
      const closeBtn = document.createElement("button");
      closeBtn.className = "qws-ch-close";
      closeBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>`;
      closeBtn.onclick = () => this.setOpen(false);
      head.append(title, closeBtn);
      const body = document.createElement("div");
      body.className = "qws-ch-body";
      this.nav = document.createElement("div");
      this.nav.className = "qws-ch-nav";
      this.content = document.createElement("div");
      this.content.className = "qws-ch-content";
      body.append(this.nav, this.content);
      el2.append(head, body);
      this.authGate = createAuthGate();
      this.content.appendChild(this.authGate);
      this.buildTabs();
      this.updateContentVisibility();
      return el2;
    }
    buildTabs() {
      const tabDefs = [
        {
          id: "messages",
          label: "Messages",
          icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>`,
          build: createMessagesTab
        },
        {
          id: "community",
          label: "Friends",
          icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>`,
          build: createCommunityTab
        },
        {
          id: "room",
          label: "Rooms",
          icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M9 3v18"/></svg>`,
          build: createRoomTab
        },
        {
          id: "groups",
          label: "Groups",
          icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>`,
          build: createGroupsTab
        },
        {
          id: "leaderboard",
          label: "Leaderboard",
          icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></svg>`,
          build: createLeaderboardTab
        },
        {
          id: "myProfile",
          label: "My Profile",
          icon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>`,
          build: createMyProfileTab
        }
      ];
      for (const def of tabDefs) {
        const btn = document.createElement("button");
        btn.className = "qws-ch-nav-btn";
        if (def.id === this.activeTab) btn.classList.add("active");
        const iconWrap = document.createElement("div");
        iconWrap.className = "qws-ch-nav-icon";
        iconWrap.innerHTML = def.icon;
        const label2 = document.createElement("span");
        label2.textContent = def.label;
        btn.append(iconWrap, label2);
        this.nav.appendChild(btn);
        this.tabButtons.set(def.id, btn);
        if (def.id === "messages" || def.id === "community") {
          const navBadge = this.createNavBadge();
          btn.appendChild(navBadge);
          this.navBadges.set(def.id, navBadge);
        }
        btn.onclick = () => this.switchTab(def.id);
        const tab = def.build();
        style2(tab.root, {
          display: def.id === this.activeTab ? "flex" : "none"
        });
        this.content.appendChild(tab.root);
        this.tabs.set(def.id, tab);
      }
    }
    switchTab(id) {
      if (this.activeTab === id) return;
      this.tabs.get(this.activeTab)?.hide?.();
      this.tabButtons.get(this.activeTab)?.classList.remove("active");
      this.activeTab = id;
      window.__qws_community_hub_last_tab = id;
      this.tabs.get(id)?.show?.();
      this.tabButtons.get(id)?.classList.add("active");
    }
    setOpen(open) {
      if (this.panelOpen === open) return;
      this.panelOpen = open;
      if (open) {
        this.updateContentVisibility();
        this.panel.style.display = "block";
        requestAnimationFrame(() => {
          this.panel.classList.add("open");
        });
        if (hasApiKey()) this.maybeShowRoomPrivacyNotice();
        try {
          window.dispatchEvent(new CustomEvent(CH_EVENTS.OPEN));
        } catch {
        }
      } else {
        this.panel.classList.remove("open");
        setTimeout(() => {
          if (!this.panelOpen) {
            this.panel.style.display = "none";
          }
        }, 200);
        try {
          window.dispatchEvent(new CustomEvent(CH_EVENTS.CLOSE));
        } catch {
        }
      }
    }
    updateContentVisibility() {
      const authenticated = hasApiKey();
      if (authenticated) {
        if (this.authGate) {
          this.authGate.style.display = "none";
        }
        for (const [id, tab] of this.tabs) {
          tab.root.style.display = id === this.activeTab ? "flex" : "none";
        }
        for (const btn of this.tabButtons.values()) {
          btn.style.pointerEvents = "auto";
          btn.style.opacity = "1";
        }
      } else {
        if (this.authGate) {
          this.authGate.style.display = "flex";
        }
        for (const tab of this.tabs.values()) {
          tab.root.style.display = "none";
        }
        for (const btn of this.tabButtons.values()) {
          btn.style.pointerEvents = "none";
          btn.style.opacity = "0.5";
        }
      }
    }
    maybeShowRoomPrivacyNotice() {
      if (hasSeenRoomPrivacyNotice()) return;
      if (this.roomPrivacyNotice?.isConnected) return;
      this.roomPrivacyNotice?.remove();
      this.roomPrivacyNotice = createRoomPrivacyNotice(() => {
        this.roomPrivacyNotice?.remove();
        this.roomPrivacyNotice = null;
      });
      this.panel.appendChild(this.roomPrivacyNotice);
    }
    destroy() {
      window.removeEventListener("pointerdown", this.handlePointerDown);
      window.removeEventListener(CH_EVENTS.OPEN, this.handleOverlayOpen);
      window.removeEventListener(CH_EVENTS.CLOSE, this.handleOverlayClose);
      window.removeEventListener(CH_EVENTS.CONVERSATIONS_REFRESH, this.handleConversationsRefresh);
      window.removeEventListener(CH_EVENTS.FRIEND_REQUESTS_REFRESH, this.handleFriendRequestsRefresh);
      window.removeEventListener(CH_EVENTS.OPEN_FRIEND_CHAT, this.handleOpenFriendChat);
      window.removeEventListener(CH_EVENTS.OPEN_GROUP_CHAT, this.handleOpenGroupChat);
      window.removeEventListener("qws-friend-overlay-auth-update", this.handleAuthUpdate);
      window.removeEventListener("gemini:ch-close-after-decline", this.handleCloseAfterDecline);
      if (this.cleanupToolbarButton) {
        this.cleanupToolbarButton();
        this.cleanupToolbarButton = null;
      }
      cleanupNotificationSound();
      if (this.authGate) {
        this.authGate.remove();
        this.authGate = null;
      }
      if (this.roomPrivacyNotice) {
        this.roomPrivacyNotice.remove();
        this.roomPrivacyNotice = null;
      }
      for (const tab of this.tabs.values()) {
        tab.destroy?.();
      }
      this.tabs.clear();
      this.tabButtons.clear();
      this.slot.remove();
    }
  };
  async function renderCommunityHub() {
    const prev = window.__qws_cleanup_community_hub;
    if (typeof prev === "function") {
      try {
        prev();
      } catch {
      }
    }
    const hub = new CommunityHub();
    window.__qws_cleanup_community_hub = () => {
      try {
        hub.destroy();
      } catch {
      }
    };
  }

  // src/utils/shopUtility.ts
  init_atoms();
  var SHOP_TYPES = ["plant", "egg", "tool", "decor"];
  var BTN_CLASS = "romann-buyall-btn";
  var STYLE_ID2 = "tm-buyall-css";
  var ITEM_SELECTOR = "div.McFlex.css-1kkwxjt";
  var LIST_SELECTOR = "div.McFlex.css-1lfov12";
  var ROW_SELECTOR = "div.McFlex.css-b9riu6";
  var INDEX_ATTR = "data-tm-shop-index";
  var RESCAN_MS = 20;
  var SHOP_ATOMS = {
    plant: Atoms.shop.seedShop,
    egg: Atoms.shop.eggShop,
    tool: Atoms.shop.toolShop,
    decor: Atoms.shop.decorShop
  };
  var MODAL_TO_SHOP_TYPE = {
    seedShop: "plant",
    eggShop: "egg",
    toolShop: "tool",
    decorShop: "decor"
  };
  var shopInventoryCache = {};
  var shopInventoryLengths = {};
  var shopInventoryInitStarted = false;
  var shopInventoryUnsubs = {};
  async function detectShopFromActiveModal() {
    try {
      const modalId = await Atoms.ui.activeModal.get();
      console.log("[TM][BuyAll] activeModal =", modalId);
      if (typeof modalId !== "string" || !modalId) return null;
      const shop = MODAL_TO_SHOP_TYPE[modalId] ?? null;
      console.log("[TM][BuyAll] mapped modal -> shop =", { modalId, shop });
      return shop;
    } catch (error) {
      console.warn("[TM][BuyAll] failed to read active modal", error);
      return null;
    }
  }
  function extractInventoryId(shop, entry) {
    if (!entry) return null;
    if (shop === "plant") return entry?.species ? String(entry.species) : null;
    if (shop === "egg") return entry?.eggId ? String(entry.eggId) : null;
    if (shop === "tool") return entry?.toolId ? String(entry.toolId) : null;
    if (shop === "decor") return entry?.decorId ? String(entry.decorId) : null;
    return null;
  }
  function extractInventoryName(shop, entry) {
    if (!entry) return null;
    if (shop === "plant") return entry?.species ? String(entry.species) : null;
    if (shop === "egg") return entry?.eggId ? String(entry.eggId) : null;
    if (shop === "tool") return entry?.toolId ? String(entry.toolId) : null;
    if (shop === "decor") return entry?.decorId ? String(entry.decorId) : null;
    return null;
  }
  function normalizeInventory(shop, data) {
    const rawInventory = Array.isArray(data?.inventory) ? data.inventory : [];
    const normalized = [];
    for (const entry of rawInventory) {
      const id = extractInventoryId(shop, entry);
      if (!id) continue;
      normalized.push({ id, name: extractInventoryName(shop, entry), raw: entry });
    }
    return normalized;
  }
  function updateShopInventoryCache(shop, data) {
    const normalized = normalizeInventory(shop, data);
    shopInventoryCache[shop] = normalized;
    shopInventoryLengths[shop] = normalized.length;
  }
  async function initShopInventoryWatchers() {
    for (const shop of SHOP_TYPES) {
      const atom = SHOP_ATOMS[shop];
      console.log(await atom.get());
      if (!atom) continue;
      if (!shopInventoryInitStarted) return;
      try {
        updateShopInventoryCache(shop, await atom.get());
      } catch (error) {
        console.warn(`[TM] buyAll failed to fetch ${shop} inventory`, error);
      }
      if (!shopInventoryInitStarted) return;
      try {
        const unsub = await atom.onChange((next) => {
          updateShopInventoryCache(shop, next);
        });
        if (!shopInventoryInitStarted) {
          try {
            unsub();
          } catch (error) {
            console.warn(`[TM] buyAll failed to cancel stale ${shop} inventory watcher`, error);
          }
          return;
        }
        shopInventoryUnsubs[shop] = () => {
          try {
            unsub();
          } catch (err) {
            console.warn(`[TM] buyAll failed to unsubscribe ${shop} inventory`, err);
          }
        };
      } catch (error) {
        console.warn(`[TM] buyAll failed to subscribe to ${shop} inventory`, error);
      }
    }
  }
  function ensureShopInventories() {
    if (shopInventoryInitStarted) return;
    shopInventoryInitStarted = true;
    void initShopInventoryWatchers().catch((error) => {
      console.warn("[TM] buyAll inventory init error", error);
    });
  }
  function getInventoryEntry(shop, index) {
    const list = shopInventoryCache[shop];
    if (!list || index < 0 || index >= list.length) return null;
    return list[index] ?? null;
  }
  var PURCHASE_FNS = {
    plant: (id) => PlayerService.purchaseSeed(id),
    egg: (id) => PlayerService.purchaseEgg(id),
    tool: (id) => PlayerService.purchaseTool(id),
    decor: (id) => PlayerService.purchaseDecor(id)
  };
  function incrementShopPurchaseStat(shop) {
    switch (shop) {
      case "plant":
        StatsService.incrementShopStat("seedsBought");
        break;
      case "decor":
        StatsService.incrementShopStat("decorBought");
        break;
      case "egg":
        StatsService.incrementShopStat("eggsBought");
        break;
      case "tool":
        StatsService.incrementShopStat("toolsBought");
        break;
      default:
        break;
    }
  }
  async function purchaseRemainingItems(shop, itemId, remaining) {
    if (!shop || !itemId) return;
    const purchase = PURCHASE_FNS[shop];
    if (!purchase) return;
    const totalToBuy = typeof remaining === "number" ? Math.max(0, Math.floor(remaining)) : 0;
    if (totalToBuy <= 0) return;
    for (let bought = 0; bought < totalToBuy; bought += 1) {
      try {
        await purchase(itemId);
        incrementShopPurchaseStat(shop);
      } catch (error) {
        console.warn("[TM] buyAll purchase failed", { shop, itemId, attempt: bought + 1, error });
        break;
      }
    }
  }
  function parseCompactNumber(s) {
    if (!s) return void 0;
    const txt = s.replace(/\u00A0|\u202F/g, " ").trim();
    const re = /(\d{1,3}(?:[ \u00A0\u202F.,]\d{3})+|\d+(?:[.,]\d+)?)(\s*[kKmMbBtT])?/g;
    let m;
    let lastNum = null;
    let lastSuf = null;
    while (m = re.exec(txt)) {
      lastNum = m[1];
      lastSuf = (m[2] || "").trim().toUpperCase() || null;
    }
    if (!lastNum) return void 0;
    if (lastSuf) {
      const base = Number(lastNum.replace(/[ \u00A0\u202F]/g, "").replace(",", "."));
      if (!Number.isFinite(base)) return void 0;
      const mult = lastSuf === "K" ? 1e3 : lastSuf === "M" ? 1e6 : lastSuf === "B" ? 1e9 : lastSuf === "T" ? 1e12 : 1;
      return Math.round(base * mult);
    }
    const hasThousandsSep = /[ \u00A0\u202F.,]\d{3}/.test(lastNum);
    if (hasThousandsSep) {
      const val = Number(lastNum.replace(/[ \u00A0\u202F.,]/g, ""));
      return Number.isFinite(val) ? val : void 0;
    } else {
      const val = Number(lastNum.replace(",", "."));
      return Number.isFinite(val) ? Math.round(val) : void 0;
    }
  }
  var lastShops = null;
  var lastPurchases = null;
  var shopsSubStarted = false;
  var purchasesSubStarted = false;
  function purchasedCountForId2(id, purchases) {
    if (!purchases) return 0;
    const [type, raw] = String(id).split(":");
    const section = type === "Seed" ? purchases.seed : type === "Egg" ? purchases.egg : type === "Tool" ? purchases.tool : purchases.decor;
    if (!section || !section.purchases) return 0;
    const n = section.purchases[raw];
    return typeof n === "number" && n > 0 ? n : 0;
  }
  function toNotifierItemId(shop, itemId) {
    if (!shop || !itemId) return null;
    const raw = String(itemId);
    switch (shop) {
      case "plant":
        return `Seed:${raw}`;
      case "egg":
        return `Egg:${raw}`;
      case "tool":
        return `Tool:${raw}`;
      case "decor":
        return `Decor:${raw}`;
      default:
        return null;
    }
  }
  function ensureNotifierSnapshots() {
    if (!shopsSubStarted) {
      shopsSubStarted = true;
      NotifierService.onShopsChangeNow((snap) => {
        lastShops = snap;
      }).catch((err) => {
        shopsSubStarted = false;
        console.warn("[TM] buyAll notifier shops subscription failed", err);
      });
    }
    if (!purchasesSubStarted) {
      purchasesSubStarted = true;
      NotifierService.onPurchasesChangeNow((snap) => {
        lastPurchases = snap;
      }).catch((err) => {
        purchasesSubStarted = false;
        console.warn("[TM] buyAll notifier purchases subscription failed", err);
      });
    }
  }
  function extractInitialStock(shop, rawId) {
    if (!shop || !rawId || !lastShops) {
      return { initialStock: null };
    }
    const byShop = shop === "plant" ? lastShops.seed?.inventory ?? [] : shop === "egg" ? lastShops.egg?.inventory ?? [] : shop === "tool" ? lastShops.tool?.inventory ?? [] : lastShops.decor?.inventory ?? [];
    const match = byShop.find((entry) => {
      if (!entry) return false;
      if (shop === "plant") return String(entry.species) === rawId;
      if (shop === "egg") return String(entry.eggId) === rawId;
      if (shop === "tool") return String(entry.toolId) === rawId;
      return String(entry.decorId) === rawId;
    });
    if (!match) return { initialStock: null };
    const initial = Number(match.initialStock);
    const normalized = Number.isFinite(initial) ? initial : null;
    return { initialStock: normalized };
  }
  function getRemainingDetails(shop, itemId) {
    const notifierItemId = toNotifierItemId(shop, itemId);
    if (!notifierItemId) {
      return { notifierItemId: null, initialStock: null, purchased: null, remaining: null };
    }
    const rawId = notifierItemId.split(":")[1] ?? null;
    const { initialStock } = extractInitialStock(shop, rawId);
    if (initialStock == null) {
      return { notifierItemId, initialStock, purchased: null, remaining: null };
    }
    const purchased = purchasedCountForId2(notifierItemId, lastPurchases);
    const remaining = Math.max(0, initialStock - purchased);
    return { notifierItemId, initialStock, purchased, remaining };
  }
  function isItemDisabled(itemEl) {
    if (!itemEl) return false;
    return !!itemEl.querySelector(".chakra-text.css-1ox18rb");
  }
  function getListItems(listRoot) {
    const direct = listRoot.querySelectorAll(`:scope > ${ITEM_SELECTOR}`);
    if (direct.length) return Array.from(direct);
    return Array.from(listRoot.querySelectorAll(ITEM_SELECTOR));
  }
  function parsePriceFromButton(btn) {
    if (!btn) return void 0;
    const label2 = btn.querySelector(".css-1uduba2");
    const raw = (label2?.innerText ?? btn.textContent ?? "").trim();
    return parseCompactNumber(raw);
  }
  function findRowForItem(itemEl) {
    const bySelector = itemEl.querySelector(ROW_SELECTOR);
    if (bySelector) return bySelector;
    const any = Array.from(itemEl.querySelectorAll("div")).find((d) => d.querySelectorAll("button.chakra-button").length >= 2);
    return any ?? null;
  }
  function ensureGlobalStyles() {
    if (document.getElementById(STYLE_ID2)) return;
    const css3 = `
    .${BTN_CLASS}{
      background: var(--chakra-colors-Blue-Magic, #0067B4) !important;
      border-color: var(--chakra-colors-Blue-Dark, #264093) !important;
      color: #fff !important;
      border-width: 2px;
      border-radius: 5px;
      text-transform: uppercase;
      height: 40px;
      padding-inline: 24px;
      padding-top: 12px;
      padding-bottom: 12px;
      width: 100%;
    }
    .${BTN_CLASS}:hover{
      background: var(--chakra-colors-Blue-Light, #48ADF4) !important;
      border-color: var(--chakra-colors-Blue-Magic, #0067B4) !important;
    }
    .${BTN_CLASS}:focus-visible{
      outline: transparent solid 2px;
      outline-offset: 2px;
      box-shadow: var(--chakra-ring-offset-shadow, 0 0 #0000),
                  var(--chakra-ring-shadow, 0 0 #0000),
                  0 0 0 3px var(--chakra-ring-color, rgba(66,153,225,0.6));
    }
    /* \xC9tat disabled : couleurs/gris EXACTES demand\xE9es + blocage du hover */
    .${BTN_CLASS}[disabled],
    .${BTN_CLASS}[aria-disabled="true"]{
      background: var(--chakra-colors-Neutral-Grey) !important;
      border-color: var(--chakra-colors-Neutral-EarlGrey) !important;
      color: var(--chakra-colors-Neutral-EarlGrey) !important;
      opacity: 0.7 !important;
      cursor: not-allowed !important;
      box-shadow: none !important;
      pointer-events: none; /* pour l\u2019aria-disabled \xE9ventuel */
    }
    .${BTN_CLASS}[disabled]:hover,
    .${BTN_CLASS}[disabled]:focus,
    .${BTN_CLASS}[aria-disabled="true"]:hover,
    .${BTN_CLASS}[aria-disabled="true"]:focus{
      background: var(--chakra-colors-Neutral-Grey) !important;
      border-color: var(--chakra-colors-Neutral-EarlGrey) !important;
      color: var(--chakra-colors-Neutral-EarlGrey) !important;
      box-shadow: none !important;
    }
  `.trim();
    const style3 = document.createElement("style");
    style3.id = STYLE_ID2;
    style3.textContent = css3;
    document.head.appendChild(style3);
  }
  function createButton2(templateBtn) {
    const btn = document.createElement("button");
    btn.type = "button";
    if (templateBtn?.className) {
      const classes = `${templateBtn.className} ${BTN_CLASS}`.replace(new RegExp(`\\b${BTN_CLASS}\\b`, "g"), "").trim();
      btn.className = `${classes} ${BTN_CLASS}`.trim();
    } else {
      btn.className = `chakra-button ${BTN_CLASS}`;
    }
    const flex = document.createElement("div");
    flex.className = "McFlex css-1fxg3mj";
    const label2 = document.createElement("span");
    label2.className = "css-1uduba2";
    label2.textContent = "Buy all";
    flex.appendChild(label2);
    btn.appendChild(flex);
    btn.addEventListener("click", async (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      if (btn.disabled) return;
      const itemEl = btn.closest(ITEM_SELECTOR);
      const listRoot = itemEl?.closest(LIST_SELECTOR) || document.body;
      const items = getListItems(listRoot);
      const total = items.length;
      const attrIndex = itemEl?.getAttribute(INDEX_ATTR);
      let idx0 = attrIndex != null && attrIndex !== "" ? Number.parseInt(attrIndex, 10) : -1;
      if (!Number.isFinite(idx0) || idx0 < 0) {
        idx0 = itemEl ? items.indexOf(itemEl) : -1;
      }
      const idx1 = idx0 >= 0 ? idx0 + 1 : -1;
      const shop = await detectShopFromActiveModal();
      let itemId = null;
      let itemName = null;
      let reason = "none";
      let coinParsed;
      let creditParsed;
      if (shop && itemEl) {
        const row = findRowForItem(itemEl);
        if (row) {
          const me = btn;
          const coinBtn = me.previousElementSibling;
          const creditBtn = me.nextElementSibling;
          coinParsed = parsePriceFromButton(coinBtn);
          creditParsed = parsePriceFromButton(creditBtn);
          const inventoryEntry = idx0 >= 0 ? getInventoryEntry(shop, idx0) : null;
          if (inventoryEntry) {
            itemId = inventoryEntry.id;
            itemName = inventoryEntry.name ?? inventoryEntry.id;
            reason = "inventory";
          } else if (idx0 >= 0 && typeof coinParsed === "number" && typeof creditParsed === "number") {
            reason = "index";
          }
        }
      }
      const remainingDetails = getRemainingDetails(shop ?? null, itemId);
      void purchaseRemainingItems(shop, itemId, remainingDetails.remaining);
      window.dispatchEvent(new CustomEvent("tm:buyAll", {
        detail: {
          index1: idx1,
          index0: idx0,
          total,
          shopType: shop,
          itemId,
          itemName,
          reason,
          coin: coinParsed,
          credit: creditParsed,
          element: itemEl,
          remaining: remainingDetails.remaining,
          notifierItemId: remainingDetails.notifierItemId
        }
      }));
    });
    return btn;
  }
  function insertIntoItem(itemEl) {
    const listRoot = itemEl.closest(LIST_SELECTOR);
    if (listRoot && !itemEl.hasAttribute(INDEX_ATTR)) {
      const items = getListItems(listRoot);
      const idx = items.indexOf(itemEl);
      if (idx >= 0) {
        itemEl.setAttribute(INDEX_ATTR, String(idx));
      }
    }
    const row = itemEl.querySelector(ROW_SELECTOR) || Array.from(itemEl.querySelectorAll("div")).find((d) => d.querySelectorAll("button.chakra-button").length >= 2);
    if (!row) return;
    const btns = row.querySelectorAll("button.chakra-button");
    if (btns.length < 2) return;
    let middle = row.querySelector(`button.${BTN_CLASS}`);
    if (!middle) {
      middle = createButton2(btns[0]);
      row.insertBefore(middle, btns[1]);
    }
    const disabled = isItemDisabled(itemEl);
    middle.disabled = disabled;
    middle.setAttribute("aria-disabled", disabled ? "true" : "false");
  }
  function scan(root = document) {
    root.querySelectorAll(ITEM_SELECTOR).forEach(insertIntoItem);
  }
  var observer = null;
  var intervalId = null;
  function setupBuyAll() {
    ensureGlobalStyles();
    ensureNotifierSnapshots();
    ensureShopInventories();
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", () => scan());
    } else {
      scan();
    }
    observer = new MutationObserver((mutations) => {
      for (const m of mutations) {
        for (const n of m.addedNodes) {
          if (!(n instanceof Element)) continue;
          if (n.matches(ITEM_SELECTOR)) insertIntoItem(n);
          n.querySelectorAll?.(ITEM_SELECTOR).forEach(insertIntoItem);
        }
      }
    });
    const startObserver = () => observer.observe(document.body, { childList: true, subtree: true });
    if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", startObserver);
    else startObserver();
    startRescan();
  }
  function startRescan() {
    if (intervalId != null) return;
    intervalId = window.setInterval(() => scan(), RESCAN_MS);
  }
  function stopRescan() {
    if (intervalId != null) {
      window.clearInterval(intervalId);
      intervalId = null;
    }
  }
  document.addEventListener("visibilitychange", () => {
    if (document.hidden) stopRescan();
    else if (observer) startRescan();
  });
  var DEFAULTS2 = {
    containerSelector: ".McFlex.css-1lfov12",
    itemSelector: ".McFlex.css-1kkwxjt",
    flagSelector: ".chakra-text.css-pyjzrq"
  };
  function startReorderObserver(options = {}) {
    if (!isBrowser2()) {
      return {
        stop() {
        },
        runOnce() {
        },
        isRunning() {
          return false;
        }
      };
    }
    const CONTAINER_SEL = options.containerSelector ?? DEFAULTS2.containerSelector;
    const ITEM_SEL = options.itemSelector ?? DEFAULTS2.itemSelector;
    const FLAG_SEL = options.flagSelector ?? DEFAULTS2.flagSelector;
    const ROOT = options.root ?? document;
    const OBSERVE_HISTORY = options.observeHistory ?? true;
    const PREFER_DIRECT = options.preferDirectChildren ?? false;
    const logger = typeof options.log === "function" ? options.log : options.log ? (...args) => console.debug("[ReorderObserver]", ...args) : () => {
    };
    let running = true;
    let pending = false;
    function processAll() {
      if (!running || pending) return;
      pending = true;
      requestAnimationFrame(() => {
        try {
          const containers = queryAll(ROOT, CONTAINER_SEL);
          for (const c of containers) {
            reorderContainer(c, ITEM_SEL, FLAG_SEL, PREFER_DIRECT);
          }
        } finally {
          pending = false;
        }
      });
    }
    const observeTarget = ROOT.documentElement ?? ROOT;
    const mo = new MutationObserver(processAll);
    mo.observe(observeTarget, { childList: true, subtree: true });
    processAll();
    let unhookHistory = null;
    if (OBSERVE_HISTORY) {
      const { unhook } = hookHistory2(processAll);
      unhookHistory = unhook;
    }
    const controller = {
      stop() {
        if (!running) return;
        running = false;
        mo.disconnect();
        unhookHistory?.();
        unhookHistory = null;
        logger("Stopped.");
      },
      runOnce() {
        processAll();
      },
      isRunning() {
        return running;
      }
    };
    return controller;
  }
  function isBrowser2() {
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function queryAll(root, selector) {
    return Array.from(root.querySelectorAll(selector));
  }
  function supportsScope() {
    try {
      document.querySelector(":scope");
      return true;
    } catch {
      return false;
    }
  }
  function childrenOrDescendants(container, itemSel) {
    if (supportsScope()) {
      const direct = Array.from(container.querySelectorAll(`:scope > ${itemSel}`));
      if (direct.length > 0) return direct;
    }
    return Array.from(container.querySelectorAll(itemSel));
  }
  function reorderContainer(container, itemSel, flagSel, preferDirectChildren) {
    const items = preferDirectChildren ? Array.from(container.children).filter((n) => n instanceof Element && n.matches(itemSel)) : childrenOrDescendants(container, itemSel);
    if (items.length === 0) return;
    const withFlag = [];
    const withoutFlag = [];
    for (const el2 of items) {
      (el2.querySelector(flagSel) ? withFlag : withoutFlag).push(el2);
    }
    if (withFlag.length === 0) return;
    let seenRest = false;
    for (const el2 of items) {
      const flagged = !!el2.querySelector(flagSel);
      if (!flagged) seenRest = true;
      else if (seenRest) {
        const frag = document.createDocumentFragment();
        for (const e of withFlag) frag.appendChild(e);
        for (const e of withoutFlag) frag.appendChild(e);
        container.appendChild(frag);
        return;
      }
    }
  }
  function hookHistory2(onNavigate) {
    const origPush = history.pushState?.bind(history);
    const origReplace = history.replaceState?.bind(history);
    function wrap(fn) {
      if (!fn) return fn;
      const wrapped = function(...args) {
        const ret = fn.apply(this, args);
        onNavigate();
        return ret;
      };
      return wrapped;
    }
    const onPop = () => onNavigate();
    if (origPush) history.pushState = wrap(origPush);
    if (origReplace) history.replaceState = wrap(origReplace);
    window.addEventListener("popstate", onPop);
    return {
      unhook() {
        if (origPush) history.pushState = origPush;
        if (origReplace) history.replaceState = origReplace;
        window.removeEventListener("popstate", onPop);
      }
    };
  }

  // src/core/dom.ts
  var ready = new Promise((res) => {
    if (document.readyState !== "loading") res();
    else addEventListener("DOMContentLoaded", () => res(), { once: true });
  });
  function addStyle(css3) {
    const s = document.createElement("style");
    s.textContent = css3;
    document.head.appendChild(s);
    return s;
  }
  function toPredicate(selOrFn) {
    if (typeof selOrFn === "function") return selOrFn;
    if (typeof selOrFn === "string") return (el2) => el2.matches?.(selOrFn) ?? false;
    throw new Error("Selector or predicate required");
  }
  function onAdded(selOrFn, cb, { root = document, callForExisting = true } = {}) {
    const pred = toPredicate(selOrFn);
    const seen = /* @__PURE__ */ new WeakSet();
    const consider = (el2) => {
      if (seen.has(el2)) return;
      if (pred(el2)) {
        seen.add(el2);
        cb(el2);
      }
    };
    if (callForExisting && "querySelectorAll" in root) {
      root.querySelectorAll("*").forEach(consider);
    }
    const obs = new MutationObserver((muts) => {
      for (const m of muts) for (const n of Array.from(m.addedNodes)) {
        if (n.nodeType !== 1) continue;
        const el2 = n;
        consider(el2);
        el2.querySelectorAll?.("*").forEach(consider);
      }
    });
    obs.observe(root, { childList: true, subtree: true });
    return { disconnect: () => obs.disconnect() };
  }

  // src/utils/petPanelEnhancer.ts
  init_atoms();
  init_fakeModal();
  var PANEL_SELECTOR = ".css-1rszi55";
  var FEED_BUTTON_CLASS = "tm-feed-from-inventory-btn";
  var FEED_FROM_INVENTORY_BUTTON_CLASS = "tm-feed-from-inventory-select-btn";
  var FEED_ROW_CLASS = "tm-feed-from-inventory-row";
  var PATH_PETS_PANEL_BUTTONS = "pets.panelButtons";
  var DEFAULT_PANEL_BUTTONS = {
    instantFeed: true,
    feedFromInventory: true
  };
  var started2 = false;
  function startPetPanelEnhancer() {
    if (started2) return;
    started2 = true;
    if (typeof document === "undefined") {
      return;
    }
    onAdded(PANEL_SELECTOR, (node) => {
      if (!(node instanceof HTMLElement)) return;
      enhancePanel(node);
    });
  }
  function getPetPanelButtonSettings() {
    const raw = readAriesPath(PATH_PETS_PANEL_BUTTONS);
    return {
      instantFeed: raw?.instantFeed !== false,
      feedFromInventory: raw?.feedFromInventory !== false
    };
  }
  function setPetPanelButtonSettings(patch2) {
    const merged = {
      ...DEFAULT_PANEL_BUTTONS,
      ...getPetPanelButtonSettings(),
      ...patch2 || {}
    };
    writeAriesPath(PATH_PETS_PANEL_BUTTONS, merged);
    return merged;
  }
  function applyPetPanelButtonVisibility(scope) {
    if (typeof document === "undefined") return;
    const root = scope ?? document;
    const { instantFeed, feedFromInventory } = getPetPanelButtonSettings();
    const instantBtn = root.querySelector(`.${FEED_BUTTON_CLASS}`);
    if (instantBtn) instantBtn.style.display = instantFeed ? "" : "none";
    const inventoryBtn = root.querySelector(`.${FEED_FROM_INVENTORY_BUTTON_CLASS}`);
    if (inventoryBtn) inventoryBtn.style.display = feedFromInventory ? "" : "none";
    const row = root.querySelector(`.${FEED_ROW_CLASS}`);
    if (row) row.style.display = instantFeed || feedFromInventory ? "" : "none";
  }
  function enhancePanel(root) {
    try {
      ensureFeedButton(root);
    } catch (err) {
      console.warn("[PetPanel] Failed to inject feed button", err);
    }
  }
  function ensureFeedButton(root) {
    if (root.querySelector(`.${FEED_BUTTON_CLASS}`)) {
      applyPetPanelButtonVisibility(root);
      return;
    }
    const templateBtn = root.querySelector("button.chakra-button");
    const btn = createStyledButton(templateBtn, "INSTANT FEED");
    btn.classList.add(FEED_BUTTON_CLASS);
    btn.setAttribute("aria-label", "Feed pet from inventory");
    btn.title = "Feed pet from inventory";
    btn.style.width = "100%";
    btn.style.minWidth = "100%";
    btn.style.alignContent = "center";
    btn.style.alignItems = "center";
    btn.style.padding = "6px 14px";
    btn.style.fontSize = "13px";
    btn.style.border = "2px solid #FFC83D";
    btn.style.color = "rgb(205 200 193)";
    btn.style.borderRadius = "10px";
    btn.style.height = "40px";
    btn.addEventListener("click", () => {
      void handleFeedClick(btn);
    });
    const row = document.createElement("div");
    row.classList.add("McFlex", FEED_ROW_CLASS);
    row.style.marginTop = "8px";
    row.style.justifyContent = "center";
    row.style.width = "100%";
    row.style.flexDirection = "column";
    row.style.alignItems = "stretch";
    row.style.gap = "8px";
    row.appendChild(btn);
    const feedFromInventoryBtn = createStyledButton(
      templateBtn,
      "FEED FROM INVENTORY"
    );
    feedFromInventoryBtn.classList.add(FEED_FROM_INVENTORY_BUTTON_CLASS);
    feedFromInventoryBtn.style.width = "100%";
    feedFromInventoryBtn.style.minWidth = "100%";
    feedFromInventoryBtn.style.alignContent = "center";
    feedFromInventoryBtn.style.alignItems = "center";
    feedFromInventoryBtn.style.marginTop = "8px";
    feedFromInventoryBtn.style.padding = "6px 14px";
    feedFromInventoryBtn.style.fontSize = "13px";
    feedFromInventoryBtn.style.border = "2px solid #BA5E1E";
    feedFromInventoryBtn.style.color = "rgb(205 200 193)";
    feedFromInventoryBtn.style.borderRadius = "10px";
    feedFromInventoryBtn.style.height = "40px";
    row.appendChild(feedFromInventoryBtn);
    feedFromInventoryBtn.addEventListener("click", () => {
      void handleInventoryPreviewClick(feedFromInventoryBtn);
    });
    const actions = root.querySelector(".McFlex.css-cabebk");
    const abilities = root.querySelector(".McFlex.css-1hd05pq");
    if (actions && abilities && abilities.parentElement === actions.parentElement) {
      abilities.parentElement.insertBefore(row, abilities);
    } else if (actions?.parentElement) {
      actions.parentElement.insertBefore(row, actions.nextSibling);
    } else {
      root.appendChild(row);
    }
    applyPetPanelButtonVisibility(root);
  }
  function createStyledButton(template, label2) {
    const btn = document.createElement("button");
    btn.type = "button";
    if (template?.className) {
      btn.className = template.className;
    } else {
      btn.className = "chakra-button";
    }
    const wrapper = document.createElement("div");
    wrapper.className = template?.firstElementChild instanceof HTMLElement ? template.firstElementChild.className : "McFlex";
    const textEl = document.createElement("p");
    const templateText = template?.querySelector(".chakra-text");
    textEl.className = templateText instanceof HTMLElement ? templateText.className : "chakra-text";
    textEl.textContent = label2;
    wrapper.appendChild(textEl);
    btn.appendChild(wrapper);
    return btn;
  }
  async function handleFeedClick(btn) {
    const prevDisabled = btn.disabled;
    btn.disabled = true;
    try {
      const petId = await getExpandedPetId();
      if (!petId) {
        await toastSimple("Feed from inventory", "No expanded pet detected.", "error");
        return;
      }
      const pet = await findPetById2(petId);
      if (!pet) {
        await toastSimple("Feed from inventory", "Unable to resolve expanded pet.", "error");
        return;
      }
      const species = String(pet?.slot?.petSpecies || "");
      const allowed = PetsService.getInstantFeedAllowedCrops(species);
      if (!allowed.size) {
        await toastSimple(
          "Feed from inventory",
          "No allowed crops for this pet. Check the Feeding tab.",
          "info"
        );
        return;
      }
      const inventory = await PlayerService.getCropInventoryState();
      const items = Array.isArray(inventory) ? inventory : [];
      const favoriteSet = await PlayerService.getFavoriteIdSet().catch(() => /* @__PURE__ */ new Set());
      const chosen = items.find((item) => {
        const speciesId = String(item?.species || "");
        if (!speciesId || !allowed.has(speciesId)) return false;
        const id = String(item?.id || "");
        return id && !favoriteSet.has(id);
      });
      const chosenId = String(chosen?.id || "");
      if (!chosenId) {
        await toastSimple(
          "Feed from inventory",
          "No compatible crops in inventory (excluding favorites).",
          "info"
        );
        return;
      }
      const previousHungerPct = getHungerPctForPet(pet);
      await PlayerService.feedPet(petId, chosenId);
      const hungerPct = await waitForHungerIncrease(petId, previousHungerPct, {
        initialDelay: 150
      });
      const hungerSuffix = hungerPct != null ? ` Hunger: ${formatHungerPct(hungerPct)}%.` : "";
      const cropName = String(chosen?.species || "crop");
      const petLabel = pet?.slot?.name || species || petId;
      await toastSimple(
        "Feed from inventory",
        `Fed ${petLabel} with ${cropName}.${hungerSuffix}`,
        "success"
      );
    } catch (err) {
      console.error("[Pet panel] Failed to feed pet from inventory", err);
      await toastSimple(
        "Feed from inventory",
        err instanceof Error ? err.message : "Failed to feed pet.",
        "error"
      );
    } finally {
      btn.disabled = prevDisabled;
    }
  }
  async function handleInventoryPreviewClick(btn) {
    const prevDisabled = btn.disabled;
    let shouldCloseInventory = false;
    btn.disabled = true;
    try {
      const petId = await getExpandedPetId();
      if (!petId) {
        await toastSimple("Feed from inventory", "No expanded pet detected.", "error");
        return;
      }
      const pet = await findPetById2(petId);
      if (!pet) {
        await toastSimple("Feed from inventory", "Unable to resolve expanded pet.", "error");
        return;
      }
      const species = String(pet?.slot?.petSpecies || "");
      let lastKnownHungerPct = getHungerPctForPet(pet);
      const allowed = await getAllowedCrops(petId, species);
      if (!allowed.size) {
        await toastSimple("Feed from inventory", "No compatible crops for this pet.", "info");
        return;
      }
      const inventory = await PlayerService.getCropInventoryState();
      const items = Array.isArray(inventory) ? inventory : [];
      const favoriteSet = await PlayerService.getFavoriteIdSet().catch(() => /* @__PURE__ */ new Set());
      const filtered = items.filter((item) => {
        const speciesId = String(item?.species || "");
        if (!speciesId || !allowed.has(speciesId)) return false;
        const id = String(item?.id || "");
        return id && !favoriteSet.has(id);
      });
      if (!filtered.length) {
        await toastSimple("Feed from inventory", "No compatible crops in inventory.", "info");
        return;
      }
      const computeFavoritedIds = (items2) => {
        const allowedIds = /* @__PURE__ */ new Set();
        for (const item of items2) {
          const id = String(item?.id || "");
          if (id) allowedIds.add(id);
        }
        return Array.from(favoriteSet).filter((id) => allowedIds.has(id));
      };
      await clearHandSelection().catch(() => {
      });
      let visibleItems = filtered.slice();
      let favoritedItemIds = computeFavoritedIds(visibleItems);
      await fakeInventoryShow({ items: visibleItems, favoritedItemIds }, { open: true });
      const label2 = pet?.slot?.name || species || petId;
      await toastSimple(
        "Feed from inventory",
        `Showing ${visibleItems.length} compatible crop(s) for ${label2}. Select a crop to feed it immediately.`,
        "info"
      );
      while (true) {
        const selectedIndex = await waitForFakeInventorySelection(2e4);
        if (selectedIndex == null) {
          await toastSimple("Feed from inventory", "No crop selected.", "info");
          break;
        }
        if (selectedIndex < 0 || selectedIndex >= visibleItems.length) {
          await toastSimple("Feed from inventory", "Invalid crop selection.", "error");
          await clearHandSelection().catch(() => {
          });
          continue;
        }
        const chosen = visibleItems[selectedIndex];
        const chosenId = String(chosen?.id || "");
        if (!chosenId) {
          await toastSimple("Feed from inventory", "Invalid crop selection.", "error");
          await clearHandSelection().catch(() => {
          });
          continue;
        }
        const hungerPctBeforeFeed = lastKnownHungerPct;
        await PlayerService.feedPet(petId, chosenId);
        const hungerPct = await waitForHungerIncrease(petId, hungerPctBeforeFeed, {
          initialDelay: 200
        });
        if (hungerPct != null) {
          lastKnownHungerPct = hungerPct;
        }
        const hungerSuffix = hungerPct != null ? ` Hunger: ${formatHungerPct(hungerPct)}%.` : "";
        const cropName = String(chosen?.species || "crop");
        const petLabel = pet?.slot?.name || species || petId;
        await toastSimple(
          "Feed from inventory",
          `Fed ${petLabel} with ${cropName}.${hungerSuffix}`,
          "success"
        );
        const hungerFull = hungerPct != null && hungerPct >= 99.9;
        if (hungerFull) {
          shouldCloseInventory = true;
          try {
            await closeInventoryPanel();
          } catch {
          }
          break;
        }
        let invItems = null;
        try {
          const nextInventory = await PlayerService.getCropInventoryState();
          invItems = Array.isArray(nextInventory) ? nextInventory : null;
        } catch {
          invItems = null;
        }
        let nextVisible = invItems?.filter((item) => {
          const speciesId = String(item?.species || "");
          if (!speciesId || !allowed.has(speciesId)) return false;
          const id = String(item?.id || "");
          return id && !favoriteSet.has(id);
        }) ?? null;
        const removeChosenLocally = () => visibleItems.filter((item) => String(item?.id || "") !== chosenId);
        if (!nextVisible) {
          nextVisible = removeChosenLocally();
        } else {
          const stillContainsChosen = nextVisible.some(
            (item) => String(item?.id || "") === chosenId
          );
          if (stillContainsChosen) {
            nextVisible = removeChosenLocally();
          }
        }
        visibleItems = nextVisible;
        if (!visibleItems.length) {
          await toastSimple("Feed from inventory", "No compatible crops in inventory.", "info");
          shouldCloseInventory = true;
          try {
            await closeInventoryPanel();
          } catch {
          }
          break;
        }
        favoritedItemIds = computeFavoritedIds(visibleItems);
        await fakeInventoryShow({ items: visibleItems, favoritedItemIds }, { open: false });
        await clearHandSelection().catch(() => {
        });
      }
    } catch (err) {
      console.error("[Pet panel] Failed to handle inventory feed", err);
      await toastSimple(
        "Feed from inventory",
        err instanceof Error ? err.message : "Failed to feed pet from inventory.",
        "error"
      );
    } finally {
      try {
        await clearHandSelection();
      } catch {
      }
      if (shouldCloseInventory) {
        try {
          await closeInventoryPanel();
        } catch {
        }
      }
      btn.disabled = prevDisabled;
    }
  }
  async function getExpandedPetId() {
    try {
      const raw = await Atoms.pets.expandedPetSlotId.get();
      const id = typeof raw === "string" ? raw.trim() : "";
      return id.length ? id : null;
    } catch {
      return null;
    }
  }
  async function findPetById2(petId) {
    try {
      const list = await PetsService.getPets();
      const arr = Array.isArray(list) ? list : [];
      return arr.find((p) => String(p?.slot?.id || "") === petId) ?? null;
    } catch (err) {
      console.warn("[Pet panel] Failed to fetch pets", err);
      return null;
    }
  }
  async function getAllowedCrops(petId, species) {
    const defaults = PetsService.getCompatibleCropsForSpecies(species) ?? [];
    return new Set(defaults);
  }
  function formatHungerPct(pct) {
    if (!Number.isFinite(pct)) return "";
    const clamped = Math.max(0, Math.min(100, pct));
    const rounded = Math.round(clamped * 10) / 10;
    return Number.isInteger(rounded) ? String(rounded) : rounded.toFixed(1);
  }
  var HUNGER_EPSILON = 0.05;
  var HUNGER_TIMEOUT_MS = 4e3;
  var HUNGER_POLL_INTERVAL_MS = 120;
  function isPetInfo(value) {
    if (!value || typeof value !== "object") return false;
    const slot = value.slot;
    return !!slot && typeof slot === "object";
  }
  function getHungerPctForPet(pet) {
    if (!isPetInfo(pet)) return null;
    try {
      const hungerPct = PetsService.getHungerPctFor(pet);
      return typeof hungerPct === "number" && Number.isFinite(hungerPct) ? hungerPct : null;
    } catch {
      return null;
    }
  }
  async function getPetHungerPct(petId) {
    try {
      const updatedPet = await findPetById2(petId);
      return getHungerPctForPet(updatedPet);
    } catch {
      return null;
    }
  }
  async function waitForHungerIncrease(petId, previousPct, options = {}) {
    const { initialDelay = 0, timeout = HUNGER_TIMEOUT_MS, interval = HUNGER_POLL_INTERVAL_MS } = options;
    if (initialDelay > 0) {
      await delay3(initialDelay);
    }
    const start2 = typeof performance !== "undefined" && typeof performance.now === "function" ? performance.now() : Date.now();
    let lastResult = null;
    while (true) {
      const pct = await getPetHungerPct(petId);
      if (pct != null) {
        lastResult = pct;
        if (previousPct == null || pct >= Math.min(100, previousPct + HUNGER_EPSILON) || pct >= 99.9) {
          return pct;
        }
      }
      const now2 = typeof performance !== "undefined" && typeof performance.now === "function" ? performance.now() : Date.now();
      if (now2 - start2 >= timeout) {
        return lastResult;
      }
      if (interval > 0) {
        await delay3(interval);
      }
    }
  }
  function delay3(ms) {
    return new Promise((resolve2) => setTimeout(resolve2, ms));
  }
  async function waitForFakeInventorySelection(timeoutMs = 2e4) {
    const start2 = performance.now();
    while (performance.now() - start2 < timeoutMs) {
      try {
        const modalVal = await Atoms.ui.activeModal.get();
        if (!isInventoryOpen(modalVal)) return null;
      } catch {
        return null;
      }
      try {
        const value = await Atoms.inventory.myPossiblyNoLongerValidSelectedItemIndex.get();
        if (typeof value === "number" && Number.isInteger(value) && value >= 0) {
          return value;
        }
      } catch {
      }
      await new Promise((resolve2) => setTimeout(resolve2, 80));
    }
    return null;
  }

  // src/utils/cropPrice.ts
  init_atoms();
  var isPlantObject2 = (o) => !!o && o.objectType === "plant";
  var defaultOrder2 = (n) => Array.from({ length: n }, (_, i) => i);
  var clamp2 = (n, min, max) => Math.max(min, Math.min(max, n));
  function startCropPriceWatcherViaGardenObject() {
    let cur = null;
    let players = void 0;
    let sortedIdx = null;
    let selectedIdx = null;
    let lastPrice = null;
    const listeners5 = /* @__PURE__ */ new Set();
    const notify2 = () => {
      for (const fn of listeners5) try {
        fn();
      } catch {
      }
    };
    let scheduled = false;
    const scheduleRecomputeAndNotify = () => {
      if (scheduled) return;
      scheduled = true;
      requestAnimationFrame(() => {
        scheduled = false;
        recomputeAndNotify();
      });
    };
    function getOrder() {
      const n = Array.isArray(cur?.slots) ? cur.slots.length : 0;
      if (!n) return [];
      return Array.isArray(sortedIdx) && sortedIdx.length === n ? sortedIdx : defaultOrder2(n);
    }
    function selectedOrderedPosition() {
      if (!isPlantObject2(cur)) return 0;
      const slots = cur.slots ?? [];
      const n = Array.isArray(slots) ? slots.length : 0;
      if (!n) return 0;
      const raw = Number.isFinite(selectedIdx) ? selectedIdx : 0;
      const clampedRaw = clamp2(raw, 0, n - 1);
      const ord = getOrder();
      const pos = ord.indexOf(clampedRaw);
      return pos >= 0 ? pos : 0;
    }
    function getOrderedSlots() {
      if (!isPlantObject2(cur)) return [];
      const slots = Array.isArray(cur.slots) ? cur.slots : [];
      const ord = getOrder();
      const out = [];
      for (const i of ord) if (slots[i] != null) out.push(slots[i]);
      return out;
    }
    function computeSelectedSlotPrice() {
      if (!isPlantObject2(cur)) return null;
      const ordered = getOrderedSlots();
      if (!ordered.length) return null;
      const pos = selectedOrderedPosition();
      const slot = ordered[clamp2(pos, 0, ordered.length - 1)];
      const val = valueFromGardenSlot(slot, DefaultPricing, players);
      return Number.isFinite(val) && val > 0 ? val : null;
    }
    function computeWholePlantPrice() {
      if (!isPlantObject2(cur)) return null;
      const v = valueFromGardenPlant(cur, DefaultPricing, players);
      return Number.isFinite(v) && v > 0 ? v : null;
    }
    function recomputeAndNotify() {
      const slotVal = computeSelectedSlotPrice();
      const next = slotVal ?? computeWholePlantPrice() ?? null;
      if (next !== lastPrice) {
        lastPrice = next;
        notify2();
      }
    }
    (async () => {
      try {
        cur = await myCurrentGardenObject.get();
      } catch {
      }
      try {
        players = await numPlayers.get();
      } catch {
      }
      try {
        const v = await myCurrentSortedGrowSlotIndices.get();
        sortedIdx = Array.isArray(v) ? v.slice() : null;
      } catch {
      }
      try {
        selectedIdx = await myCurrentGrowSlotIndex.get();
      } catch {
      }
      numPlayers.onChange((n) => {
        players = n;
      });
      myCurrentSortedGrowSlotIndices.onChange((v) => {
        sortedIdx = Array.isArray(v) ? v.slice() : null;
      });
      myCurrentGardenObject.onChange((v) => {
        cur = v;
        scheduleRecomputeAndNotify();
      });
      myCurrentGrowSlotIndex.onChange((idx) => {
        selectedIdx = Number.isFinite(idx) ? idx : 0;
        scheduleRecomputeAndNotify();
      });
      recomputeAndNotify();
    })();
    return {
      get() {
        return lastPrice;
      },
      onChange(cb) {
        listeners5.add(cb);
        return () => listeners5.delete(cb);
      },
      stop() {
        listeners5.clear();
      }
    };
  }

  // src/utils/cropValues.ts
  init_page_context();
  function getQpmGlobal() {
    return readSharedGlobal("QPM");
  }
  function getQpmSizeSpan(inner) {
    const QPM = getQpmGlobal();
    if (!QPM) return null;
    return inner.querySelector("span.qpm-crop-size");
  }
  var DEFAULTS3 = {
    rootSelector: ".McFlex.css-fsggty",
    innerSelector: ".McFlex.css-1l3zq7, .McFlex.css-11dqzw",
    markerClass: "tm-crop-price"
  };
  var OMA_SEL = ".McFlex.css-1l3zq7, .McFlex.css-11dqzw";
  var ICON_CLASS = "tm-crop-price-icon";
  var LABEL_CLASS = "tm-crop-price-label";
  var LOCK_TEXT_SELECTOR = ":scope > .chakra-text.css-1uvlb8k";
  var LOCK_EMOJI = "\u{1F512}";
  var LOCK_BORDER_STYLE = "2px solid rgb(188, 53, 215)";
  var LOCK_BORDER_RADIUS = "15px";
  var TOOLTIP_ROOT_CLASS = "css-qnqsp4";
  var LOCK_ICON_CLASS = "tm-locker-tooltip-lock-icon";
  var DATASET_KEY_COLOR = "tmLockerOriginalColor";
  var DATASET_KEY_DISPLAY = "tmLockerOriginalDisplay";
  var DATASET_KEY_ALIGN = "tmLockerOriginalAlign";
  var DATASET_KEY_TEXT = "tmLockerOriginalHtml";
  var DATASET_KEY_BORDER = "tmLockerOriginalBorder";
  var DATASET_KEY_BORDER_RADIUS = "tmLockerOriginalBorderRadius";
  var DATASET_KEY_POSITION = "tmLockerOriginalPosition";
  var DATASET_KEY_OVERFLOW = "tmLockerOriginalOverflow";
  var LOCK_PREFIX_REGEX = new RegExp(`^${LOCK_EMOJI}(?:\\u00A0|\\s|&nbsp;)*`);
  var PRICE_FALLBACK = "\u2014";
  var nfUS = new Intl.NumberFormat("en-US");
  var formatCoins = (value) => value == null ? PRICE_FALLBACK : nfUS.format(Math.max(0, Math.round(value)));
  var hasDOM = typeof window !== "undefined" && typeof document !== "undefined";
  function queryAll2(root, sel) {
    return Array.from(root.querySelectorAll(sel));
  }
  function createLogger(option) {
    if (typeof option === "function") return option;
    if (option) return (...args) => console.debug("[AppendCropPrice/GO]", ...args);
    return () => {
    };
  }
  function forEachInner(root, selectors, callback) {
    queryAll2(root, selectors.rootSelector).forEach((rootEl) => {
      queryAll2(rootEl, selectors.innerSelector).forEach(callback);
    });
  }
  function updatePanels(root, selectors, markerClass, text, locked) {
    forEachInner(root, selectors, (inner) => {
      if (shouldSkipInner(inner, markerClass)) {
        removeMarker(inner, markerClass);
        updateLockEmoji(inner, false);
        return;
      }
      updateLockEmoji(inner, locked);
      ensureSpanAtEnd(inner, text, markerClass);
    });
  }
  function getLockerHarvestAllowed() {
    try {
      return lockerService.getCurrentSlotSnapshot().harvestAllowed ?? null;
    } catch {
      return null;
    }
  }
  function subscribeLocker(handler) {
    try {
      return lockerService.onSlotInfoChange(handler);
    } catch {
      return null;
    }
  }
  function startCropValuesObserverFromGardenAtom(options = {}) {
    if (!hasDOM) {
      return { stop() {
      }, runOnce() {
      }, isRunning: () => false };
    }
    const selectors = {
      rootSelector: options.rootSelector ?? DEFAULTS3.rootSelector,
      innerSelector: options.innerSelector ?? DEFAULTS3.innerSelector
    };
    const markerClass = options.markerClass ?? DEFAULTS3.markerClass;
    const root = options.root ?? document;
    const logger = createLogger(options.log);
    const priceWatcher = startCropPriceWatcherViaGardenObject();
    const shouldWaitForLocker = lockerService.getState().enabled;
    let running = true;
    let lockerHarvestAllowed = getLockerHarvestAllowed();
    let lockerReady = !shouldWaitForLocker;
    let lastRenderedValue = void 0;
    let lastRenderedLocked = void 0;
    let needsRepositionRender = false;
    let qpmObserver = null;
    const render2 = () => {
      if (!running) return;
      if (!lockerReady) return;
      const value = priceWatcher.get();
      const locked = lockerHarvestAllowed === false;
      if (value === lastRenderedValue && locked === lastRenderedLocked && !needsRepositionRender) {
        return;
      }
      lastRenderedValue = value;
      lastRenderedLocked = locked;
      needsRepositionRender = false;
      updatePanels(root, selectors, markerClass, formatCoins(value), locked);
      logger("render", { value, locked });
    };
    let lockerReadyTimeout = null;
    const clearLockerReadyTimeout = () => {
      if (lockerReadyTimeout == null) return;
      if (typeof globalThis !== "undefined" && typeof globalThis.clearTimeout === "function") {
        globalThis.clearTimeout(lockerReadyTimeout);
      }
      lockerReadyTimeout = null;
    };
    const startLockerReadyTimeout = () => {
      if (!shouldWaitForLocker || lockerReady || lockerReadyTimeout != null) return;
      if (typeof globalThis === "undefined" || typeof globalThis.setTimeout !== "function") return;
      lockerReadyTimeout = globalThis.setTimeout(() => {
        lockerReadyTimeout = null;
        if (!lockerReady) {
          lockerReady = true;
          render2();
        }
      }, 500);
    };
    startLockerReadyTimeout();
    const startQpmObserver = () => {
      if (qpmObserver) return;
      if (typeof MutationObserver === "undefined") return;
      const target = document.body ?? document.documentElement ?? document;
      if (!target) return;
      qpmObserver = new MutationObserver((mutations) => {
        let found = false;
        for (const mutation of mutations) {
          for (const node of Array.from(mutation.addedNodes)) {
            if (!(node instanceof Element)) continue;
            if (node.classList.contains("qpm-crop-size")) {
              found = true;
              break;
            }
            if (node.querySelector(".qpm-crop-size")) {
              found = true;
              break;
            }
          }
          if (found) break;
        }
        if (found) {
          needsRepositionRender = true;
          render2();
        }
      });
      qpmObserver.observe(target, { childList: true, subtree: true });
    };
    const stopQpmObserver = () => {
      if (!qpmObserver) return;
      try {
        qpmObserver.disconnect();
      } catch {
      }
      qpmObserver = null;
    };
    startQpmObserver();
    const lockerOff = subscribeLocker((event) => {
      lockerHarvestAllowed = event.harvestAllowed ?? null;
      clearLockerReadyTimeout();
      if (!lockerReady && shouldWaitForLocker) {
        lockerReady = true;
      }
      render2();
    });
    if (shouldWaitForLocker && lockerOff == null) {
      clearLockerReadyTimeout();
      lockerReady = true;
    }
    render2();
    const off = priceWatcher.onChange(render2);
    return {
      stop() {
        if (!running) return;
        running = false;
        clearLockerReadyTimeout();
        stopQpmObserver();
        off?.();
        if (typeof lockerOff === "function") {
          try {
            lockerOff();
          } catch {
          }
        }
        priceWatcher.stop();
        logger("stopped");
      },
      runOnce() {
        render2();
      },
      isRunning() {
        return running;
      }
    };
  }
  function shouldSkipInner(inner, markerClass) {
    if (!(inner instanceof Element)) return false;
    if (!inner.matches(OMA_SEL)) return false;
    const realChildren = getRealElementChildren(inner, markerClass);
    return realChildren.length === 1;
  }
  function getRealElementChildren(inner, markerClass) {
    const children = Array.from(inner.children);
    return children.filter(
      (el2) => !(el2.tagName === "SPAN" && el2.classList.contains(markerClass))
    );
  }
  function removeMarker(inner, markerClass) {
    const markers = inner.querySelectorAll(`:scope > span.${CSS.escape(markerClass)}`);
    markers.forEach((m) => m.remove());
  }
  function cleanupLegacyLockIcons() {
    if (typeof document === "undefined") return;
    const all = document.querySelectorAll(`span.${LOCK_ICON_CLASS}`);
    all.forEach((icon) => {
      if (!icon.closest(`.${TOOLTIP_ROOT_CLASS}`)) {
        icon.remove();
      }
    });
  }
  function getTooltipRoot(inner) {
    return inner.closest(`.${TOOLTIP_ROOT_CLASS}`);
  }
  function updateLockEmoji(inner, locked) {
    if (!(inner instanceof HTMLElement)) return;
    inner.querySelectorAll(":scope > span.tm-locker-lock-emoji").forEach((node) => node.remove());
    cleanupLegacyLockIcons();
    const textTarget = inner.querySelector(LOCK_TEXT_SELECTOR) ?? inner.querySelector(":scope > .chakra-text");
    const tooltipRoot = getTooltipRoot(inner);
    const outerContainer = inner.closest(".css-502lyi");
    if (outerContainer && outerContainer !== tooltipRoot) {
      restoreTooltipStyles(outerContainer);
      removeLockIcon(outerContainer);
    }
    if (!locked) {
      if (textTarget) {
        restoreTextContent(textTarget);
        restoreTextStyles(textTarget);
      }
      if (tooltipRoot) {
        restoreTooltipStyles(tooltipRoot);
        removeLockIcon(tooltipRoot);
      }
      return;
    }
    if (textTarget) {
      restoreTextContent(textTarget);
    }
    if (tooltipRoot) {
      storeOriginalTooltipStyles(tooltipRoot);
      applyLockedTooltipStyles(tooltipRoot);
      ensureLockIcon(tooltipRoot);
    }
  }
  function restoreTextStyles(textTarget) {
    restoreStyleFromDataset(textTarget, DATASET_KEY_COLOR, "color");
    restoreStyleFromDataset(textTarget, DATASET_KEY_DISPLAY, "display");
    restoreStyleFromDataset(textTarget, DATASET_KEY_ALIGN, "align-items");
  }
  function restoreTextContent(textTarget) {
    const originalHtml = textTarget.dataset[DATASET_KEY_TEXT];
    if (originalHtml !== void 0) {
      textTarget.innerHTML = originalHtml;
      delete textTarget.dataset[DATASET_KEY_TEXT];
      return;
    }
    const currentHtml = textTarget.innerHTML;
    const sanitizedHtml = stripLockPrefix(currentHtml);
    if (sanitizedHtml !== currentHtml) {
      textTarget.innerHTML = sanitizedHtml;
    }
  }
  function restoreStyleFromDataset(el2, datasetKey, cssProperty) {
    const datasetMap = el2.dataset;
    const originalValue = datasetMap[datasetKey];
    if (originalValue === void 0) return;
    if (originalValue) {
      el2.style.setProperty(cssProperty, originalValue);
    } else {
      el2.style.removeProperty(cssProperty);
    }
    delete datasetMap[datasetKey];
  }
  function storeOriginalTooltipStyles(tooltip) {
    if (tooltip.dataset[DATASET_KEY_BORDER] === void 0) {
      tooltip.dataset[DATASET_KEY_BORDER] = tooltip.style.border ?? "";
    }
    if (tooltip.dataset[DATASET_KEY_BORDER_RADIUS] === void 0) {
      tooltip.dataset[DATASET_KEY_BORDER_RADIUS] = tooltip.style.borderRadius ?? "";
    }
    if (tooltip.dataset[DATASET_KEY_OVERFLOW] === void 0) {
      tooltip.dataset[DATASET_KEY_OVERFLOW] = tooltip.style.overflow ?? "";
    }
  }
  function applyLockedTooltipStyles(tooltip) {
    tooltip.style.border = LOCK_BORDER_STYLE;
    tooltip.style.borderRadius = LOCK_BORDER_RADIUS;
    tooltip.style.overflow = "visible";
    const computedPosition = typeof window !== "undefined" ? window.getComputedStyle(tooltip).position : tooltip.style.position || "static";
    if (computedPosition === "static") {
      if (tooltip.dataset[DATASET_KEY_POSITION] === void 0) {
        tooltip.dataset[DATASET_KEY_POSITION] = tooltip.style.position ?? "";
      }
      tooltip.style.position = "relative";
    }
  }
  function restoreTooltipStyles(tooltip) {
    const originalBorder = tooltip.dataset[DATASET_KEY_BORDER];
    if (originalBorder !== void 0) {
      if (originalBorder) {
        tooltip.style.border = originalBorder;
      } else {
        tooltip.style.removeProperty("border");
      }
      delete tooltip.dataset[DATASET_KEY_BORDER];
    } else {
      tooltip.style.removeProperty("border");
    }
    const originalBorderRadius = tooltip.dataset[DATASET_KEY_BORDER_RADIUS];
    if (originalBorderRadius !== void 0) {
      if (originalBorderRadius) {
        tooltip.style.borderRadius = originalBorderRadius;
      } else {
        tooltip.style.removeProperty("border-radius");
      }
      delete tooltip.dataset[DATASET_KEY_BORDER_RADIUS];
    } else {
      tooltip.style.removeProperty("border-radius");
    }
    const originalOverflow = tooltip.dataset[DATASET_KEY_OVERFLOW];
    if (originalOverflow !== void 0) {
      if (originalOverflow) {
        tooltip.style.overflow = originalOverflow;
      } else {
        tooltip.style.removeProperty("overflow");
      }
      delete tooltip.dataset[DATASET_KEY_OVERFLOW];
    } else {
      tooltip.style.removeProperty("overflow");
    }
    const originalPosition = tooltip.dataset[DATASET_KEY_POSITION];
    if (originalPosition !== void 0) {
      if (originalPosition) {
        tooltip.style.position = originalPosition;
      } else {
        tooltip.style.removeProperty("position");
      }
      delete tooltip.dataset[DATASET_KEY_POSITION];
    } else if (tooltip.style.position === "relative") {
      tooltip.style.removeProperty("position");
    }
  }
  function ensureLockIcon(tooltip) {
    const icons = tooltip.querySelectorAll(`:scope > span.${LOCK_ICON_CLASS}`);
    icons.forEach((node, idx) => {
      if (idx > 0) node.remove();
    });
    let icon = icons[0] ?? null;
    if (!icon) {
      icon = document.createElement("span");
      icon.className = LOCK_ICON_CLASS;
      tooltip.append(icon);
    }
    icon.textContent = LOCK_EMOJI;
    icon.style.position = "absolute";
    icon.style.top = "0";
    icon.style.right = "0";
    icon.style.left = "";
    icon.style.transform = "translate(50%, -50%)";
    icon.style.fontSize = "18px";
    icon.style.padding = "2px 8px";
    icon.style.borderRadius = "999px";
    icon.style.border = "none";
    icon.style.background = "transparent";
    icon.style.color = "white";
    icon.style.pointerEvents = "none";
    icon.style.userSelect = "none";
    icon.style.zIndex = "1";
  }
  function removeLockIcon(tooltip) {
    tooltip.querySelectorAll(`:scope > span.${LOCK_ICON_CLASS}`).forEach((node) => node.remove());
  }
  function stripLockPrefix(content) {
    return content.replace(LOCK_PREFIX_REGEX, "");
  }
  function ensureSpanAtEnd(inner, text, markerClass) {
    const spans = Array.from(
      inner.querySelectorAll(`:scope > span.${CSS.escape(markerClass)}`)
    );
    let span = spans[0] ?? null;
    for (let i = 1; i < spans.length; i++) spans[i].remove();
    if (!span) {
      span = document.createElement("span");
      span.className = markerClass;
    }
    span.style.display = "block";
    span.style.marginTop = "6px";
    span.style.fontWeight = "700";
    span.style.color = "#FFD84D";
    span.style.fontSize = "14px";
    let icon = span.querySelector(`:scope > span.${ICON_CLASS}`);
    if (!icon) {
      icon = document.createElement("span");
      icon.className = ICON_CLASS;
      icon.setAttribute("aria-hidden", "true");
      icon.style.width = "18px";
      icon.style.height = "18px";
      icon.style.display = "inline-block";
      icon.style.verticalAlign = "middle";
      icon.style.marginRight = "6px";
      icon.style.userSelect = "none";
      icon.style.pointerEvents = "none";
      icon.style.backgroundSize = "contain";
      icon.style.backgroundRepeat = "no-repeat";
      icon.style.backgroundPosition = "center";
      span.insertBefore(icon, span.firstChild);
    }
    const bg = `url("${coin.img64}")`;
    if (icon.style.backgroundImage !== bg) {
      icon.style.backgroundImage = bg;
    }
    let label2 = span.querySelector(`:scope > span.${LABEL_CLASS}`);
    if (!label2) {
      label2 = document.createElement("span");
      label2.className = LABEL_CLASS;
      label2.style.display = "inline";
      span.appendChild(label2);
    }
    if (label2.textContent !== text) {
      label2.textContent = text;
    }
    const sizeSpan = getQpmSizeSpan(inner);
    if (sizeSpan) {
      const next = sizeSpan.nextElementSibling;
      if (next !== span) {
        inner.insertBefore(span, next);
      }
      return;
    }
    if (inner.lastElementChild !== span) {
      inner.appendChild(span);
    }
  }

  // src/utils/sellCropsLock.ts
  init_atoms();
  var CONTAINER_SELECTOR = ".css-vmnhaw";
  var LOCK_ICON_CLASS2 = "tm-sell-crops-lock";
  var DATA_BORDER = "tmSellLockBorder";
  var DATA_RADIUS = "tmSellLockRadius";
  var DATA_POSITION = "tmSellLockPosition";
  var DATA_PADDING = "tmSellLockPadding";
  var DATA_BOX = "tmSellLockBox";
  var DATA_SHADOW = "tmSellLockShadow";
  var DATA_OVERFLOW = "tmSellLockOverflow";
  function startSellCropsLockWatcher() {
    if (typeof window === "undefined" || typeof document === "undefined") {
      return { stop() {
      } };
    }
    let bonusFromMultiplier = null;
    let bonusFromPlayers = friendBonusPercentFromPlayers(1);
    let running = true;
    const disposables = [];
    const resolveCurrentBonus = () => bonusFromMultiplier ?? bonusFromPlayers ?? 0;
    const applyLockState = (locked) => {
      const containers = Array.from(
        document.querySelectorAll(CONTAINER_SELECTOR)
      );
      containers.forEach((wrap) => setContainerLocked(wrap, locked));
    };
    const recompute = () => {
      if (!running) return;
      const requiredPct = lockerRestrictionsService.getRequiredPercent();
      const current = resolveCurrentBonus();
      const locked = requiredPct > 0 && !(Number.isFinite(current) && current + 1e-4 >= requiredPct);
      applyLockState(locked);
    };
    const observeDom = () => {
      const mo = new MutationObserver(() => recompute());
      mo.observe(document.documentElement, { childList: true, subtree: true });
      disposables.push(() => mo.disconnect());
    };
    const subscribeAtoms = async () => {
      try {
        const initial = await Atoms.server.friendBonusMultiplier.get();
        bonusFromMultiplier = friendBonusPercentFromMultiplier(initial);
      } catch {
      }
      try {
        const unsub = await Atoms.server.friendBonusMultiplier.onChange((next) => {
          bonusFromMultiplier = friendBonusPercentFromMultiplier(next);
          recompute();
        });
        if (typeof unsub === "function") disposables.push(unsub);
      } catch {
      }
      try {
        const initialPlayers = await Atoms.server.numPlayers.get();
        bonusFromPlayers = friendBonusPercentFromPlayers(initialPlayers);
      } catch {
      }
      try {
        const unsubPlayers = await Atoms.server.numPlayers.onChange((next) => {
          bonusFromPlayers = friendBonusPercentFromPlayers(next);
          recompute();
        });
        if (typeof unsubPlayers === "function") disposables.push(unsubPlayers);
      } catch {
      }
    };
    observeDom();
    disposables.push(lockerRestrictionsService.subscribe(() => recompute()));
    void subscribeAtoms();
    recompute();
    return {
      stop() {
        running = false;
        disposables.splice(0).forEach((fn) => {
          try {
            fn();
          } catch {
          }
        });
        applyLockState(false);
      }
    };
  }
  function setContainerLocked(container, locked) {
    if (!container) return;
    const sellButton = findSellButton(container);
    if (!sellButton) {
      restoreContainerStyles(container);
      removeLockIcon2(container);
      return;
    }
    if (!locked) {
      restoreContainerStyles(container);
      removeLockIcon2(container);
      return;
    }
    storeOriginalStyle(container, DATA_BORDER, "border");
    storeOriginalStyle(container, DATA_RADIUS, "borderRadius");
    storeOriginalStyle(container, DATA_POSITION, "position");
    storeOriginalStyle(container, DATA_PADDING, "padding");
    storeOriginalStyle(container, DATA_BOX, "boxSizing");
    storeOriginalStyle(container, DATA_SHADOW, "boxShadow");
    storeOriginalStyle(container, DATA_OVERFLOW, "overflow");
    container.style.border = "none";
    container.style.borderRadius = "";
    container.style.padding = "";
    container.style.boxSizing = "";
    container.style.boxShadow = "none";
    container.style.overflow = "";
    const computedPos = window.getComputedStyle(container).position;
    if (computedPos === "static") {
      container.style.position = "relative";
    }
    container.style.zIndex = "1000";
    ensureLockIcon2(container);
  }
  function storeOriginalStyle(el2, key2, cssProperty) {
    const data = el2.dataset;
    if (data[key2] !== void 0) return;
    data[key2] = el2.style[cssProperty];
  }
  function restoreContainerStyles(el2) {
    restoreStyle(el2, DATA_BORDER, "border");
    restoreStyle(el2, DATA_RADIUS, "borderRadius");
    restoreStyle(el2, DATA_POSITION, "position");
    restoreStyle(el2, DATA_PADDING, "padding");
    restoreStyle(el2, DATA_BOX, "boxSizing");
    restoreStyle(el2, DATA_SHADOW, "boxShadow");
    restoreStyle(el2, DATA_OVERFLOW, "overflow");
  }
  function restoreStyle(el2, key2, cssProperty) {
    const data = el2.dataset;
    if (data[key2] === void 0) return;
    const value = data[key2];
    if (value) {
      el2.style.setProperty(camelToKebab(cssProperty), value);
    } else {
      el2.style.removeProperty(camelToKebab(cssProperty));
    }
    delete data[key2];
  }
  function camelToKebab(str) {
    return str.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`);
  }
  function ensureLockIcon2(btn) {
    const existing = btn.querySelector(`span.${LOCK_ICON_CLASS2}`);
    if (existing) return;
    const icon = document.createElement("span");
    icon.className = LOCK_ICON_CLASS2;
    icon.textContent = "\u{1F512}";
    icon.style.position = "absolute";
    icon.style.top = "-4px";
    icon.style.right = "-4px";
    icon.style.fontSize = "16px";
    icon.style.pointerEvents = "none";
    icon.style.userSelect = "none";
    icon.style.zIndex = "2";
    btn.appendChild(icon);
  }
  function removeLockIcon2(btn) {
    btn.querySelectorAll(`span.${LOCK_ICON_CLASS2}`).forEach((node) => node.remove());
  }
  function findSellButton(container) {
    const btn = container.querySelector("button");
    if (!btn) return null;
    const text = (btn.textContent || "").trim();
    return /sell\s*crops/i.test(text) ? btn : null;
  }

  // src/utils/eggHatchLockIndicator.ts
  init_atoms();
  var CONTAINER_SELECTOR2 = ".css-502lyi";
  var LOCK_CLASS = "tm-egg-lock";
  var BORDER_COLOR = "rgb(188, 53, 215)";
  var DATA_BORDER2 = "tmEggLockBorder";
  var DATA_RADIUS2 = "tmEggLockRadius";
  var DATA_POSITION2 = "tmEggLockPosition";
  var DATA_OVERFLOW2 = "tmEggLockOverflow";
  function startEggHatchLockIndicator() {
    if (typeof window === "undefined" || typeof document === "undefined") {
      return { stop() {
      } };
    }
    let running = true;
    let currentEggId = null;
    const disposables = [];
    const isEggLocked = () => lockerRestrictionsService.isEggLocked(currentEggId);
    const applyLockState = () => {
      if (!running) return;
      const locked = isEggLocked();
      const containers = Array.from(document.querySelectorAll(CONTAINER_SELECTOR2));
      containers.forEach((el2) => {
        if (!containsEggLabel(el2)) {
          restore(el2);
          return;
        }
        setLocked(el2, locked);
      });
    };
    const observeDom = () => {
      const mo = new MutationObserver(() => applyLockState());
      mo.observe(document.documentElement, { childList: true, subtree: true });
      disposables.push(() => mo.disconnect());
    };
    const subscribeAtoms = async () => {
      try {
        const initial = await Atoms.data.myCurrentGardenObject.get();
        currentEggId = extractEggId2(initial);
      } catch {
      }
      try {
        const unsub = await Atoms.data.myCurrentGardenObject.onChange((next) => {
          currentEggId = extractEggId2(next);
          applyLockState();
        });
        if (typeof unsub === "function") disposables.push(unsub);
      } catch {
      }
      const unsubLocker = lockerRestrictionsService.subscribe(() => applyLockState());
      disposables.push(unsubLocker);
    };
    observeDom();
    void subscribeAtoms();
    applyLockState();
    return {
      stop() {
        running = false;
        disposables.splice(0).forEach((fn) => {
          try {
            fn();
          } catch {
          }
        });
        const containers = Array.from(document.querySelectorAll(CONTAINER_SELECTOR2));
        containers.forEach(restore);
      }
    };
  }
  function containsEggLabel(el2) {
    const text = (el2.textContent || "").toLowerCase();
    return text.includes("egg");
  }
  function setLocked(el2, locked) {
    if (!locked) {
      restore(el2);
      return;
    }
    storeStyle(el2, DATA_BORDER2, "border");
    storeStyle(el2, DATA_RADIUS2, "borderRadius");
    storeStyle(el2, DATA_POSITION2, "position");
    storeStyle(el2, DATA_OVERFLOW2, "overflow");
    el2.style.border = `3px solid ${BORDER_COLOR}`;
    el2.style.borderRadius = "16px";
    el2.style.overflow = "visible";
    const pos = window.getComputedStyle(el2).position;
    if (pos === "static") {
      el2.style.position = "relative";
    }
    ensureLockIcon3(el2);
  }
  function restore(el2) {
    restoreStyle2(el2, DATA_BORDER2, "border");
    restoreStyle2(el2, DATA_RADIUS2, "borderRadius");
    restoreStyle2(el2, DATA_POSITION2, "position");
    restoreStyle2(el2, DATA_OVERFLOW2, "overflow");
    removeLockIcon3(el2);
  }
  function storeStyle(el2, key2, cssProperty) {
    const data = el2.dataset;
    if (data[key2] !== void 0) return;
    data[key2] = el2.style[cssProperty];
  }
  function restoreStyle2(el2, key2, cssProperty) {
    const data = el2.dataset;
    if (data[key2] === void 0) return;
    const value = data[key2];
    if (value) {
      el2.style.setProperty(camelToKebab2(cssProperty), value);
    } else {
      el2.style.removeProperty(camelToKebab2(cssProperty));
    }
    delete data[key2];
  }
  function camelToKebab2(str) {
    return str.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`);
  }
  function ensureLockIcon3(el2) {
    const existing = el2.querySelector(`span.${LOCK_CLASS}`);
    if (existing) return;
    const icon = document.createElement("span");
    icon.className = LOCK_CLASS;
    icon.textContent = "\u{1F512}";
    icon.style.position = "absolute";
    icon.style.top = "-8px";
    icon.style.right = "-8px";
    icon.style.fontSize = "16px";
    icon.style.pointerEvents = "none";
    icon.style.userSelect = "none";
    icon.style.zIndex = "2";
    el2.appendChild(icon);
  }
  function removeLockIcon3(el2) {
    el2.querySelectorAll(`span.${LOCK_CLASS}`).forEach((node) => node.remove());
  }
  function extractEggId2(obj) {
    if (!obj || typeof obj !== "object") return null;
    if (obj.objectType !== "egg") return null;
    const eggId = obj.eggId;
    return typeof eggId === "string" && eggId ? eggId : null;
  }

  // src/utils/decorPickupLockIndicator.ts
  var CONTAINER_SELECTOR3 = ".css-502lyi";
  var LOCK_CLASS2 = "tm-decor-lock";
  var BORDER_COLOR2 = "rgb(188, 53, 215)";
  var DATA_BORDER3 = "tmDecorLockBorder";
  var DATA_RADIUS3 = "tmDecorLockRadius";
  var DATA_POSITION3 = "tmDecorLockPosition";
  var DATA_OVERFLOW3 = "tmDecorLockOverflow";
  var DECOR_LABELS = (() => {
    const labels = /* @__PURE__ */ new Set();
    try {
      Object.entries(decorCatalog).forEach(([decorId, entry]) => {
        if (decorId) labels.add(decorId.toLowerCase());
        const name = entry?.name;
        if (typeof name === "string" && name) {
          labels.add(name.toLowerCase());
        }
      });
    } catch {
    }
    return Array.from(labels).filter(Boolean);
  })();
  function startDecorPickupLockIndicator() {
    if (typeof window === "undefined" || typeof document === "undefined") {
      return { stop() {
      } };
    }
    let running = true;
    const disposables = [];
    const isLocked = () => lockerRestrictionsService.isDecorPickupLocked();
    const applyLockState = () => {
      if (!running) return;
      const locked = isLocked();
      const containers = Array.from(document.querySelectorAll(CONTAINER_SELECTOR3));
      containers.forEach((el2) => {
        if (!looksLikeDecorItem(el2)) {
          restore2(el2);
          return;
        }
        setLocked2(el2, locked);
      });
    };
    const observeDom = () => {
      const mo = new MutationObserver(() => applyLockState());
      mo.observe(document.documentElement, { childList: true, subtree: true });
      disposables.push(() => mo.disconnect());
    };
    const subscribeLocker2 = () => {
      const unsub = lockerRestrictionsService.subscribe(() => applyLockState());
      disposables.push(unsub);
    };
    observeDom();
    subscribeLocker2();
    applyLockState();
    return {
      stop() {
        running = false;
        disposables.splice(0).forEach((fn) => {
          try {
            fn();
          } catch {
          }
        });
        const containers = Array.from(document.querySelectorAll(CONTAINER_SELECTOR3));
        containers.forEach(restore2);
      }
    };
  }
  function looksLikeDecorItem(el2) {
    const text = (el2.textContent || "").toLowerCase();
    if (!text) return false;
    if (!el2.querySelector("canvas")) return false;
    return DECOR_LABELS.some((label2) => label2 && text.includes(label2));
  }
  function setLocked2(el2, locked) {
    if (!locked) {
      restore2(el2);
      return;
    }
    storeStyle2(el2, DATA_BORDER3, "border");
    storeStyle2(el2, DATA_RADIUS3, "borderRadius");
    storeStyle2(el2, DATA_POSITION3, "position");
    storeStyle2(el2, DATA_OVERFLOW3, "overflow");
    el2.style.border = `3px solid ${BORDER_COLOR2}`;
    el2.style.borderRadius = "16px";
    el2.style.overflow = "visible";
    const pos = window.getComputedStyle(el2).position;
    if (pos === "static") {
      el2.style.position = "relative";
    }
    ensureLockIcon4(el2);
  }
  function restore2(el2) {
    restoreStyle3(el2, DATA_BORDER3, "border");
    restoreStyle3(el2, DATA_RADIUS3, "borderRadius");
    restoreStyle3(el2, DATA_POSITION3, "position");
    restoreStyle3(el2, DATA_OVERFLOW3, "overflow");
    removeLockIcon4(el2);
  }
  function storeStyle2(el2, key2, cssProperty) {
    const data = el2.dataset;
    if (data[key2] !== void 0) return;
    data[key2] = el2.style[cssProperty];
  }
  function restoreStyle3(el2, key2, cssProperty) {
    const data = el2.dataset;
    if (data[key2] === void 0) return;
    const value = data[key2];
    if (value) {
      el2.style.setProperty(camelToKebab3(cssProperty), value);
    } else {
      el2.style.removeProperty(camelToKebab3(cssProperty));
    }
    delete data[key2];
  }
  function camelToKebab3(str) {
    return str.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`);
  }
  function ensureLockIcon4(el2) {
    const existing = el2.querySelector(`span.${LOCK_CLASS2}`);
    if (existing) return;
    const icon = document.createElement("span");
    icon.className = LOCK_CLASS2;
    icon.textContent = "\u{1F512}";
    icon.style.position = "absolute";
    icon.style.top = "-8px";
    icon.style.right = "-8px";
    icon.style.fontSize = "16px";
    icon.style.pointerEvents = "none";
    icon.style.userSelect = "none";
    icon.style.zIndex = "2";
    el2.appendChild(icon);
  }
  function removeLockIcon4(el2) {
    el2.querySelectorAll(`span.${LOCK_CLASS2}`).forEach((node) => node.remove());
  }

  // src/utils/inventorySelectionLogger.ts
  init_atoms();
  var started3 = false;
  var cachedItems = [];
  var currentIndex = null;
  var lastLoggedQuantity = void 0;
  var desiredButtonQuantity = null;
  var buttonDiscoveryObserver = null;
  var buttonVisibilityObserver = null;
  function getActionButton() {
    if (typeof document === "undefined") return null;
    const primaryButton = document.querySelector(
      "button.chakra-button.css-w004xu"
    );
    if (primaryButton) return primaryButton;
    const growButtons = Array.from(
      document.querySelectorAll(
        "button.chakra-button.css-35ruvm"
      )
    );
    return growButtons.find(
      (button) => (button.textContent ?? "").includes("Grow")
    ) ?? null;
  }
  function applyQuantityToButton(button, quantity) {
    const quantityContainer = button.querySelector(".css-telpzl");
    const readButtonLabel = () => {
      const clone = button.cloneNode(true);
      clone.querySelectorAll(".css-telpzl").forEach((element) => element.remove());
      return (clone.textContent ?? "").replace(/\s+/g, " ").trim();
    };
    const ensureBaseLabel = () => {
      const existing = button.dataset.baseLabel ?? "";
      const lastQuantity = button.dataset.lastQuantity;
      const currentLabel = readButtonLabel();
      const normalizedCurrentLabel = (() => {
        if (!currentLabel) return "";
        if (lastQuantity && lastQuantity.length > 0) {
          const withSpace = ` \xD7${lastQuantity}`;
          if (currentLabel.endsWith(withSpace)) {
            return currentLabel.slice(0, -withSpace.length).replace(/\s+$/, "");
          }
          const withoutSpace = `\xD7${lastQuantity}`;
          if (currentLabel.endsWith(withoutSpace)) {
            return currentLabel.slice(0, -withoutSpace.length).replace(/\s+$/, "");
          }
        }
        return currentLabel;
      })();
      if (normalizedCurrentLabel && normalizedCurrentLabel !== existing) {
        button.dataset.baseLabel = normalizedCurrentLabel;
        return normalizedCurrentLabel;
      }
      if (!existing && normalizedCurrentLabel) {
        button.dataset.baseLabel = normalizedCurrentLabel;
        return normalizedCurrentLabel;
      }
      return existing;
    };
    const setButtonLabel = (label2) => {
      const contentNode = Array.from(button.childNodes).find((node) => {
        if (quantityContainer && node === quantityContainer) return false;
        const text = node.textContent ?? "";
        return text.trim().length > 0;
      });
      if (contentNode) {
        contentNode.textContent = label2;
        return;
      }
      const referenceNode = quantityContainer ?? button.firstChild;
      button.insertBefore(document.createTextNode(label2), referenceNode ?? null);
    };
    const baseLabel = ensureBaseLabel();
    if (quantityContainer) {
      quantityContainer.textContent = "";
      quantityContainer.style.marginLeft = "";
      quantityContainer.style.display = "none";
    }
    if (quantity == null) {
      button.dataset.lastQuantity = "";
      setButtonLabel(baseLabel);
      return;
    }
    const labelWithQuantity = baseLabel ? `${baseLabel} \xD7${quantity}` : `\xD7${quantity}`;
    button.dataset.lastQuantity = String(quantity);
    setButtonLabel(labelWithQuantity);
  }
  function ensureButtonVisibilityObserver(button) {
    if (typeof IntersectionObserver === "undefined") return;
    if (!buttonVisibilityObserver) {
      buttonVisibilityObserver = new IntersectionObserver((entries) => {
        entries.filter((entry) => entry.isIntersecting).forEach((entry) => {
          applyQuantityToButton(entry.target, desiredButtonQuantity);
        });
      });
    } else {
      buttonVisibilityObserver.disconnect();
    }
    buttonVisibilityObserver.observe(button);
  }
  function ensureButtonDiscoveryObserver() {
    if (typeof document === "undefined") return;
    if (buttonDiscoveryObserver || typeof MutationObserver === "undefined") return;
    const target = document.body;
    if (!target) return;
    buttonDiscoveryObserver = new MutationObserver(() => {
      const button = getActionButton();
      if (!button) return;
      ensureButtonVisibilityObserver(button);
      applyQuantityToButton(button, desiredButtonQuantity);
    });
    buttonDiscoveryObserver.observe(target, { childList: true, subtree: true });
  }
  function updateButtonQuantity(quantity) {
    if (typeof document === "undefined") return;
    desiredButtonQuantity = quantity;
    const button = getActionButton();
    if (!button) {
      ensureButtonDiscoveryObserver();
      return;
    }
    ensureButtonVisibilityObserver(button);
    applyQuantityToButton(button, quantity);
  }
  function normalizeItems(snapshot) {
    if (!snapshot || !Array.isArray(snapshot.items)) return [];
    return snapshot.items.slice();
  }
  function extractQuantity(index) {
    if (index == null || index < 0 || index >= cachedItems.length) return null;
    const raw = cachedItems[index];
    if (!raw) return null;
    const qty = Number(raw.quantity);
    return Number.isFinite(qty) ? qty : null;
  }
  function logQuantity(force = false) {
    if (currentIndex == null) {
      updateButtonQuantity(null);
      lastLoggedQuantity = null;
      return;
    }
    const qty = extractQuantity(currentIndex);
    if (!force && qty === lastLoggedQuantity) return;
    updateButtonQuantity(qty);
    lastLoggedQuantity = qty;
  }
  async function readInventory() {
    try {
      return await Atoms.inventory.myInventory.get();
    } catch (error) {
      return null;
    }
  }
  async function readSelectedIndex() {
    try {
      const value = await Atoms.inventory.myPossiblyNoLongerValidSelectedItemIndex.get();
      return typeof value === "number" ? value : null;
    } catch (error) {
      return null;
    }
  }
  async function startSelectedInventoryQuantityLogger() {
    if (started3) return;
    started3 = true;
    cachedItems = normalizeItems(await readInventory());
    currentIndex = await readSelectedIndex();
    logQuantity(true);
    try {
      await Atoms.inventory.myInventory.onChange((next) => {
        cachedItems = normalizeItems(next);
        logQuantity();
      });
    } catch (error) {
    }
    try {
      await Atoms.inventory.myPossiblyNoLongerValidSelectedItemIndex.onChange((next) => {
        if (typeof next === "number") {
          currentIndex = next;
        } else {
          currentIndex = null;
        }
        lastLoggedQuantity = null;
        logQuantity(true);
      });
    } catch (error) {
    }
  }

  // src/utils/inventorySorting.ts
  init_atoms();
  var DEFAULTS4 = {
    // Updated to new Inventory root grid container (game UI update)
    gridSelector: "div.McGrid.css-1kv58ap",
    filtersBlockSelector: ".McGrid.css-o1vp12",
    closeButtonSelector: "button.css-vuqwsg",
    checkboxSelector: "label.chakra-checkbox.css-1v6h4z7",
    checkboxLabelSelector: ".chakra-checkbox__label",
    injectDarkStyles: true
  };
  var INVENTORY_SEARCH_INPUT_SELECTOR = "input.chakra-input.css-8e1l1i";
  var BASE_SORT = ["alpha", "qty", "rarity", "value"];
  var ORDER = [
    "none",
    "alpha",
    "qty",
    "rarity",
    "value",
    "size",
    "mutations",
    "strength"
  ];
  var SORT_KEY_PATH = "inventory.sortKey";
  var SORT_KEY_SET = new Set(ORDER);
  var SORT_DIRECTION_PATH = "inventory.sortDirection";
  var SORT_DIRECTION_SET = /* @__PURE__ */ new Set(["asc", "desc"]);
  var DEFAULT_DIRECTION_LABEL = "Order:";
  var DIRECTION_LABELS_DEFAULT = {
    asc: "Ascending",
    desc: "Descending"
  };
  var getPetAbilityDisplayName = (abilityId) => {
    if (typeof abilityId !== "string") return null;
    const trimmedId = abilityId.trim();
    if (!trimmedId) return null;
    const ability = petAbilities[trimmedId] ?? null;
    const name = ability?.name;
    if (typeof name !== "string") return null;
    const trimmedName = name.trim();
    return trimmedName ? trimmedName : null;
  };
  var INVENTORY_VALUE_VISIBILITY_PATH = "inventory.showValues";
  var resolveVisibilityFromStoredValue = (value) => {
    if (value === true || value === false) return value;
    if (value === 1 || value === "1" || value === "true") return true;
    if (value === 0 || value === "0" || value === "false") return false;
    return null;
  };
  var loadPersistedInventoryValueVisibility = () => {
    try {
      const stored = readAriesPath(INVENTORY_VALUE_VISIBILITY_PATH);
      return resolveVisibilityFromStoredValue(stored);
    } catch (error) {
      console.warn(
        "[InventorySorting] Impossible de lire la pr\xE9f\xE9rence d'affichage des valeurs d'inventaire",
        error
      );
      return null;
    }
  };
  var persistInventoryValueVisibility = (visible) => {
    try {
      writeAriesPath(INVENTORY_VALUE_VISIBILITY_PATH, visible);
    } catch (error) {
      console.warn(
        "[InventorySorting] Impossible de sauvegarder la pr\xE9f\xE9rence d'affichage des valeurs d'inventaire",
        error
      );
    }
  };
  var shouldDisplayInventoryValues = true;
  var setShouldDisplayInventoryValues = (visible) => {
    shouldDisplayInventoryValues = visible;
  };
  var getShouldDisplayInventoryValues = () => shouldDisplayInventoryValues;
  var DEFAULT_DIRECTION_BY_SORT_KEY = {
    none: "asc",
    alpha: "asc",
    qty: "desc",
    rarity: "asc",
    value: "desc",
    size: "desc",
    mutations: "desc",
    strength: "desc"
  };
  var DIRECTION_ORDER = ["asc", "desc"];
  var isPersistedSortKey = (value) => typeof value === "string" && SORT_KEY_SET.has(value);
  var isPersistedSortDirection = (value) => typeof value === "string" && SORT_DIRECTION_SET.has(value);
  var loadPersistedSortKey = () => {
    try {
      const stored = readAriesPath(SORT_KEY_PATH);
      return isPersistedSortKey(stored) ? stored : null;
    } catch (error) {
      console.warn("[InventorySorting] Impossible de lire la valeur de tri persist\xE9e", error);
      return null;
    }
  };
  var persistSortKey = (value) => {
    try {
      writeAriesPath(SORT_KEY_PATH, value);
    } catch (error) {
      console.warn("[InventorySorting] Impossible de sauvegarder la valeur de tri", error);
    }
  };
  var loadPersistedSortDirection = () => {
    try {
      const stored = readAriesPath(SORT_DIRECTION_PATH);
      return isPersistedSortDirection(stored) ? stored : null;
    } catch (error) {
      console.warn("[InventorySorting] Impossible de lire l'ordre de tri persist\xE9", error);
      return null;
    }
  };
  var persistSortDirection = (value) => {
    try {
      writeAriesPath(SORT_DIRECTION_PATH, value);
    } catch (error) {
      console.warn("[InventorySorting] Impossible de sauvegarder l'ordre de tri", error);
    }
  };
  var MAP_EXTRA_BY_FILTER_DEFAULT = {
    // seed/tool/ decor = tri de base
    seed: [],
    tool: [],
    decor: [],
    // crop/plant = base + size/mutations
    crop: ["size", "mutations"],
    produce: ["size", "mutations"],
    plant: [],
    // pet = base + size/mutations/strength
    pet: ["mutations", "strength"]
  };
  var FILTER_CONTEXT_ITEM_TYPES_CACHE = /* @__PURE__ */ new Map();
  var FILTER_CONTEXT_LISTENERS = /* @__PURE__ */ new Set();
  var addFilterContextListener = (listener) => {
    FILTER_CONTEXT_LISTENERS.add(listener);
    return () => {
      FILTER_CONTEXT_LISTENERS.delete(listener);
    };
  };
  var notifyFilterContextListeners = (contextKey) => {
    FILTER_CONTEXT_LISTENERS.forEach((listener) => {
      try {
        listener(contextKey);
      } catch (error) {
        console.warn("[InventorySorting] Listener de contexte de filtre en erreur", error);
      }
    });
  };
  var LABEL_BY_VALUE_DEFAULT = {
    none: "None",
    alpha: "A\u2013Z",
    qty: "Quantity",
    rarity: "Rarity",
    value: "Values",
    size: "Size",
    mutations: "Mutations",
    strength: "Strength"
  };
  var INVENTORY_BASE_INDEX_DATASET_KEY = "tmInventoryBaseIndex";
  var INVENTORY_ITEM_CARD_SELECTORS = [".css-vmnhaw", ".css-1avy1fz"];
  var INVENTORY_ITEMS_CONTAINER_SELECTOR = ".McFlex.css-zo8r2v";
  var INVENTORY_NOISE_SELECTOR = ".McFlex.css-1tkifdd, .chakra-text.css-glp3xv, .chakra-text.css-repqgl, .chakra-text.css-ah6ymv";
  var INVENTORY_STRENGTH_WRAPPER_SELECTOR = ".McFlex.css-15lpbqz";
  var INVENTORY_STRENGTH_TEXT_SELECTOR = ".chakra-text.css-wqvsdi";
  var INVENTORY_FAVORITE_BUTTON_SELECTOR = "button.chakra-button.css-1iytwn1";
  var INVENTORY_ITEM_CARD_SELECTOR = INVENTORY_ITEM_CARD_SELECTORS.join(", ");
  var INVENTORY_VALUE_CONTAINER_SELECTOR = ".McFlex.css-1p00rng";
  var INVENTORY_VALUE_ELEMENT_CLASS = "tm-inventory-item-value";
  var INVENTORY_VALUE_TEXT_CLASS = `${INVENTORY_VALUE_ELEMENT_CLASS}__text`;
  var INVENTORY_VALUE_DATASET_KEY = "tmInventoryValue";
  var FILTERED_VALUE_LOADING = "\u2026";
  var FILTERED_VALUE_UNKNOWN = "\u2014";
  var VALUE_SUMMARY_ICON_CLASS = "tm-value-toggle__summary-icon";
  var VALUE_SUMMARY_TEXT_CLASS = "tm-value-toggle__summary-text";
  var VALUE_SUMMARY_ICON_SRC = (() => {
    const src = coin?.img64 ?? "";
    if (typeof src !== "string" || !src) {
      return "";
    }
    return src.startsWith("data:") ? src : `data:image/png;base64,${src}`;
  })();
  var VALUE_SUMMARY_ICON_BACKGROUND = VALUE_SUMMARY_ICON_SRC ? `url("${VALUE_SUMMARY_ICON_SRC}")` : "";
  function createDomSnapshot(entries) {
    return entries.map((entry) => entry.wrapper);
  }
  function haveDomEntriesChanged(previous, nextEntries) {
    if (!previous) return true;
    if (previous.length !== nextEntries.length) return true;
    for (let i = 0; i < nextEntries.length; i++) {
      if (previous[i] !== nextEntries[i].wrapper) {
        return true;
      }
    }
    return false;
  }
  var debounce = (fn, wait2 = 120) => {
    let t;
    return (...args) => {
      if (t) window.clearTimeout(t);
      t = window.setTimeout(() => fn(...args), wait2);
    };
  };
  function isVisible(el2) {
    if (!el2 || !document.contains(el2)) return false;
    const r = el2.getBoundingClientRect();
    const cs = getComputedStyle(el2);
    if (cs.display === "none" || cs.visibility === "hidden" || cs.opacity === "0") return false;
    return r.width > 0 && r.height > 0;
  }
  var labelIsChecked = (el2) => el2.matches("[data-checked]") || !!el2.querySelector("[data-checked]");
  var normalize = (s) => (s ?? "").trim().toLowerCase();
  var createFilterContextKey = (filters, search) => {
    const normalizedFilters = filters.map((value) => normalize(value)).filter((value) => value && value !== "all");
    normalizedFilters.sort();
    const normalizedSearch = normalize(search);
    return `${normalizedFilters.join("|")}::${normalizedSearch}`;
  };
  var areSetsEqual = (a, b) => {
    if (a === b) return true;
    if (!a || !b || a.size !== b.size) return false;
    for (const value of a) {
      if (!b.has(value)) return false;
    }
    return true;
  };
  var getCachedItemTypesForKey = (contextKey) => {
    return FILTER_CONTEXT_ITEM_TYPES_CACHE.get(contextKey) ?? null;
  };
  var getCachedItemTypesForContext = (filters, search) => {
    const key2 = createFilterContextKey(filters, search);
    return getCachedItemTypesForKey(key2);
  };
  var setCachedItemTypesForKey = (contextKey, types) => {
    const normalizedTypes = /* @__PURE__ */ new Set();
    types.forEach((type) => {
      const normalizedType = normalize(type);
      if (normalizedType) {
        normalizedTypes.add(normalizedType);
      }
    });
    const previous = FILTER_CONTEXT_ITEM_TYPES_CACHE.get(contextKey) ?? null;
    if (previous && areSetsEqual(previous, normalizedTypes)) {
      return;
    }
    FILTER_CONTEXT_ITEM_TYPES_CACHE.set(contextKey, normalizedTypes);
    notifyFilterContextListeners(contextKey);
  };
  var getInventorySearchInput = (grid) => {
    if (!grid) return null;
    const input = grid.querySelector(INVENTORY_SEARCH_INPUT_SELECTOR);
    return input ?? null;
  };
  var getInventorySearchQuery = (grid) => {
    const input = getInventorySearchInput(grid);
    return typeof input?.value === "string" ? input.value : "";
  };
  var getNormalizedInventorySearchQuery = (grid) => normalize(getInventorySearchQuery(grid));
  var logFilteredInventorySearchResults = async (grid, filters, searchQuery) => {
    if (!grid) return;
    try {
      const inventory = await Atoms.inventory.myInventory.get();
      if (!inventory || typeof inventory !== "object") {
        console.log("[InventorySorting] Inventaire introuvable pour le log de recherche.");
        return;
      }
      const items = Array.isArray(inventory.items) ? inventory.items : [];
      const { filteredItems } = filterInventoryItems(items, filters, searchQuery);
      const container = getInventoryItemsContainer(grid);
      const entries = container ? getInventoryDomEntries(container) : [];
      console.log("[InventorySorting] R\xE9sultats filtr\xE9s (recherche) :", filteredItems);
      console.log(
        "[InventorySorting] Nombre d'\xE9l\xE9ments DOM pour la recherche :",
        entries.length
      );
    } catch (error) {
      console.warn(
        "[InventorySorting] Impossible de journaliser les r\xE9sultats filtr\xE9s de la recherche",
        error
      );
    }
  };
  var RARITY_ORDER = [
    rarity.Common,
    rarity.Uncommon,
    rarity.Rare,
    rarity.Legendary,
    rarity.Mythic,
    rarity.Divine,
    rarity.Celestial
  ].filter(Boolean);
  var RARITY_RANK = (() => {
    const entries = /* @__PURE__ */ new Map();
    RARITY_ORDER.forEach((label2, index) => {
      const key2 = normalize(label2);
      if (key2) {
        entries.set(key2, index);
      }
    });
    const mythicIndex = entries.get(normalize(rarity.Mythic));
    if (typeof mythicIndex === "number") {
      entries.set(normalize("Mythic"), mythicIndex);
    }
    return entries;
  })();
  var getRarityRank = (value) => {
    const key2 = normalize(value);
    if (!key2) return RARITY_ORDER.length;
    return RARITY_RANK.get(key2) ?? RARITY_ORDER.length;
  };
  var SPECIES_FIELDS = [
    "species",
    "seedSpecies",
    "plantSpecies",
    "cropSpecies",
    "baseSpecies",
    "seedKey"
  ];
  var normalizeSpeciesKey3 = (value) => value.toLowerCase().replace(/['`]/g, "").replace(/\s+/g, "").replace(/-/g, "").replace(/(seed|plant|baby|fruit|crop)$/i, "");
  var MAX_SCALE_BY_SPECIES3 = (() => {
    const map2 = /* @__PURE__ */ new Map();
    const register = (key2, value) => {
      if (typeof key2 !== "string") return;
      const normalized = normalizeSpeciesKey3(key2.trim());
      if (!normalized || map2.has(normalized)) return;
      map2.set(normalized, value);
    };
    for (const [species, entry] of Object.entries(plantCatalog)) {
      const maxScale = Number(entry?.crop?.maxScale);
      if (!Number.isFinite(maxScale) || maxScale <= 0) continue;
      register(species, maxScale);
      register(entry?.seed?.name, maxScale);
      register(entry?.plant?.name, maxScale);
      register(entry?.crop?.name, maxScale);
    }
    return map2;
  })();
  var lookupMaxScale3 = (species) => {
    if (typeof species !== "string") return null;
    const normalized = normalizeSpeciesKey3(species.trim());
    if (!normalized) return null;
    const value = MAX_SCALE_BY_SPECIES3.get(normalized);
    return typeof value === "number" && Number.isFinite(value) && value > 0 ? value : null;
  };
  var clampNumber2 = (value, min, max) => Math.max(min, Math.min(max, value));
  var scaleToPercent = (scale, maxScale) => {
    if (!Number.isFinite(scale)) return 50;
    const MIN_PERCENT = 50;
    const MAX_PERCENT = 100;
    const MIN_SCALE = 1;
    const safeScale = Math.max(MIN_SCALE, scale);
    if (typeof maxScale === "number" && Number.isFinite(maxScale) && maxScale > MIN_SCALE) {
      const limited2 = Math.min(maxScale, safeScale);
      const ratio2 = (limited2 - MIN_SCALE) / (maxScale - MIN_SCALE);
      const pct2 = MIN_PERCENT + ratio2 * (MAX_PERCENT - MIN_PERCENT);
      return clampNumber2(Math.round(pct2), MIN_PERCENT, MAX_PERCENT);
    }
    const FALLBACK_MAX_SCALE = 2;
    const limited = Math.min(FALLBACK_MAX_SCALE, safeScale);
    const ratio = (limited - MIN_SCALE) / (FALLBACK_MAX_SCALE - MIN_SCALE);
    const pct = MIN_PERCENT + ratio * (MAX_PERCENT - MIN_PERCENT);
    return clampNumber2(Math.round(pct), MIN_PERCENT, MAX_PERCENT);
  };
  var collectSpeciesCandidates = (source, out) => {
    if (!source || typeof source !== "object") return;
    for (const field of SPECIES_FIELDS) {
      const raw = source[field];
      if (typeof raw === "string") {
        const value = raw.trim();
        if (value) out.add(value);
      }
    }
  };
  var computeSizePercentFromScale = (speciesCandidates, scale) => {
    if (!Number.isFinite(scale)) return null;
    let maxScale = null;
    for (const candidate of speciesCandidates) {
      maxScale = lookupMaxScale3(candidate);
      if (maxScale != null) break;
    }
    return scaleToPercent(scale, maxScale);
  };
  var getInventoryItemSizePercent = (item) => {
    if (!item || typeof item !== "object") return null;
    const candidates = /* @__PURE__ */ new Set();
    collectSpeciesCandidates(item, candidates);
    collectSpeciesCandidates(item.item, candidates);
    collectSpeciesCandidates(item.data, candidates);
    const rawType = typeof item.itemType === "string" ? item.itemType : "";
    const type = rawType.trim();
    if (type === "Crop" || type === "Produce") {
      const scale = Number(item.scale);
      return computeSizePercentFromScale(candidates, scale);
    }
    return null;
  };
  var collectMutations = (source, out) => {
    if (!source || typeof source !== "object") return;
    const rawMutations = source.mutations;
    if (Array.isArray(rawMutations)) {
      for (const mutation of rawMutations) {
        if (typeof mutation === "string" && mutation.trim()) {
          out.push(mutation.trim());
        }
      }
    }
    const slots = source.slots;
    if (Array.isArray(slots)) {
      for (const slot of slots) {
        collectMutations(slot, out);
      }
    }
  };
  var getInventoryItemMutations = (item) => {
    if (!item || typeof item !== "object") return [];
    const mutations = [];
    collectMutations(item, mutations);
    collectMutations(item.item, mutations);
    collectMutations(item.data, mutations);
    return mutations;
  };
  var FILTER_LABEL_TO_ITEM_TYPES = {
    crop: ["Produce"],
    crops: ["Produce"],
    produce: ["Produce"],
    seed: ["Seed"],
    seeds: ["Seed"],
    plant: ["Plant"],
    plants: ["Plant"],
    pet: ["Pet"],
    pets: ["Pet"],
    tool: ["Tool"],
    tools: ["Tool"],
    decor: ["Decor"],
    decors: ["Decor"],
    decoration: ["Decor"],
    decorations: ["Decor"],
    egg: ["Egg"],
    eggs: ["Egg"]
  };
  var ITEM_TYPE_TO_FILTER_KEYS = (() => {
    const mapping = /* @__PURE__ */ new Map();
    for (const [filterKey, itemTypes] of Object.entries(FILTER_LABEL_TO_ITEM_TYPES)) {
      for (const itemType of itemTypes) {
        const normalizedType = normalize(itemType);
        if (!normalizedType) continue;
        const set3 = mapping.get(normalizedType) ?? /* @__PURE__ */ new Set();
        set3.add(filterKey);
        mapping.set(normalizedType, set3);
      }
    }
    const result = {};
    mapping.forEach((value, key2) => {
      result[key2] = Array.from(value);
    });
    return result;
  })();
  var getExtrasForFilterKey = (filterKey, mapExtraByFilter) => {
    if (!filterKey) return [];
    const direct = mapExtraByFilter[filterKey];
    if (Array.isArray(direct) && direct.length) {
      return direct;
    }
    if (filterKey.endsWith("s")) {
      const singular = filterKey.slice(0, -1);
      if (singular) {
        const singularMatch = mapExtraByFilter[singular];
        if (Array.isArray(singularMatch) && singularMatch.length) {
          return singularMatch;
        }
      }
    }
    return [];
  };
  var getExtrasForItemType = (itemType, mapExtraByFilter) => {
    const normalizedType = normalize(itemType);
    if (!normalizedType) return [];
    const extras = /* @__PURE__ */ new Set();
    const direct = mapExtraByFilter[normalizedType];
    if (Array.isArray(direct)) {
      direct.forEach((value) => extras.add(value));
    }
    const relatedFilterKeys = ITEM_TYPE_TO_FILTER_KEYS[normalizedType] ?? [];
    for (const filterKey of relatedFilterKeys) {
      const values = mapExtraByFilter[filterKey];
      if (Array.isArray(values)) {
        values.forEach((value) => extras.add(value));
      }
    }
    return Array.from(extras);
  };
  function filterLabelToItemTypes(filter) {
    const key2 = normalize(filter);
    if (!key2 || key2 === "all") return [];
    const mapped = FILTER_LABEL_TO_ITEM_TYPES[key2];
    if (mapped) return mapped;
    const singular = key2.endsWith("s") ? key2.slice(0, -1) : key2;
    if (!singular) return [];
    const itemType = singular.charAt(0).toUpperCase() + singular.slice(1);
    return itemType ? [itemType] : [];
  }
  function inventoryItemMatchesSearchQuery(item, normalizedQuery) {
    if (!normalizedQuery) return true;
    const visited = /* @__PURE__ */ new Set();
    const matchesValue = (value) => {
      if (value == null) return false;
      if (typeof value === "string") {
        return normalize(value).includes(normalizedQuery);
      }
      if (typeof value === "number" || typeof value === "boolean") {
        return normalize(String(value)).includes(normalizedQuery);
      }
      if (Array.isArray(value)) {
        for (const entry of value) {
          if (matchesValue(entry)) {
            return true;
          }
        }
        return false;
      }
      if (typeof value === "object") {
        if (visited.has(value)) {
          return false;
        }
        visited.add(value);
        for (const [key2, entry] of Object.entries(value)) {
          if (key2 === "itemType") {
            continue;
          }
          if (key2 === "abilities") {
            if (Array.isArray(entry)) {
              for (const abilityId of entry) {
                const abilityName = getPetAbilityDisplayName(abilityId);
                if (abilityName && matchesValue(abilityName)) {
                  return true;
                }
              }
            }
            continue;
          }
          if (matchesValue(entry)) {
            return true;
          }
        }
      }
      return false;
    };
    const abilityNames = Array.isArray(item?.abilities) ? item.abilities.map((abilityId) => getPetAbilityDisplayName(abilityId)).filter((name) => typeof name === "string" && !!name) : [];
    const candidates = [
      getInventoryItemName(item),
      typeof item?.species === "string" ? item.species : null,
      typeof item?.seedSpecies === "string" ? item.seedSpecies : null,
      typeof item?.plantSpecies === "string" ? item.plantSpecies : null,
      typeof item?.petSpecies === "string" ? item.petSpecies : null,
      typeof item?.eggId === "string" ? item.eggId : null,
      typeof item?.decorId === "string" ? item.decorId : null,
      typeof item?.toolId === "string" ? item.toolId : null,
      typeof item?.id === "string" ? item.id : null,
      ...abilityNames
    ];
    for (const candidate of candidates) {
      if (matchesValue(candidate)) {
        return true;
      }
    }
    return matchesValue(item);
  }
  function attachItemValues(items) {
    const snapshot = getInventoryValueSnapshot();
    const playersInRoom = snapshot?.plants?.playersInRoom ?? null;
    for (const item of items) {
      if (!item || typeof item !== "object") continue;
      const value = computeInventoryItemValue(item, { playersInRoom });
      item.value = value ?? null;
    }
  }
  function filterInventoryItems(items, filters, searchQuery) {
    const normalizedFilters = filters.map((f) => normalize(f)).filter(Boolean);
    const itemTypes = /* @__PURE__ */ new Set();
    let recognized = false;
    for (const filter of normalizedFilters) {
      const mappedTypes = filterLabelToItemTypes(filter);
      if (mappedTypes.length) {
        recognized = true;
        for (const type of mappedTypes) {
          if (type) itemTypes.add(type);
        }
      }
    }
    const keepAll = !recognized;
    const filteredByType = keepAll ? items.slice() : items.filter((item) => {
      const type = typeof item?.itemType === "string" ? item.itemType.trim() : "";
      return type ? itemTypes.has(type) : false;
    });
    const normalizedSearch = normalize(searchQuery);
    const filteredItems = normalizedSearch ? filteredByType.filter((item) => inventoryItemMatchesSearchQuery(item, normalizedSearch)) : filteredByType;
    attachItemValues(filteredItems);
    const detectedItemTypes = /* @__PURE__ */ new Set();
    for (const item of filteredItems) {
      const type = typeof item?.itemType === "string" ? item.itemType.trim() : "";
      if (type) {
        detectedItemTypes.add(type);
      }
    }
    const contextKey = createFilterContextKey(filters, normalizedSearch);
    setCachedItemTypesForKey(contextKey, detectedItemTypes);
    return { filteredItems, keepAll, itemTypes, detectedItemTypes };
  }
  function getInventoryItemsContainer(grid) {
    return grid.querySelector(INVENTORY_ITEMS_CONTAINER_SELECTOR) || document.querySelector(INVENTORY_ITEMS_CONTAINER_SELECTOR);
  }
  var getInventoryCardElement = (element) => {
    for (const selector of INVENTORY_ITEM_CARD_SELECTORS) {
      if (element.matches(selector)) {
        return element;
      }
    }
    return element.querySelector(INVENTORY_ITEM_CARD_SELECTOR);
  };
  var clearInventoryNoiseText = (container) => {
    if (!(container instanceof HTMLElement)) return;
    const nodes = Array.from(container.querySelectorAll(INVENTORY_NOISE_SELECTOR));
    for (const node of nodes) {
      const walker = document.createTreeWalker(node, NodeFilter.SHOW_TEXT);
      let textNode = walker.nextNode();
      while (textNode) {
        if (textNode.textContent) {
          textNode.textContent = "";
        }
        textNode = walker.nextNode();
      }
    }
  };
  var findAncestorWithDescendant = (start2, selector) => {
    let current = start2;
    while (current) {
      if (current.querySelector(selector)) return current;
      current = current.parentElement;
    }
    return null;
  };
  var alignInventoryStrengthText = (card2) => {
    const strengthWrap = card2.querySelector(INVENTORY_STRENGTH_WRAPPER_SELECTOR);
    if (!strengthWrap) return;
    const baseTransformKey = "tmStrengthBaseTransform";
    const existingBase = strengthWrap.dataset[baseTransformKey];
    if (existingBase == null) {
      strengthWrap.dataset[baseTransformKey] = strengthWrap.style.transform ?? "";
    }
    const baseTransform = strengthWrap.dataset[baseTransformKey] ?? "";
    strengthWrap.style.transform = baseTransform;
    const textEl = strengthWrap.querySelector(INVENTORY_STRENGTH_TEXT_SELECTOR);
    if (!textEl) return;
    const datasetIsMax = strengthWrap.dataset[TM_STRENGTH_IS_MAX_DATASET_KEY];
    const shouldAlign = datasetIsMax === "0" || datasetIsMax === "1" || datasetIsMax == null && !!textEl.textContent && textEl.textContent.includes("/");
    if (!shouldAlign) {
      if (strengthWrap.style.pointerEvents) {
        strengthWrap.style.pointerEvents = "";
      }
      return;
    }
    const container = findAncestorWithDescendant(strengthWrap, INVENTORY_FAVORITE_BUTTON_SELECTOR) ?? findAncestorWithDescendant(card2, INVENTORY_FAVORITE_BUTTON_SELECTOR);
    if (!container) return;
    const favoriteButton = container.querySelector(INVENTORY_FAVORITE_BUTTON_SELECTOR);
    if (!favoriteButton) return;
    const anchor = favoriteButton.querySelector("svg") ?? favoriteButton.querySelector(".chakra-icon") ?? favoriteButton;
    const containerRect = container.getBoundingClientRect();
    if (!containerRect.width) return;
    const GAP_PX_NON_MAX = 7;
    const GAP_PX_MAX = 5;
    let deltaX = null;
    if (datasetIsMax === "1") {
      const badge = textEl.querySelector(`.${TM_STRENGTH_BADGE_CLASS}`);
      const badgeRect = badge?.getBoundingClientRect();
      if (badgeRect && badgeRect.width) {
        deltaX = containerRect.left + GAP_PX_MAX - badgeRect.left;
      }
    }
    if (deltaX == null) {
      const anchorRect = anchor.getBoundingClientRect();
      const textRect = textEl.getBoundingClientRect();
      if (!anchorRect.width || !textRect.width) return;
      deltaX = anchorRect.left - textRect.right - GAP_PX_NON_MAX;
    }
    if (!Number.isFinite(deltaX)) return;
    strengthWrap.style.transform = baseTransform ? `${baseTransform} translateX(${Math.round(deltaX)}px)` : `translateX(${Math.round(deltaX)}px)`;
    textEl.style.margin = "0";
    if (strengthWrap.style.pointerEvents) {
      strengthWrap.style.pointerEvents = "";
    }
  };
  function getInventoryDomEntries(container) {
    clearInventoryNoiseText(container);
    const entries = [];
    const children = Array.from(container.children);
    for (const child of children) {
      if (!(child instanceof HTMLElement)) continue;
      const card2 = getInventoryCardElement(child);
      if (card2) {
        alignInventoryStrengthText(card2);
        entries.push({ wrapper: child, card: card2 });
      }
    }
    return entries;
  }
  var INVENTORY_COMPACT_VALUE_UNITS = [
    { threshold: 1e12, suffix: "T" },
    { threshold: 1e9, suffix: "B" },
    { threshold: 1e6, suffix: "M" },
    { threshold: 1e3, suffix: "K" }
  ];
  var INVENTORY_FULL_VALUE_FORMATTER = typeof Intl !== "undefined" && typeof Intl.NumberFormat === "function" ? new Intl.NumberFormat(void 0, { maximumFractionDigits: 2, minimumFractionDigits: 0 }) : null;
  var formatInventoryItemCompactValue = (value) => {
    const abs = Math.abs(value);
    for (const { threshold, suffix } of INVENTORY_COMPACT_VALUE_UNITS) {
      if (abs >= threshold) {
        const scaled = value / threshold;
        const formatted = scaled.toFixed(1).replace(/\.0$/, "");
        return `${formatted}${suffix}`;
      }
    }
    return INVENTORY_FULL_VALUE_FORMATTER ? INVENTORY_FULL_VALUE_FORMATTER.format(value) : String(value);
  };
  var formatInventoryItemFullValue = (value) => INVENTORY_FULL_VALUE_FORMATTER ? INVENTORY_FULL_VALUE_FORMATTER.format(value) : String(value);
  var getInventoryItemValue = (item) => {
    if (!item || typeof item !== "object") return null;
    const raw = item.value;
    if (typeof raw === "number" && Number.isFinite(raw)) return raw;
    if (typeof raw === "string" && raw.trim()) {
      const parsed = Number(raw);
      return Number.isFinite(parsed) ? parsed : null;
    }
    return null;
  };
  var parseStrengthValue = (value) => {
    const match = value.match(/(\d+)/);
    if (!match) return null;
    const parsed = Number(match[1]);
    return Number.isFinite(parsed) ? parsed : null;
  };
  var TM_STRENGTH_LABEL_CLASS = "tm-strength__label";
  var TM_STRENGTH_CURRENT_CLASS = "tm-strength__current";
  var TM_STRENGTH_MAX_CLASS = "tm-strength__max";
  var TM_STRENGTH_BADGE_CLASS = "tm-strength__badge";
  var TM_STRENGTH_IS_MAX_DATASET_KEY = "tmStrengthIsMax";
  var PET_HUTCH_HEADER_TEXT = "Pets in Hutch";
  var PET_INVENTORY_HEADER_TEXT = "Pets in Inventory";
  var PET_NAME_SELECTOR = ".McFlex.css-1lpag07 .chakra-text";
  var PET_HUTCH_ROOT_SELECTOR = ".McGrid.css-3c49ba";
  var PET_HUTCH_LIST_SELECTOR = ".McGrid.css-1nv2ym8 .McFlex.css-1tgchvv";
  var PET_HUTCH_INVENTORY_LIST_SELECTOR = ".McGrid.css-1nv2ym8 .McFlex.css-gui45t";
  var PET_HUTCH_VISIBILITY_STYLE = "visibility";
  var RAINBOW_BADGE_TEXT_GRADIENT = "linear-gradient(90deg, #ff6b6b 0%, #ffd86f 25%, #6bff8f 50%, #6bc7ff 75%, #b86bff 100%)";
  var getPetMutationTone = (item) => {
    const mutations = getInventoryItemMutations(item);
    if (!mutations.length) return "normal";
    const seen = new Set(mutations.map((mutation) => mutation.toLowerCase()));
    if (seen.has("rainbow")) return "rainbow";
    if (seen.has("gold") || seen.has("golden")) return "gold";
    return "normal";
  };
  var applyStrengthBadgeTone = (badge, tone) => {
    if (badge.dataset.tmStrengthTone === tone) return;
    badge.dataset.tmStrengthTone = tone;
    badge.style.backgroundImage = "";
    badge.style.backgroundColor = "";
    badge.style.color = "";
    badge.style.backgroundClip = "";
    badge.style.webkitBackgroundClip = "";
    badge.style.backgroundOrigin = "";
    badge.style.webkitTextFillColor = "";
    badge.style.fontWeight = "700";
    switch (tone) {
      case "rainbow":
        badge.style.color = "transparent";
        badge.style.backgroundImage = `linear-gradient(rgba(255, 255, 255, 0.25), rgba(255, 255, 255, 0.25)), ${RAINBOW_BADGE_TEXT_GRADIENT}`;
        badge.style.backgroundClip = "padding-box, text";
        badge.style.webkitBackgroundClip = "padding-box, text";
        badge.style.backgroundOrigin = "padding-box, text";
        badge.style.webkitTextFillColor = "transparent";
        break;
      case "gold":
        badge.style.color = "var(--chakra-colors-Yellow-Magic, #F3D32B)";
        badge.style.backgroundColor = "rgba(243, 211, 43, 0.25)";
        break;
      default:
        badge.style.color = "#8fd3ff";
        badge.style.backgroundColor = "rgba(79, 166, 255, 0.28)";
        break;
    }
  };
  var ensureStrengthBadge = (textEl, beforeEl) => {
    let badge = textEl.querySelector(`.${TM_STRENGTH_BADGE_CLASS}`);
    if (!badge) {
      badge = document.createElement("span");
      badge.className = TM_STRENGTH_BADGE_CLASS;
      badge.textContent = "MAX";
      Object.assign(badge.style, {
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        padding: "0 3px",
        marginRight: "0",
        borderRadius: "3px",
        fontSize: "0.5rem",
        lineHeight: "1",
        fontWeight: "700",
        color: "var(--chakra-colors-Yellow-Magic, #F3D32B)",
        backgroundColor: "rgba(243, 211, 43, 0.25)"
      });
    }
    if (badge.parentElement !== textEl) {
      textEl.insertBefore(badge, beforeEl);
    }
    return badge;
  };
  var ensureStrengthTextParts = (textEl) => {
    let label2 = textEl.querySelector(`.${TM_STRENGTH_LABEL_CLASS}`);
    let current = textEl.querySelector(`.${TM_STRENGTH_CURRENT_CLASS}`);
    let max = textEl.querySelector(`.${TM_STRENGTH_MAX_CLASS}`);
    if (!label2 || !current || !max) {
      textEl.textContent = "";
      label2 = document.createElement("span");
      label2.className = TM_STRENGTH_LABEL_CLASS;
      current = document.createElement("span");
      current.className = TM_STRENGTH_CURRENT_CLASS;
      max = document.createElement("span");
      max.className = TM_STRENGTH_MAX_CLASS;
      textEl.append(label2, current, max);
    }
    return { label: label2, current, max };
  };
  function updateInventoryCardStrengthText(card2, item) {
    const strengthWrap = card2.querySelector(INVENTORY_STRENGTH_WRAPPER_SELECTOR);
    if (!strengthWrap) return;
    const textEl = strengthWrap.querySelector(INVENTORY_STRENGTH_TEXT_SELECTOR);
    if (!textEl) return;
    const info = getPetStrengthInfo(item);
    if (!info) return;
    const { strength, maxStrength } = info;
    if (!Number.isFinite(maxStrength) || maxStrength <= 0) return;
    const existingText = textEl.textContent ?? "";
    const currentStrength = parseStrengthValue(existingText) ?? (Number.isFinite(strength) ? Math.round(strength) : null);
    if (currentStrength == null) return;
    const roundedMax = Math.round(maxStrength);
    if (!Number.isFinite(roundedMax) || roundedMax <= 0) return;
    const safeCurrent = clampNumber2(currentStrength, 0, roundedMax);
    const isMax = safeCurrent >= roundedMax;
    const mutationTone = getPetMutationTone(item);
    const parts = ensureStrengthTextParts(textEl);
    if (parts.label.textContent !== "STR ") {
      parts.label.textContent = "STR ";
    }
    const nextCurrent = String(safeCurrent);
    if (parts.current.textContent !== nextCurrent) {
      parts.current.textContent = nextCurrent;
    }
    parts.current.style.setProperty("color", "#ffffff", "important");
    parts.current.style.setProperty("font-weight", "700", "important");
    if (isMax) {
      const badge = ensureStrengthBadge(textEl, parts.label);
      applyStrengthBadgeTone(badge, mutationTone);
      if (parts.max.textContent) {
        parts.max.textContent = "";
      }
      parts.max.style.display = "none";
      parts.max.style.visibility = "";
    } else {
      textEl.querySelector(`.${TM_STRENGTH_BADGE_CLASS}`)?.remove();
      const nextMax = `/${roundedMax}`;
      if (parts.max.textContent !== nextMax) {
        parts.max.textContent = nextMax;
      }
      parts.max.style.display = "";
      parts.max.style.visibility = "";
      parts.max.style.setProperty("font-weight", "700", "important");
    }
    parts.max.style.setProperty("color", "#ffffff", "important");
    strengthWrap.dataset[TM_STRENGTH_IS_MAX_DATASET_KEY] = isMax ? "1" : "0";
  }
  var getValueSummaryElement = (wrap) => {
    if (!wrap) return null;
    const summary = wrap.__valueSummary ?? null;
    return summary ?? wrap.querySelector(".tm-value-toggle__summary");
  };
  var ensureValueSummaryContent = (summary) => {
    if (!summary.style.gap) {
      summary.style.gap = "0.25rem";
    }
    if (VALUE_SUMMARY_ICON_BACKGROUND) {
      let iconEl = summary.querySelector(`.${VALUE_SUMMARY_ICON_CLASS}`);
      if (iconEl && iconEl.tagName !== "SPAN") {
        iconEl.remove();
        iconEl = null;
      }
      if (!iconEl) {
        iconEl = document.createElement("span");
        iconEl.className = VALUE_SUMMARY_ICON_CLASS;
        iconEl.setAttribute("aria-hidden", "true");
        iconEl.style.width = "1.2rem";
        iconEl.style.height = "1.2rem";
        iconEl.style.flexShrink = "0";
        iconEl.style.display = "inline-block";
        iconEl.style.backgroundSize = "contain";
        iconEl.style.backgroundRepeat = "no-repeat";
        iconEl.style.backgroundPosition = "center";
        iconEl.style.pointerEvents = "none";
        iconEl.style.userSelect = "none";
        summary.insertBefore(iconEl, summary.firstChild);
      }
      if (iconEl && iconEl.style.backgroundImage !== VALUE_SUMMARY_ICON_BACKGROUND) {
        iconEl.style.backgroundImage = VALUE_SUMMARY_ICON_BACKGROUND;
      }
    } else {
      summary.querySelector(`.${VALUE_SUMMARY_ICON_CLASS}`)?.remove();
    }
    let textEl = summary.querySelector(`.${VALUE_SUMMARY_TEXT_CLASS}`);
    if (!textEl) {
      textEl = document.createElement("span");
      textEl.className = VALUE_SUMMARY_TEXT_CLASS;
      textEl.style.fontWeight = "700";
      textEl.style.color = "inherit";
      summary.appendChild(textEl);
    }
    return textEl;
  };
  var setValueSummaryText = (summary, text, title) => {
    if (!summary) return;
    const textEl = ensureValueSummaryContent(summary);
    textEl.textContent = text;
    if (title) {
      summary.title = title;
    } else {
      summary.removeAttribute("title");
    }
  };
  async function updateFilteredInventoryValueSummary(wrap, filters, searchQuery) {
    if (!wrap) return;
    const summary = getValueSummaryElement(wrap);
    if (!summary) return;
    const token = Symbol("value-summary");
    wrap.__valueSummaryToken = token;
    setValueSummaryText(summary, FILTERED_VALUE_LOADING);
    try {
      const inventory = await Atoms.inventory.myInventory.get();
      if (wrap.__valueSummaryToken !== token) {
        return;
      }
      if (!inventory || typeof inventory !== "object") {
        setValueSummaryText(summary, FILTERED_VALUE_UNKNOWN);
        return;
      }
      const items = Array.isArray(inventory.items) ? inventory.items : [];
      const { filteredItems } = filterInventoryItems(items, filters, searchQuery);
      if (!filteredItems.length) {
        setValueSummaryText(summary, "0", "0");
        return;
      }
      let totalValue = 0;
      let hasValue = false;
      for (const item of filteredItems) {
        const value = getInventoryItemValue(item);
        if (typeof value === "number" && Number.isFinite(value)) {
          totalValue += value;
          hasValue = true;
        }
      }
      if (!hasValue) {
        setValueSummaryText(summary, FILTERED_VALUE_UNKNOWN);
        return;
      }
      const compact = formatInventoryItemCompactValue(totalValue);
      const full = formatInventoryItemFullValue(totalValue);
      setValueSummaryText(summary, compact, full);
    } catch (error) {
      console.warn("[InventorySorting] Impossible de calculer la valeur filtr\xE9e", error);
      if (wrap.__valueSummaryToken !== token) {
        return;
      }
      setValueSummaryText(summary, FILTERED_VALUE_UNKNOWN);
    }
  }
  function updateInventoryCardValue(card2, rawValue) {
    const container = card2.querySelector(INVENTORY_VALUE_CONTAINER_SELECTOR);
    const existing = card2.dataset[INVENTORY_VALUE_DATASET_KEY];
    if (!container) {
      if (existing != null) {
        delete card2.dataset[INVENTORY_VALUE_DATASET_KEY];
      }
      return;
    }
    const currentEl = container.querySelector(`.${INVENTORY_VALUE_ELEMENT_CLASS}`);
    if (!getShouldDisplayInventoryValues()) {
      if (currentEl?.parentElement) {
        currentEl.parentElement.removeChild(currentEl);
      }
      if (existing != null) {
        delete card2.dataset[INVENTORY_VALUE_DATASET_KEY];
      }
      return;
    }
    if (typeof rawValue !== "number" || !Number.isFinite(rawValue)) {
      if (currentEl?.parentElement) {
        currentEl.parentElement.removeChild(currentEl);
      }
      if (existing != null) {
        delete card2.dataset[INVENTORY_VALUE_DATASET_KEY];
      }
      return;
    }
    const compactValue = formatInventoryItemCompactValue(rawValue);
    const fullValue = formatInventoryItemFullValue(rawValue);
    let target = currentEl;
    if (!target) {
      target = document.createElement("div");
      target.className = INVENTORY_VALUE_ELEMENT_CLASS;
    }
    Object.assign(target.style, {
      fontSynthesis: "none",
      WebkitFontSmoothing: "antialiased",
      WebkitTextSizeAdjust: "100%",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "flex-start",
      gap: "0.15rem",
      marginTop: "3px",
      fontFamily: 'var(--chakra-fonts-body, "GreyCliff CF", sans-serif)',
      fontWeight: "700",
      fontSize: "0.65rem",
      lineHeight: "1",
      textTransform: "none",
      color: "var(--chakra-colors-Yellow-Magic, #F3D32B)"
    });
    let textEl = target.querySelector(`.${INVENTORY_VALUE_TEXT_CLASS}`);
    if (!textEl) {
      target.textContent = "";
      textEl = document.createElement("span");
      textEl.className = INVENTORY_VALUE_TEXT_CLASS;
      textEl.style.display = "inline-flex";
      textEl.style.alignItems = "center";
      textEl.style.color = "inherit";
      target.appendChild(textEl);
    }
    textEl.textContent = compactValue;
    target.title = fullValue;
    card2.dataset[INVENTORY_VALUE_DATASET_KEY] = String(rawValue);
    if (target.parentElement !== container || target !== container.lastElementChild) {
      container.appendChild(target);
    }
  }
  function assignBaseIndexesToEntries(entries) {
    entries.forEach((entry, index) => {
      entry.wrapper.dataset[INVENTORY_BASE_INDEX_DATASET_KEY] = String(index);
      entry.card.dataset[INVENTORY_BASE_INDEX_DATASET_KEY] = String(index);
    });
  }
  function readBaseIndex(entry) {
    const raw = entry.wrapper.dataset[INVENTORY_BASE_INDEX_DATASET_KEY] ?? entry.card.dataset[INVENTORY_BASE_INDEX_DATASET_KEY];
    if (raw == null) return null;
    const value = Number(raw);
    return Number.isFinite(value) ? value : null;
  }
  var stringOrEmpty = (value) => typeof value === "string" ? value.trim() : "";
  var pickNestedString = (source, path) => {
    let current = source;
    for (const key2 of path) {
      if (!current || typeof current !== "object") {
        return "";
      }
      current = current[key2];
    }
    return stringOrEmpty(current);
  };
  var pickFirstNestedString = (source, paths) => {
    for (const path of paths) {
      const value = pickNestedString(source, path);
      if (value) return value;
    }
    return "";
  };
  var plantCatalogEntry = (identifier) => plantCatalog[identifier];
  var petCatalogEntry = (identifier) => petCatalog[identifier];
  var eggCatalogEntry = (identifier) => eggCatalog[identifier];
  var toolCatalogEntry = (identifier) => toolCatalog[identifier];
  var decorCatalogEntry = (identifier) => decorCatalog[identifier];
  var SEED_NAME_PATHS = [
    ["seed", "name"],
    ["plant", "name"],
    ["crop", "name"]
  ];
  var SEED_RARITY_PATHS = [
    ["seed", "rarity"],
    ["crop", "rarity"],
    ["plant", "rarity"]
  ];
  var CROP_NAME_PATHS = [
    ["crop", "name"],
    ["plant", "name"],
    ["seed", "name"]
  ];
  var CROP_RARITY_PATHS = [
    ["crop", "rarity"],
    ["plant", "rarity"],
    ["seed", "rarity"]
  ];
  var PLANT_NAME_PATHS = [
    ["plant", "name"],
    ["crop", "name"],
    ["seed", "name"]
  ];
  var PLANT_RARITY_PATHS = [
    ["plant", "rarity"],
    ["crop", "rarity"],
    ["seed", "rarity"]
  ];
  var createPlantLookup = (identifierField, namePaths, rarityPaths) => ({
    identifierField,
    getEntry: plantCatalogEntry,
    getNamePaths: namePaths,
    getRarityPaths: rarityPaths
  });
  var CATALOG_LOOKUPS = {
    Seed: createPlantLookup("species", SEED_NAME_PATHS, SEED_RARITY_PATHS),
    Crop: createPlantLookup("species", CROP_NAME_PATHS, CROP_RARITY_PATHS),
    Produce: createPlantLookup("species", CROP_NAME_PATHS, CROP_RARITY_PATHS),
    Plant: createPlantLookup("species", PLANT_NAME_PATHS, PLANT_RARITY_PATHS),
    Pet: {
      identifierField: "petSpecies",
      getEntry: petCatalogEntry,
      getNamePaths: [["name"]],
      getRarityPaths: [["rarity"]]
    },
    Egg: {
      identifierField: "eggId",
      getEntry: eggCatalogEntry,
      getNamePaths: [["name"]],
      getRarityPaths: [["rarity"]]
    },
    Tool: {
      identifierField: "toolId",
      getEntry: toolCatalogEntry,
      getNamePaths: [["name"]],
      getRarityPaths: [["rarity"]]
    },
    Decor: {
      identifierField: "decorId",
      getEntry: decorCatalogEntry,
      getNamePaths: [["name"]],
      getRarityPaths: [["rarity"]]
    }
  };
  var getCatalogLookup = (type) => CATALOG_LOOKUPS[type] ?? null;
  var getInventoryItemName = (item) => {
    if (!item || typeof item !== "object") return "";
    const type = stringOrEmpty(item.itemType);
    const lookup = getCatalogLookup(type);
    if (lookup) {
      const identifier = readNestedStringField(item, lookup.identifierField) ?? "";
      if (identifier) {
        const entry = lookup.getEntry(identifier);
        const catalogName = lookup.getNamePaths ? pickFirstNestedString(entry, lookup.getNamePaths) : "";
        if (catalogName) {
          return catalogName;
        }
        return identifier;
      }
    }
    const fallbackName = stringOrEmpty(item.name);
    if (fallbackName) return fallbackName;
    const fallbackId = stringOrEmpty(item.id);
    if (fallbackId) return fallbackId;
    return type;
  };
  var QUANTITY_ONE_TYPES = /* @__PURE__ */ new Set(["Produce", "Crop", "Plant", "Pet"]);
  var getInventoryItemQuantity = (item) => {
    if (!item || typeof item !== "object") return 0;
    const rawType = typeof item.itemType === "string" ? item.itemType : "";
    const type = rawType.trim();
    if (QUANTITY_ONE_TYPES.has(type)) {
      return 1;
    }
    const rawQuantity = item.quantity;
    const quantity = Number(rawQuantity);
    if (Number.isFinite(quantity) && quantity >= 0) {
      return quantity;
    }
    return 0;
  };
  var getInventoryItemRarity = (item) => {
    if (!item || typeof item !== "object") return "";
    const type = stringOrEmpty(item.itemType);
    const lookup = getCatalogLookup(type);
    if (!lookup || !lookup.getRarityPaths?.length) {
      return "";
    }
    const identifier = readNestedStringField(item, lookup.identifierField) ?? "";
    if (!identifier) return "";
    const entry = lookup.getEntry(identifier);
    return pickFirstNestedString(entry, lookup.getRarityPaths);
  };
  var readNestedValue = (item, field, parser) => {
    if (!item || typeof item !== "object") return null;
    const sources = [item, item.item, item.data];
    for (const source of sources) {
      if (!source || typeof source !== "object") continue;
      const raw = source[field];
      const parsed = parser(raw);
      if (parsed != null) return parsed;
    }
    return null;
  };
  var readNestedStringField = (item, field) => readNestedValue(item, field, (value) => {
    if (typeof value !== "string") return null;
    const trimmed = value.trim();
    return trimmed ? trimmed : null;
  });
  var readNestedNumberField = (item, field) => readNestedValue(item, field, (value) => {
    if (typeof value === "number" && Number.isFinite(value)) return value;
    if (typeof value === "string" && value.trim()) {
      const parsed = Number(value);
      return Number.isFinite(parsed) ? parsed : null;
    }
    return null;
  });
  var findSectionContainerByHeaderText = (headerText) => {
    if (typeof document === "undefined") return null;
    const headers = Array.from(document.querySelectorAll("p.chakra-text"));
    const header = headers.find((el2) => (el2.textContent ?? "").trim() === headerText) ?? null;
    if (!header) return null;
    let current = header;
    while (current && current !== document.body) {
      const next = current.nextElementSibling;
      if (next && next.querySelector(INVENTORY_ITEM_CARD_SELECTOR)) {
        return next;
      }
      current = current.parentElement;
    }
    return null;
  };
  var getPetCardName = (card2) => normalize(card2.querySelector(PET_NAME_SELECTOR)?.textContent ?? "");
  var getPetNameCandidates = (item) => {
    const candidates = /* @__PURE__ */ new Set();
    const name = readNestedStringField(item, "name");
    if (name) candidates.add(normalize(name));
    const species = readNestedStringField(item, "petSpecies") ?? readNestedStringField(item, "species");
    if (species) candidates.add(normalize(species));
    return Array.from(candidates);
  };
  var isPetItem = (item) => {
    const rawType = typeof item?.itemType === "string" ? item.itemType : "";
    if (rawType.trim().toLowerCase() === "pet") return true;
    const species = readNestedStringField(item, "petSpecies") ?? readNestedStringField(item, "species");
    return !!species;
  };
  var applyPetItemsToContainer = (container, items) => {
    if (!container) return;
    const entries = getInventoryDomEntries(container);
    if (!entries.length) return;
    const petItems = (Array.isArray(items) ? items : []).filter(isPetItem);
    if (!petItems.length) return;
    console.log(
      "[InventorySorting] Hutch apply",
      { container: container.className, entries: entries.length, items: petItems.length }
    );
    const used = /* @__PURE__ */ new Set();
    for (const entry of entries) {
      const cardName = getPetCardName(entry.card);
      let matchIndex = -1;
      if (cardName) {
        for (let i = 0; i < petItems.length; i += 1) {
          if (used.has(i)) continue;
          const candidates = getPetNameCandidates(petItems[i]);
          if (candidates.includes(cardName)) {
            matchIndex = i;
            break;
          }
        }
      }
      if (matchIndex < 0) {
        for (let i = 0; i < petItems.length; i += 1) {
          if (!used.has(i)) {
            matchIndex = i;
            break;
          }
        }
      }
      if (matchIndex < 0) continue;
      used.add(matchIndex);
      updateInventoryCardStrengthText(entry.card, petItems[matchIndex]);
      alignInventoryStrengthText(entry.card);
    }
  };
  var setPetHutchContainersHidden = (containers, hidden) => {
    for (const container of containers) {
      if (!container) continue;
      if (hidden) {
        container.style.setProperty(PET_HUTCH_VISIBILITY_STYLE, "hidden");
      } else {
        container.style.removeProperty(PET_HUTCH_VISIBILITY_STYLE);
      }
    }
  };
  var updatePetHutchSections = async (options = {}) => {
    const hideDuringUpdate = options.hideDuringUpdate === true;
    const root = document.querySelector(PET_HUTCH_ROOT_SELECTOR) ?? document.body;
    const hutchContainer = root.querySelector(PET_HUTCH_LIST_SELECTOR) ?? findSectionContainerByHeaderText(PET_HUTCH_HEADER_TEXT);
    const inventoryContainer = root.querySelector(PET_HUTCH_INVENTORY_LIST_SELECTOR) ?? findSectionContainerByHeaderText(PET_INVENTORY_HEADER_TEXT);
    const containers = [hutchContainer, inventoryContainer];
    if (!hutchContainer && !inventoryContainer) return false;
    if (hideDuringUpdate) {
      setPetHutchContainersHidden(containers, true);
    }
    try {
      console.log("[InventorySorting] Hutch detect", {
        root: root.className,
        hutchContainer: hutchContainer?.className ?? null,
        inventoryContainer: inventoryContainer?.className ?? null
      });
      const [hutchItemsRaw, inventoryRaw] = await Promise.all([
        myPetHutchPetItems.get().catch(() => []),
        Atoms.inventory.myInventory.get().catch(() => null)
      ]);
      const hutchItems = Array.isArray(hutchItemsRaw) ? hutchItemsRaw : [];
      const inventoryItems = Array.isArray(inventoryRaw?.items) ? inventoryRaw.items : Array.isArray(inventoryRaw) ? inventoryRaw : [];
      console.log("[InventorySorting] Hutch data", {
        hutchItems: hutchItems.length,
        inventoryItems: inventoryItems.length
      });
      applyPetItemsToContainer(hutchContainer, hutchItems);
      applyPetItemsToContainer(inventoryContainer, inventoryItems);
      return true;
    } catch (error) {
      console.warn("[InventorySorting] Impossible de mettre a jour les pets du hutch", error);
      return false;
    } finally {
      if (hideDuringUpdate) {
        setPetHutchContainersHidden(containers, false);
      }
    }
  };
  var PET_STATS_BY_SPECIES = (() => {
    const map2 = /* @__PURE__ */ new Map();
    const register = (key2, maxScale, hoursToMature) => {
      if (typeof key2 !== "string") return;
      const normalized = normalizeSpeciesKey3(key2);
      if (!normalized || map2.has(normalized)) return;
      map2.set(normalized, { maxScale, hoursToMature });
    };
    for (const [species, entry] of Object.entries(petCatalog)) {
      const maxScale = Number(entry?.maxScale);
      const hoursToMature = Number(entry?.hoursToMature);
      if (!Number.isFinite(maxScale) || maxScale <= 1) continue;
      if (!Number.isFinite(hoursToMature) || hoursToMature <= 0) continue;
      register(species, maxScale, hoursToMature);
      register(entry?.name, maxScale, hoursToMature);
    }
    return map2;
  })();
  var lookupPetStats = (species) => {
    if (typeof species !== "string") return null;
    const normalized = normalizeSpeciesKey3(species);
    if (!normalized) return null;
    return PET_STATS_BY_SPECIES.get(normalized) ?? null;
  };
  var getPetStrengthInfo = (item) => {
    if (!item || typeof item !== "object") return null;
    const rawType = typeof item.itemType === "string" ? item.itemType : "";
    const type = rawType.trim();
    if (type !== "Pet") return null;
    const rawXp = readNestedNumberField(item, "xp");
    const xp = typeof rawXp === "number" && Number.isFinite(rawXp) ? rawXp : 0;
    const rawTargetScale = readNestedNumberField(item, "targetScale");
    const targetScale = typeof rawTargetScale === "number" && Number.isFinite(rawTargetScale) ? rawTargetScale : 1;
    const speciesCandidates = /* @__PURE__ */ new Set();
    const maybePetSpecies = readNestedStringField(item, "petSpecies");
    if (maybePetSpecies) speciesCandidates.add(maybePetSpecies);
    const maybeSpecies = readNestedStringField(item, "species");
    if (maybeSpecies) speciesCandidates.add(maybeSpecies);
    const maybeName = readNestedStringField(item, "name");
    if (maybeName) speciesCandidates.add(maybeName);
    let stats = null;
    for (const candidate of speciesCandidates) {
      stats = lookupPetStats(candidate);
      if (stats) break;
    }
    if (!stats) return null;
    const { maxScale, hoursToMature } = stats;
    if (!Number.isFinite(maxScale) || maxScale <= 1) return null;
    if (!Number.isFinite(hoursToMature) || hoursToMature <= 0) return null;
    const safeXp = Math.max(0, xp);
    const xpDenominator = hoursToMature * 3600;
    const xpComponent = xpDenominator > 0 ? Math.min(Math.floor(safeXp / xpDenominator * 30), 30) : 0;
    const minScale = 1;
    const clampedScale = clampNumber2(targetScale, minScale, maxScale);
    const scaleDenominator = maxScale - minScale;
    const scaleComponent = scaleDenominator > 0 ? Math.floor((clampedScale - minScale) / scaleDenominator * 20 + 80) : 80;
    const maxStrength = clampNumber2(scaleComponent, 0, 100);
    const combined = xpComponent + maxStrength - 30;
    const strength = clampNumber2(combined, 0, maxStrength);
    return { strength, maxStrength };
  };
  var getPetStrength3 = (item) => {
    const info = getPetStrengthInfo(item);
    return info ? info.strength : null;
  };
  var compareByNameThenTypeThenId = (a, b) => {
    const nameA = getInventoryItemName(a);
    const nameB = getInventoryItemName(b);
    if (nameA && nameB) {
      const cmp = nameA.localeCompare(nameB, void 0, { sensitivity: "base" });
      if (cmp !== 0) return cmp;
    }
    if (!nameA && nameB) return 1;
    if (nameA && !nameB) return -1;
    const typeA = typeof a?.itemType === "string" ? a.itemType : "";
    const typeB = typeof b?.itemType === "string" ? b.itemType : "";
    const typeCmp = typeA.localeCompare(typeB, void 0, { sensitivity: "base" });
    if (typeCmp !== 0) return typeCmp;
    const idA = typeof a.id === "string" ? a.id : "";
    const idB = typeof b.id === "string" ? b.id : "";
    return idA.localeCompare(idB, void 0, { sensitivity: "base" });
  };
  function sortInventoryItems(items, sortKey, direction) {
    const sorted = items.slice();
    const isDesc = direction === "desc";
    switch (sortKey) {
      case "alpha":
        sorted.sort((a, b) => {
          const cmp = compareByNameThenTypeThenId(a, b);
          return isDesc ? -cmp : cmp;
        });
        break;
      case "qty":
        sorted.sort((a, b) => {
          const qtyA = getInventoryItemQuantity(a);
          const qtyB = getInventoryItemQuantity(b);
          if (qtyA !== qtyB) {
            const cmp = qtyA - qtyB;
            return isDesc ? -cmp : cmp;
          }
          return compareByNameThenTypeThenId(a, b);
        });
        break;
      case "rarity":
        sorted.sort((a, b) => {
          const rarityA = getInventoryItemRarity(a);
          const rarityB = getInventoryItemRarity(b);
          const rankA = getRarityRank(rarityA);
          const rankB = getRarityRank(rarityB);
          if (rankA !== rankB) {
            const cmp = rankA - rankB;
            return isDesc ? -cmp : cmp;
          }
          const cmpRarity = rarityA.localeCompare(rarityB, void 0, { sensitivity: "base" });
          if (cmpRarity !== 0) return cmpRarity;
          return compareByNameThenTypeThenId(a, b);
        });
        break;
      case "value":
        sorted.sort((a, b) => {
          const rawValueA = a?.value;
          const rawValueB = b?.value;
          const hasA = typeof rawValueA === "number" && Number.isFinite(rawValueA);
          const hasB = typeof rawValueB === "number" && Number.isFinite(rawValueB);
          if (hasA && hasB && rawValueA !== rawValueB) {
            const cmp = rawValueA - rawValueB;
            return isDesc ? -cmp : cmp;
          }
          if (hasA && !hasB) return isDesc ? -1 : 1;
          if (!hasA && hasB) return isDesc ? 1 : -1;
          return compareByNameThenTypeThenId(a, b);
        });
        break;
      case "size":
        sorted.sort((a, b) => {
          const sizeA = getInventoryItemSizePercent(a);
          const sizeB = getInventoryItemSizePercent(b);
          const hasA = typeof sizeA === "number" && Number.isFinite(sizeA);
          const hasB = typeof sizeB === "number" && Number.isFinite(sizeB);
          if (hasA && hasB && sizeA !== sizeB) {
            const cmp = sizeA - sizeB;
            return isDesc ? -cmp : cmp;
          }
          if (hasA && !hasB) return isDesc ? -1 : 1;
          if (!hasA && hasB) return isDesc ? 1 : -1;
          return compareByNameThenTypeThenId(a, b);
        });
        break;
      case "mutations":
        sorted.sort((a, b) => {
          const mutationsA = getInventoryItemMutations(a);
          const mutationsB = getInventoryItemMutations(b);
          const countA = mutationsA.length;
          const countB = mutationsB.length;
          if (countA !== countB) {
            const cmp = countA - countB;
            return isDesc ? -cmp : cmp;
          }
          if (countA > 0 && countB > 0) {
            const labelA = mutationsA.slice().sort((x, y) => x.localeCompare(y, void 0, { sensitivity: "base" })).join("\0");
            const labelB = mutationsB.slice().sort((x, y) => x.localeCompare(y, void 0, { sensitivity: "base" })).join("\0");
            const cmp = labelA.localeCompare(labelB, void 0, { sensitivity: "base" });
            if (cmp !== 0) return cmp;
          }
          return compareByNameThenTypeThenId(a, b);
        });
        break;
      case "strength":
        sorted.sort((a, b) => {
          const strengthA = getPetStrength3(a);
          const strengthB = getPetStrength3(b);
          const hasA = typeof strengthA === "number" && Number.isFinite(strengthA);
          const hasB = typeof strengthB === "number" && Number.isFinite(strengthB);
          if (hasA && hasB && strengthA !== strengthB) {
            const cmp = strengthA - strengthB;
            return isDesc ? -cmp : cmp;
          }
          if (hasA && !hasB) return isDesc ? -1 : 1;
          if (!hasA && hasB) return isDesc ? 1 : -1;
          return compareByNameThenTypeThenId(a, b);
        });
        break;
      default:
        break;
    }
    return sorted;
  }
  async function logInventoryForFilters(filters, sortKey, direction, searchQuery) {
    try {
      const inventory = await Atoms.inventory.myInventory.get();
      if (!inventory || typeof inventory !== "object") {
        console.log("[InventorySorting] Inventaire introuvable pour le log des filtres.");
        return;
      }
      const items = Array.isArray(inventory.items) ? inventory.items : [];
      const { filteredItems, keepAll, itemTypes } = filterInventoryItems(items, filters, searchQuery);
      const resolvedDirection = sortKey ? (direction && DIRECTION_ORDER.includes(direction) ? direction : DEFAULT_DIRECTION_BY_SORT_KEY[sortKey]) ?? "asc" : direction && DIRECTION_ORDER.includes(direction) ? direction : "asc";
      const itemsForLog = sortKey ? sortInventoryItems(filteredItems, sortKey, resolvedDirection) : filteredItems.slice();
      const descriptor = keepAll ? "toutes cat\xE9gories" : `types: ${Array.from(itemTypes).join(", ") || "(aucun)"}`;
      const sortDescriptor = sortKey ? `tri: ${sortKey} (${resolvedDirection})` : "tri: (non sp\xE9cifi\xE9)";
      const searchDescriptor = searchQuery ? `recherche: "${searchQuery}"` : "recherche: (vide)";
      console.log(
        `[InventorySorting] myInventory filtr\xE9 (${descriptor}, ${sortDescriptor}, ${searchDescriptor}).`
      );
    } catch (error) {
      console.warn("[InventorySorting] Impossible de r\xE9cup\xE9rer myInventory pour le log", error);
    }
  }
  function createDefaultApplySorting(cfg) {
    const stateByGrid = /* @__PURE__ */ new WeakMap();
    const ensureState = async (grid, filters, entries, searchQuery) => {
      const filtersKey = JSON.stringify({ filters });
      const state3 = stateByGrid.get(grid);
      const hasAllBaseIndexes = entries.every((e) => readBaseIndex(e) != null);
      const searchChanged = state3 ? state3.searchQuery !== searchQuery : false;
      const entryCountChanged = state3 ? state3.entryCount !== entries.length : false;
      const filtersChanged = state3 ? state3.filtersKey !== filtersKey : false;
      const baseLengthChanged = state3 ? state3.baseItems.length !== entries.length : false;
      const needsRebuild = !state3 || filtersChanged || entryCountChanged || baseLengthChanged || !hasAllBaseIndexes || searchChanged;
      if (state3 && !needsRebuild) {
        state3.entryByBaseIndex.clear();
        for (const entry of entries) {
          const baseIndex = readBaseIndex(entry);
          if (baseIndex != null) {
            state3.entryByBaseIndex.set(baseIndex, entry);
          }
        }
        state3.filtersKey = filtersKey;
        state3.searchQuery = searchQuery;
        state3.entryCount = entries.length;
        return state3;
      }
      try {
        const inventory = await Atoms.inventory.myInventory.get();
        if (!inventory || typeof inventory !== "object") {
          console.log("[InventorySorting] Inventaire introuvable pour le tri DOM.");
          return null;
        }
        const items = Array.isArray(inventory.items) ? inventory.items : [];
        const { filteredItems } = filterInventoryItems(items, filters, searchQuery);
        if (filteredItems.length !== entries.length) {
          console.warn(
            `[InventorySorting] Nombre d'\xE9l\xE9ments filtr\xE9s (${filteredItems.length}) diff\xE9rent du DOM (${entries.length}). R\xE9organisation annul\xE9e.`
          );
          return null;
        }
        assignBaseIndexesToEntries(entries);
        const newState = {
          filtersKey,
          searchQuery,
          entryCount: entries.length,
          baseItems: filteredItems.slice(),
          entryByBaseIndex: /* @__PURE__ */ new Map(),
          lastSortKey: state3?.lastSortKey ?? null
        };
        entries.forEach((entry, index) => {
          newState.entryByBaseIndex.set(index, entry);
        });
        stateByGrid.set(grid, newState);
        return newState;
      } catch (error) {
        console.warn("[InventorySorting] Impossible de r\xE9cup\xE9rer myInventory pour le tri DOM", error);
        return null;
      }
    };
    const rebaseStateToDomOrder = (state3, entries) => {
      if (entries.length !== state3.baseItems.length) return false;
      const reordered = [];
      const used = /* @__PURE__ */ new Set();
      for (const entry of entries) {
        const baseIndex = readBaseIndex(entry);
        if (baseIndex == null || baseIndex < 0 || baseIndex >= state3.baseItems.length) {
          return false;
        }
        if (used.has(baseIndex)) {
          return false;
        }
        used.add(baseIndex);
        reordered.push(state3.baseItems[baseIndex]);
      }
      if (reordered.length !== state3.baseItems.length) return false;
      let changed = false;
      for (let i = 0; i < reordered.length; i++) {
        if (reordered[i] !== state3.baseItems[i]) {
          changed = true;
          break;
        }
      }
      if (!changed) return false;
      state3.baseItems = reordered;
      assignBaseIndexesToEntries(entries);
      state3.entryByBaseIndex.clear();
      entries.forEach((entry, index) => {
        state3.entryByBaseIndex.set(index, entry);
      });
      state3.entryCount = entries.length;
      return true;
    };
    return async (grid, sortKey, direction) => {
      if (typeof document === "undefined") return;
      const container = getInventoryItemsContainer(grid);
      if (!container) return;
      const entries = getInventoryDomEntries(container);
      if (!entries.length) return;
      const filters = getActiveFiltersFromGrid(
        grid,
        cfg.checkboxSelector,
        cfg.checkboxLabelSelector
      );
      const searchQuery = getNormalizedInventorySearchQuery(grid);
      const state3 = await ensureState(grid, filters, entries, searchQuery);
      if (!state3) return;
      const previousSortKey = state3.lastSortKey;
      if ((!sortKey || sortKey === "none") && previousSortKey === "none") {
        rebaseStateToDomOrder(state3, entries);
      }
      const baseIndexByItem = /* @__PURE__ */ new Map();
      state3.baseItems.forEach((item, index) => {
        baseIndexByItem.set(item, index);
      });
      const effectiveDirection = direction && DIRECTION_ORDER.includes(direction) ? direction : DEFAULT_DIRECTION_BY_SORT_KEY[sortKey] ?? "asc";
      const desiredItems = !sortKey || sortKey === "none" ? state3.baseItems.slice() : sortInventoryItems(state3.baseItems, sortKey, effectiveDirection);
      const desiredEntries = [];
      const usedEntries = /* @__PURE__ */ new Set();
      for (const item of desiredItems) {
        const baseIndex = baseIndexByItem.get(item);
        if (baseIndex == null) continue;
        const entry = state3.entryByBaseIndex.get(baseIndex);
        if (!entry || usedEntries.has(entry)) continue;
        const value = getInventoryItemValue(item);
        updateInventoryCardValue(entry.card, value);
        updateInventoryCardStrengthText(entry.card, item);
        alignInventoryStrengthText(entry.card);
        desiredEntries.push(entry);
        usedEntries.add(entry);
      }
      if (desiredEntries.length !== entries.length) {
        console.warn(
          `[InventorySorting] Impossible de r\xE9ordonner l'inventaire : correspondances insuffisantes (${desiredEntries.length}/${entries.length}).`
        );
        return;
      }
      const alreadyOrdered = desiredEntries.every(
        (entry, index) => entry.wrapper === entries[index]?.wrapper
      );
      if (!alreadyOrdered) {
        const fragment = document.createDocumentFragment();
        desiredEntries.forEach((entry) => {
          fragment.appendChild(entry.wrapper);
        });
        container.appendChild(fragment);
      }
      state3.entryByBaseIndex.clear();
      desiredEntries.forEach((entry) => {
        const baseIndex = readBaseIndex(entry);
        if (baseIndex != null) {
          state3.entryByBaseIndex.set(baseIndex, entry);
        }
      });
      state3.lastSortKey = sortKey;
    };
  }
  function getActiveFiltersFromGrid(grid, checkboxSelector, checkboxLabelSelector) {
    return Array.from(grid.querySelectorAll(checkboxSelector)).filter(labelIsChecked).map(
      (lbl) => (lbl.querySelector(checkboxLabelSelector)?.textContent ?? "").trim()
    ).filter(Boolean);
  }
  function computeSortOptions(activeFilters, labelByValue = LABEL_BY_VALUE_DEFAULT, mapExtraByFilter = MAP_EXTRA_BY_FILTER_DEFAULT, searchQuery = "") {
    const normalizedFilters = activeFilters.map((value) => (value ?? "").trim().toLowerCase()).filter(Boolean);
    const normalizedSearch = normalize(searchQuery);
    const intersectSets = (sets) => {
      if (!sets.length) return null;
      let intersection = new Set(sets[0]);
      for (let i = 1; i < sets.length; i++) {
        const current = sets[i];
        intersection = new Set([...intersection].filter((value) => current.has(value)));
      }
      return intersection;
    };
    const filterSets = normalizedFilters.map(
      (filterKey) => /* @__PURE__ */ new Set([...BASE_SORT, ...getExtrasForFilterKey(filterKey, mapExtraByFilter)])
    );
    const detectedItemTypes = getCachedItemTypesForContext(activeFilters, normalizedSearch);
    const typeSets = [];
    if (detectedItemTypes && detectedItemTypes.size) {
      detectedItemTypes.forEach((itemType) => {
        const extras = getExtrasForItemType(itemType, mapExtraByFilter);
        typeSets.push(/* @__PURE__ */ new Set([...BASE_SORT, ...extras]));
      });
    }
    const allowedFromFilters = intersectSets(filterSets);
    const allowedFromTypes = intersectSets(typeSets);
    let allowed = null;
    if (allowedFromFilters && allowedFromTypes) {
      allowed = new Set([...allowedFromFilters].filter((value) => allowedFromTypes.has(value)));
    } else if (allowedFromFilters) {
      allowed = new Set(allowedFromFilters);
    } else if (allowedFromTypes) {
      allowed = new Set(allowedFromTypes);
    }
    if (!allowed || !allowed.size) {
      allowed = new Set(BASE_SORT);
    }
    const values = ORDER.filter((value) => value === "none" || allowed.has(value));
    return values.map((value) => ({ value, label: labelByValue[value] || value }));
  }
  function isMacOsPlatform() {
    if (typeof navigator === "undefined") return false;
    const nav = navigator;
    const platform = nav.userAgentData?.platform || nav.platform || "";
    if (platform && /mac/i.test(platform)) {
      return true;
    }
    const userAgent = typeof nav.userAgent === "string" ? nav.userAgent : "";
    return /mac os x/i.test(userAgent);
  }
  function shouldUseCustomSelectStyles() {
    return !isMacOsPlatform();
  }
  function injectDarkSelectStyles(id = "inv-sort-dark-styles") {
    if (document.getElementById(id)) return;
    const css3 = `
    .tm-sort-select {
      color: #e7eef7 !important;
      background-color: rgba(17,17,17,0.98) !important;
      border: 1px solid rgba(255,255,255,0.25) !important;
      outline: none !important;
      -webkit-appearance: none;
      appearance: none;
      color-scheme: dark;
      padding-right: 28px !important;
    }
    .tm-sort-select:focus { box-shadow: 0 0 0 2px rgba(122,162,255,.35); }
    .tm-sort-select option { color: #e7eef7; background-color: #111; }
    .tm-sort-select option:checked { background-color: #222; }
    .tm-sort-select option:hover   { background-color: #1a1a1a; }
    .tm-select-wrap { position: relative; display: inline-flex; align-items: center; }
    .tm-select-arrow {
      position: absolute; right: 10px; top: 50%;
      transform: translateY(-50%);
      pointer-events: none; display: inline-flex; align-items: center; justify-content: center;
    }
    .tm-select-arrow svg { display: block; }
  `;
    const style3 = document.createElement("style");
    style3.id = id;
    style3.textContent = css3;
    document.head.appendChild(style3);
  }
  function createSortingBar(useCustomSelectStyles) {
    const wrap = document.createElement("div");
    wrap.className = "tm-sort-wrap";
    Object.assign(wrap.style, {
      display: "block",
      width: "100%",
      margin: "0",
      padding: "0",
      position: "relative",
      flex: "0 0 auto",
      minHeight: "0",
      contain: "layout style"
    });
    const bar = document.createElement("div");
    bar.className = "tm-sorting-bar";
    Object.assign(bar.style, {
      display: "flex",
      alignItems: "center",
      flexWrap: "wrap",
      gap: "8px",
      marginTop: "10px",
      paddingTop: "8px",
      borderTop: "1px solid rgba(255,255,255,0.12)",
      width: "100%",
      boxSizing: "border-box",
      position: "relative",
      flex: "0 0 auto",
      height: "auto",
      minHeight: "0",
      maxHeight: "none",
      alignSelf: "stretch"
    });
    const label2 = document.createElement("span");
    label2.textContent = "Sort by:";
    Object.assign(label2.style, { font: "inherit", opacity: "0.8", flex: "0 0 auto" });
    const selectWrap = document.createElement("div");
    selectWrap.className = "tm-select-wrap";
    const select2 = document.createElement("select");
    select2.className = "tm-sort-select tm-sort-select--key";
    if (useCustomSelectStyles) {
      Object.assign(select2.style, {
        padding: "6px 10px",
        border: "1px solid rgba(255,255,255,0.25)",
        borderRadius: "6px",
        background: "rgba(17,17,17,0.98)",
        color: "#e7eef7",
        cursor: "pointer",
        flex: "0 0 auto",
        width: "auto",
        outline: "none",
        appearance: "none"
      });
      select2.style.setProperty("-webkit-appearance", "none");
    }
    const arrow = document.createElement("span");
    arrow.className = "tm-select-arrow";
    arrow.innerHTML = `
    <svg width="12" height="8" viewBox="0 0 12 8" aria-hidden="true">
      <path d="M1 1l5 5 5-5" stroke="white" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
  `;
    if (useCustomSelectStyles) {
      selectWrap.append(select2, arrow);
    } else {
      selectWrap.append(select2);
    }
    bar.append(label2, selectWrap);
    const directionLabel = document.createElement("span");
    directionLabel.className = "tm-direction-label";
    directionLabel.textContent = DEFAULT_DIRECTION_LABEL;
    Object.assign(directionLabel.style, {
      font: "inherit",
      opacity: "0.8",
      flex: "0 0 auto"
    });
    const directionWrap = document.createElement("div");
    directionWrap.className = "tm-select-wrap";
    const directionSelect = document.createElement("select");
    directionSelect.className = "tm-sort-select tm-direction-select";
    const canStyleDirectionSelect = useCustomSelectStyles && !isMacOsPlatform();
    if (canStyleDirectionSelect) {
      Object.assign(directionSelect.style, {
        padding: "6px 10px",
        border: "1px solid rgba(255,255,255,0.25)",
        borderRadius: "6px",
        background: "rgba(17,17,17,0.98)",
        color: "#e7eef7",
        cursor: "pointer",
        flex: "0 0 auto",
        width: "auto",
        outline: "none",
        appearance: "none"
      });
      directionSelect.style.setProperty("-webkit-appearance", "none");
    }
    const directionArrow = document.createElement("span");
    directionArrow.className = "tm-select-arrow";
    directionArrow.innerHTML = `
    <svg width="12" height="8" viewBox="0 0 12 8" aria-hidden="true">
      <path d="M1 1l5 5 5-5" stroke="white" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
  `;
    if (canStyleDirectionSelect) {
      directionWrap.append(directionSelect, directionArrow);
    } else {
      directionWrap.append(directionSelect);
    }
    bar.append(directionLabel, directionWrap);
    const divider = document.createElement("span");
    divider.className = "tm-value-toggle__divider";
    Object.assign(divider.style, {
      alignSelf: "stretch",
      width: "1px",
      minHeight: "24px",
      background: "rgba(255,255,255,0.15)",
      flex: "0 0 auto",
      opacity: "0.5"
    });
    const valueToggleLabel = document.createElement("label");
    valueToggleLabel.className = "tm-value-toggle";
    Object.assign(valueToggleLabel.style, {
      display: "inline-flex",
      alignItems: "center",
      gap: "8px",
      font: "inherit",
      opacity: "0.9",
      cursor: "pointer",
      flex: "0 0 auto"
    });
    const valueToggleControl = document.createElement("span");
    valueToggleControl.className = "tm-value-toggle__control";
    Object.assign(valueToggleControl.style, {
      position: "relative",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      width: "36px",
      height: "20px",
      flex: "0 0 auto"
    });
    const valueToggleInput = document.createElement("input");
    valueToggleInput.type = "checkbox";
    valueToggleInput.className = "tm-value-toggle__checkbox";
    Object.assign(valueToggleInput.style, {
      position: "absolute",
      inset: "0",
      margin: "0",
      opacity: "0",
      cursor: "pointer"
    });
    const switchTrack = document.createElement("span");
    switchTrack.className = "tm-value-toggle__switch";
    Object.assign(switchTrack.style, {
      position: "relative",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "flex-start",
      width: "100%",
      height: "100%",
      borderRadius: "999px",
      background: "rgba(255,255,255,0.25)",
      transition: "background 120ms ease",
      padding: "2px",
      boxSizing: "border-box"
    });
    const switchThumb = document.createElement("span");
    switchThumb.className = "tm-value-toggle__thumb";
    Object.assign(switchThumb.style, {
      width: "16px",
      height: "16px",
      borderRadius: "50%",
      background: "#111",
      boxShadow: "0 1px 3px rgba(0,0,0,0.35)",
      transform: "translateX(0)",
      transition: "transform 120ms ease, background 120ms ease"
    });
    switchTrack.appendChild(switchThumb);
    valueToggleControl.append(valueToggleInput, switchTrack);
    const valueToggleText = document.createElement("span");
    valueToggleText.className = "tm-value-toggle__label";
    valueToggleText.textContent = "Show values";
    Object.assign(valueToggleText.style, {
      font: "inherit",
      color: "inherit"
    });
    valueToggleLabel.append(valueToggleControl, valueToggleText);
    const valueSummaryText = document.createElement("span");
    valueSummaryText.className = "tm-value-toggle__summary";
    Object.assign(valueSummaryText.style, {
      font: "inherit",
      color: "var(--chakra-colors-Yellow-Magic, #F3D32B)",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "flex-end",
      flex: "1 1 auto",
      whiteSpace: "nowrap",
      marginLeft: "auto",
      textAlign: "right",
      gap: "0.25rem"
    });
    setValueSummaryText(valueSummaryText, FILTERED_VALUE_LOADING);
    bar.append(divider, valueToggleLabel, valueSummaryText);
    const syncValueToggleVisual = (checked) => {
      switchTrack.style.background = checked ? "var(--chakra-colors-Yellow-Magic, #F3D32B)" : "rgba(255,255,255,0.25)";
      switchThumb.style.transform = checked ? "translateX(16px)" : "translateX(0)";
      valueToggleLabel.setAttribute("data-checked", checked ? "true" : "false");
      valueToggleLabel.setAttribute("role", "switch");
      valueToggleLabel.setAttribute("aria-checked", checked ? "true" : "false");
    };
    valueToggleInput.addEventListener("change", () => {
      syncValueToggleVisual(valueToggleInput.checked);
    });
    wrap.__syncValueToggle = syncValueToggleVisual;
    syncValueToggleVisual(valueToggleInput.checked);
    wrap.appendChild(bar);
    return {
      wrap,
      bar,
      select: select2,
      directionSelect,
      directionLabel,
      valueToggleInput,
      valueToggleLabel,
      valueSummary: valueSummaryText
    };
  }
  function ensureSortingBar(grid, cfg, useCustomSelectStyles, labelByValue, directionLabelText, onChange, showValues, onToggleValues) {
    const filtersBlock = grid.querySelector(cfg.filtersBlockSelector);
    if (!filtersBlock) return null;
    const closeBtn = null;
    let wrap = filtersBlock.querySelector(":scope > .tm-sort-wrap");
    let select2;
    let directionSelect;
    let directionLabelEl = null;
    let valueToggleInput = null;
    let valueSummaryEl = null;
    if (!wrap) {
      const ui = createSortingBar(useCustomSelectStyles);
      wrap = ui.wrap;
      select2 = ui.select;
      directionSelect = ui.directionSelect;
      directionLabelEl = ui.directionLabel;
      valueToggleInput = ui.valueToggleInput;
      valueSummaryEl = ui.valueSummary;
      wrap.__grid = grid;
      wrap.__valueSummary = valueSummaryEl ?? null;
      wrap.style.gridColumn = "1 / -1";
      filtersBlock.appendChild(wrap);
      if (directionLabelEl) {
        directionLabelEl.textContent = directionLabelText;
      }
      if (valueToggleInput) {
        valueToggleInput.checked = showValues;
        valueToggleInput.addEventListener("change", () => {
          const nextVisible = valueToggleInput ? valueToggleInput.checked : false;
          wrap.__showValues = nextVisible;
          onToggleValues(nextVisible);
        });
      }
      select2.addEventListener("change", () => {
        const value = select2.value;
        wrap.__prevValue = value;
        const direction = directionSelect?.value || "asc";
        const currentGrid = wrap.__grid;
        const activeFilters = currentGrid ? getActiveFiltersFromGrid(
          currentGrid,
          cfg.checkboxSelector,
          cfg.checkboxLabelSelector
        ) : [];
        const searchQuery = getNormalizedInventorySearchQuery(currentGrid);
        console.log("[InventorySorting] Tri s\xE9lectionn\xE9 :", value);
        void logInventoryForFilters(activeFilters, value, direction, searchQuery);
        onChange(value, direction, activeFilters, searchQuery);
      });
      directionSelect.addEventListener("change", () => {
        const direction = directionSelect.value;
        wrap.__prevDirection = direction;
        const value = select2?.value || "none";
        const currentGrid = wrap.__grid;
        const activeFilters = currentGrid ? getActiveFiltersFromGrid(
          currentGrid,
          cfg.checkboxSelector,
          cfg.checkboxLabelSelector
        ) : [];
        const searchQuery = getNormalizedInventorySearchQuery(currentGrid);
        console.log("[InventorySorting] Ordre de tri s\xE9lectionn\xE9 :", direction);
        void logInventoryForFilters(activeFilters, value, direction, searchQuery);
        onChange(value, direction, activeFilters, searchQuery);
      });
    } else {
      const maybeSelect = wrap.querySelector("select.tm-sort-select--key");
      const maybeDirectionSelect = wrap.querySelector("select.tm-direction-select");
      if (!maybeSelect || !maybeDirectionSelect) return null;
      select2 = maybeSelect;
      directionSelect = maybeDirectionSelect;
      directionLabelEl = wrap.querySelector(".tm-direction-label");
      valueToggleInput = wrap.querySelector('label.tm-value-toggle input[type="checkbox"]');
      valueSummaryEl = wrap.querySelector(".tm-value-toggle__summary");
      wrap.__valueSummary = valueSummaryEl ?? null;
      if (directionLabelEl) {
        directionLabelEl.textContent = directionLabelText;
      }
      if (wrap.parentElement !== filtersBlock) {
        wrap.style.gridColumn = "1 / -1";
        filtersBlock.appendChild(wrap);
      } else {
        wrap.style.gridColumn = "1 / -1";
      }
    }
    if (valueToggleInput) {
      valueToggleInput.checked = showValues;
    }
    const syncValueToggle = wrap.__syncValueToggle;
    if (syncValueToggle) {
      syncValueToggle(valueToggleInput?.checked ?? showValues);
    }
    wrap.__grid = grid;
    wrap.__showValues = valueToggleInput?.checked ?? showValues;
    return { wrap, select: select2, directionSelect, valueToggleInput, valueSummary: valueSummaryEl };
  }
  function renderSelectOptions(select2, options, prevValue) {
    const prev = prevValue ?? select2.value;
    select2.innerHTML = "";
    for (const opt of options) {
      const o = document.createElement("option");
      o.value = opt.value;
      o.textContent = opt.label;
      select2.appendChild(o);
    }
    if (options.some((o) => o.value === "none")) {
      select2.value = "none";
    }
    if (prev && options.some((o) => o.value === prev) && prev !== "none") {
      select2.value = prev;
    }
  }
  function renderDirectionOptions(select2, labels, prevValue) {
    const prev = prevValue ?? select2.value ?? null;
    select2.innerHTML = "";
    for (const value of DIRECTION_ORDER) {
      const option = document.createElement("option");
      option.value = value;
      option.textContent = labels[value] ?? value;
      select2.appendChild(option);
    }
    if (prev && DIRECTION_ORDER.includes(prev)) {
      select2.value = prev;
    } else {
      select2.value = DIRECTION_ORDER[0];
    }
  }
  function attachInventorySorting(userConfig = {}) {
    const cfg = {
      ...DEFAULTS4,
      ...userConfig
    };
    const mapExtraByFilter = { ...MAP_EXTRA_BY_FILTER_DEFAULT, ...cfg.mapExtraByFilter || {} };
    const labelByValue = { ...LABEL_BY_VALUE_DEFAULT, ...cfg.labelByValue || {} };
    const directionLabelText = cfg.directionLabel ?? DEFAULT_DIRECTION_LABEL;
    const directionLabelByValue = {
      ...DIRECTION_LABELS_DEFAULT,
      ...cfg.directionLabelByValue || {}
    };
    const defaultDirectionBySortKey = {
      ...DEFAULT_DIRECTION_BY_SORT_KEY,
      ...cfg.defaultDirectionBySortKey || {}
    };
    const useCustomSelectStyles = shouldUseCustomSelectStyles();
    if (cfg.injectDarkStyles && useCustomSelectStyles) injectDarkSelectStyles();
    const applySorting = cfg.applySorting ?? createDefaultApplySorting(cfg);
    let showInventoryValues = loadPersistedInventoryValueVisibility() ?? true;
    setShouldDisplayInventoryValues(showInventoryValues);
    let grid = null;
    let currentWrap = null;
    let currentSelect = null;
    let currentDirectionSelect = null;
    let currentValueToggle = null;
    let stopValueSummaryListener = null;
    let lastLoggedFilters = null;
    let lastAppliedFiltersKey = null;
    let lastAppliedSortKey = null;
    let lastAppliedDirection = null;
    let shouldEnsureInventoryValueWatcherOnNextVisible = true;
    let lastSortedDomSnapshot = null;
    let lastComputedFilterContextKey = null;
    let stopFilterContextListener = null;
    let lastRenderedInventoryEntryCount = null;
    let noiseObserver = null;
    let noiseObserverContainer = null;
    let lastPetHutchRoot = null;
    let petHutchNeedsInit = true;
    const updateDomSnapshotForGrid = (target) => {
      if (!target) {
        lastSortedDomSnapshot = null;
        return;
      }
      const container = getInventoryItemsContainer(target);
      if (!container) {
        lastSortedDomSnapshot = null;
        return;
      }
      const entries = getInventoryDomEntries(container);
      lastSortedDomSnapshot = createDomSnapshot(entries);
    };
    const applySortingWithSnapshot = (target, sortKey, direction) => Promise.resolve(applySorting(target, sortKey, direction)).then(() => {
      updateDomSnapshotForGrid(target);
    });
    const ensureNoiseObserver = () => {
      if (noiseObserver) return;
      noiseObserver = new MutationObserver(() => {
        if (noiseObserverContainer) {
          clearInventoryNoiseText(noiseObserverContainer);
        }
      });
    };
    const observeNoiseContainer = (container) => {
      if (noiseObserverContainer === container) return;
      if (noiseObserver) {
        noiseObserver.disconnect();
      }
      noiseObserverContainer = container;
      if (!container) return;
      ensureNoiseObserver();
      noiseObserver?.observe(container, {
        subtree: true,
        childList: true,
        characterData: true
      });
      clearInventoryNoiseText(container);
    };
    const obs = new MutationObserver((muts) => {
      const relevant = muts.some(
        (m) => m.type === "attributes" ? ["data-checked", "style", "class", "hidden", "aria-hidden"].includes(m.attributeName || "") : m.type === "childList"
      );
      if (relevant) refresh();
    });
    const setGrid = (next) => {
      if (grid === next) return;
      obs.disconnect();
      grid = next;
      lastLoggedFilters = null;
      lastAppliedFiltersKey = null;
      lastAppliedSortKey = null;
      lastSortedDomSnapshot = null;
      lastComputedFilterContextKey = null;
      lastRenderedInventoryEntryCount = null;
      shouldEnsureInventoryValueWatcherOnNextVisible = true;
      if (!grid && stopValueSummaryListener) {
        stopValueSummaryListener();
        stopValueSummaryListener = null;
      }
      if (!grid && stopFilterContextListener) {
        stopFilterContextListener();
        stopFilterContextListener = null;
      }
      if (!grid) {
        observeNoiseContainer(null);
      }
      if (grid) {
        obs.observe(grid, {
          subtree: true,
          childList: true,
          attributes: true,
          attributeFilter: ["data-checked", "style", "class", "hidden", "aria-hidden"]
        });
      }
    };
    const bodyObserver = new MutationObserver(() => {
      const hasCurrent = !!(grid && document.contains(grid));
      if (!hasCurrent && grid) {
        setGrid(null);
      }
      const current = hasCurrent ? grid : null;
      const next = document.querySelector(cfg.gridSelector);
      if (next !== current) {
        setGrid(next);
        if (next) {
          update();
        }
      }
      maybeInitPetHutch();
      refreshPetHutch();
    });
    const resolveGrid = () => {
      if (grid && document.contains(grid)) return grid;
      const next = document.querySelector(cfg.gridSelector);
      if (next !== grid) {
        setGrid(next);
      }
      return grid && document.contains(grid) ? grid : null;
    };
    const applyCurrentSorting = () => {
      const targetGrid = resolveGrid();
      if (!targetGrid) return;
      const sortKey = currentSelect?.value ?? "none";
      const fallbackDirection = defaultDirectionBySortKey[sortKey] ?? DEFAULT_DIRECTION_BY_SORT_KEY[sortKey] ?? "asc";
      const direction = currentDirectionSelect?.value ?? fallbackDirection;
      void applySortingWithSnapshot(targetGrid, sortKey, direction);
    };
    const update = () => {
      const targetGrid = resolveGrid();
      if (!targetGrid || !isVisible(targetGrid)) {
        shouldEnsureInventoryValueWatcherOnNextVisible = true;
        return;
      }
      setShouldDisplayInventoryValues(showInventoryValues);
      if (shouldEnsureInventoryValueWatcherOnNextVisible) {
        shouldEnsureInventoryValueWatcherOnNextVisible = false;
        void ensureInventoryValueWatcher().catch((error) => {
          console.warn(
            "[InventorySorting] Impossible d'initialiser la surveillance de la valeur de l'inventaire",
            error
          );
        });
      }
      const mount = ensureSortingBar(
        targetGrid,
        cfg,
        useCustomSelectStyles,
        labelByValue,
        directionLabelText,
        (value, direction, filters, searchQuery) => {
          lastAppliedSortKey = value;
          lastAppliedDirection = direction;
          const filtersKey = JSON.stringify({ filters: filters ?? [], search: searchQuery ?? "" });
          lastAppliedFiltersKey = filtersKey;
          persistSortKey(value);
          persistSortDirection(direction);
          cfg.onSortChange?.(value, direction);
          void applySortingWithSnapshot(targetGrid, value, direction);
        },
        showInventoryValues,
        (visible) => {
          showInventoryValues = visible;
          setShouldDisplayInventoryValues(visible);
          persistInventoryValueVisibility(visible);
          if (currentValueToggle) {
            currentValueToggle.checked = visible;
          }
          applyCurrentSorting();
        }
      );
      if (!mount) return;
      currentWrap = mount.wrap;
      currentSelect = mount.select;
      currentDirectionSelect = mount.directionSelect;
      currentValueToggle = mount.valueToggleInput ?? null;
      if (!stopValueSummaryListener) {
        stopValueSummaryListener = onInventoryValueChange(() => {
          const sourceGrid = resolveGrid();
          if (!sourceGrid || !currentWrap) return;
          const filtersForSummary = getActiveFiltersFromGrid(
            sourceGrid,
            cfg.checkboxSelector,
            cfg.checkboxLabelSelector
          );
          const searchForSummary = getNormalizedInventorySearchQuery(sourceGrid);
          void updateFilteredInventoryValueSummary(
            currentWrap,
            filtersForSummary,
            searchForSummary
          );
        });
      }
      const activeFilters = getActiveFiltersFromGrid(
        targetGrid,
        cfg.checkboxSelector,
        cfg.checkboxLabelSelector
      );
      const container = getInventoryItemsContainer(targetGrid);
      observeNoiseContainer(container);
      const currentEntries = container ? getInventoryDomEntries(container) : [];
      const inventoryEntryCountChanged = lastRenderedInventoryEntryCount === null || lastRenderedInventoryEntryCount !== currentEntries.length;
      const shouldRenderSelectOptions = inventoryEntryCountChanged || !currentSelect?.options?.length;
      const shouldRenderDirectionOptions = inventoryEntryCountChanged || !currentDirectionSelect?.options?.length;
      const domChangedSinceLastSort = haveDomEntriesChanged(lastSortedDomSnapshot, currentEntries);
      const currentDomSnapshot = createDomSnapshot(currentEntries);
      const searchQueryForGrid = getNormalizedInventorySearchQuery(targetGrid);
      lastComputedFilterContextKey = createFilterContextKey(activeFilters, searchQueryForGrid);
      if (!stopFilterContextListener) {
        stopFilterContextListener = addFilterContextListener((contextKey) => {
          if (contextKey === lastComputedFilterContextKey) {
            setTimeout(refresh, 0);
          }
        });
      }
      void updateFilteredInventoryValueSummary(currentWrap, activeFilters, searchQueryForGrid);
      const serializedFilters = JSON.stringify({
        filters: activeFilters,
        search: searchQueryForGrid
      });
      const filtersChanged = serializedFilters !== lastAppliedFiltersKey;
      if (serializedFilters !== lastLoggedFilters) {
        lastLoggedFilters = serializedFilters;
        console.log("[InventorySorting] Filtres actifs :", activeFilters);
        const currentSortKey = currentSelect?.value ?? void 0;
        const currentDirection = currentDirectionSelect?.value ?? void 0;
        void logInventoryForFilters(
          activeFilters,
          currentSortKey,
          currentDirection,
          searchQueryForGrid
        );
      }
      const options = computeSortOptions(
        activeFilters,
        labelByValue,
        mapExtraByFilter,
        searchQueryForGrid
      );
      const wrapPrevValue = typeof currentWrap.__prevValue === "string" ? currentWrap.__prevValue : null;
      const persistedSortKey = loadPersistedSortKey();
      const preferredValue = (wrapPrevValue && options.some((o) => o.value === wrapPrevValue) ? wrapPrevValue : null) || (persistedSortKey && options.some((o) => o.value === persistedSortKey) ? persistedSortKey : null);
      if (shouldRenderSelectOptions) {
        renderSelectOptions(currentSelect, options, preferredValue);
        lastRenderedInventoryEntryCount = currentEntries.length;
      }
      currentWrap.__prevValue = currentSelect.value;
      const appliedSortKey = currentSelect.value;
      const wrapPrevDirection = typeof currentWrap.__prevDirection === "string" ? currentWrap.__prevDirection : null;
      const persistedDirection = loadPersistedSortDirection();
      const fallbackDirection = defaultDirectionBySortKey[appliedSortKey] ?? DEFAULT_DIRECTION_BY_SORT_KEY[appliedSortKey] ?? "asc";
      const preferredDirection = (wrapPrevDirection && DIRECTION_ORDER.includes(wrapPrevDirection) ? wrapPrevDirection : null) || (persistedDirection && DIRECTION_ORDER.includes(persistedDirection) ? persistedDirection : null) || fallbackDirection;
      let appliedDirection;
      if (currentDirectionSelect) {
        if (shouldRenderDirectionOptions) {
          renderDirectionOptions(currentDirectionSelect, directionLabelByValue, preferredDirection);
        }
        if (preferredDirection && DIRECTION_ORDER.includes(preferredDirection) && currentDirectionSelect.value !== preferredDirection) {
          currentDirectionSelect.value = preferredDirection;
        }
        appliedDirection = currentDirectionSelect.value;
        if (!DIRECTION_ORDER.includes(appliedDirection)) {
          appliedDirection = fallbackDirection;
          currentDirectionSelect.value = fallbackDirection;
        }
        currentWrap.__prevDirection = appliedDirection;
      } else {
        appliedDirection = fallbackDirection;
      }
      const sortChanged = appliedSortKey !== lastAppliedSortKey || appliedDirection !== lastAppliedDirection;
      const shouldApplySorting = sortChanged || domChangedSinceLastSort;
      if (shouldApplySorting) {
        lastAppliedSortKey = appliedSortKey;
        lastAppliedDirection = appliedDirection;
        lastAppliedFiltersKey = serializedFilters;
        persistSortKey(appliedSortKey);
        persistSortDirection(appliedDirection);
        cfg.onSortChange?.(appliedSortKey, appliedDirection);
        void applySortingWithSnapshot(targetGrid, appliedSortKey, appliedDirection);
      } else {
        if (filtersChanged) {
          lastAppliedFiltersKey = serializedFilters;
          console.log(
            "[InventorySorting] Filtres modifi\xE9s mais la liste DOM est inchang\xE9e, tri non r\xE9appliqu\xE9."
          );
        }
        lastSortedDomSnapshot = currentDomSnapshot;
      }
    };
    const refresh = debounce(update, 120);
    const refreshPetHutch = debounce(() => {
      void updatePetHutchSections();
    }, 120);
    const maybeInitPetHutch = () => {
      const root = document.querySelector(PET_HUTCH_ROOT_SELECTOR);
      if (!root) {
        lastPetHutchRoot = null;
        petHutchNeedsInit = true;
        return;
      }
      if (root !== lastPetHutchRoot) {
        lastPetHutchRoot = root;
        petHutchNeedsInit = true;
      }
      if (!petHutchNeedsInit) return;
      void updatePetHutchSections({ hideDuringUpdate: true }).then((applied) => {
        if (applied) petHutchNeedsInit = false;
      });
    };
    const changeHandler = (e) => {
      const target = e.target;
      if (!target) return;
      const within = target.closest(cfg.gridSelector);
      const currentGrid = resolveGrid();
      if (e.type === "input" && target instanceof HTMLInputElement && target.matches(INVENTORY_SEARCH_INPUT_SELECTOR) && within && within === currentGrid) {
        console.log("[InventorySorting] Texte de recherche modifi\xE9 :", target.value);
        const activeFilters = getActiveFiltersFromGrid(
          currentGrid,
          cfg.checkboxSelector,
          cfg.checkboxLabelSelector
        );
        const normalizedSearch = getNormalizedInventorySearchQuery(currentGrid);
        void logFilteredInventorySearchResults(currentGrid, activeFilters, normalizedSearch);
      }
      if (within && within === currentGrid) {
        setTimeout(refresh, 0);
      }
    };
    const startObservers = () => {
      const root = document.body || document.documentElement;
      if (root) {
        bodyObserver.observe(root, { childList: true, subtree: true });
      }
      setGrid(document.querySelector(cfg.gridSelector));
      document.addEventListener("change", changeHandler, true);
      document.addEventListener("input", changeHandler, true);
      update();
      maybeInitPetHutch();
      refreshPetHutch();
    };
    startObservers();
    return {
      destroy() {
        obs.disconnect();
        bodyObserver.disconnect();
        noiseObserver?.disconnect();
        noiseObserver = null;
        noiseObserverContainer = null;
        document.removeEventListener("change", changeHandler, true);
        document.removeEventListener("input", changeHandler, true);
        if (stopValueSummaryListener) {
          stopValueSummaryListener();
          stopValueSummaryListener = null;
        }
        if (stopFilterContextListener) {
          stopFilterContextListener();
          stopFilterContextListener = null;
        }
        if (currentWrap && currentWrap.parentElement) {
          currentWrap.parentElement.removeChild(currentWrap);
        }
        currentWrap = null;
        currentSelect = null;
        currentDirectionSelect = null;
        currentValueToggle = null;
        grid = null;
        lastLoggedFilters = null;
        lastAppliedFiltersKey = null;
        lastAppliedSortKey = null;
        lastAppliedDirection = null;
        shouldEnsureInventoryValueWatcherOnNextVisible = true;
        lastSortedDomSnapshot = null;
      },
      update,
      getActiveFilters() {
        const targetGrid = resolveGrid();
        if (!targetGrid) return [];
        return getActiveFiltersFromGrid(targetGrid, cfg.checkboxSelector, cfg.checkboxLabelSelector);
      },
      getCurrentSortKey() {
        return currentSelect?.value ?? null;
      },
      getCurrentSortDirection() {
        return currentDirectionSelect?.value ?? null;
      },
      setSortKey(k) {
        if (!currentSelect) return;
        currentSelect.value = k;
        currentWrap.__prevValue = k;
        const targetGrid = resolveGrid();
        if (targetGrid) {
          const filtersForLog = getActiveFiltersFromGrid(
            targetGrid,
            cfg.checkboxSelector,
            cfg.checkboxLabelSelector
          );
          const searchQuery = getNormalizedInventorySearchQuery(targetGrid);
          const filtersKey = JSON.stringify({ filters: filtersForLog, search: searchQuery });
          console.log("[InventorySorting] Tri s\xE9lectionn\xE9 (programmatique) :", k);
          const directionToApply = currentDirectionSelect?.value ?? defaultDirectionBySortKey[k] ?? DEFAULT_DIRECTION_BY_SORT_KEY[k] ?? "asc";
          if (currentDirectionSelect) {
            currentDirectionSelect.value = directionToApply;
            currentWrap.__prevDirection = directionToApply;
          }
          void logInventoryForFilters(filtersForLog, k, directionToApply, searchQuery);
          lastAppliedFiltersKey = filtersKey;
          lastAppliedSortKey = k;
          lastAppliedDirection = directionToApply;
          persistSortKey(k);
          persistSortDirection(directionToApply);
          cfg.onSortChange?.(k, directionToApply);
          setShouldDisplayInventoryValues(showInventoryValues);
          void applySortingWithSnapshot(targetGrid, k, directionToApply);
        }
      },
      setSortDirection(direction) {
        if (!currentDirectionSelect) return;
        currentDirectionSelect.value = direction;
        currentWrap.__prevDirection = direction;
        const targetGrid = resolveGrid();
        const sortKey = currentSelect?.value ?? "none";
        if (targetGrid) {
          const filtersForLog = getActiveFiltersFromGrid(
            targetGrid,
            cfg.checkboxSelector,
            cfg.checkboxLabelSelector
          );
          const searchQuery = getNormalizedInventorySearchQuery(targetGrid);
          const filtersKey = JSON.stringify({ filters: filtersForLog, search: searchQuery });
          console.log("[InventorySorting] Ordre de tri s\xE9lectionn\xE9 (programmatique) :", direction);
          void logInventoryForFilters(filtersForLog, sortKey, direction, searchQuery);
          lastAppliedFiltersKey = filtersKey;
          lastAppliedSortKey = sortKey;
          lastAppliedDirection = direction;
          persistSortKey(sortKey);
          persistSortDirection(direction);
          cfg.onSortChange?.(sortKey, direction);
          setShouldDisplayInventoryValues(showInventoryValues);
          void applySortingWithSnapshot(targetGrid, sortKey, direction);
        }
      },
      getSortOptions() {
        const targetGrid = resolveGrid();
        const filters = targetGrid ? getActiveFiltersFromGrid(targetGrid, cfg.checkboxSelector, cfg.checkboxLabelSelector) : [];
        const search = getNormalizedInventorySearchQuery(targetGrid);
        return computeSortOptions(filters, labelByValue, mapExtraByFilter, search);
      },
      getGrid() {
        return resolveGrid();
      }
    };
  }
  function startInventorySortingObserver(options = {}) {
    if (typeof window === "undefined" || typeof document === "undefined") {
      return {
        stop() {
        },
        refresh() {
        },
        getController() {
          return null;
        }
      };
    }
    const { waitForGrid = true, log: log2, ...config } = options;
    const cfg = config;
    let controller = null;
    let observer2 = null;
    let readyListener = null;
    const logger = typeof log2 === "function" ? log2 : log2 ? (...args) => console.debug("[InventorySorting]", ...args) : () => {
    };
    const attachIfPossible = () => {
      if (controller) return controller;
      if (waitForGrid) {
        const selector = cfg.gridSelector ?? DEFAULTS4.gridSelector;
        const hasGrid = !!document.querySelector(selector);
        const hasHutch = !!document.querySelector(PET_HUTCH_ROOT_SELECTOR);
        if (!hasGrid && !hasHutch) {
          return null;
        }
      }
      controller = attachInventorySorting(cfg);
      logger("attached");
      return controller;
    };
    const ensureObserver = () => {
      if (controller || observer2 || !waitForGrid) return;
      const target = document.body || document.documentElement;
      if (!target) return;
      observer2 = new MutationObserver(() => {
        if (attachIfPossible()) {
          observer2?.disconnect();
          observer2 = null;
          logger("attached via mutation");
        }
      });
      observer2.observe(target, { childList: true, subtree: true });
    };
    const start2 = () => {
      if (!attachIfPossible()) {
        ensureObserver();
      }
    };
    if (document.readyState === "loading") {
      readyListener = () => {
        readyListener = null;
        start2();
      };
      document.addEventListener("DOMContentLoaded", readyListener, { once: true });
    } else {
      start2();
    }
    return {
      stop() {
        if (readyListener) {
          document.removeEventListener("DOMContentLoaded", readyListener);
          readyListener = null;
        }
        observer2?.disconnect();
        observer2 = null;
        controller?.destroy();
        controller = null;
      },
      refresh() {
        if (controller) {
          controller.update();
        } else {
          start2();
        }
      },
      getController() {
        return controller;
      }
    };
  }

  // src/utils/checkModal.ts
  init_page_context();
  var DEFAULTS5 = {
    intervalMs: 6e4,
    log: false
  };
  var normalize2 = (s) => (s || "").replace(/\s+/g, " ").trim();
  var reGameUpdate = /game\s*update\s+ava?ilab?le/i;
  var reDailyBread = /your\s+daily\s+bread/i;
  var log = (enabled, ...args) => {
    if (enabled) console.log("[checkModal]", ...args);
  };
  var reloadScheduled = false;
  var schedulePageReload = (doLog) => {
    if (reloadScheduled) return;
    reloadScheduled = true;
    log(doLog, "Game Update: \u267B\uFE0F rechargement de la page dans un instant...");
    pageWindow.setTimeout(() => {
      log(doLog, "Game Update: \u{1F504} rechargement maintenant.");
      pageWindow.location.reload();
    }, 500);
  };
  var isVisible2 = (el2) => {
    if (!el2 || !(el2 instanceof HTMLElement)) return false;
    const rect = el2.getBoundingClientRect();
    if (rect.width <= 0 || rect.height <= 0) return false;
    const cs = getComputedStyle(el2);
    if (cs.display === "none" || cs.visibility === "hidden" || parseFloat(cs.opacity) === 0) return false;
    let cur = el2;
    while (cur) {
      const cs2 = getComputedStyle(cur);
      if (cs2.display === "none" || cs2.visibility === "hidden") return false;
      cur = cur.parentElement;
    }
    return true;
  };
  function findGameUpdateModal() {
    const sections = document.querySelectorAll(
      'section.chakra-modal__content[role="dialog"], section.chakra-modal__content[role="alertdialog"]'
    );
    for (const sec of sections) {
      const header = sec.querySelector("header.chakra-modal__header");
      const txt = normalize2(header?.textContent || sec.textContent || "");
      if (reGameUpdate.test(txt)) return sec;
    }
    return null;
  }
  function findBreadModal() {
    const sections = document.querySelectorAll(
      'section.chakra-modal__content[role="dialog"], section.chakra-modal__content[role="alertdialog"]'
    );
    for (const sec of sections) {
      const txt = normalize2(sec.textContent || "");
      if (!reDailyBread.test(txt)) continue;
      let btn = sec.querySelector("button.chakra-button.css-1o32am8");
      if (!btn) {
        const candidates = sec.querySelectorAll("button");
        btn = Array.from(candidates).find((b) => /claim/i.test(normalize2(b.textContent))) ?? null;
      }
      if (btn) return { section: sec, button: btn };
    }
    return null;
  }
  var clickedBreadButtons = /* @__PURE__ */ new WeakSet();
  function clickBreadIfVisible(btn, doLog) {
    if (clickedBreadButtons.has(btn)) {
      log(doLog, "Bread: bouton d\xE9j\xE0 cliqu\xE9 (guard).");
      return false;
    }
    const ariaDisabled = btn.getAttribute("aria-disabled");
    if (btn.disabled || ariaDisabled === "true") {
      log(doLog, "Bread: bouton d\xE9sactiv\xE9.");
      return false;
    }
    if (!isVisible2(btn)) {
      log(doLog, "Bread: bouton non visible.");
      return false;
    }
    btn.click();
    clickedBreadButtons.add(btn);
    log(doLog, "Bread: \u2705 click() envoy\xE9.");
    return true;
  }
  function checkOnce(opts) {
    const { log: doLog } = { ...DEFAULTS5, ...opts };
    const gameUpdateSec = findGameUpdateModal();
    const gameUpdateFound = !!gameUpdateSec;
    if (gameUpdateFound) {
      log(doLog, "Game Update: \u2705 d\xE9tect\xE9.", gameUpdateSec);
      schedulePageReload(doLog);
    }
    const found = findBreadModal();
    const breadFound = !!found;
    let breadClicked = false;
    if (found) {
      log(doLog, "Daily Bread: \u2705 d\xE9tect\xE9.", found.section);
      breadClicked = clickBreadIfVisible(found.button, doLog);
    }
    if (!gameUpdateFound && !breadFound) log(doLog, "Rien d\xE9tect\xE9 pour l\u2019instant.");
    return { gameUpdateFound, breadFound, breadClicked };
  }
  function startModalObserver(options) {
    const { intervalMs, log: doLog } = { ...DEFAULTS5, ...options };
    let stopped = false;
    const tick = () => {
      if (stopped) return { gameUpdateFound: false, breadFound: false, breadClicked: false };
      return checkOnce({ log: doLog });
    };
    tick();
    const timer = pageWindow.setInterval(tick, intervalMs);
    const stop2 = () => {
      if (stopped) return;
      stopped = true;
      pageWindow.clearInterval(timer);
      log(doLog, "\u23F9\uFE0F Observateur arr\xEAt\xE9.");
    };
    log(doLog, `\u25B6\uFE0F Observateur d\xE9marr\xE9 (intervalle: ${intervalMs} ms).`);
    return { stop: stop2, tick };
  }
  var exposed = {
    startModalObserver,
    checkOnce,
    findGameUpdateModal,
    findBreadModal
  };
  shareGlobal("CheckModal", exposed);

  // src/utils/activityLogFilter.ts
  var FILTER_STORAGE_KEY = "activityLog.filter";
  var STYLE_ID3 = "mg-activity-log-filter-style";
  var ROOT_FLAG_ATTR = "data-mg-activity-log-filter-ready";
  var WRAPPER_CLASS = "mg-activity-log-filter";
  var BUTTON_CLASS = "mg-activity-log-filter-btn";
  var ACTIVE_CLASS = "is-active";
  var ACTION_ORDER = [
    "all",
    "found",
    "buy",
    "sell",
    "harvest",
    "plant",
    "feed",
    "hatch",
    "water",
    "coinFinder",
    "seedFinder",
    "double",
    "eggGrowth",
    "plantGrowth",
    "granter",
    "kisser",
    "refund",
    "boost",
    "remove",
    "other"
  ];
  var ACTION_LABELS = {
    all: "All",
    found: "Finds",
    buy: "Purchases",
    sell: "Sold",
    harvest: "Harvests",
    plant: "Planted",
    feed: "Feed",
    hatch: "Hatch",
    water: "Water",
    coinFinder: "Coin Finder",
    seedFinder: "Seed Finder",
    double: "Double",
    eggGrowth: "Egg Growth",
    plantGrowth: "Plant Growth",
    granter: "Granters",
    kisser: "Kissers",
    refund: "Refunds",
    boost: "Boosts",
    remove: "Remove",
    other: "Other"
  };
  var ACTION_MAP = {
    purchaseDecor: "buy",
    purchaseSeed: "buy",
    purchaseEgg: "buy",
    purchaseTool: "buy",
    waterPlant: "water",
    plantSeed: "plant",
    plantGardenPlant: "plant",
    potPlant: "plant",
    removeGardenObject: "remove",
    harvest: "harvest",
    feedPet: "feed",
    plantEgg: "hatch",
    hatchEgg: "hatch",
    instaGrow: "boost",
    customRestock: "boost",
    spinSlotMachine: "boost",
    sellAllCrops: "sell",
    sellPet: "sell",
    logItems: "boost",
    mutationPotion: "boost",
    ProduceScaleBoost: "boost",
    ProduceScaleBoostII: "boost",
    DoubleHarvest: "double",
    DoubleHatch: "double",
    ProduceEater: "boost",
    SellBoostI: "boost",
    SellBoostII: "boost",
    SellBoostIII: "boost",
    SellBoostIV: "boost",
    ProduceRefund: "boost",
    PlantGrowthBoost: "plantGrowth",
    PlantGrowthBoostII: "plantGrowth",
    SnowyPlantGrowthBoost: "plantGrowth",
    HungerRestore: "boost",
    HungerRestoreII: "boost",
    SnowyHungerRestore: "boost",
    GoldGranter: "granter",
    RainbowGranter: "granter",
    RainDance: "granter",
    SnowGranter: "granter",
    FrostGranter: "granter",
    PetXpBoost: "boost",
    PetXpBoostII: "boost",
    SnowyPetXpBoost: "boost",
    SnowyEggGrowthBoost: "eggGrowth",
    EggGrowthBoost: "eggGrowth",
    EggGrowthBoostII_NEW: "eggGrowth",
    EggGrowthBoostII: "eggGrowth",
    PetAgeBoost: "boost",
    PetAgeBoostII: "boost",
    CoinFinderI: "coinFinder",
    CoinFinderII: "coinFinder",
    CoinFinderIII: "coinFinder",
    SnowyCoinFinder: "coinFinder",
    SnowyCropSizeBoost: "boost",
    SnowyHungerBoost: "boost",
    SeedFinderI: "seedFinder",
    SeedFinderII: "seedFinder",
    SeedFinderIII: "seedFinder",
    SeedFinderIV: "seedFinder",
    PetHatchSizeBoost: "boost",
    PetHatchSizeBoostII: "boost",
    MoonKisser: "kisser",
    DawnKisser: "kisser",
    PetRefund: "refund",
    PetRefundII: "refund"
  };
  var ACTION_MAP_LOWER = Object.fromEntries(
    Object.entries(ACTION_MAP).map(([k, v]) => [k.toLowerCase(), v])
  );
  function normalizeAbilityAction(raw) {
    const trimmed = String(raw || "").trim();
    if (!trimmed) return null;
    let key2 = trimmed.replace(/^Snowy/i, "");
    key2 = key2.replace(/_NEW$/i, "");
    key2 = key2.replace(/(?:[_-]?(?:I|II|III|IV|V|VI|VII|VIII|IX|X)|\d+)$/i, "");
    key2 = key2.replace(/[_-]+$/g, "");
    return key2 ? key2 : null;
  }
  var PATTERNS = [
    { key: "found", re: /\bfound\b/i },
    { key: "buy", re: /\b(bought|purchas(e|ed))\b/i },
    { key: "sell", re: /\bsold\b/i },
    { key: "harvest", re: /harvest/i },
    { key: "water", re: /water(ed)?/i },
    { key: "plant", re: /planted/i },
    { key: "feed", re: /\bfed\b/i },
    { key: "hatch", re: /\bhatched?\b/i },
    { key: "remove", re: /\b(remove|removed|delete)\b/i },
    // Ability-derived buckets (fallback when no data-action is set)
    { key: "coinFinder", re: /\b(coin\s*finder|coins?\s+found)\b/i },
    { key: "seedFinder", re: /\b(seed\s*finder|seeds?\s+found)\b/i },
    { key: "double", re: /\b(double\s+(harvest|hatch)|extra\s+(crop|pet))\b/i },
    { key: "eggGrowth", re: /\b(egg\s*growth|hatch\s*time|hatch\s*speed)\b/i },
    { key: "plantGrowth", re: /\b((plant|crop)\s*growth)\b/i },
    { key: "granter", re: /\b(granter|granted|granting)\b/i },
    { key: "kisser", re: /\b(kisser|kissed)\b/i },
    { key: "refund", re: /\b(refund|refunded)\b/i },
    { key: "boost", re: /\b(boost|potion|refund|growth|restock|spin)\b/i }
  ];
  var started4 = false;
  var activeFilter = loadPersistedFilter() ?? "all";
  function startActivityLogFilter() {
    if (started4 || typeof document === "undefined") return;
    started4 = true;
    ensureStyles();
    onAdded(
      (el2) => el2 instanceof HTMLElement && el2.matches("p.chakra-text") && /activity\s*log/i.test(el2.textContent || ""),
      (titleEl) => {
        const root = titleEl.closest("div.McGrid");
        if (!root || root.hasAttribute(ROOT_FLAG_ATTR)) return;
        const header = root.querySelector("div.McFlex.css-2tfeb0") ?? titleEl.closest("div.McFlex");
        const content = root.querySelector("div.McFlex.css-iek5kf") ?? root.querySelectorAll("div.McFlex")[1] ?? null;
        if (!header || !content) return;
        root.setAttribute(ROOT_FLAG_ATTR, "1");
        injectFilter(header, content);
      },
      { callForExisting: true }
    );
  }
  function injectFilter(header, content) {
    const wrapper = document.createElement("div");
    wrapper.className = WRAPPER_CLASS;
    wrapper.style.width = "100%";
    wrapper.style.boxSizing = "border-box";
    wrapper.style.gridColumn = "1 / -1";
    wrapper.style.alignSelf = "start";
    wrapper.style.justifyContent = "flex-start";
    wrapper.style.flex = "0 0 auto";
    wrapper.style.minHeight = "auto";
    const label2 = document.createElement("span");
    label2.textContent = "Filter by action:";
    label2.className = `${WRAPPER_CLASS}__label`;
    const buttons = document.createElement("div");
    buttons.className = `${WRAPPER_CLASS}__buttons`;
    buttons.style.flex = "1 1 100%";
    buttons.style.minWidth = "0";
    buttons.style.alignItems = "center";
    wrapper.append(label2, buttons);
    content.insertBefore(wrapper, content.firstChild);
    const entriesContainer = content.querySelector("div.McFlex.css-173k61n") ?? content.querySelector("div.McFlex") ?? content;
    const renderButtons = (counts) => {
      const actions = mergeActions(Array.from(counts.keys()));
      if (!actions.includes("all")) actions.unshift("all");
      buttons.innerHTML = "";
      for (const action2 of actions) {
        const count = counts.get(action2) ?? 0;
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = `${BUTTON_CLASS}${action2 === activeFilter ? ` ${ACTIVE_CLASS}` : ""}`;
        btn.textContent = `${getActionLabel(action2)}${count ? ` (${count})` : ""}`;
        btn.dataset.action = action2;
        btn.addEventListener("click", () => {
          activeFilter = action2;
          persistFilter(action2);
          updateButtons(buttons);
          applyFilter(entriesContainer, activeFilter);
        });
        buttons.appendChild(btn);
      }
    };
    const refresh = () => {
      const counts = /* @__PURE__ */ new Map();
      for (const entry of getEntryElements(entriesContainer)) {
        const action2 = classifyEntry(entry);
        counts.set(action2, (counts.get(action2) ?? 0) + 1);
      }
      renderButtons(counts);
      if (!counts.has(activeFilter) && activeFilter !== "all") {
        activeFilter = "all";
        persistFilter(activeFilter);
        updateButtons(buttons);
      }
      applyFilter(entriesContainer, activeFilter);
    };
    const obs = new MutationObserver(() => refresh());
    obs.observe(entriesContainer, { childList: true, subtree: true });
    refresh();
    const cleanup2 = () => obs.disconnect();
    const onRemoved = () => cleanup2();
    wrapper.addEventListener("DOMNodeRemovedFromDocument", onRemoved, { once: true });
  }
  function classifyEntry(entry) {
    const preset = entry.dataset.action || entry.getAttribute("data-action") || entry.getAttribute("data-activity") || entry.dataset.mgAction;
    if (preset && typeof preset === "string") {
      const trimmed = preset.trim();
      if (trimmed) {
        const normalized = normalizeAction(trimmed);
        entry.dataset.mgAction = normalized;
        return normalized;
      }
    }
    const text = (entry.textContent || "").trim();
    for (const { key: key2, re } of PATTERNS) {
      if (re.test(text)) {
        entry.dataset.mgAction = key2;
        return key2;
      }
    }
    entry.dataset.mgAction = "other";
    return "other";
  }
  function normalizeAction(raw) {
    const lowered = raw.toLowerCase();
    const mapped = ACTION_MAP[raw];
    const mappedLower = ACTION_MAP_LOWER[lowered];
    const abilityKey = normalizeAbilityAction(raw);
    if (mapped) {
      if (mapped === "boost" && abilityKey) return abilityKey;
      return mapped;
    }
    if (mappedLower) {
      if (mappedLower === "boost" && abilityKey) return abilityKey;
      return mappedLower;
    }
    if (abilityKey) return abilityKey;
    for (const { key: key2, re } of PATTERNS) {
      if (re.test(lowered)) return key2;
    }
    return lowered || "other";
  }
  function getEntryElements(container) {
    const candidates = Array.from(container.children).filter((child) => child instanceof HTMLElement);
    return candidates.filter((child) => {
      if (child.classList.contains(WRAPPER_CLASS)) return false;
      const text = child.textContent || "";
      return /\bago\b/i.test(text) || child.querySelector("p.chakra-text");
    });
  }
  function mergeActions(actions) {
    const seen = /* @__PURE__ */ new Set();
    const ordered = [];
    for (const k of ACTION_ORDER) {
      if (k === "all") continue;
      if (actions.includes(k) && !seen.has(k)) {
        seen.add(k);
        ordered.push(k);
      }
    }
    for (const a of actions) {
      if (a === "all") continue;
      if (!seen.has(a)) {
        seen.add(a);
        ordered.push(a);
      }
    }
    return ordered;
  }
  function applyFilter(container, filter) {
    for (const entry of getEntryElements(container)) {
      const action2 = entry.dataset.mgAction ?? classifyEntry(entry);
      const visible = filter === "all" || action2 === filter;
      entry.style.display = visible ? "" : "none";
    }
  }
  function updateButtons(buttons) {
    buttons.querySelectorAll(`.${BUTTON_CLASS}`).forEach((btn) => {
      if (!(btn instanceof HTMLButtonElement)) return;
      const action2 = btn.dataset.action;
      btn.classList.toggle(ACTIVE_CLASS, action2 === activeFilter);
    });
  }
  function getActionLabel(action2) {
    const preset = ACTION_LABELS[action2];
    if (preset) return preset;
    const spaced = String(action2 || "").replace(/([a-z])([A-Z])/g, "$1 $2").replace(/[_-]+/g, " ").replace(/\s+/g, " ").trim();
    if (!spaced) return String(action2 || "");
    return spaced.split(" ").map((w) => w ? w.charAt(0).toUpperCase() + w.slice(1) : w).join(" ");
  }
  function loadPersistedFilter() {
    try {
      const stored = readAriesPath(FILTER_STORAGE_KEY);
      return stored || null;
    } catch {
      return null;
    }
  }
  function persistFilter(value) {
    try {
      writeAriesPath(FILTER_STORAGE_KEY, String(value));
    } catch {
    }
  }
  function ensureStyles() {
    if (document.getElementById(STYLE_ID3)) return;
    const css3 = `
.${WRAPPER_CLASS}{
  display:flex;
  align-items:center;
  gap:8px;
  padding:8px 10px;
  margin:8px 0 10px 0;
  border-radius:12px;
  background:linear-gradient(180deg, #f7e8d4, #f1dcc1);
  border:1px solid #d7b989;
  box-shadow:inset 0 1px 0 rgba(255,255,255,0.45), 0 6px 14px rgba(120,70,34,0.22);
  flex-wrap:wrap;
  max-width:100%;
  box-sizing:border-box;
}
.${WRAPPER_CLASS}__label{
  font-size:12px;
  letter-spacing:0.03em;
  text-transform:uppercase;
  opacity:0.85;
  font-weight:700;
  color:#7b4b2b;
}
.${WRAPPER_CLASS}__buttons{
  display:flex;
  flex-wrap:wrap;
  gap:6px;
  flex:1 1 100%;
  min-width:0;
}
.${BUTTON_CLASS}{
  border:1px solid #caa56f;
  background:linear-gradient(180deg, #ffe9c8, #f6d7aa);
  color:#5c3416;
  border-radius:999px;
  padding:4px 10px;
  font-size:12px;
  cursor:pointer;
  transition:background 120ms ease, border-color 120ms ease, transform 120ms ease;
  white-space:nowrap;
}
.${BUTTON_CLASS}:hover{
  background:linear-gradient(180deg, #ffe2b2, #f3c98d);
  border-color:#d7b989;
}
.${BUTTON_CLASS}.${ACTIVE_CLASS}{
  background:linear-gradient(180deg, #ffcd82, #f3b05e);
  border-color:#e3a23d;
  box-shadow:0 0 0 1px rgba(227,162,61,0.35), 0 4px 10px rgba(158,94,32,0.25);
  transform:translateY(-1px);
}
`;
    const s = addStyle(css3);
    s.id = STYLE_ID3;
  }

  // src/services/activityLogHistory.ts
  init_fakeModal();
  init_atoms();
  var HISTORY_STORAGE_KEY = "activityLog.history";
  var HISTORY_LIMIT = 500;
  var skipNextHistoryReopen = false;
  function skipNextActivityLogHistoryReopen() {
    skipNextHistoryReopen = true;
  }
  function normalizeEntry(raw) {
    if (!raw || typeof raw !== "object") return null;
    const ts = Number(raw.timestamp);
    if (!Number.isFinite(ts)) return null;
    const parameters = (() => {
      const p = raw.parameters;
      if (!p || typeof p !== "object") return p;
      const petId = typeof p?.pet?.id === "string" ? p.pet.id : null;
      if (petId && !p.petId) {
        return { ...p, petId };
      }
      return p;
    })();
    const action2 = typeof raw.action === "string" && raw.action.trim() ? String(raw.action) : null;
    const entry = {
      ...raw,
      timestamp: ts,
      parameters
    };
    if (action2 !== null) entry.action = action2;
    return entry;
  }
  function normalizeList(logs) {
    const out = [];
    if (!Array.isArray(logs)) return out;
    for (const raw of logs) {
      const norm3 = normalizeEntry(raw);
      if (norm3) out.push(norm3);
    }
    return out;
  }
  function stableStringify(value) {
    const seen = /* @__PURE__ */ new WeakSet();
    const walk = (val) => {
      if (val === null) return null;
      if (typeof val !== "object") return val;
      if (seen.has(val)) return "__CYCLE__";
      seen.add(val);
      if (Array.isArray(val)) return val.map(walk);
      const obj = {};
      const keys = Object.keys(val).sort();
      for (const k of keys) obj[k] = walk(val[k]);
      return obj;
    };
    try {
      return JSON.stringify(walk(value));
    } catch {
      return "";
    }
  }
  function entryIdentity(entry) {
    const p = entry?.parameters;
    const candidates = [
      p?.id,
      p?.pet?.id,
      p?.petId,
      p?.playerId,
      p?.userId,
      p?.objectId,
      p?.slotId,
      p?.itemId,
      p?.cropId,
      p?.seedId,
      p?.decorId,
      p?.toolId,
      p?.targetId,
      p?.abilityId
    ];
    for (const c of candidates) {
      if (typeof c === "string" && c.trim()) return c;
    }
    return null;
  }
  function entryKey(entry) {
    const ts = Number(entry.timestamp);
    const action2 = typeof entry.action === "string" ? entry.action : "";
    const identity = entryIdentity(entry) ?? "__noid__";
    const tsPart = Number.isFinite(ts) ? String(ts) : `t:${stableStringify({ timestamp: entry.timestamp ?? null })}`;
    return `${tsPart}|${action2}|${identity}`;
  }
  function entriesEqual(a, b) {
    return stableStringify(a) === stableStringify(b);
  }
  function loadHistory() {
    try {
      const parsed = readAriesPath(HISTORY_STORAGE_KEY);
      if (!Array.isArray(parsed)) return [];
      const out = [];
      for (const item of parsed) {
        const norm3 = normalizeEntry(item);
        if (norm3) out.push(norm3);
      }
      return out;
    } catch {
      return [];
    }
  }
  function saveHistory(entries) {
    const sorted = entries.slice().sort((a, b) => Number(a.timestamp || 0) - Number(b.timestamp || 0));
    if (sorted.length > HISTORY_LIMIT) {
      sorted.splice(0, sorted.length - HISTORY_LIMIT);
    }
    try {
      writeAriesPath(HISTORY_STORAGE_KEY, sorted);
    } catch {
    }
  }
  function diffSnapshots(prev, next) {
    const prevBuckets = /* @__PURE__ */ new Map();
    const bucketPush = (k, entry) => {
      const arr = prevBuckets.get(k);
      if (arr) arr.push(entry);
      else prevBuckets.set(k, [entry]);
    };
    for (const entry of prev) bucketPush(entryKey(entry), entry);
    const added = [];
    const updated = [];
    for (const entry of next) {
      const key2 = entryKey(entry);
      const bucket = prevBuckets.get(key2);
      const prevEntry = bucket?.shift();
      if (!prevEntry) {
        added.push(entry);
      } else if (!entriesEqual(prevEntry, entry)) {
        updated.push(entry);
      }
      if (bucket && bucket.length === 0) prevBuckets.delete(key2);
    }
    return { added, updated };
  }
  function syncHistory(prevSnapshot, nextSnapshot) {
    const history2 = loadHistory();
    const { added, updated } = diffSnapshots(prevSnapshot, nextSnapshot);
    if (!added.length && !updated.length) return history2;
    const map2 = /* @__PURE__ */ new Map();
    for (const h of history2) map2.set(entryKey(h), h);
    let changed = false;
    const upsert = (entry) => {
      const key2 = entryKey(entry);
      const cur = map2.get(key2);
      if (!cur || !entriesEqual(cur, entry)) {
        map2.set(key2, entry);
        changed = true;
      }
    };
    updated.forEach(upsert);
    added.forEach(upsert);
    if (!changed) return history2;
    const merged = Array.from(map2.values());
    saveHistory(merged);
    return merged;
  }
  async function reopenFakeActivityLogFromHistory() {
    try {
      const history2 = loadHistory();
      await fakeActivityLogShow(history2, { open: true });
    } catch {
    }
  }
  async function startActivityLogHistoryWatcher() {
    const stops = [];
    let lastSnapshot = [];
    const ingest = async (logs, prev) => {
      try {
        const prevSnapshot = typeof prev !== "undefined" ? normalizeList(prev) : lastSnapshot;
        const nextSnapshot = normalizeList(logs);
        syncHistory(prevSnapshot, nextSnapshot);
        lastSnapshot = nextSnapshot;
      } catch {
      }
    };
    try {
      const initial = normalizeList(await myActivityLog.get());
      await ingest(initial);
    } catch {
    }
    try {
      const unsub = await myActivityLog.onChange((next, prev) => {
        void ingest(next, prev);
      });
      stops.push(() => {
        try {
          unsub();
        } catch {
        }
      });
    } catch {
    }
    let lastModal = null;
    try {
      const cur = await Atoms.ui.activeModal.get();
      lastModal = cur ?? null;
    } catch {
    }
    const consumeHistoryReopenSkip = () => {
      if (!skipNextHistoryReopen) return false;
      skipNextHistoryReopen = false;
      return true;
    };
    const onModalChange = async (modalId) => {
      const cur = modalId ?? null;
      if (cur === ACTIVITY_LOG_MODAL_ID && lastModal !== ACTIVITY_LOG_MODAL_ID) {
        if (!consumeHistoryReopenSkip()) {
          await reopenFakeActivityLogFromHistory();
        }
      }
      lastModal = cur;
    };
    try {
      const unsubModal = await Atoms.ui.activeModal.onChange(onModalChange);
      stops.push(() => {
        try {
          unsubModal();
        } catch {
        }
      });
    } catch {
    }
    return async () => {
      for (const stop2 of stops) {
        try {
          await stop2();
        } catch {
        }
      }
    };
  }

  // src/ui/hud.ts
  function mountHUD(opts) {
    const HUD_POS_PATH = "hud.pos";
    const HUD_COLLAPSED_PATH = "hud.collapsed";
    const HUD_HIDDEN_PATH = "hud.hidden";
    const HUD_WIN_PATH = (id) => `hud.windows.${id}`;
    const MARGIN = 8;
    const Z_BASE = 2e6;
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", () => mountHUD(opts), { once: true });
      return;
    }
    const css3 = `
  :root{
    --qws-bg:        #0f1318;
    --qws-panel:     #111823cc;
    --qws-border:    #ffffff22;
    --qws-border-2:  #ffffff14;
    --qws-accent:    #7aa2ff;
    --qws-text:      #e7eef7;
    --qws-text-dim:  #b9c3cf;
    --qws-blur:      8px;
    --qws-shadow:    0 10px 36px rgba(0,0,0,.45);
  }

  /* ---------- HUD floating box ---------- */
  .qws2{
    position:fixed; right:16px; bottom:16px; z-index:${Z_BASE};
    position:fixed; right:16px; bottom:16px; z-index:1000010;
    font:12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    color:var(--qws-text);
    background:var(--qws-panel);
    border:1px solid var(--qws-border);
    border-radius:12px;
    padding:10px 12px;
    box-shadow:var(--qws-shadow);
    backdrop-filter:blur(var(--qws-blur));
    min-width:160px;
    display:flex; flex-direction:column; gap:8px;
  }
  .qws2.hidden{ display:none }
  .qws2 .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
  .qws2 .col{ display:flex; flex-direction:column; gap:4px }
  .qws2 .title{ font-weight:700; letter-spacing:.2px }
  .qws2 .sp{ flex:1 }

  .qws2 .pill{
    display:inline-flex; align-items:center; gap:6px;
    padding:4px 8px; border-radius:999px;
    border:1px solid #ffffff26;
    background:rgba(255,255,255,.06);
    color:var(--qws-text);
    box-shadow:inset 0 1px 0 rgba(255,255,255,.08);
  }
  .qws2 .ok{   background:rgba(36, 161, 72, .20);  border-color:#48d17066 }
  .qws2 .warn{ background:rgba(241, 194, 27, .18); border-color:#ffd65c66 }
  .qws2 .bad{  background:rgba(218, 30, 40, .20);  border-color:#ff7c8666 }

  .qws2 .btn{
    cursor:pointer; border-radius:10px; border:1px solid var(--qws-border);
    padding:6px 10px;
    background:linear-gradient(180deg, #ffffff12, #ffffff06);
    color:#fff;
    transition:transform .1s ease, background .18s ease, border-color .18s ease;
  }
  .qws2 .btn:hover{ background:linear-gradient(180deg, #ffffff18, #ffffff0a); border-color:#ffffff44 }
  .qws2 .btn:active{ transform:translateY(1px) }
  .qws2 .drag{ cursor:move; opacity:.9 }

  .qws2 .mini{ display:none }
  .qws2.min .mini{ display:inline-flex }
  .qws2.min .body{ display:none }

  /* Launcher always shown */
  .qws-launch{ margin-top:4px; border-top:1px solid var(--qws-border); padding-top:6px; display:block }
  .qws-launch .launch-item{ display:flex; align-items:center; gap:8px; margin:4px 0 }
  .qws-launch .launch-item .name{ flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis }
  .qws-launch .launch-item .btn.active{
    background:linear-gradient(180deg, rgba(122,162,255,.28), rgba(122,162,255,.12));
    border-color:#9db7ff66;
  }

  /* ---------- Windows ---------- */
  .qws-win{
    position:fixed; z-index:${Z_BASE + 1}; min-width:260px; max-width:900px; max-height:90vh; overflow:auto;
    background:var(--qws-panel); color:var(--qws-text);
    border:1px solid var(--qws-border); border-radius:12px;
    box-shadow:var(--qws-shadow); backdrop-filter:blur(var(--qws-blur));
  }
  .qws-win .w-head{
    display:flex; align-items:center; gap:8px; padding:10px 12px;
    border-bottom:1px solid var(--qws-border); cursor:move;
    background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    border-top-left-radius:12px; border-top-right-radius:12px;
  }
  .qws-win .w-title{ font-weight:700 }
  .qws-win .sp{ flex:1 }
  .qws-win .w-btn{
    cursor:pointer; border-radius:10px; border:1px solid var(--qws-border);
    padding:4px 8px; background:linear-gradient(180deg, #ffffff12, #ffffff06); color:#fff;
  }
  .qws-win .w-btn:hover{ background:linear-gradient(180deg, #ffffff18, #ffffff0a); border-color:#ffffff44 }
  .qws-win .w-body{ padding:12px }

  /* Inputs inside windows */
  .qws-win input[type="text"], .qws-win input[type="number"]{
    width:120px; padding:8px 10px; border-radius:10px;
    border:1px solid var(--qws-border); background:rgba(0,0,0,.42); color:#fff;
    box-shadow:inset 0 1px 0 rgba(255,255,255,.06);
  }
  .qws-win .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin:6px 0 }
  `;
    const st = document.createElement("style");
    st.textContent = css3;
    (document.documentElement || document.body).appendChild(st);
    const box = document.createElement("div");
    box.className = "qws2";
    box.innerHTML = `
    <div class="row drag">
      <div class="title">Arie's Mod</div>
      <div class="sp"></div>
      <span id="qws2-status-mini" class="pill warn mini">\u2026</span>
      <button id="qws2-min" class="btn" title="Minimize/Expand">\u2013</button>
      <button id="qws2-hide" class="btn" title="Hide">\u2715</button>
    </div>

    <!-- Status & store side-by-side (no mode label) -->
    <div class="row" style="margin:2px 0 2px 0;">
      <span id="qws2-status" class="pill warn">status</span>
      <span id="qws2-version" class="pill warn">\u2026</span>
    </div>

    <div class="body">
      <div id="qws-launch" class="qws-launch"></div>
    </div>
  `;
    (document.documentElement || document.body).appendChild(box);
    const setHUDHidden = (hidden) => {
      box.classList.toggle("hidden", hidden);
      try {
        writeAriesPath(HUD_HIDDEN_PATH, hidden);
      } catch {
      }
      return hidden;
    };
    const toggleHUDHidden = () => setHUDHidden(!box.classList.contains("hidden"));
    let insertDown = false;
    let insertUsedAsModifier = false;
    const KEY_TOGGLE = "gui.toggle";
    const KEY_DRAG = "gui.drag";
    const downCodes = /* @__PURE__ */ new Set();
    let toggleHotkey = getKeybind(KEY_TOGGLE);
    let dragHotkey = getKeybind(KEY_DRAG);
    let dragActive = false;
    const codeEquals = (expected, actual) => {
      if (expected === actual) return true;
      if ((expected === "AltLeft" || expected === "AltRight") && (actual === "AltLeft" || actual === "AltRight")) return true;
      if ((expected === "ControlLeft" || expected === "ControlRight") && (actual === "ControlLeft" || actual === "ControlRight")) return true;
      if ((expected === "ShiftLeft" || expected === "ShiftRight") && (actual === "ShiftLeft" || actual === "ShiftRight")) return true;
      if ((expected === "MetaLeft" || expected === "MetaRight") && (actual === "MetaLeft" || actual === "MetaRight")) return true;
      return false;
    };
    const isCodePressed = (code) => {
      for (const pressed of downCodes) {
        if (codeEquals(code, pressed)) return true;
      }
      return false;
    };
    const matchesHotkey = (e, hk) => {
      if (!hk) return false;
      if (!!hk.ctrl !== e.ctrlKey) return false;
      if (!!hk.shift !== e.shiftKey) return false;
      if (!!hk.alt !== e.altKey) return false;
      if (!!hk.meta !== e.metaKey) return false;
      return codeEquals(hk.code, e.code);
    };
    const updateDragState = () => {
      if (!dragHotkey) {
        dragActive = false;
        return;
      }
      const altDown = isCodePressed("AltLeft");
      const ctrlDown = isCodePressed("ControlLeft");
      const shiftDown = isCodePressed("ShiftLeft");
      const metaDown = isCodePressed("MetaLeft");
      if (!!dragHotkey.alt !== altDown) {
        dragActive = false;
        return;
      }
      if (!!dragHotkey.ctrl !== ctrlDown) {
        dragActive = false;
        return;
      }
      if (!!dragHotkey.shift !== shiftDown) {
        dragActive = false;
        return;
      }
      if (!!dragHotkey.meta !== metaDown) {
        dragActive = false;
        return;
      }
      dragActive = isCodePressed(dragHotkey.code);
    };
    updateDragState();
    const isInsertKey = (e) => e.code === "Insert" || e.key === "Insert";
    const isModifierActive = (e) => {
      if (dragHotkey && dragActive) return true;
      const alt = "altKey" in e && e.altKey;
      const ctrl = "ctrlKey" in e && e.ctrlKey;
      const meta = "metaKey" in e && e.metaKey;
      const shift = "shiftKey" in e && e.shiftKey;
      const insertModifier = insertDown && !alt && !ctrl && !meta;
      if (insertModifier && !shift) insertUsedAsModifier = true;
      return insertModifier && !shift;
    };
    const onInsertKey = (e) => {
      if (!isInsertKey(e)) return;
      if (e.type === "keydown") {
        if (!insertDown) insertUsedAsModifier = false;
        insertDown = true;
        return;
      }
      const target = e.target;
      const editing = !!target && (target.isContentEditable || /^(input|textarea|select)$/i.test(target.tagName));
      const usedAsModifier = insertUsedAsModifier;
      insertDown = false;
      insertUsedAsModifier = false;
      if (!usedAsModifier && !editing) {
        e.preventDefault();
        toggleHUDHidden();
      }
    };
    window.addEventListener("keydown", onInsertKey, true);
    window.addEventListener("keyup", onInsertKey, true);
    window.addEventListener("blur", () => {
      insertDown = false;
      insertUsedAsModifier = false;
      downCodes.clear();
      updateDragState();
    }, true);
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState !== "visible") {
        insertDown = false;
        insertUsedAsModifier = false;
        downCodes.clear();
        updateDragState();
      }
    });
    function clampRect(el2) {
      const rect = el2.getBoundingClientRect();
      const vw = window.innerWidth, vh = window.innerHeight;
      let r = parseFloat(getComputedStyle(el2).right) || vw - rect.right;
      let b = parseFloat(getComputedStyle(el2).bottom) || vh - rect.bottom;
      const maxRight = Math.max(MARGIN, vw - rect.width - MARGIN);
      const maxBottom = Math.max(MARGIN, vh - rect.height - MARGIN);
      r = Math.min(Math.max(r, MARGIN), maxRight);
      b = Math.min(Math.max(b, MARGIN), maxBottom);
      el2.style.right = r + "px";
      el2.style.bottom = b + "px";
    }
    function ensureOnScreen(el2) {
      clampRect(el2);
      const rect = el2.getBoundingClientRect();
      const head = el2.querySelector(".w-head");
      const hrect = head?.getBoundingClientRect() || rect;
      const vw = window.innerWidth, vh = window.innerHeight;
      const M = MARGIN;
      let r = parseFloat(getComputedStyle(el2).right);
      if (Number.isNaN(r)) r = vw - rect.right;
      let b = parseFloat(getComputedStyle(el2).bottom);
      if (Number.isNaN(b)) b = vh - rect.bottom;
      const maxRight = Math.max(M, vw - rect.width - M);
      const maxBottom = Math.max(M, vh - rect.height - M);
      if (hrect.top < M) {
        const delta = M - hrect.top;
        b = Math.max(M, Math.min(maxBottom, b - delta));
      }
      if (rect.left < M) {
        const deltaL = M - rect.left;
        r = Math.max(M, Math.min(maxRight, r - deltaL));
      }
      el2.style.right = r + "px";
      el2.style.bottom = b + "px";
    }
    function attachAutoClamp(win) {
      const anyWin = win;
      if (anyWin.__qwsClampObserver || typeof ResizeObserver === "undefined") return;
      let raf = 0;
      const ro = new ResizeObserver(() => {
        if (raf) cancelAnimationFrame(raf);
        raf = requestAnimationFrame(() => ensureOnScreen(win));
      });
      ro.observe(win);
      anyWin.__qwsClampObserver = ro;
    }
    function resetWinPosDefault(el2) {
      el2.style.right = "16px";
      el2.style.bottom = "16px";
      ensureOnScreen(el2);
    }
    function withTopLocked(el2, mutate) {
      const before = el2.getBoundingClientRect();
      const vh = window.innerHeight;
      let b = parseFloat(getComputedStyle(el2).bottom);
      if (Number.isNaN(b)) b = vh - before.bottom;
      mutate();
      requestAnimationFrame(() => {
        const after = el2.getBoundingClientRect();
        const deltaTop = after.top - before.top;
        let newBottom = b + deltaTop;
        const maxBottom = Math.max(MARGIN, vh - after.height - MARGIN);
        newBottom = Math.min(Math.max(MARGIN, newBottom), maxBottom);
        el2.style.bottom = newBottom + "px";
        ensureOnScreen(el2);
      });
    }
    function saveHUDPos() {
      try {
        const r = parseFloat(box.style.right) || 16;
        const b = parseFloat(box.style.bottom) || 16;
        writeAriesPath(HUD_POS_PATH, { r, b });
      } catch {
      }
    }
    try {
      const pos = readAriesPath(HUD_POS_PATH);
      if (pos && typeof pos.r === "number" && typeof pos.b === "number") {
        box.style.right = pos.r + "px";
        box.style.bottom = pos.b + "px";
      }
      const collapsed = readAriesPath(HUD_COLLAPSED_PATH);
      if (collapsed === true || collapsed === "1" || collapsed === 1) {
        box.classList.add("min");
        const btnMin0 = box.querySelector("#qws2-min");
        if (btnMin0) btnMin0.textContent = "+";
      }
      const hidden = readAriesPath(HUD_HIDDEN_PATH);
      if (hidden === true || hidden === "1" || hidden === 1) box.classList.add("hidden");
      requestAnimationFrame(() => clampRect(box));
      window.addEventListener("resize", () => clampRect(box));
    } catch {
    }
    const header = box.querySelector(".drag");
    const btnMin = box.querySelector("#qws2-min");
    const btnHide = box.querySelector("#qws2-hide");
    const sMini = box.querySelector("#qws2-status-mini");
    const sFull = box.querySelector("#qws2-status");
    const sVersion = box.querySelector("#qws2-version");
    const launch = box.querySelector("#qws-launch");
    if (!header || !btnMin || !btnHide || !sMini || !sFull || !sVersion || !launch) {
      console.warn("[QuinoaWS] HUD elements missing, abort init");
      return;
    }
    const launchEl = launch;
    const updateHideButtonTitle = () => {
      const pieces = [];
      if (toggleHotkey) {
        const label2 = getKeybindLabel(KEY_TOGGLE);
        if (label2 && label2 !== "\u2014") pieces.push(label2);
      }
      pieces.push("Insert");
      btnHide.title = pieces.length ? `Hide (${pieces.join(" / ")})` : "Hide";
    };
    updateHideButtonTitle();
    onKeybindChange(KEY_TOGGLE, (hk) => {
      toggleHotkey = hk;
      updateHideButtonTitle();
    });
    onKeybindChange(KEY_DRAG, (hk) => {
      dragHotkey = hk;
      updateDragState();
    });
    (function makeDraggable2() {
      let sx = 0, sy = 0, or = 0, ob = 0, down = false;
      header.addEventListener("mousedown", (e) => {
        down = true;
        sx = e.clientX;
        sy = e.clientY;
        const rect = box.getBoundingClientRect();
        or = parseFloat(getComputedStyle(box).right) || window.innerWidth - rect.right;
        ob = parseFloat(getComputedStyle(box).bottom) || window.innerHeight - rect.bottom;
        document.body.style.userSelect = "none";
      });
      window.addEventListener("mousemove", (e) => {
        if (!down) return;
        const dx = e.clientX - sx;
        const dy = e.clientY - sy;
        let r = or - dx;
        let b = ob - dy;
        const rect = box.getBoundingClientRect();
        const vw = window.innerWidth, vh = window.innerHeight;
        const maxRight = Math.max(MARGIN, vw - rect.width - MARGIN);
        const maxBottom = Math.max(MARGIN, vh - rect.height - MARGIN);
        r = Math.min(Math.max(r, MARGIN), maxRight);
        b = Math.min(Math.max(b, MARGIN), maxBottom);
        box.style.right = r + "px";
        box.style.bottom = b + "px";
      });
      window.addEventListener("mouseup", () => {
        if (!down) return;
        down = false;
        document.body.style.userSelect = "";
        saveHUDPos();
      });
    })();
    btnMin.onclick = () => {
      withTopLocked(box, () => {
        box.classList.toggle("min");
        btnMin.textContent = box.classList.contains("min") ? "+" : "\u2013";
        try {
          writeAriesPath(HUD_COLLAPSED_PATH, box.classList.contains("min"));
        } catch {
        }
      });
    };
    btnHide.onclick = () => {
      setHUDHidden(true);
    };
    window.addEventListener(
      "keydown",
      (e) => {
        downCodes.add(e.code);
        updateDragState();
        const t = e.target;
        const editing = !!t && (t.isContentEditable || /^(input|textarea|select)$/i.test(t.tagName));
        if (editing) return;
        if (e.repeat) return;
        if (matchesHotkey(e, toggleHotkey)) {
          if (insertDown && !e.altKey && !e.ctrlKey && !e.metaKey && !e.shiftKey) {
            insertUsedAsModifier = true;
          }
          e.preventDefault();
          toggleHUDHidden();
        }
      },
      true
    );
    window.addEventListener(
      "keyup",
      (e) => {
        downCodes.delete(e.code);
        updateDragState();
      },
      true
    );
    const windows = /* @__PURE__ */ new Map();
    let cascade = 0;
    function openWindow(id, title, render2) {
      if (windows.has(id)) {
        const w = windows.get(id);
        w.el.style.display = "";
        bumpZ(w.el);
        setLaunchState(id, true);
        return;
      }
      const win = document.createElement("div");
      win.className = "qws-win";
      win.innerHTML = `
      <div class="w-head">
        <div class="w-title"></div>
        <div class="sp"></div>
        <button class="w-btn" data-act="min" title="Minimize/Expand">\u2013</button>
        <button class="w-btn" data-act="close" title="Close">\u2715</button>
      </div>
      <div class="w-body"></div>
    `;
      (document.documentElement || document.body).appendChild(win);
      const head = win.querySelector(".w-head");
      const titleEl = win.querySelector(".w-title");
      const btnMin2 = win.querySelector('[data-act="min"]');
      const btnClose = win.querySelector('[data-act="close"]');
      const body = win.querySelector(".w-body");
      titleEl.textContent = title;
      const offset = cascade++ % 5 * 24;
      win.style.right = 16 + offset + "px";
      win.style.bottom = 16 + offset + "px";
      clampRect(win);
      bumpZ(win);
      (function dragWin() {
        let sx = 0, sy = 0, or = 0, ob = 0, down = false;
        head.addEventListener("mousedown", (e) => {
          const t = e.target;
          if (t.closest(".w-btn")) return;
          down = true;
          sx = e.clientX;
          sy = e.clientY;
          const rect = win.getBoundingClientRect();
          or = parseFloat(getComputedStyle(win).right) || window.innerWidth - rect.right;
          ob = parseFloat(getComputedStyle(win).bottom) || window.innerHeight - rect.bottom;
          document.body.style.userSelect = "none";
          bumpZ(win);
        });
        window.addEventListener("mousemove", (e) => {
          if (!down) return;
          const dx = e.clientX - sx;
          const dy = e.clientY - sy;
          let r = or - dx;
          let b = ob - dy;
          const rect = win.getBoundingClientRect();
          const vw = window.innerWidth, vh = window.innerHeight;
          const maxRight = Math.max(MARGIN, vw - rect.width - MARGIN);
          const maxBottom = Math.max(MARGIN, vh - rect.height - MARGIN);
          r = Math.min(Math.max(r, MARGIN), maxRight);
          b = Math.min(Math.max(b, MARGIN), maxBottom);
          win.style.right = r + "px";
          win.style.bottom = b + "px";
        });
        window.addEventListener("mouseup", () => {
          down = false;
          document.body.style.userSelect = "";
          saveWinPos(id, win);
        });
      })();
      btnMin2.onclick = () => {
        withTopLocked(win, () => {
          const hidden = body.style.display === "none";
          body.style.display = hidden ? "" : "none";
          btnMin2.textContent = hidden ? "\u2013" : "+";
        });
      };
      btnClose.onclick = () => {
        win.style.display = "none";
        setLaunchState(id, false);
      };
      patchInputsKeyTrap(win);
      try {
        render2(body);
      } catch (e) {
        body.textContent = String(e);
      }
      attachAutoClamp(win);
      requestAnimationFrame(() => ensureOnScreen(win));
      saveWinPos(id, win);
      windows.set(id, { id, el: win, head, body });
      setLaunchState(id, true);
    }
    function isShown(el2) {
      return el2.style.display !== "none";
    }
    function toggleWindow(id, title, render2) {
      const existing = windows.get(id);
      if (!existing) {
        openWindow(id, title, (root) => {
          const el2 = root.closest(".qws-win");
          if (el2) restoreWinPos(id, el2);
          render2(root);
        });
        return true;
      } else {
        if (isShown(existing.el)) {
          existing.el.style.display = "none";
          setLaunchState(id, false);
          return false;
        } else {
          existing.el.style.display = "";
          bumpZ(existing.el);
          ensureOnScreen(existing.el);
          setLaunchState(id, true);
          return true;
        }
      }
    }
    function bumpZ(el2) {
      let maxZ = Z_BASE + 1;
      windows.forEach((w) => {
        const z = parseInt(getComputedStyle(w.el).zIndex || String(Z_BASE + 1), 10);
        if (z > maxZ) maxZ = z;
      });
      el2.style.zIndex = String(maxZ + 1);
    }
    function saveWinPos(id, el2) {
      try {
        const r = parseFloat(el2.style.right) || 16;
        const b = parseFloat(el2.style.bottom) || 16;
        writeAriesPath(HUD_WIN_PATH(id), { r, b });
      } catch {
      }
    }
    function restoreWinPos(id, el2) {
      try {
        const pos = readAriesPath(HUD_WIN_PATH(id));
        if (pos && typeof pos.r === "number") el2.style.right = pos.r + "px";
        if (pos && typeof pos.b === "number") el2.style.bottom = pos.b + "px";
        ensureOnScreen(el2);
      } catch {
      }
    }
    window.addEventListener("resize", () => {
      windows.forEach((w) => ensureOnScreen(w.el));
    });
    function enableAltDragAnywhere() {
      let st2 = null;
      const pickRoot = (node) => {
        const el2 = node;
        if (!el2) return null;
        return el2.closest?.(".qws-win, .qws2") || null;
      };
      const onDown = (e) => {
        if (!isModifierActive(e) || e.button !== 0) return;
        const root = pickRoot(e.target);
        if (!root || root.style.display === "none") return;
        const rect = root.getBoundingClientRect();
        const vw = window.innerWidth, vh = window.innerHeight;
        let or = parseFloat(getComputedStyle(root).right);
        let ob = parseFloat(getComputedStyle(root).bottom);
        if (Number.isNaN(or)) or = vw - rect.right;
        if (Number.isNaN(ob)) ob = vh - rect.bottom;
        st2 = { el: root, sx: e.clientX, sy: e.clientY, or, ob };
        document.body.style.userSelect = "none";
        bumpZ(root);
        e.preventDefault();
        e.stopPropagation();
      };
      const onMove = (e) => {
        if (!st2) return;
        const dx = e.clientX - st2.sx;
        const dy = e.clientY - st2.sy;
        let r = st2.or - dx;
        let b = st2.ob - dy;
        const rect = st2.el.getBoundingClientRect();
        const vw = window.innerWidth, vh = window.innerHeight;
        const maxRight = Math.max(MARGIN, vw - rect.width - MARGIN);
        const maxBottom = Math.max(MARGIN, vh - rect.height - MARGIN);
        r = Math.min(Math.max(r, MARGIN), maxRight);
        b = Math.min(Math.max(b, MARGIN), maxBottom);
        st2.el.style.right = `${r}px`;
        st2.el.style.bottom = `${b}px`;
      };
      const stopDrag = () => {
        if (!st2) return;
        document.body.style.userSelect = "";
        clampRect(st2.el);
        const el2 = st2.el;
        let saved = false;
        windows.forEach((w) => {
          if (w.el === el2 && !saved) {
            saveWinPos(w.id, el2);
            saved = true;
          }
        });
        if (!saved && el2 === box) saveHUDPos();
        st2 = null;
      };
      const onUp = () => stopDrag();
      const onKeyUp = (e) => {
        if (!dragHotkey) {
          stopDrag();
          return;
        }
        if (matchesHotkey(e, dragHotkey) || !dragActive) {
          stopDrag();
        }
      };
      window.addEventListener("mousedown", onDown, true);
      window.addEventListener("mousemove", onMove, true);
      window.addEventListener("mouseup", onUp, true);
      window.addEventListener("keyup", onKeyUp, true);
    }
    function patchInputsKeyTrap(scope) {
      const isEditable = (el2) => {
        if (!el2 || !(el2 instanceof HTMLElement)) return false;
        if (el2 instanceof HTMLTextAreaElement) return true;
        if (el2 instanceof HTMLInputElement) {
          const t = (el2.type || "").toLowerCase();
          return t === "text" || t === "number" || t === "search";
        }
        return el2.isContentEditable === true;
      };
      const handler = (ev) => {
        const target = ev.target;
        const active = document.activeElement;
        const inScope = (node) => !!(node && (scope.contains(node) || node.closest?.(".qws-win") || node.closest?.(".qws2")));
        if (!(inScope(target) && isEditable(target) || inScope(active) && isEditable(active))) return;
        ev.stopPropagation();
        ev.stopImmediatePropagation?.();
      };
      const types = ["keydown", "keypress", "keyup"];
      types.forEach((t) => {
        window.addEventListener(t, handler, { capture: true });
        document.addEventListener(t, handler, { capture: true });
        scope.addEventListener(t, handler, { capture: true });
      });
      return () => {
        types.forEach((t) => {
          window.removeEventListener(t, handler, { capture: true });
          document.removeEventListener(t, handler, { capture: true });
          scope.removeEventListener(t, handler, { capture: true });
        });
      };
    }
    const registry2 = [];
    const launchButtons = /* @__PURE__ */ new Map();
    function setLaunchState(id, open) {
      const btn = launchButtons.get(id);
      if (!btn) return;
      btn.textContent = open ? "Close" : "Open";
      btn.dataset.open = open ? "1" : "0";
      if (open) btn.classList.add("active");
      else btn.classList.remove("active");
    }
    function register(id, title, render2) {
      registry2.push({ id, title, render: render2 });
      addLaunchItem(id, title, render2);
    }
    function addLaunchItem(id, title, render2) {
      const item = document.createElement("div");
      item.className = "launch-item";
      item.innerHTML = `<div class="name">${escapeHtml2(title)}</div>`;
      const openBtn = document.createElement("button");
      openBtn.className = "btn";
      openBtn.textContent = "Open";
      openBtn.dataset.open = "0";
      launchButtons.set(id, openBtn);
      openBtn.onclick = () => {
        const w = windows.get(id);
        if (w && w.el.style.display !== "none") {
          w.el.style.display = "none";
          setLaunchState(id, false);
        } else {
          openWindow(id, title, (root) => {
            const el2 = root.closest(".qws-win");
            if (el2) restoreWinPos(id, el2);
            render2(root);
          });
          setLaunchState(id, true);
        }
      };
      item.appendChild(openBtn);
      launch.appendChild(item);
    }
    try {
      opts?.onRegister?.(register);
    } catch {
    }
    patchInputsKeyTrap(box);
    enableAltDragAnywhere();
    (function initVersionBadge() {
      const setBadge = (text, cls) => {
        sVersion.textContent = text;
        tag(sVersion, cls);
      };
      const setDownloadTarget = (url) => {
        if (url) {
          sVersion.dataset.download = url;
          sVersion.style.cursor = "pointer";
          sVersion.title = `Download the new version`;
        } else {
          delete sVersion.dataset.download;
          sVersion.style.removeProperty("cursor");
          sVersion.removeAttribute("title");
        }
      };
      setBadge("checking\u2026", "warn");
      setDownloadTarget(null);
      const openDownloadLink = (url) => {
        const shouldUseGM = isDiscordSurface();
        const gmObject = globalThis.GM;
        const gmOpen = typeof GM_openInTab === "function" ? GM_openInTab : typeof gmObject?.openInTab === "function" ? gmObject.openInTab.bind(gmObject) : null;
        if (shouldUseGM && gmOpen) {
          try {
            gmOpen(url, { active: true, setParent: true });
            return;
          } catch (error) {
            console.warn("[MagicGarden] GM_openInTab failed, falling back to window.open", error);
          }
        }
        window.open(url, "_blank", "noopener,noreferrer");
      };
      sVersion.addEventListener("click", () => {
        const url = sVersion.dataset.download;
        if (url) {
          openDownloadLink(url);
        }
      });
      (async () => {
        const localVersion = getLocalVersion();
        try {
          const remoteData = await fetchRemoteVersion();
          const remoteVersion = remoteData?.version?.trim();
          if (!remoteVersion) {
            if (localVersion) {
              setBadge(localVersion, "warn");
            } else {
              setBadge("version inconnue", "warn");
            }
            return;
          }
          if (!localVersion) {
            setBadge(remoteVersion, "warn");
            setDownloadTarget(remoteData?.download || null);
            return;
          }
          if (localVersion === remoteVersion) {
            setBadge(localVersion, "ok");
            setDownloadTarget(null);
            return;
          }
          setBadge(`${localVersion} \u2192 ${remoteVersion}`, "warn");
          setDownloadTarget(remoteData?.download || null);
        } catch (error) {
          console.error("[MagicGarden] Failed to check version:", error);
          if (localVersion) {
            setBadge(localVersion, "warn");
          } else {
            setBadge("Unknown", "warn");
          }
        }
      })();
    })();
    (async () => {
      try {
        await ensureStore();
      } catch {
      }
    })();
    let warmupState2 = getSpriteWarmupState();
    const updateStatus = () => {
      if (!warmupState2.completed) {
        const total = warmupState2.total;
        const done = warmupState2.done;
        const progressText = total > 0 ? `${done}/${total}` : `${done}`;
        const summary2 = total > 0 ? `Sprites warming: ${progressText}` : "Sprites warming up";
        sFull.textContent = `Sprites ${progressText}`;
        sFull.title = summary2;
        tag(sFull, "warn");
        sFull.style.display = "";
        sMini.textContent = progressText;
        sMini.title = summary2;
        tag(sMini, "warn");
        sMini.style.display = "";
        return;
      }
      const wsStatus = getWSStatus();
      const storeStatus = getStoreStatus();
      const isStoreMissing = storeStatus.message === "store none";
      const isWsMissing = wsStatus.level === "bad";
      const level = isStoreMissing && isWsMissing ? "bad" : wsStatus.level === "ok" && storeStatus.level === "ok" ? "ok" : "warn";
      const summary = `${wsStatus.message}, ${storeStatus.message}`;
      sFull.textContent = "status";
      sFull.title = summary;
      tag(sFull, level);
      sFull.style.display = "";
      const miniText = level === "ok" ? "OK" : level === "warn" ? "WARN" : "ISSUES";
      sMini.textContent = miniText;
      sMini.title = summary;
      tag(sMini, level);
      if (level === "ok") {
        sMini.style.display = "none";
      } else {
        sMini.style.display = "";
      }
    };
    const offWarmup = onSpriteWarmupProgress((state3) => {
      warmupState2 = state3;
      updateStatus();
    });
    setInterval(updateStatus, 800);
    function getOpenPageWS() {
      for (let i = 0; i < sockets.length; i++) {
        if (sockets[i].readyState === NativeWS.OPEN) return sockets[i];
      }
      throw new Error("no page ws");
    }
    function getWSStatus() {
      try {
        getOpenPageWS();
        return { level: "ok", message: "ws open" };
      } catch {
        const viaWorker = !!window.__QWS_workerFound || workerFound;
        if (viaWorker) {
          return { level: "ok", message: "ws via worker" };
        }
        return { level: "bad", message: "ws none" };
      }
    }
    function getStoreStatus() {
      try {
        const captured = isStoreCaptured();
        const info = getCapturedInfo();
        if (captured) {
          return { level: "ok", message: `store ${info.via || "ready"}` };
        }
        if (info.via === "polyfill" || info.polyfill) {
          return { level: "warn", message: "store polyfill" };
        }
        return { level: "bad", message: "store none" };
      } catch {
        return { level: "bad", message: "store error" };
      }
    }
    function tag(el2, cls) {
      el2.classList.remove("ok", "warn", "bad");
      if (cls) el2.classList.add(cls);
    }
    box.__cleanup__ = (() => {
      const prev = box.__cleanup__;
      return () => {
        offWarmup?.();
        if (typeof prev === "function") prev();
      };
    })();
    function escapeHtml2(s) {
      return s.replace(/[&<>"']/g, (m) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" })[m]);
    }
  }
  function initWatchers() {
    installShopKeybindsOnce();
    installSellKeybindsOnce();
    installPetHutchKeybindsOnce();
    installGameKeybindsOnce();
    installJournalKeybindsOnce();
    installSeedSiloKeybindsOnce();
    installDecorShedKeybindsOnce();
    (async () => {
      try {
        await renderOverlay();
      } catch (e) {
        console.error("[HUD] renderOverlay failed:", e);
      }
      try {
        await renderCommunityHub();
      } catch (e) {
        console.error("[HUD] renderCommunityHub failed:", e);
      }
    })();
    (async () => {
      try {
        await PetAlertService.start();
      } catch {
      }
      try {
        setTeamsForHotkeys(PetsService.getTeams());
      } catch {
      }
      try {
        await PetsService.onTeamsChangeNow((teams) => {
          try {
            setTeamsForHotkeys(teams);
          } catch {
          }
        });
      } catch {
      }
      try {
        installPetTeamHotkeysOnce(async (teamId) => {
          try {
            await PetsService.useTeam(teamId);
          } catch (e) {
            console.warn("[Pets] hotkey useTeam failed:", e);
          }
        });
      } catch {
      }
      try {
        await PetsService.startAbilityLogsWatcher();
      } catch {
      }
      try {
        await startActivityLogHistoryWatcher();
      } catch {
      }
      startActivityLogFilter();
      setupBuyAll();
      startReorderObserver();
      startCropValuesObserverFromGardenAtom();
      startSellCropsLockWatcher();
      startDecorPickupLockIndicator();
      startEggHatchLockIndicator();
      startInjectSellAllPets();
      startPetPanelEnhancer();
      startSelectedInventoryQuantityLogger();
      startInventorySortingObserver();
      startModalObserver({ intervalMs: 6e4, log: true });
    })();
  }

  // src/ui/menus/debug-data-shared.ts
  function setBtnLabel(btn, text) {
    const label2 = btn.querySelector(".label");
    if (label2) label2.textContent = text;
    else btn.textContent = text;
  }
  function toast(msg, type = "warn") {
    try {
      window.toastSimple?.(msg, "", type);
    } catch {
    }
  }
  function createTwoColumns(view) {
    const columns = document.createElement("div");
    columns.className = "dd-debug-columns";
    view.appendChild(columns);
    const leftCol = document.createElement("div");
    leftCol.className = "dd-debug-column";
    const rightCol = document.createElement("div");
    rightCol.className = "dd-debug-column";
    columns.append(leftCol, rightCol);
    return { columns, leftCol, rightCol };
  }
  function copy(text) {
    const str = String(text ?? "");
    if (!str.length) return;
    const fallback = () => {
      const ta = document.createElement("textarea");
      ta.value = str;
      ta.setAttribute("readonly", "true");
      ta.style.position = "fixed";
      ta.style.left = "-9999px";
      ta.style.opacity = "0";
      document.body.appendChild(ta);
      ta.focus();
      ta.select();
      let ok = false;
      try {
        ok = document.execCommand("copy");
      } catch {
      }
      document.body.removeChild(ta);
      try {
        window.toastSimple?.(ok ? "Copied" : "Copy failed", "", ok ? "success" : "error");
      } catch {
      }
    };
    if (window.isSecureContext && navigator.clipboard?.writeText) {
      navigator.clipboard.writeText(str).then(() => {
        try {
          window.toastSimple?.("Copied", "", "success");
        } catch {
        }
      }).catch(fallback);
    } else {
      fallback();
    }
  }
  function safeRegex(q) {
    try {
      return new RegExp(q, "i");
    } catch {
      return /.*/i;
    }
  }
  function stylePre(pre) {
    pre.style.maxHeight = "260px";
    pre.style.overflow = "auto";
    pre.style.background = "#0b1016";
    pre.style.border = "1px solid #ffffff18";
    pre.style.borderRadius = "12px";
    pre.style.padding = "12px";
    pre.style.margin = "6px 0 0";
    pre.style.fontSize = "12px";
    pre.style.lineHeight = "1.5";
    pre.style.color = "#dbe4ff";
    pre.style.boxShadow = "inset 0 1px 0 rgba(255,255,255,.04)";
  }

  // src/ui/menus/debug-data-audio.ts
  function renderAudioPlayerTab(view, ui) {
    view.innerHTML = "";
    view.classList.add("dd-debug-view");
    const { leftCol, rightCol } = createTwoColumns(view);
    let infoList = [];
    let groupEntries = [];
    let visibleSounds = [];
    const overviewCard = ui.card("\u{1F3A7} Audio player", {
      tone: "muted",
      subtitle: "Inspect detected sounds, auto groups and Howler status."
    });
    leftCol.appendChild(overviewCard.root);
    const summary = document.createElement("div");
    summary.className = "dd-audio-summary";
    const summarySounds = document.createElement("div");
    const summaryGroups = document.createElement("div");
    const summarySources = document.createElement("div");
    summary.append(summarySounds, summaryGroups, summarySources);
    const volumeLine = document.createElement("div");
    volumeLine.className = "dd-audio-volume";
    const finalLine = document.createElement("div");
    finalLine.className = "dd-audio-volume";
    const overviewError = ui.errorBar();
    const actionsRow = ui.flexRow({ gap: 10, wrap: true, fullWidth: true });
    const btnScan = ui.btn("Rescan sounds", {
      icon: "\u{1F504}",
      variant: "primary",
      onClick: () => {
        void refreshAll({ rescan: true });
      }
    });
    const btnRefresh = ui.btn("Refresh snapshot", {
      icon: "\u{1F501}",
      onClick: () => {
        void refreshAll();
      }
    });
    const btnCopyJson = ui.btn("Copy JSON", {
      icon: "\u{1F4CB}",
      onClick: () => copy(audioPlayer.exportJSON())
    });
    actionsRow.append(btnScan, btnRefresh, btnCopyJson);
    overviewCard.body.append(summary, volumeLine, finalLine, overviewError.el, actionsRow);
    const groupsCard = ui.card("\u{1F39B}\uFE0F Groups", {
      tone: "muted",
      subtitle: "Browse auto-generated groups and play random variations."
    });
    leftCol.appendChild(groupsCard.root);
    const groupToolbar = ui.flexRow({ gap: 10, wrap: true, fullWidth: true });
    const groupFilter = ui.inputText("filter groups (regex)", "");
    groupFilter.classList.add("dd-grow");
    const btnGroupClear = ui.btn("Clear", {
      icon: "\u{1F9F9}",
      onClick: () => {
        groupFilter.value = "";
        renderGroups();
        groupFilter.focus();
      }
    });
    groupToolbar.append(groupFilter, btnGroupClear);
    const groupInfo = document.createElement("p");
    groupInfo.className = "dd-card-description";
    groupInfo.style.margin = "0";
    const groupList = document.createElement("div");
    groupList.className = "dd-audio-list";
    const groupEmpty = document.createElement("div");
    groupEmpty.className = "dd-audio-empty";
    groupEmpty.textContent = "No groups match the current filter.";
    groupsCard.body.append(groupToolbar, groupInfo, groupList, groupEmpty);
    const soundsCard = ui.card("\u{1F509} Sounds", {
      tone: "muted",
      subtitle: "Inspect detected files and trigger playback."
    });
    rightCol.appendChild(soundsCard.root);
    const soundToolbar = ui.flexRow({ gap: 10, wrap: true, fullWidth: true });
    const soundFilter = ui.inputText("filter sounds (regex)", "");
    soundFilter.classList.add("dd-grow");
    const btnSoundClear = ui.btn("Clear", {
      icon: "\u{1F9F9}",
      onClick: () => {
        soundFilter.value = "";
        renderSounds();
        soundFilter.focus();
      }
    });
    const btnCopyVisible = ui.btn("Copy visible URLs", {
      icon: "\u{1F4CB}",
      onClick: () => {
        if (!visibleSounds.length) return;
        copy(visibleSounds.map((s) => s.url).join("\n"));
      }
    });
    soundToolbar.append(soundFilter, btnSoundClear, btnCopyVisible);
    const soundInfo = document.createElement("p");
    soundInfo.className = "dd-card-description";
    soundInfo.style.margin = "0";
    const soundList = document.createElement("div");
    soundList.className = "dd-audio-list";
    const soundEmpty = document.createElement("div");
    soundEmpty.className = "dd-audio-empty";
    soundEmpty.textContent = "No sounds match the current filter.";
    soundsCard.body.append(soundToolbar, soundInfo, soundList, soundEmpty);
    groupFilter.addEventListener("input", () => renderGroups());
    groupFilter.addEventListener("keydown", (ev) => {
      if (ev.key === "Enter") {
        ev.preventDefault();
        renderGroups();
      }
    });
    soundFilter.addEventListener("input", () => renderSounds());
    soundFilter.addEventListener("keydown", (ev) => {
      if (ev.key === "Enter") {
        ev.preventDefault();
        renderSounds();
      }
    });
    let busy = false;
    function labelForSound(info) {
      return info.logicalName || info.name || fileNameFromUrl(info.url);
    }
    function fileNameFromUrl(url) {
      try {
        return new URL(url, location.href).pathname.split("/").pop() || url;
      } catch {
        return url;
      }
    }
    function formatNumber(value, digits = 3) {
      return value == null || Number.isNaN(value) || !Number.isFinite(value) ? "\u2014" : value.toFixed(digits);
    }
    function setButtonEnabled(btn, enabled) {
      const setter = btn.setEnabled;
      if (typeof setter === "function") setter(enabled);
      else btn.disabled = !enabled;
    }
    const scanLabel = btnScan.querySelector(".label");
    const defaultScanText = scanLabel?.textContent ?? "Rescan sounds";
    function setScanButtonLoading(loading) {
      setButtonEnabled(btnScan, !loading);
      if (scanLabel) scanLabel.textContent = loading ? "Scanning\u2026" : defaultScanText;
    }
    function refreshData() {
      infoList = audioPlayer.info().slice().sort((a, b) => labelForSound(a).localeCompare(labelForSound(b)));
      groupEntries = Object.entries(audioPlayer.groups()).sort((a, b) => a[0].localeCompare(b[0]));
    }
    function updateOverview() {
      const sources = /* @__PURE__ */ new Set();
      infoList.forEach((info) => {
        (info.sources || "").split(",").map((s) => s.trim()).filter(Boolean).forEach((src) => sources.add(src));
      });
      const vol = audioPlayer.getGameSfxVolume();
      const howlerGlobal = window?.Howler;
      let howlerMaster = null;
      try {
        if (howlerGlobal && typeof howlerGlobal.volume === "function") {
          const val = howlerGlobal.volume();
          if (typeof val === "number" && Number.isFinite(val)) howlerMaster = val;
        }
      } catch {
      }
      const howlerCount = Array.isArray(howlerGlobal?._howls) ? howlerGlobal._howls.length : 0;
      summarySounds.innerHTML = `<strong>${infoList.length}</strong> sounds detected`;
      summaryGroups.innerHTML = `<strong>${groupEntries.length}</strong> auto groups`;
      summarySources.innerHTML = `<strong>${sources.size}</strong> unique source tags`;
      volumeLine.textContent = `Atom raw: ${formatNumber(vol.raw)} (clamped ${formatNumber(vol.clamped)})`;
      let suffix = "";
      if (howlerMaster != null) {
        suffix = ` \xB7 Howler master ${formatNumber(howlerMaster)}`;
        if (howlerCount) suffix += ` (${howlerCount} howl${howlerCount === 1 ? "" : "s"})`;
      } else if (howlerCount) {
        suffix = ` \xB7 ${howlerCount} howl${howlerCount === 1 ? "" : "s"} registered`;
      }
      finalLine.textContent = `Final output volume: ${formatNumber(vol.vol)}${suffix}`;
    }
    function renderGroups() {
      const rx = safeRegex(groupFilter.value.trim() || ".*");
      const infoByUrl = new Map(infoList.map((info) => [info.url, info]));
      groupList.innerHTML = "";
      let visible = 0;
      const matches = (value) => !!value && rx.test(value);
      for (const [name, urls] of groupEntries) {
        const include = matches(name) || urls.some((url) => {
          const info = infoByUrl.get(url);
          return matches(url) || matches(info?.logicalName) || matches(info?.name);
        });
        if (!include) continue;
        visible++;
        const sampleUrl = urls[0] || "";
        const sampleInfo = infoByUrl.get(sampleUrl);
        const row = document.createElement("div");
        row.className = "dd-audio-row";
        const infoWrap = document.createElement("div");
        infoWrap.className = "dd-audio-row__info";
        const title = document.createElement("div");
        title.className = "dd-audio-row__title";
        title.textContent = name;
        const meta = document.createElement("div");
        meta.className = "dd-audio-meta";
        const parts = [];
        parts.push(`${urls.length} variation${urls.length === 1 ? "" : "s"}`);
        if (sampleInfo?.name) parts.push(`Sample: ${sampleInfo.name}`);
        if (sampleInfo?.sources) parts.push(`Sources: ${sampleInfo.sources}`);
        meta.textContent = parts.join(" \u2022 ");
        const urlEl = document.createElement("div");
        urlEl.className = "dd-audio-url";
        urlEl.textContent = sampleUrl || "(no sample)";
        infoWrap.append(title, meta, urlEl);
        row.appendChild(infoWrap);
        const actions = ui.flexRow({ gap: 6, wrap: false, align: "center" });
        actions.className = "dd-audio-actions";
        const playBtn = ui.btn("Play", {
          icon: "\u25B6\uFE0F",
          size: "sm",
          onClick: () => {
            audioPlayer.playGroup(name, { random: true });
          }
        });
        const copyBtn = ui.btn("Copy URLs", {
          icon: "\u{1F4CB}",
          size: "sm",
          onClick: () => copy(urls.join("\n"))
        });
        const openBtn = sampleUrl ? ui.btn("Open", {
          icon: "\u{1F517}",
          size: "sm",
          onClick: () => {
            try {
              window.open(sampleUrl, "_blank", "noopener,noreferrer");
            } catch {
            }
          }
        }) : null;
        actions.append(playBtn, copyBtn);
        if (openBtn) actions.append(openBtn);
        row.appendChild(actions);
        groupList.appendChild(row);
      }
      groupInfo.textContent = groupEntries.length ? `${visible} / ${groupEntries.length} groups shown.` : "No groups have been detected yet. Run a rescan to populate the cache.";
      groupList.style.display = visible ? "" : "none";
      groupEmpty.textContent = groupEntries.length ? "No groups match the current filter." : "No groups detected yet. Run a rescan to populate the cache.";
      groupEmpty.style.display = visible ? "none" : "block";
      setButtonEnabled(btnGroupClear, groupFilter.value.trim().length > 0);
    }
    function renderSounds() {
      const rx = safeRegex(soundFilter.value.trim() || ".*");
      visibleSounds = [];
      soundList.innerHTML = "";
      const matches = (value) => !!value && rx.test(value);
      for (const info of infoList) {
        if (!(matches(info.logicalName) || matches(info.name) || matches(info.sources) || matches(info.url))) continue;
        visibleSounds.push(info);
        const row = document.createElement("div");
        row.className = "dd-audio-row";
        const infoWrap = document.createElement("div");
        infoWrap.className = "dd-audio-row__info";
        const title = document.createElement("div");
        title.className = "dd-audio-row__title";
        title.textContent = labelForSound(info);
        const meta = document.createElement("div");
        meta.className = "dd-audio-meta";
        const parts = [];
        if (info.name && info.name !== info.logicalName) parts.push(`File: ${info.name}`);
        if (info.logicalName) parts.push(`Logical: ${info.logicalName}`);
        if (info.sources) parts.push(`Sources: ${info.sources}`);
        meta.textContent = parts.join(" \u2022 ");
        const urlEl = document.createElement("div");
        urlEl.className = "dd-audio-url";
        urlEl.textContent = info.url;
        infoWrap.append(title, meta, urlEl);
        row.appendChild(infoWrap);
        const actions = ui.flexRow({ gap: 6, wrap: false, align: "center" });
        actions.className = "dd-audio-actions";
        const playBtn = ui.btn("Play", {
          icon: "\u25B6\uFE0F",
          size: "sm",
          onClick: () => {
            audioPlayer.playUrl(info.url);
          }
        });
        const copyBtn = ui.btn("Copy", {
          icon: "\u{1F4CB}",
          size: "sm",
          onClick: () => copy(info.url)
        });
        const openBtn = ui.btn("Open", {
          icon: "\u{1F517}",
          size: "sm",
          onClick: () => {
            try {
              window.open(info.url, "_blank", "noopener,noreferrer");
            } catch {
            }
          }
        });
        actions.append(playBtn, copyBtn, openBtn);
        row.appendChild(actions);
        soundList.appendChild(row);
      }
      soundInfo.textContent = infoList.length ? `${visibleSounds.length} / ${infoList.length} sounds shown.` : "No sounds have been detected yet. Run a rescan to populate the cache.";
      soundList.style.display = visibleSounds.length ? "" : "none";
      soundEmpty.textContent = infoList.length ? "No sounds match the current filter." : "No sounds detected yet. Run a rescan to populate the cache.";
      soundEmpty.style.display = visibleSounds.length ? "none" : "block";
      setButtonEnabled(btnCopyVisible, visibleSounds.length > 0);
      setButtonEnabled(btnSoundClear, soundFilter.value.trim().length > 0);
    }
    async function refreshAll(opts = {}) {
      if (busy) return;
      busy = true;
      const { rescan = false } = opts;
      overviewError.clear();
      if (rescan) setScanButtonLoading(true);
      else setButtonEnabled(btnScan, false);
      setButtonEnabled(btnRefresh, false);
      let scanError = null;
      try {
        if (rescan) {
          try {
            await audioPlayer.scan();
          } catch (err) {
            scanError = err;
          }
        }
        refreshData();
        updateOverview();
        renderGroups();
        renderSounds();
        if (scanError) {
          const message = scanError instanceof Error ? scanError.message : String(scanError);
          overviewError.show(`Scan failed: ${message}`);
          console.error("[debug] audio scan failed", scanError);
        }
      } finally {
        if (rescan) setScanButtonLoading(false);
        else setButtonEnabled(btnScan, true);
        setButtonEnabled(btnRefresh, true);
        busy = false;
      }
    }
    void refreshAll();
  }

  // src/ui/menus/debug-data-jotai.ts
  init_jotai();
  function renderJotaiTab(view, ui) {
    view.innerHTML = "";
    view.classList.add("dd-debug-view");
    const { leftCol, rightCol } = createTwoColumns(view);
    {
      const card2 = ui.card("\u{1F5C4}\uFE0F Capture store", {
        tone: "muted",
        subtitle: "Initialize the Jotai store so atoms can be inspected."
      });
      leftCol.appendChild(card2.root);
      const status = document.createElement("span");
      status.className = "dd-status-chip";
      const refreshStatus = () => {
        const captured = isStoreCaptured();
        status.textContent = captured ? "Store captured" : "Store not captured";
        status.classList.toggle("is-ok", captured);
        status.classList.toggle("is-warn", !captured);
      };
      refreshStatus();
      const actions = ui.flexRow({ gap: 10, align: "center", wrap: true });
      const btnCap = ui.btn("Capture store", {
        variant: "primary",
        icon: "\u23FA",
        onClick: async () => {
          try {
            await ensureStore();
          } catch {
          }
          refreshStatus();
        }
      });
      actions.append(btnCap, status);
      card2.body.appendChild(actions);
    }
    {
      const card2 = ui.card("\u{1F50D} Explore atoms", {
        tone: "muted",
        subtitle: "Filter labels using a regular expression."
      });
      leftCol.appendChild(card2.root);
      const queryRow = ui.flexRow({ gap: 10, wrap: true, fullWidth: true });
      const q = ui.inputText("regex label (ex: position|health)", "");
      q.classList.add("dd-grow");
      const btnList = ui.btn("List", { icon: "\u{1F4C4}", onClick: () => doList() });
      const btnCopy = ui.btn("Copy", { icon: "\u{1F4CB}", onClick: () => copy(pre.textContent || "") });
      queryRow.append(q, btnList, btnCopy);
      const pre = document.createElement("pre");
      stylePre(pre);
      pre.style.minHeight = "140px";
      async function doList() {
        const raw = q.value.trim();
        const rx = safeRegex(raw || ".*");
        const all = findAtomsByLabel(/.*/);
        const atoms = all.filter((a) => rx.test(String(a?.debugLabel || a?.label || "")));
        const labels = atoms.map((a) => String(a?.debugLabel || a?.label || "<?>"));
        pre.textContent = labels.join("\n");
      }
      card2.body.append(queryRow, pre);
    }
    {
      const card2 = ui.card("\u{1F9ED} Inspect an atom", {
        tone: "muted",
        subtitle: "Get the current value or subscribe to updates."
      });
      rightCol.appendChild(card2.root);
      const controls = ui.flexRow({ gap: 10, wrap: true, fullWidth: true });
      const q = ui.inputText("atom label (ex: positionAtom)", "");
      q.classList.add("dd-grow");
      const pre = document.createElement("pre");
      stylePre(pre);
      pre.style.minHeight = "160px";
      let unsubRef = null;
      const btnGet = ui.btn("Get", {
        icon: "\u{1F441}",
        onClick: async () => {
          const atom = getAtomByLabel(q.value.trim());
          if (!atom) {
            pre.textContent = `Atom "${q.value}" not found`;
            return;
          }
          try {
            setText(pre, await jGet(atom));
          } catch (e) {
            setText(pre, e?.message || String(e));
          }
        }
      });
      const btnSub = ui.btn("Subscribe", {
        icon: "\u{1F514}",
        onClick: async () => {
          const label2 = q.value.trim();
          if (!label2) return;
          const atom = getAtomByLabel(label2);
          if (!atom) {
            pre.textContent = `Atom "${label2}" not found`;
            return;
          }
          if (unsubRef) {
            unsubRef();
            unsubRef = null;
            btnSub.textContent = "Subscribe";
            return;
          }
          unsubRef = await jSub(atom, async () => {
            try {
              setText(pre, await jGet(atom));
            } catch {
            }
          });
          btnSub.textContent = "Unsubscribe";
        }
      });
      const btnCopy = ui.btn("Copy", { icon: "\u{1F4CB}", onClick: () => copy(pre.textContent || "") });
      controls.append(q, btnGet, btnSub, btnCopy);
      const note = document.createElement("p");
      note.className = "dd-inline-note";
      note.textContent = "Tip: subscriptions keep the value updated after each mutation.";
      card2.body.append(controls, note, pre);
    }
    {
      const card2 = ui.card("\u270F\uFE0F Update an atom", {
        tone: "muted",
        subtitle: "Publish a new value (JSON)."
      });
      rightCol.appendChild(card2.root);
      const controls = ui.flexRow({ gap: 10, wrap: true, fullWidth: true });
      const q = ui.inputText("atom label (ex: activeModalAtom)", "");
      q.classList.add("dd-grow");
      const ta = document.createElement("textarea");
      ta.className = "qmm-input dd-textarea";
      ta.placeholder = `JSON or text value, e.g. inventory or { "x": 1, "y": 2 }`;
      const btnSet = ui.btn("Set", {
        icon: "\u2705",
        variant: "primary",
        onClick: async () => {
          const label2 = q.value.trim();
          if (!label2) {
            toast("Enter an atom label");
            return;
          }
          try {
            await ensureStore();
          } catch (e) {
            toast(e?.message || "Unable to capture store");
            return;
          }
          if (!isStoreCaptured()) {
            toast('Store not captured. Use "Capture store" first.');
            return;
          }
          const atom = getAtomByLabel(label2);
          if (!atom) {
            toast(`Atom "${label2}" not found`);
            return;
          }
          const raw = ta.value;
          const trimmed = raw.trim();
          let val = raw;
          let fallback = false;
          if (trimmed) {
            try {
              val = JSON.parse(trimmed);
            } catch {
              fallback = true;
            }
          } else {
            val = "";
          }
          try {
            await jSet(atom, val);
            toast(fallback ? "Set OK (raw text)" : "Set OK");
          } catch (e) {
            toast(e?.message || "Set failed");
          }
        }
      });
      const btnCopy = ui.btn("Copy JSON", { icon: "\u{1F4CB}", onClick: () => copy(ta.value) });
      controls.append(q, btnSet, btnCopy);
      card2.body.append(controls, ta);
    }
    function setText(el2, v) {
      el2.textContent = typeof v === "string" ? v : JSON.stringify(v, null, 2);
    }
  }

  // src/ui/menus/debug-data-live-atoms.ts
  init_jotai();

  // src/services/debug-data.ts
  var fmtTime = (ms) => {
    const d = new Date(ms);
    const pad = (n, s = 2) => String(n).padStart(s, "0");
    return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}.${String(d.getMilliseconds()).padStart(3, "0")}`;
  };
  var escapeLite = (s) => s.replace(/[<>&]/g, (m) => ({ "<": "&lt;", ">": "&gt;", "&": "&amp;" })[m]);
  var FrameBuffer = class {
    constructor(max = 2e3) {
      this.max = max;
      __publicField(this, "arr", []);
    }
    push(f) {
      this.arr.push(f);
      if (this.arr.length > this.max) this.arr.splice(0, this.arr.length - this.max);
    }
    toArray() {
      return this.arr.slice();
    }
    clear() {
      this.arr.length = 0;
    }
  };
  var registry = /* @__PURE__ */ new Map();
  function getWSInfos() {
    return Array.from(registry.values());
  }
  function getWSStatusText() {
    const anyOpen = sockets.some((ws) => ws.readyState === WebSocket.OPEN);
    const viaW = workerFound ? "worker" : "page/auto";
    return `status: ${anyOpen ? "OPEN" : "none"} \u2022 mode: ${viaW}`;
  }
  var HOOKED_CTOR_FLAG = Symbol.for("qmm.wsCtorHooked");
  var WS_PATCHED_SEND = Symbol.for("qmm.wsPatchedSend");
  var hookedOnce = false;
  function installWSHookIfNeeded(onFrame) {
    const Ctor = window.WebSocket;
    if (!Ctor[HOOKED_CTOR_FLAG]) {
      const ProxyCtor = new Proxy(Ctor, {
        construct(target, args, newTarget) {
          const ws = Reflect.construct(target, args, newTarget);
          try {
            trackSocket(ws, "new", onFrame);
          } catch (err) {
          }
          return ws;
        }
      });
      ProxyCtor[HOOKED_CTOR_FLAG] = true;
      window.WebSocket = ProxyCtor;
    }
    sockets.forEach((ws) => {
      try {
        trackSocket(ws, "existing", onFrame);
      } catch (err) {
      }
    });
    if (!hookedOnce) {
      hookedOnce = true;
    } else {
    }
  }
  function trackSocket(ws, why, onFrame) {
    if (registry.has(ws)) {
      return;
    }
    const id = `WS#${1 + registry.size} (${label(ws.readyState)})`;
    const info = { ws, id, listeners: [] };
    if (!sockets.includes(ws)) sockets.push(ws);
    setQWS?.(ws, why);
    const onMsg = (ev) => {
      let text = "";
      try {
        text = typeof ev.data === "string" ? ev.data : JSON.stringify(ev.data);
      } catch {
        text = String(ev.data);
      }
      onFrame({ t: Date.now(), dir: "in", text, ws });
    };
    ws.addEventListener("message", onMsg);
    info.listeners.push(() => ws.removeEventListener("message", onMsg));
    const onOpen = () => {
      info.id = info.id.replace(/\(.*\)/, `(${label(ws.readyState)})`);
    };
    const onClose = () => {
      info.id = info.id.replace(/\(.*\)/, `(${label(ws.readyState)})`);
    };
    ws.addEventListener("open", onOpen);
    ws.addEventListener("close", onClose);
    info.listeners.push(() => ws.removeEventListener("open", onOpen));
    info.listeners.push(() => ws.removeEventListener("close", onClose));
    if (!ws[WS_PATCHED_SEND]) {
      const orig = ws.send.bind(ws);
      info.sendOrig = orig;
      ws[WS_PATCHED_SEND] = true;
      ws.send = (data) => {
        try {
          const text = typeof data === "string" ? data : JSON.stringify(data);
          onFrame({ t: Date.now(), dir: "out", text, ws });
        } catch {
          onFrame({ t: Date.now(), dir: "out", text: String(data), ws });
        }
        return orig(data);
      };
    } else {
    }
    registry.set(ws, info);
  }

  // src/ui/menus/debug-data-live-atoms.ts
  function renderLiveAtomsTab(view, ui) {
    if (typeof view.__atoms_live_cleanup__ === "function") {
      try {
        view.__atoms_live_cleanup__();
      } catch {
      }
    }
    view.innerHTML = "";
    view.classList.add("dd-debug-view");
    const entries = /* @__PURE__ */ new Map();
    const records = [];
    let recording = false;
    let selectedRecord = null;
    const { leftCol, rightCol } = createTwoColumns(view);
    const selectCard = ui.card("\u{1F9EA} Pick atoms", {
      tone: "muted",
      subtitle: "Filter labels with a regex then toggle atoms to monitor."
    });
    leftCol.appendChild(selectCard.root);
    const filterRow = ui.flexRow({ gap: 10, wrap: true, fullWidth: true });
    const filterInput = ui.inputText("regex label (ex: position|health)", "");
    filterInput.classList.add("dd-grow");
    const btnFilter = ui.btn("Refresh", { icon: "\u{1F50D}", onClick: () => refreshMatches() });
    filterRow.append(filterInput, btnFilter);
    const matchesWrap = document.createElement("div");
    matchesWrap.className = "dd-atom-list";
    const emptyMatches = document.createElement("p");
    emptyMatches.className = "dd-card-description";
    emptyMatches.textContent = "No atoms match the current filter.";
    emptyMatches.style.display = "none";
    const selectedInfo = document.createElement("p");
    selectedInfo.className = "dd-card-description";
    selectedInfo.style.marginTop = "8px";
    selectCard.body.append(filterRow, matchesWrap, emptyMatches, selectedInfo);
    filterInput.addEventListener("keydown", (ev) => {
      if (ev.key === "Enter") {
        ev.preventDefault();
        refreshMatches();
      }
    });
    const logCard = ui.card("\u{1F4E1} Live atom log", {
      tone: "muted",
      subtitle: "Start recording to capture updates for the selected atoms."
    });
    rightCol.appendChild(logCard.root);
    const controlsRow = ui.flexRow({ gap: 10, wrap: true, fullWidth: true });
    const btnRecord = ui.btn("Start recording", {
      variant: "primary",
      onClick: () => toggleRecording()
    });
    const btnClear = ui.btn("Clear log", {
      variant: "ghost",
      icon: "\u{1F9F9}",
      onClick: () => {
        records.length = 0;
        selectedRecord = null;
        renderRecords(false);
        updateDetails(null);
        updateControls();
      }
    });
    const btnCopyLog = ui.btn("Copy log", {
      variant: "ghost",
      icon: "\u{1F4CB}",
      onClick: () => copyLog()
    });
    controlsRow.append(btnRecord, btnClear, btnCopyLog);
    logCard.body.appendChild(controlsRow);
    const logWrap = document.createElement("div");
    logWrap.className = "dd-log";
    logWrap.style.fontFamily = "ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    const logEmpty = document.createElement("div");
    logEmpty.className = "dd-log__empty";
    logEmpty.textContent = "No updates yet.";
    logWrap.appendChild(logEmpty);
    logCard.body.appendChild(logWrap);
    const detailHeader = document.createElement("p");
    detailHeader.className = "dd-card-description";
    detailHeader.textContent = "Select a log entry to inspect previous and next values.";
    const detailWrap = ui.flexRow({ gap: 12, wrap: true, fullWidth: true });
    const prevBox = document.createElement("div");
    prevBox.style.flex = "1 1 320px";
    const prevTitle = document.createElement("strong");
    prevTitle.textContent = "Previous";
    prevTitle.style.display = "block";
    prevTitle.style.marginBottom = "6px";
    const prevPre = document.createElement("pre");
    stylePre(prevPre);
    prevPre.style.minHeight = "140px";
    prevPre.textContent = "";
    prevBox.append(prevTitle, prevPre);
    const nextBox = document.createElement("div");
    nextBox.style.flex = "1 1 320px";
    const nextTitle = document.createElement("strong");
    nextTitle.textContent = "Next";
    nextTitle.style.display = "block";
    nextTitle.style.marginBottom = "6px";
    const nextPre = document.createElement("pre");
    stylePre(nextPre);
    nextPre.style.minHeight = "140px";
    nextPre.textContent = "";
    nextBox.append(nextTitle, nextPre);
    const historyBox = document.createElement("div");
    historyBox.style.flex = "1 1 100%";
    historyBox.style.minWidth = "0";
    const historyTitle = document.createElement("strong");
    historyTitle.textContent = "History";
    historyTitle.style.display = "block";
    historyTitle.style.marginBottom = "6px";
    const historyList = document.createElement("div");
    historyList.style.display = "flex";
    historyList.style.flexDirection = "column";
    historyList.style.gap = "10px";
    historyList.style.maxHeight = "320px";
    historyList.style.overflow = "auto";
    historyBox.append(historyTitle, historyList);
    detailWrap.append(prevBox, nextBox, historyBox);
    logCard.body.append(detailHeader, detailWrap);
    function refreshMatches() {
      const raw = filterInput.value.trim();
      const rx = safeRegex(raw || ".*");
      const atoms = findAtomsByLabel(rx);
      matchesWrap.innerHTML = "";
      emptyMatches.style.display = atoms.length ? "none" : "block";
      atoms.map((atom) => ({ atom, label: String(atom?.debugLabel || atom?.label || "<unknown>") })).sort((a, b) => a.label.localeCompare(b.label)).forEach(({ atom, label: label2 }) => {
        const row = document.createElement("label");
        row.className = "dd-atom-list__item";
        row.title = label2;
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.checked = entries.has(label2);
        checkbox.className = "dd-atom-list__checkbox";
        const text = document.createElement("span");
        text.className = "dd-atom-list__label";
        text.textContent = label2;
        row.append(checkbox, text);
        checkbox.addEventListener("change", async () => {
          if (checkbox.checked) {
            const existing = entries.get(label2);
            if (existing) {
              existing.atom = atom;
            } else {
              entries.set(label2, { atom, lastValue: null, unsubscribe: null });
            }
            if (recording) {
              const ok = await attachEntry(label2);
              if (!ok) checkbox.checked = false;
            }
          } else {
            const existing = entries.get(label2);
            if (existing?.unsubscribe) {
              try {
                existing.unsubscribe();
              } catch {
              }
            }
            entries.delete(label2);
          }
          updateSelectedInfo();
          updateControls();
        });
        matchesWrap.appendChild(row);
        if (entries.has(label2)) {
          const existing = entries.get(label2);
          if (existing) existing.atom = atom;
        }
      });
      updateSelectedInfo();
    }
    function updateSelectedInfo() {
      const size = entries.size;
      selectedInfo.textContent = size ? `${size} atom${size > 1 ? "s" : ""} selected.` : "No atom selected.";
    }
    function updateControls() {
      setBtnLabel(btnRecord, recording ? "Stop recording" : "Start recording");
      btnRecord.classList.toggle("active", recording);
      btnRecord.disabled = !recording && !entries.size;
      btnClear.disabled = records.length === 0;
      btnCopyLog.disabled = records.length === 0;
    }
    function renderRecords(autoScroll = false) {
      logWrap.innerHTML = "";
      if (!records.length) {
        logWrap.appendChild(logEmpty);
        renderHistoryFor(null, null);
        return;
      }
      records.forEach((rec, idx) => {
        const row = document.createElement("div");
        row.className = "atoms-log-row";
        row.dataset.idx = String(idx);
        row.style.display = "grid";
        row.style.gridTemplateColumns = "minmax(120px, 160px) minmax(0, 1fr)";
        row.style.gap = "12px";
        row.style.padding = "10px 12px";
        row.style.margin = "4px 0";
        row.style.borderRadius = "12px";
        row.style.border = "1px solid rgba(255,255,255,.12)";
        const isSelected = selectedRecord === idx;
        row.style.background = isSelected ? "rgba(92,126,255,.16)" : "rgba(11,16,22,.85)";
        row.style.borderColor = isSelected ? "rgba(92,126,255,.42)" : "rgba(255,255,255,.12)";
        row.style.cursor = "pointer";
        row.addEventListener("mouseenter", () => {
          row.style.borderColor = "rgba(255,255,255,.28)";
        });
        row.addEventListener("mouseleave", () => {
          const sel = selectedRecord === idx;
          row.style.borderColor = sel ? "rgba(92,126,255,.42)" : "rgba(255,255,255,.12)";
        });
        const left = document.createElement("div");
        left.style.display = "flex";
        left.style.flexDirection = "column";
        left.style.gap = "2px";
        const lbl = document.createElement("strong");
        lbl.textContent = rec.label;
        const ts = document.createElement("span");
        ts.style.opacity = "0.7";
        ts.style.fontSize = "12px";
        ts.textContent = `${fmtTime(rec.timestamp)}${rec.type === "initial" ? " \u2022 initial" : ""}`;
        left.append(lbl, ts);
        const summary = document.createElement("div");
        summary.style.fontSize = "12px";
        summary.style.lineHeight = "1.45";
        summary.style.whiteSpace = "pre-wrap";
        const prefix = rec.type === "initial" ? "[initial] " : "";
        summary.textContent = prefix + summarizeValue(rec.next);
        row.append(left, summary);
        row.addEventListener("click", () => {
          selectedRecord = idx;
          renderRecords(false);
          updateDetails(rec);
        });
        logWrap.appendChild(row);
      });
      if (autoScroll) logWrap.scrollTop = logWrap.scrollHeight;
      if (selectedRecord != null && !records[selectedRecord]) {
        selectedRecord = records.length ? Math.min(selectedRecord, records.length - 1) : null;
      }
      if (selectedRecord != null) {
        renderHistoryFor(records[selectedRecord]?.label ?? null, selectedRecord);
      }
    }
    function updateDetails(rec) {
      if (!rec) {
        detailHeader.textContent = "Select a log entry to inspect previous and next values.";
        prevTitle.textContent = "Previous";
        prevPre.textContent = "";
        nextTitle.textContent = "Next";
        nextPre.textContent = "";
        renderHistoryFor(null, null);
        return;
      }
      const typeSuffix = rec.type === "initial" ? " (initial)" : "";
      detailHeader.textContent = `${rec.label} \u2014 ${fmtTime(rec.timestamp)}${typeSuffix}`;
      prevTitle.textContent = rec.type === "initial" ? "Previous (none)" : "Previous";
      prevPre.textContent = rec.type === "initial" ? "(no previous snapshot)" : stringify(rec.previous);
      nextTitle.textContent = rec.type === "initial" ? "Initial value" : "Next";
      nextPre.textContent = stringify(rec.next);
      renderHistoryFor(rec.label, selectedRecord);
    }
    function renderHistoryFor(label2, selectedIdx) {
      historyList.innerHTML = "";
      if (!label2) {
        const empty = document.createElement("p");
        empty.className = "dd-card-description";
        empty.textContent = "Select a log entry to inspect the value history.";
        historyList.appendChild(empty);
        return;
      }
      const relevant = records.map((rec, idx) => ({ rec, idx })).filter(({ rec }) => rec.label === label2);
      if (!relevant.length) {
        const empty = document.createElement("p");
        empty.className = "dd-card-description";
        empty.textContent = "No history recorded yet.";
        historyList.appendChild(empty);
        return;
      }
      relevant.forEach(({ rec, idx }, order) => {
        const item = document.createElement("div");
        item.style.display = "flex";
        item.style.flexDirection = "column";
        item.style.gap = "6px";
        item.style.padding = "10px 12px";
        item.style.borderRadius = "12px";
        item.style.border = "1px solid rgba(255,255,255,.12)";
        const isSelected = idx === selectedIdx;
        item.style.background = isSelected ? "rgba(92,126,255,.16)" : "rgba(11,16,22,.85)";
        item.style.borderColor = isSelected ? "rgba(92,126,255,.42)" : "rgba(255,255,255,.12)";
        item.style.cursor = "pointer";
        item.addEventListener("mouseenter", () => {
          if (!isSelected) item.style.borderColor = "rgba(255,255,255,.24)";
        });
        item.addEventListener("mouseleave", () => {
          item.style.borderColor = isSelected ? "rgba(92,126,255,.42)" : "rgba(255,255,255,.12)";
        });
        item.addEventListener("click", () => {
          selectedRecord = idx;
          renderRecords(false);
          updateDetails(records[selectedRecord]);
        });
        const head = document.createElement("div");
        head.style.display = "flex";
        head.style.alignItems = "center";
        head.style.justifyContent = "space-between";
        const meta = document.createElement("div");
        meta.style.display = "flex";
        meta.style.alignItems = "center";
        meta.style.gap = "8px";
        const orderBadge = document.createElement("span");
        orderBadge.textContent = `#${order + 1}`;
        orderBadge.style.fontSize = "11px";
        orderBadge.style.letterSpacing = ".04em";
        orderBadge.style.textTransform = "uppercase";
        orderBadge.style.padding = "2px 6px";
        orderBadge.style.borderRadius = "999px";
        orderBadge.style.background = "rgba(255,255,255,.08)";
        orderBadge.style.border = "1px solid rgba(255,255,255,.16)";
        const type = document.createElement("span");
        type.textContent = rec.type === "initial" ? "Initial" : "Update";
        type.style.fontSize = "11px";
        type.style.opacity = "0.75";
        type.style.textTransform = "uppercase";
        meta.append(orderBadge, type);
        const ts = document.createElement("span");
        ts.textContent = fmtTime(rec.timestamp);
        ts.style.fontSize = "12px";
        ts.style.opacity = "0.75";
        head.append(meta, ts);
        const val = document.createElement("pre");
        stylePre(val);
        val.style.margin = "0";
        val.textContent = stringify(rec.next);
        item.append(head, val);
        historyList.appendChild(item);
      });
    }
    async function toggleRecording() {
      if (recording) {
        stopRecording();
        return;
      }
      if (!entries.size) {
        toast("Select at least one atom");
        return;
      }
      try {
        await ensureStore();
      } catch (e) {
        toast(e?.message || "Unable to capture store");
        return;
      }
      recording = true;
      updateControls();
      for (const label2 of Array.from(entries.keys())) {
        const ok = await attachEntry(label2);
        if (!ok) entries.delete(label2);
      }
      if (!entries.size) {
        stopRecording();
      }
      updateSelectedInfo();
      updateControls();
    }
    function stopRecording() {
      if (!recording) return;
      recording = false;
      for (const entry of entries.values()) {
        if (entry.unsubscribe) {
          try {
            entry.unsubscribe();
          } catch {
          }
          entry.unsubscribe = null;
        }
      }
      updateControls();
    }
    async function attachEntry(label2) {
      const entry = entries.get(label2);
      if (!entry) return false;
      if (entry.unsubscribe) {
        try {
          entry.unsubscribe();
        } catch {
        }
        entry.unsubscribe = null;
      }
      try {
        const initialValue = snapshot(await jGet(entry.atom));
        entry.lastValue = initialValue;
        const unsub = await jSub(entry.atom, async () => {
          const previous = snapshot(entry.lastValue);
          let nextValue;
          try {
            nextValue = await jGet(entry.atom);
          } catch (err) {
            nextValue = err?.message || String(err);
          }
          const nextSnap = snapshot(nextValue);
          entry.lastValue = nextSnap;
          const rec = {
            label: label2,
            timestamp: Date.now(),
            previous,
            next: nextSnap,
            type: "update"
          };
          records.push(rec);
          if (selectedRecord == null) selectedRecord = records.length - 1;
          renderRecords(true);
          updateDetails(records[selectedRecord]);
          updateControls();
        });
        const initialRecord = {
          label: label2,
          timestamp: Date.now(),
          previous: null,
          next: snapshot(initialValue),
          type: "initial"
        };
        records.push(initialRecord);
        if (selectedRecord == null) selectedRecord = records.length - 1;
        renderRecords(true);
        updateDetails(records[selectedRecord]);
        entry.unsubscribe = () => {
          try {
            unsub();
          } catch {
          }
          ;
        };
        return true;
      } catch (err) {
        toast(err?.message || `Unable to subscribe to ${label2}`);
        entries.delete(label2);
        updateSelectedInfo();
        updateControls();
        return false;
      }
    }
    function copyLog() {
      if (!records.length) return;
      const text = records.map((rec) => {
        const prev = rec.previous == null ? "(no previous snapshot)" : stringify(rec.previous);
        const next = stringify(rec.next);
        const type = rec.type === "initial" ? "initial" : "update";
        return `[${fmtTime(rec.timestamp)}] ${rec.label} (${type})
previous: ${prev}
next: ${next}`;
      }).join("\n\n");
      copy(text);
    }
    function snapshot(value) {
      if (value == null) return value;
      try {
        if (typeof structuredClone === "function") return structuredClone(value);
      } catch {
      }
      try {
        return JSON.parse(JSON.stringify(value));
      } catch {
        return value;
      }
    }
    function stringify(value) {
      if (typeof value === "string") return value;
      try {
        return JSON.stringify(value, null, 2);
      } catch {
        return String(value);
      }
    }
    function summarizeValue(value) {
      const str = stringify(value).replace(/\s+/g, " ").trim();
      return str.length > 140 ? str.slice(0, 140) + "\u2026" : str;
    }
    refreshMatches();
    updateControls();
    view.__atoms_live_cleanup__ = () => {
      stopRecording();
      for (const entry of entries.values()) {
        if (entry.unsubscribe) {
          try {
            entry.unsubscribe();
          } catch {
          }
        }
      }
      entries.clear();
      records.length = 0;
      selectedRecord = null;
    };
  }

  // src/ui/menus/debug-data-ws.ts
  function renderWSTab(view, ui) {
    if (typeof view.__ws_cleanup__ === "function") {
      try {
        view.__ws_cleanup__();
      } catch {
      }
    }
    view.innerHTML = "";
    view.classList.add("dd-debug-view");
    const frames = new FrameBuffer(2e3);
    const framesMap = /* @__PURE__ */ new Map();
    let seq = 0;
    let paused = false;
    let autoScroll = true;
    let showIn = true;
    let showOut = true;
    let filterText = "";
    let onlyCurrentSocket = false;
    let replayToSource = false;
    let selectedId = null;
    let mutePatterns = [];
    const setSelectedRow = (fid) => {
      selectedId = fid;
      [...logWrap.querySelectorAll("[data-fid]")].forEach((row) => {
        row.classList.toggle("selected", String(fid || "") === row.dataset.fid);
      });
      if (fid != null) {
        const f = framesMap.get(fid);
        if (f) ta.value = f.text;
      }
    };
    const matchesMutes = (text) => mutePatterns.some((rx) => rx.test(text));
    const statusCard = ui.card("\u{1F4E1} Live traffic", {
      tone: "muted",
      subtitle: "Monitor, filter, and replay WebSocket frames."
    });
    view.appendChild(statusCard.root);
    const muteCard = ui.card("\u{1F649} Mutes (regex)", {
      tone: "muted",
      subtitle: "Hide unwanted messages."
    });
    view.appendChild(muteCard.root);
    const logCard = ui.card("\u{1F9FE} Frame log", { tone: "muted" });
    view.appendChild(logCard.root);
    const sendCard = ui.card("\u{1F4E4} Send a frame", {
      tone: "muted",
      subtitle: "Pick or compose a payload and send it."
    });
    view.appendChild(sendCard.root);
    const statusToolbar = document.createElement("div");
    statusToolbar.className = "dd-toolbar dd-toolbar--stretch";
    statusCard.body.appendChild(statusToolbar);
    const lblConn = document.createElement("span");
    lblConn.className = "dd-status-chip";
    const sel = ui.select({ width: "220px" });
    const btnPause = ui.btn("Pause", {
      variant: "secondary",
      onClick: () => {
        paused = !paused;
        setPauseLabel(paused ? "Resume" : "Pause");
        btnPause.classList.toggle("active", paused);
        btnPause.title = paused ? "Resume live updates" : "Pause live updates";
      }
    });
    const setPauseLabel = (text) => {
      const label2 = btnPause.querySelector(".label");
      if (label2) label2.textContent = text;
      else btnPause.textContent = text;
    };
    setPauseLabel("Pause");
    btnPause.title = "Suspend live updates";
    const btnClear = ui.btn("Clear", {
      variant: "ghost",
      icon: "\u{1F9F9}",
      onClick: () => {
        frames.clear();
        framesMap.clear();
        setSelectedRow(null);
        repaint(true);
      }
    });
    const btnCopy = ui.btn("Copy visible", {
      variant: "ghost",
      icon: "\u{1F4CB}",
      onClick: () => copyVisible()
    });
    statusToolbar.append(lblConn, sel, btnPause, btnClear, btnCopy);
    const filterToolbar = document.createElement("div");
    filterToolbar.className = "dd-toolbar dd-toolbar--stretch";
    statusCard.body.appendChild(filterToolbar);
    const inputFilter = ui.inputText("filter text (case-insensitive)", "");
    inputFilter.classList.add("dd-grow");
    inputFilter.addEventListener("input", () => {
      filterText = inputFilter.value.trim().toLowerCase();
      repaint(true);
    });
    const inToggle = ui.toggleChip("IN", { checked: true, icon: "\u2190", tooltip: "Show incoming messages" });
    inToggle.input.addEventListener("change", () => {
      showIn = inToggle.input.checked;
      repaint(true);
    });
    const outToggle = ui.toggleChip("OUT", { checked: true, icon: "\u2192", tooltip: "Show outgoing messages" });
    outToggle.input.addEventListener("change", () => {
      showOut = outToggle.input.checked;
      repaint(true);
    });
    const currentToggle = ui.toggleChip("Active socket", { checked: false, icon: "\u{1F3AF}", tooltip: "Limit to the selected socket" });
    currentToggle.input.addEventListener("change", () => {
      onlyCurrentSocket = currentToggle.input.checked;
      repaint(true);
    });
    const autoScrollToggle = ui.toggleChip("Auto-scroll", { checked: true, icon: "\u{1F4DC}", tooltip: "Keep the log aligned with the latest frames" });
    autoScrollToggle.input.addEventListener("change", () => {
      autoScroll = autoScrollToggle.input.checked;
    });
    filterToolbar.append(inputFilter, inToggle.root, outToggle.root, currentToggle.root, autoScrollToggle.root);
    const muteRow = ui.flexRow({ gap: 10, wrap: true, fullWidth: true });
    const muteInput = ui.inputText("add regex (e.g. ping|keepalive)", "");
    muteInput.classList.add("dd-grow");
    const btnAddMute = ui.btn("Add", {
      icon: "\u2795",
      onClick: () => {
        const raw = muteInput.value.trim();
        if (!raw) return;
        try {
          mutePatterns.push(new RegExp(raw, "i"));
          muteInput.value = "";
          repaintMutes();
          repaint(true);
        } catch {
        }
      }
    });
    muteRow.append(muteInput, btnAddMute);
    muteCard.body.appendChild(muteRow);
    const mutesWrap = document.createElement("div");
    mutesWrap.className = "dd-mute-chips";
    muteCard.body.appendChild(mutesWrap);
    function repaintMutes() {
      mutesWrap.innerHTML = "";
      mutePatterns.forEach((rx, i) => {
        const chip = ui.btn(`/${rx.source}/i \xD7`, {
          variant: "ghost",
          size: "sm",
          onClick: () => {
            mutePatterns.splice(i, 1);
            repaintMutes();
            repaint(true);
          }
        });
        mutesWrap.appendChild(chip);
      });
    }
    const logWrap = document.createElement("div");
    logWrap.className = "dd-log";
    logWrap.style.fontFamily = "ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    logWrap.style.fontSize = "12px";
    logWrap.style.lineHeight = "1.4";
    logWrap.style.userSelect = "text";
    const emptyState = document.createElement("div");
    emptyState.className = "dd-log__empty";
    emptyState.textContent = "No frames visible yet.";
    logWrap.appendChild(emptyState);
    logCard.body.appendChild(logWrap);
    const ta = document.createElement("textarea");
    ta.className = "qmm-input dd-textarea";
    ta.placeholder = `Select a frame or paste a payload here. Choose Text or JSON below.`;
    const sendControls = document.createElement("div");
    sendControls.className = "dd-send-controls";
    const asJson = ui.radioGroup(
      "ws-send-mode",
      [{ value: "text", label: "Text" }, { value: "json", label: "JSON" }],
      "text",
      () => {
      }
    );
    const replayToggle = ui.toggleChip("Use source WS", { checked: false, icon: "\u21A9" });
    replayToggle.input.addEventListener("change", () => {
      replayToSource = replayToggle.input.checked;
    });
    const btnSend = ui.btn("Send", { variant: "primary", icon: "\u{1F4E8}", onClick: () => doSend() });
    const btnCopyPayload = ui.btn("Copy payload", { variant: "ghost", icon: "\u{1F4CB}", onClick: () => copy(ta.value) });
    sendControls.append(asJson, replayToggle.root, btnSend, btnCopyPayload);
    sendCard.body.append(ta, sendControls);
    function refreshSocketPicker() {
      const wsArr = getWSInfos();
      sel.innerHTML = "";
      wsArr.forEach((info, idx) => {
        const op = document.createElement("option");
        op.value = String(idx);
        op.textContent = info.id + (info.ws === quinoaWS ? " \u2022 page" : "");
        sel.appendChild(op);
      });
      if (!sel.value && sel.options.length) sel.value = "0";
      updateStatus();
    }
    function currentWS() {
      const idx = Number(sel.value);
      const vals = getWSInfos();
      return Number.isFinite(idx) ? vals[idx]?.ws ?? null : null;
    }
    function updateStatus() {
      const text = getWSStatusText();
      lblConn.textContent = text;
      const low = text.toLowerCase();
      lblConn.classList.toggle("is-ok", /open|connected|ready/.test(low));
      lblConn.classList.toggle("is-warn", /closing|connecting|pending/.test(low));
    }
    function updateEmptyState() {
      const hasRows = logWrap.querySelector(".ws-row") != null;
      emptyState.style.display = hasRows ? "none" : "";
    }
    function passesFilters(f) {
      if (f.dir === "in" && !showIn || f.dir === "out" && !showOut) return false;
      if (filterText && !f.text.toLowerCase().includes(filterText)) return false;
      if (onlyCurrentSocket && f.ws && currentWS() && f.ws !== currentWS()) return false;
      if (matchesMutes(f.text)) return false;
      return true;
    }
    function rowActions(fid, f) {
      const acts = document.createElement("div");
      acts.className = "acts";
      const bCopy = document.createElement("button");
      bCopy.className = "qmm-btn";
      bCopy.textContent = "Copy";
      bCopy.onclick = (e) => {
        e.stopPropagation();
        copy(f.text);
      };
      const bToEd = document.createElement("button");
      bToEd.className = "qmm-btn";
      bToEd.textContent = "\u2192 Editor";
      bToEd.onclick = (e) => {
        e.stopPropagation();
        ta.value = f.text;
        setSelectedRow(fid);
      };
      const bReplay = document.createElement("button");
      bReplay.className = "qmm-btn";
      bReplay.textContent = "Replay";
      bReplay.title = "Send right away (to current WS or source WS if enabled)";
      bReplay.onclick = (e) => {
        e.stopPropagation();
        replayFrame(f);
      };
      acts.append(bCopy, bToEd, bReplay);
      return acts;
    }
    function buildRow(f) {
      const row = document.createElement("div");
      row.className = "ws-row";
      row.dataset.fid = String(f.id);
      const ts = document.createElement("div");
      ts.className = "ts";
      ts.textContent = fmtTime(f.t);
      const arrow = document.createElement("div");
      arrow.className = "arrow";
      arrow.textContent = f.dir === "in" ? "\u2190" : "\u2192";
      arrow.style.color = f.dir === "in" ? "#4bd17a" : "#8ab4ff";
      const body = document.createElement("div");
      body.className = "body";
      body.innerHTML = `<code>${escapeLite(f.text)}</code>`;
      const acts = rowActions(f.id, f);
      row.append(ts, arrow, body, acts);
      row.onclick = () => setSelectedRow(f.id);
      row.ondblclick = () => {
        ta.value = f.text;
        setSelectedRow(f.id);
      };
      return row;
    }
    function appendOne(f) {
      if (!passesFilters(f)) return;
      const row = buildRow(f);
      logWrap.appendChild(row);
      updateEmptyState();
      if (autoScroll) logWrap.scrollTop = logWrap.scrollHeight;
    }
    function repaint(_full = false) {
      logWrap.querySelectorAll(".ws-row").forEach((n) => n.remove());
      frames.toArray().forEach((f) => {
        if (passesFilters(f)) logWrap.appendChild(buildRow(f));
      });
      updateEmptyState();
      if (selectedId != null) setSelectedRow(selectedId);
      if (autoScroll) logWrap.scrollTop = logWrap.scrollHeight;
    }
    function copyVisible() {
      const lines = frames.toArray().filter((f) => passesFilters(f)).map((f) => `[${fmtTime(f.t)}] ${f.dir === "in" ? "<-" : "->"} ${f.text}`).join("\n");
      copy(lines);
    }
    function replayFrame(f) {
      const target = replayToSource && f.ws ? f.ws : currentWS();
      if (!target || target.readyState !== WebSocket.OPEN) return;
      const mode = asJson.querySelector('input[type="radio"]:checked')?.value || "text";
      if (mode === "json") {
        try {
          target.send(JSON.parse(f.text));
        } catch {
          target.send(f.text);
        }
      } else {
        target.send(f.text);
      }
    }
    function doSend() {
      const ws = currentWS();
      const wsAlt = selectedId != null && replayToSource ? framesMap.get(selectedId)?.ws ?? null : null;
      const target = (replayToSource ? wsAlt : ws) || ws;
      if (!target || target.readyState !== WebSocket.OPEN) return;
      const mode = asJson.querySelector('input[type="radio"]:checked')?.value || "text";
      if (mode === "json") {
        try {
          target.send(JSON.parse(ta.value));
        } catch {
          target.send(ta.value);
        }
      } else {
        target.send(ta.value);
      }
    }
    installWSHookIfNeeded((f) => {
      if (paused) return;
      const ex = { ...f, id: ++seq };
      frames.push(ex);
      framesMap.set(ex.id, ex);
      updateStatus();
      appendOne(ex);
    });
    refreshSocketPicker();
    repaint(true);
    const pollId = window.setInterval(() => {
      refreshSocketPicker();
    }, 1e3);
    view.__ws_cleanup__ = () => {
      window.clearInterval(pollId);
    };
  }

  // src/ui/menus/debug-data-sprites.ts
  init_settings();
  var SPRITE_FAMILY_ID = "sprite";
  var ANY_CATEGORY = "all";
  var MAX_VISIBLE_SPRITES = 400;
  var SPRITE_ICON_SIZE = 96;
  var spriteServicePromise = null;
  var sleep4 = (ms) => new Promise((resolve2) => setTimeout(resolve2, ms));
  function resolveGlobalSpriteService() {
    const root = globalThis.unsafeWindow || globalThis;
    return root?.__MG_SPRITE_SERVICE__ ?? null;
  }
  async function waitForSpriteService() {
    const timeoutMs = 8e3;
    const start2 = Date.now();
    while (Date.now() - start2 < timeoutMs) {
      const svc = resolveGlobalSpriteService();
      if (svc) {
        try {
          if (svc.ready && typeof svc.ready.then === "function") {
            await svc.ready;
          }
        } catch {
        }
        return svc;
      }
      await sleep4(200);
    }
    return null;
  }
  async function acquireSpriteService(force = false) {
    if (force) {
      spriteServicePromise = null;
    }
    if (!spriteServicePromise) {
      spriteServicePromise = waitForSpriteService();
    }
    const svc = await spriteServicePromise;
    if (!svc) {
      spriteServicePromise = null;
      return null;
    }
    return svc;
  }
  function parseSpriteKey(key2) {
    const safe = String(key2 || "");
    const parts = safe.split("/").filter(Boolean);
    const start2 = parts[0] === "sprite" || parts[0] === "sprites" ? 1 : 0;
    const category = parts[start2] ?? "misc";
    const id = parts.slice(start2 + 1).join("/") || parts[parts.length - 1] || safe;
    const full = parts.slice(start2).join("/") || safe;
    return { category, id, full };
  }
  function buildSpriteCandidates2(parsed) {
    const variants = [parsed.id, parsed.full];
    const compact = parsed.id.replace(/\W+/g, "");
    if (compact && compact !== parsed.id) {
      variants.push(compact);
    }
    return Array.from(new Set(variants.filter(Boolean)));
  }
  function extractSpriteCategories(service) {
    if (!service) return [];
    const cats = service.state?.cats;
    let values = [];
    if (cats instanceof Map) {
      values = Array.from(cats.keys());
    } else if (cats && typeof cats === "object") {
      values = Object.keys(cats);
    }
    if (!values.length && typeof service.list === "function") {
      try {
        const fallback = service.list("any") ?? [];
        const collected = /* @__PURE__ */ new Set();
        fallback.forEach((entry) => {
          const parsed = parseSpriteKey(entry?.key ?? "");
          if (parsed.category) collected.add(parsed.category);
        });
        values = Array.from(collected);
      } catch {
        values = [];
      }
    }
    return values.map((value) => value.trim()).filter(Boolean).sort((a, b) => a.localeCompare(b));
  }
  var sanitizeFileComponent = (value) => value.replace(/[^a-z0-9_\-]+/gi, "_").replace(/_+/g, "_").replace(/^_+|_+$/g, "") || "sprite";
  var buildSpriteFilename = (parsed, mutations) => {
    const mutSegment = mutations.length ? `-${mutations.map((m) => sanitizeFileComponent(m)).join("_")}` : "";
    return `${sanitizeFileComponent(parsed.category)}-${sanitizeFileComponent(parsed.id)}${mutSegment}.png`;
  };
  var COLOR_SELECTIONS = ["None", ...MUT_G1];
  var CONDITION_SELECTIONS = ["None", ...MUT_G2];
  var LIGHTING_SELECTIONS = ["None", ...MUT_G3];
  function renderSpritesTab(view, ui) {
    view.innerHTML = "";
    view.classList.add("dd-debug-view");
    const { leftCol, rightCol } = createTwoColumns(view);
    const explorerCard = ui.card("Sprite Explorer", {
      tone: "muted",
      subtitle: "Browse captured sprites via the runtime sprite service."
    });
    leftCol.appendChild(explorerCard.root);
    const listCard = ui.card("Sprites", {
      tone: "muted",
      subtitle: "Preview sprites for the selected category."
    });
    rightCol.appendChild(listCard.root);
    const familySelect = ui.select({ width: "100%" });
    const families = [{ value: SPRITE_FAMILY_ID, label: "Sprite catalog" }];
    families.forEach(({ value, label: label2 }) => {
      const option = document.createElement("option");
      option.value = value;
      option.textContent = label2;
      familySelect.appendChild(option);
    });
    familySelect.value = SPRITE_FAMILY_ID;
    const categorySelect = ui.select({ width: "100%" });
    categorySelect.disabled = true;
    const searchInput = document.createElement("input");
    searchInput.type = "search";
    searchInput.placeholder = "Search name or key";
    searchInput.className = "dd-sprite-search";
    const reloadBtn = ui.btn("Reload sprites", {
      size: "sm",
      variant: "ghost",
      onClick: () => {
        void updateList(true);
      }
    });
    const downloadBtnLabel = "Download visible sprites";
    const downloadBtn = ui.btn(downloadBtnLabel, {
      size: "sm",
      variant: "primary",
      onClick: () => {
        void downloadVisibleSprites();
      }
    });
    downloadBtn.disabled = true;
    const controlsGrid = document.createElement("div");
    controlsGrid.className = "dd-sprite-control-grid";
    controlsGrid.append(
      createSelectControl("Asset family", familySelect),
      createSelectControl("Asset category", categorySelect),
      createSelectControl("Search", searchInput)
    );
    explorerCard.body.appendChild(controlsGrid);
    const actionRow = document.createElement("div");
    actionRow.className = "dd-sprite-actions";
    actionRow.append(reloadBtn, downloadBtn);
    explorerCard.body.appendChild(actionRow);
    const mutationFilters = { color: "None", condition: "None", lighting: "None" };
    let mutationGroupContainers = null;
    const mutationCard = ui.card("Mutations", {
      tone: "muted",
      subtitle: "Apply color or weather overlays to the previews."
    });
    leftCol.appendChild(mutationCard.root);
    const mutationBody = document.createElement("div");
    mutationBody.className = "dd-sprite-mutation-card";
    mutationCard.body.appendChild(mutationBody);
    mutationGroupContainers = {
      color: document.createElement("div"),
      condition: document.createElement("div"),
      lighting: document.createElement("div")
    };
    mutationGroupContainers.color.className = "dd-sprite-mutation-group";
    mutationGroupContainers.condition.className = "dd-sprite-mutation-group";
    mutationGroupContainers.lighting.className = "dd-sprite-mutation-group";
    mutationBody.append(
      mutationGroupContainers.color,
      mutationGroupContainers.condition,
      mutationGroupContainers.lighting
    );
    renderMutationControls();
    const stats = document.createElement("p");
    stats.className = "dd-sprite-stats";
    stats.textContent = "Waiting for sprite service\u2026";
    explorerCard.body.appendChild(stats);
    const previewArea = document.createElement("div");
    previewArea.className = "dd-sprite-grid";
    const previewWrap = document.createElement("div");
    previewWrap.className = "dd-sprite-grid-wrap";
    previewWrap.appendChild(previewArea);
    listCard.body.appendChild(previewWrap);
    let selectedFamily = SPRITE_FAMILY_ID;
    let selectedCategory = ANY_CATEGORY;
    let searchTerm = "";
    let spriteCategories = [];
    let listRequestId = 0;
    let retryTimer = null;
    let searchDebounce = null;
    let visibleSpriteRecords = [];
    let downloadInProgress = false;
    const clearRetry = () => {
      if (retryTimer !== null) {
        clearTimeout(retryTimer);
        retryTimer = null;
      }
    };
    const scheduleRetry = () => {
      if (retryTimer !== null) return;
      retryTimer = window.setTimeout(() => {
        retryTimer = null;
        void updateList();
      }, 2e3);
    };
    const applySpriteCategories = (categories) => {
      spriteCategories = categories;
      categorySelect.innerHTML = "";
      const allOption = document.createElement("option");
      allOption.value = ANY_CATEGORY;
      allOption.textContent = categories.length ? "All categories" : "No categories";
      categorySelect.appendChild(allOption);
      categories.forEach((category) => {
        const option = document.createElement("option");
        option.value = category;
        option.textContent = category;
        categorySelect.appendChild(option);
      });
      const valid = categories.includes(selectedCategory);
      selectedCategory = valid ? selectedCategory : ANY_CATEGORY;
      categorySelect.value = selectedCategory;
      categorySelect.disabled = !categories.length;
    };
    const renderEmptyState = (message) => {
      previewArea.innerHTML = "";
      const empty = document.createElement("div");
      empty.className = "dd-sprite-grid__empty";
      empty.textContent = message;
      previewArea.appendChild(empty);
    };
    const getActiveMutations = () => {
      const active = [];
      if (mutationFilters.color !== "None") active.push(mutationFilters.color);
      if (mutationFilters.condition !== "None") active.push(mutationFilters.condition);
      if (mutationFilters.lighting !== "None") active.push(mutationFilters.lighting);
      return active;
    };
    function renderMutationControls() {
      if (!mutationGroupContainers) return;
      renderMutationGroup(
        "color",
        COLOR_SELECTIONS,
        "Color",
        mutationGroupContainers.color
      );
      renderMutationGroup(
        "condition",
        CONDITION_SELECTIONS,
        "Weather",
        mutationGroupContainers.condition
      );
      renderMutationGroup(
        "lighting",
        LIGHTING_SELECTIONS,
        "Lighting",
        mutationGroupContainers.lighting
      );
    }
    function renderMutationGroup(key2, options, label2, container) {
      container.innerHTML = "";
      const heading = document.createElement("span");
      heading.className = "dd-sprite-mutation-group-title";
      heading.textContent = label2;
      const row = document.createElement("div");
      row.className = "dd-sprite-mutation-buttons";
      options.forEach((option) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "dd-sprite-mutation-btn";
        btn.textContent = option === "None" ? "None" : option;
        if (mutationFilters[key2] === option) {
          btn.classList.add("active");
        }
        btn.setAttribute("aria-pressed", mutationFilters[key2] === option ? "true" : "false");
        btn.addEventListener("click", () => {
          if (mutationFilters[key2] === option) return;
          mutationFilters[key2] = option;
          renderMutationControls();
          if (visibleSpriteRecords.length) {
            renderSpriteCards(visibleSpriteRecords);
          }
        });
        row.appendChild(btn);
      });
      container.append(heading, row);
    }
    ;
    function renderSpriteCards(records) {
      if (!records.length) {
        renderEmptyState("No sprites match the current filters.");
        return;
      }
      const activeMutations = getActiveMutations();
      previewArea.innerHTML = "";
      records.forEach((record) => {
        const { entry, parsed } = record;
        const card2 = document.createElement("div");
        card2.className = "dd-sprite-grid__item";
        card2.title = entry?.key ?? parsed.full;
        const imgWrap = document.createElement("div");
        imgWrap.className = "dd-sprite-grid__img";
        imgWrap.style.setProperty("--sprite-size", `${SPRITE_ICON_SIZE}px`);
        const iconSlot = document.createElement("span");
        iconSlot.className = "dd-sprite-grid__icon";
        iconSlot.textContent = "\u2026";
        imgWrap.appendChild(iconSlot);
        attachSpriteIcon(
          iconSlot,
          [parsed.category],
          buildSpriteCandidates2(parsed),
          SPRITE_ICON_SIZE,
          "debug-sprites",
          { mutations: activeMutations }
        );
        const nameEl = document.createElement("span");
        nameEl.className = "dd-sprite-grid__name";
        const animSuffix = entry?.isAnim && typeof entry.count === "number" ? ` (anim ${entry.count})` : entry?.isAnim ? " (anim)" : "";
        nameEl.textContent = `${parsed.id}${animSuffix}`;
        const meta = document.createElement("span");
        meta.className = "dd-sprite-grid__meta";
        meta.textContent = entry?.key ?? parsed.full;
        card2.append(imgWrap, nameEl, meta);
        const triggerDownload = () => {
          if (downloadInProgress) return;
          void downloadSpriteRecord(record, void 0, getActiveMutations());
        };
        card2.addEventListener("click", triggerDownload);
        card2.addEventListener("keydown", (event) => {
          if (event.key === "Enter" || event.key === " ") {
            event.preventDefault();
            triggerDownload();
          }
        });
        card2.tabIndex = 0;
        previewArea.appendChild(card2);
      });
    }
    const updateList = async (forceService = false) => {
      const token = ++listRequestId;
      stats.textContent = "Loading sprites\u2026";
      const service = await acquireSpriteService(forceService);
      if (token !== listRequestId) return;
      if (!service) {
        renderEmptyState("Sprite service not ready. Waiting\u2026");
        stats.textContent = "Sprite service not ready yet.";
        scheduleRetry();
        return;
      }
      clearRetry();
      if (!spriteCategories.length || forceService) {
        const categories = extractSpriteCategories(service);
        applySpriteCategories(categories);
      }
      if (selectedFamily !== SPRITE_FAMILY_ID) {
        renderEmptyState("No assets for this family.");
        stats.textContent = "Select the sprite family to browse sprites.";
        return;
      }
      const catArg = selectedCategory === ANY_CATEGORY ? "any" : selectedCategory;
      let sprites = [];
      try {
        sprites = typeof service.list === "function" ? service.list(catArg) ?? [] : [];
      } catch (error) {
        console.error("[DebugSprites] Failed to list sprites", error);
        renderEmptyState("Failed to list sprites (see console).");
        stats.textContent = "Listing sprites failed.";
        return;
      }
      const normalizedSearch = searchTerm.trim().toLowerCase();
      const filtered = !normalizedSearch ? sprites : sprites.filter((entry) => {
        const parsed = parseSpriteKey(entry?.key ?? "");
        const label2 = `${parsed.category}/${parsed.id}`.toLowerCase();
        return label2.includes(normalizedSearch) || (entry?.key ?? "").toLowerCase().includes(normalizedSearch);
      });
      const limited = filtered.slice(0, MAX_VISIBLE_SPRITES);
      const records = limited.map((entry) => ({ entry, parsed: parseSpriteKey(entry?.key ?? "") }));
      visibleSpriteRecords = records;
      if (!downloadInProgress) {
        downloadBtn.textContent = downloadBtnLabel;
      }
      downloadBtn.disabled = !records.length || downloadInProgress;
      if (!records.length) {
        renderEmptyState("No sprites match the current filters.");
      } else {
        renderSpriteCards(records);
      }
      const clipped = filtered.length > MAX_VISIBLE_SPRITES;
      const categoryLabel = selectedCategory === ANY_CATEGORY ? "all categories" : `category "${selectedCategory}"`;
      stats.textContent = clipped ? `Showing ${limited.length}/${filtered.length} sprites for ${categoryLabel}.` : `${filtered.length} sprites for ${categoryLabel}.`;
    };
    familySelect.addEventListener("change", () => {
      selectedFamily = familySelect.value || SPRITE_FAMILY_ID;
      void updateList();
    });
    categorySelect.addEventListener("change", () => {
      selectedCategory = categorySelect.value || ANY_CATEGORY;
      void updateList();
    });
    searchInput.addEventListener("input", () => {
      if (searchDebounce !== null) {
        clearTimeout(searchDebounce);
      }
      searchDebounce = window.setTimeout(() => {
        searchDebounce = null;
        searchTerm = searchInput.value || "";
        void updateList();
      }, 150);
    });
    void updateList();
    async function downloadSpriteRecord(record, svc, mutations) {
      const activeMutations = mutations ?? getActiveMutations();
      const dataUrl = await renderRecordToDataUrl(record, svc, activeMutations);
      if (!dataUrl) return false;
      triggerDataUrlDownload(
        dataUrl,
        buildSpriteFilename(record.parsed, activeMutations)
      );
      return true;
    }
    async function downloadVisibleSprites() {
      if (!visibleSpriteRecords.length || downloadInProgress) return;
      downloadInProgress = true;
      downloadBtn.disabled = true;
      downloadBtn.textContent = "Preparing zip...";
      try {
        const service = await acquireSpriteService();
        if (!service) return;
        const activeMutations = getActiveMutations();
        const files = [];
        for (const record of visibleSpriteRecords) {
          const dataUrl = await renderRecordToDataUrl(record, service, activeMutations);
          if (!dataUrl) continue;
          files.push({ name: buildSpriteFilename(record.parsed, activeMutations), dataUrl });
          downloadBtn.textContent = `Collected ${files.length}/${visibleSpriteRecords.length}`;
        }
        if (!files.length) return;
        downloadBtn.textContent = "Bundling zip...";
        const zipBlob = await packFilesToZip(files);
        triggerBlobDownload(zipBlob, `sprites-${Date.now()}.zip`);
      } finally {
        downloadInProgress = false;
        downloadBtn.textContent = downloadBtnLabel;
        downloadBtn.disabled = !visibleSpriteRecords.length;
      }
    }
    async function renderRecordToDataUrl(record, svc, mutations) {
      const service = svc ?? await acquireSpriteService();
      if (!service?.renderToDataURL) return null;
      try {
        const dataUrl = await service.renderToDataURL(
          {
            category: record.parsed.category,
            id: record.parsed.id,
            mutations: mutations ?? getActiveMutations()
          },
          "image/png"
        );
        return dataUrl ?? null;
      } catch (error) {
        console.error("[DebugSprites] download failed", { key: record.entry.key, error });
        return null;
      }
    }
    async function packFilesToZip(files) {
      const chunks = [];
      const fileEntries = [];
      let offset = 0;
      for (const file of files) {
        const { bytes: data, crc32: crc322 } = dataUrlToBytesAndCrc(file.dataUrl);
        const nameBytes = new TextEncoder().encode(file.name);
        const localHeader = buildZipLocalHeader(nameBytes, data.length, crc322);
        fileEntries.push({ nameBytes, data, crc: crc322, offset });
        chunks.push(localHeader, data);
        offset += localHeader.length + data.length;
      }
      const centralRecords = [];
      fileEntries.forEach((entry) => {
        centralRecords.push(
          buildZipCentralDirectory(entry.nameBytes, entry.data.length, entry.crc, entry.offset)
        );
      });
      const centralDirectory = concatUint8Arrays(centralRecords);
      const endRecord = buildZipEndRecord(fileEntries.length, centralDirectory.length, offset);
      return new Blob([...chunks, centralDirectory, endRecord].map((chunk) => chunk.slice()), {
        type: "application/zip"
      });
    }
    const LOCAL_HEADER_SIGNATURE = 67324752;
    const CENTRAL_DIR_SIGNATURE = 33639248;
    const END_SIGNATURE = 101010256;
    const ZIP_VERSION = 20;
    const ZIP_FLAGS = 0;
    const ZIP_METHOD_STORE = 0;
    function buildZipLocalHeader(nameBytes, size, crc322) {
      const buffer = new ArrayBuffer(30 + nameBytes.length);
      const view2 = new DataView(buffer);
      let offset = 0;
      view2.setUint32(offset, LOCAL_HEADER_SIGNATURE, true);
      offset += 4;
      view2.setUint16(offset, ZIP_VERSION, true);
      offset += 2;
      view2.setUint16(offset, ZIP_FLAGS, true);
      offset += 2;
      view2.setUint16(offset, ZIP_METHOD_STORE, true);
      offset += 2;
      view2.setUint16(offset, 0, true);
      offset += 2;
      view2.setUint16(offset, 0, true);
      offset += 2;
      view2.setUint32(offset, crc322 >>> 0, true);
      offset += 4;
      view2.setUint32(offset, size, true);
      offset += 4;
      view2.setUint32(offset, size, true);
      offset += 4;
      view2.setUint16(offset, nameBytes.length, true);
      offset += 2;
      view2.setUint16(offset, 0, true);
      const out = new Uint8Array(buffer);
      out.set(nameBytes, offset);
      return out;
    }
    function buildZipCentralDirectory(nameBytes, size, crc322, offset) {
      const buffer = new ArrayBuffer(46 + nameBytes.length);
      const view2 = new DataView(buffer);
      let pos = 0;
      view2.setUint32(pos, CENTRAL_DIR_SIGNATURE, true);
      pos += 4;
      view2.setUint16(pos, ZIP_VERSION, true);
      pos += 2;
      view2.setUint16(pos, ZIP_VERSION, true);
      pos += 2;
      view2.setUint16(pos, ZIP_FLAGS, true);
      pos += 2;
      view2.setUint16(pos, ZIP_METHOD_STORE, true);
      pos += 2;
      view2.setUint16(pos, 0, true);
      pos += 2;
      view2.setUint16(pos, 0, true);
      pos += 2;
      view2.setUint32(pos, crc322 >>> 0, true);
      pos += 4;
      view2.setUint32(pos, size, true);
      pos += 4;
      view2.setUint32(pos, size, true);
      pos += 4;
      view2.setUint16(pos, nameBytes.length, true);
      pos += 2;
      view2.setUint16(pos, 0, true);
      pos += 2;
      view2.setUint16(pos, 0, true);
      pos += 2;
      view2.setUint16(pos, 0, true);
      pos += 2;
      view2.setUint16(pos, 0, true);
      pos += 2;
      view2.setUint32(pos, 0, true);
      pos += 4;
      view2.setUint32(pos, offset, true);
      pos += 4;
      const out = new Uint8Array(buffer);
      out.set(nameBytes, pos);
      return out;
    }
    function buildZipEndRecord(fileCount, centralSize, centralOffset) {
      const buffer = new ArrayBuffer(22);
      const view2 = new DataView(buffer);
      let pos = 0;
      view2.setUint32(pos, END_SIGNATURE, true);
      pos += 4;
      view2.setUint16(pos, 0, true);
      pos += 2;
      view2.setUint16(pos, 0, true);
      pos += 2;
      view2.setUint16(pos, fileCount, true);
      pos += 2;
      view2.setUint16(pos, fileCount, true);
      pos += 2;
      view2.setUint32(pos, centralSize, true);
      pos += 4;
      view2.setUint32(pos, centralOffset, true);
      pos += 4;
      view2.setUint16(pos, 0, true);
      return new Uint8Array(buffer);
    }
    function concatUint8Arrays(arrays) {
      const total = arrays.reduce((sum, arr) => sum + arr.length, 0);
      const result = new Uint8Array(total);
      let offset = 0;
      arrays.forEach((arr) => {
        result.set(arr, offset);
        offset += arr.length;
      });
      return result;
    }
    function dataUrlToBytesAndCrc(dataUrl) {
      const base64 = dataUrl.split(",")[1] ?? "";
      const binary = atob(base64);
      const length = binary.length;
      const bytes = new Uint8Array(length);
      for (let i = 0; i < length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return { bytes, crc32: crc32(bytes) };
    }
    function crc32(bytes) {
      let crc = ~0;
      for (let i = 0; i < bytes.length; i++) {
        crc = crc >>> 8 ^ CRC_TABLE[(crc ^ bytes[i]) & 255];
      }
      return ~crc >>> 0;
    }
    const CRC_TABLE = (() => {
      const table = new Uint32Array(256);
      for (let i = 0; i < 256; i++) {
        let c = i;
        for (let k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[i] = c >>> 0;
      }
      return table;
    })();
    function triggerDataUrlDownload(dataUrl, filename) {
      const a = document.createElement("a");
      a.href = dataUrl;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }
    function triggerBlobDownload(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 1e3);
    }
  }
  function createSelectControl(labelText, control) {
    const wrapper = document.createElement("label");
    wrapper.className = "dd-sprite-control";
    const label2 = document.createElement("span");
    label2.className = "dd-sprite-control__label";
    label2.textContent = labelText;
    wrapper.append(label2, control);
    return wrapper;
  }

  // src/ui/menus/debug-data.ts
  var stylesInjected = false;
  function ensureStyles2() {
    if (stylesInjected) return;
    stylesInjected = true;
    const style3 = document.createElement("style");
    style3.id = "mg-debug-data-styles";
    style3.textContent = `
  .dd-debug-view{display:flex;flex-direction:column;gap:16px;}
  .dd-debug-columns{display:grid;gap:16px;grid-template-columns:repeat(2,minmax(320px,1fr));align-items:start;}
  @media (max-width:720px){.dd-debug-columns{grid-template-columns:minmax(0,1fr);}}
  .dd-debug-column{display:flex;flex-direction:column;gap:16px;min-width:0;}
  .dd-card-description{font-size:13px;opacity:.72;margin:0;}
  .dd-atom-list{display:flex;flex-direction:column;gap:4px;margin-top:8px;max-height:40vh;overflow:auto;padding-right:4px;}
  .dd-atom-list__item{display:flex;align-items:center;gap:8px;font-size:13px;padding:4px 6px;border-radius:8px;border:1px solid transparent;cursor:pointer;transition:background .12s ease,border-color .12s ease;}
  .dd-atom-list__item:hover{background:rgba(255,255,255,.06);border-color:rgba(255,255,255,.1);}
  .dd-atom-list__checkbox{accent-color:#5c7eff;}
  .dd-atom-list__label{flex:1 1 auto;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}
  .dd-status-chip{display:inline-flex;align-items:center;gap:6px;padding:4px 12px;border-radius:999px;font-size:12px;font-weight:600;letter-spacing:.01em;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.14);color:#f5f7ff;}
  .dd-status-chip.is-ok{color:#49d389;background:rgba(73,211,137,.14);border-color:rgba(73,211,137,.32);}
  .dd-status-chip.is-warn{color:#ffb760;background:rgba(255,183,96,.12);border-color:rgba(255,183,96,.32);}
  .dd-toolbar{display:flex;flex-wrap:wrap;gap:10px;align-items:center;}
  .dd-toolbar--stretch{width:100%;}
  .dd-toolbar .qmm-input{min-width:160px;}
  .dd-toolbar .dd-grow{flex:1 1 220px;min-width:180px;}
  .dd-mute-chips{display:flex;flex-wrap:wrap;gap:6px;}
  .dd-log{position:relative;border:1px solid #ffffff18;border-radius:16px;background:#0b1016;padding:10px;max-height:48vh;overflow:auto;box-shadow:inset 0 1px 0 rgba(255,255,255,.04);}
  .dd-log__empty{padding:28px 12px;text-align:center;font-size:13px;opacity:.6;}
  .dd-log .ws-row{position:relative;display:grid;grid-template-columns:96px 20px minmax(0,1fr);gap:10px;padding:8px 12px;border-radius:12px;border:1px solid transparent;transition:background .15s ease,border-color .15s ease;align-items:start;margin:2px 0;}
  .dd-log .ws-row .ts{opacity:.76;font-size:12px;}
  .dd-log .ws-row .arrow{font-weight:600;}
  .dd-log .ws-row .body{white-space:pre-wrap;word-break:break-word;}
  .dd-log .ws-row .body code{font-family:inherit;font-size:12px;color:#dbe4ff;}
  .dd-log .ws-row .acts{position:absolute;top:6px;right:8px;display:flex;gap:6px;padding:4px 6px;background:rgba(13,18,25,.94);border:1px solid rgba(255,255,255,.18);border-radius:8px;opacity:0;visibility:hidden;transition:opacity .12s ease;z-index:1;}
  .dd-log .ws-row .acts .qmm-btn{padding:2px 6px;font-size:11px;}
  .dd-log .ws-row:hover .acts{opacity:1;visibility:visible;}
  .dd-log .ws-row:hover{background:rgba(255,255,255,.05);border-color:rgba(255,255,255,.18);}
  .dd-log .ws-row.selected{background:rgba(92,126,255,.16);border-color:rgba(92,126,255,.42);}
  .dd-send-controls{display:flex;flex-wrap:wrap;gap:10px;align-items:center;}
  .dd-send-controls .qmm-radio-group{display:flex;gap:10px;}
  .dd-textarea{min-height:140px;}
  .dd-inline-note{font-size:12px;opacity:.7;}
  .dd-log-filter-group{display:flex;flex-wrap:wrap;gap:6px;align-items:center;}
  .dd-script-log{position:relative;border:1px solid #ffffff18;border-radius:16px;background:#0b1016;max-height:48vh;overflow:auto;box-shadow:inset 0 1px 0 rgba(255,255,255,.04);}
  .dd-script-log__empty{padding:28px 12px;text-align:center;font-size:13px;opacity:.6;}
  .dd-script-log__row{display:grid;grid-template-columns:minmax(92px,96px) minmax(70px,90px) minmax(120px,160px) minmax(0,1fr);gap:12px;padding:12px 16px;border-bottom:1px solid rgba(255,255,255,.06);align-items:start;}
  .dd-script-log__row:last-child{border-bottom:none;}
  .dd-script-log__ts{font-size:12px;opacity:.7;font-family:var(--qmm-font-mono,monospace);}
  .dd-script-log__level{display:inline-flex;align-items:center;justify-content:center;padding:2px 8px;border-radius:999px;font-size:11px;font-weight:600;letter-spacing:.03em;text-transform:uppercase;min-width:58px;}
  .dd-script-log__level.is-debug{background:rgba(138,180,255,.14);color:#8ab4ff;border:1px solid rgba(138,180,255,.32);}
  .dd-script-log__level.is-info{background:rgba(92,126,255,.14);color:#9fb6ff;border:1px solid rgba(92,126,255,.32);}
  .dd-script-log__level.is-warn{background:rgba(255,183,96,.12);color:#ffb760;border:1px solid rgba(255,183,96,.32);}
  .dd-script-log__level.is-error{background:rgba(255,108,132,.16);color:#ff6c84;border:1px solid rgba(255,108,132,.32);}
  .dd-script-log__source{font-size:12px;font-weight:600;opacity:.85;}
  .dd-script-log__context{display:block;font-size:11px;opacity:.6;margin-top:2px;text-transform:uppercase;letter-spacing:.05em;}
  .dd-script-log__message-wrap{display:flex;flex-direction:column;gap:6px;}
  .dd-script-log__message{font-size:13px;line-height:1.45;white-space:pre-wrap;word-break:break-word;}
  .dd-script-log__actions{display:flex;gap:6px;justify-content:flex-end;align-self:flex-end;}
  .dd-script-log__actions button{padding:2px 8px;font-size:11px;border-radius:8px;border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.04);color:inherit;cursor:pointer;transition:background .12s ease,border-color .12s ease;}
  .dd-script-log__actions button:hover{background:rgba(255,255,255,.08);border-color:rgba(255,255,255,.28);}
  .dd-script-log__details{grid-column:1/-1;margin:4px 0 0;background:#05080c;border:1px solid rgba(255,255,255,.08);border-radius:10px;padding:10px;white-space:pre-wrap;font-family:var(--qmm-font-mono,monospace);font-size:12px;line-height:1.4;display:none;word-break:break-word;max-height:180px;overflow:auto;}
  .dd-script-log__row.is-open .dd-script-log__details{display:block;}
  .dd-log-source-chips{display:flex;flex-wrap:wrap;gap:6px;}
  .dd-log-toolbar-spacer{flex:1 1 auto;}
  .dd-audio-summary{display:grid;gap:4px;font-size:13px;}
  .dd-audio-summary strong{font-size:14px;}
  .dd-audio-volume{font-family:var(--qmm-font-mono,monospace);font-size:12px;opacity:.78;}
  .dd-audio-list{display:flex;flex-direction:column;gap:8px;margin-top:4px;max-height:48vh;overflow:auto;padding-right:4px;}
  .dd-audio-row{display:flex;flex-wrap:wrap;gap:12px;align-items:flex-start;padding:10px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.08);background:rgba(9,12,18,.72);}
  .dd-audio-row__info{flex:1 1 260px;min-width:0;display:flex;flex-direction:column;gap:6px;}
  .dd-audio-row__title{font-weight:600;font-size:13px;word-break:break-word;}
  .dd-audio-meta{font-size:12px;opacity:.72;display:flex;flex-wrap:wrap;gap:8px;}
  .dd-audio-url{font-family:var(--qmm-font-mono,monospace);font-size:11px;word-break:break-all;color:#d6dcffb3;}
  .dd-audio-actions{display:flex;gap:6px;flex-wrap:wrap;margin-left:auto;}
  .dd-audio-empty{padding:24px 12px;text-align:center;font-size:13px;opacity:.6;}
  .dd-sprite-control-grid{display:grid;gap:12px;width:100%;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));align-items:end;}
  .dd-sprite-control{display:flex;flex-direction:column;gap:4px;font-size:12px;}
  .dd-sprite-control__label{font-size:11px;letter-spacing:.04em;text-transform:uppercase;opacity:.75;}
  .dd-sprite-control select,.dd-sprite-control input{width:100%;padding:6px 8px;border-radius:8px;border:1px solid rgba(255,255,255,.18);background:rgba(12,16,23,.9);color:#f5f7ff;font-size:13px;}
  .dd-sprite-control input[type="search"]::-webkit-search-cancel-button{filter:invert(1);}
  .dd-sprite-stats{font-size:13px;opacity:.75;margin:8px 0 0;}
  .dd-sprite-actions{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px;}
  .dd-sprite-grid-wrap{max-height:65vh;overflow:auto;padding-right:6px;width:100%;}
  .dd-sprite-grid{display:grid;gap:12px;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));align-items:stretch;min-height:0;}
  .dd-sprite-grid__item{display:flex;flex-direction:column;gap:8px;padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,.08);background:rgba(8,11,17,.85);box-shadow:inset 0 1px 0 rgba(255,255,255,.04);min-width:0;cursor:pointer;outline:none;}
  .dd-sprite-grid__item:focus-visible{border-color:rgba(88,138,255,.6);box-shadow:0 0 0 1px rgba(88,138,255,.3);}
  .dd-sprite-grid__img{display:flex;align-items:center;justify-content:center;background:#05080d;border-radius:12px;border:1px solid rgba(255,255,255,.05);overflow:hidden;min-height:var(--sprite-size,96px);}
  .dd-sprite-grid__icon{width:var(--sprite-size,96px);height:var(--sprite-size,96px);display:flex;align-items:center;justify-content:center;}
  .dd-sprite-grid__icon img{max-width:100%;max-height:100%;object-fit:contain;}
  .dd-sprite-grid__name{font-weight:600;font-size:13px;word-break:break-word;}
  .dd-sprite-grid__meta{font-size:11px;opacity:.65;word-break:break-all;font-family:var(--qmm-font-mono,monospace);}
  .dd-sprite-grid__empty{grid-column:1/-1;text-align:center;padding:32px 12px;font-size:13px;opacity:.66;}
  .dd-sprite-mutation-card{display:flex;flex-direction:column;gap:12px;}
  .dd-sprite-mutation-group{display:flex;flex-direction:column;gap:6px;}
  .dd-sprite-mutation-group-title{font-size:11px;letter-spacing:.04em;text-transform:uppercase;opacity:.75;}
  .dd-sprite-mutation-buttons{display:flex;flex-wrap:wrap;gap:6px;}
  .dd-sprite-mutation-btn{padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.18);background:rgba(14,18,26,.8);color:#e4e8f1;font-size:12px;cursor:pointer;transition:background .12s ease,border-color .12s ease,color .12s ease;}
  .dd-sprite-mutation-btn:hover{border-color:rgba(255,255,255,.35);}
  .dd-sprite-mutation-btn.active{background:rgba(90,118,255,.18);border-color:rgba(90,118,255,.6);color:#9fb4ff;}
  `;
    document.head.appendChild(style3);
  }
  async function renderDebugDataMenu(root) {
    ensureStyles2();
    const ui = new Menu({ id: "debug-tools", compact: true });
    ui.mount(root);
    ui.addTab("jotai", "Jotai", (view) => renderJotaiTab(view, ui));
    ui.addTab("atoms-live", "Live atoms", (view) => renderLiveAtomsTab(view, ui));
    ui.addTab("sprite-assets", "Sprites", (view) => renderSpritesTab(view, ui));
    ui.addTab("audio-player", "Audio player", (view) => renderAudioPlayerTab(view, ui));
    ui.addTab("websocket", "WebSocket", (view) => renderWSTab(view, ui));
  }

  // src/ui/menus/locker.ts
  init_atoms();
  var NO_WEATHER_TAG = "NoWeatherEffect";
  var SEED_EMOJIS = [
    "\u{1F955}",
    "\u{1F353}",
    "\u{1F343}",
    "\u{1F535}",
    "\u{1F34E}",
    "\u{1F337}",
    "\u{1F345}",
    "\u{1F33C}",
    "\u{1F33D}",
    "\u{1F349}",
    "\u{1F383}",
    "\u{1F33F}",
    "\u{1F965}",
    "\u{1F34C}",
    "\u{1F338}",
    "\u{1F7E2}",
    "\u{1F344}",
    "\u{1F335}",
    "\u{1F38D}",
    "\u{1F347}",
    "\u{1F336}\uFE0F",
    "\u{1F34B}",
    "\u{1F96D}",
    "\u{1F409}",
    "\u{1F352}",
    "\u{1F33B}",
    "\u2728",
    "\u{1F506}",
    "\u{1F52E}"
  ];
  var lockerSeedOptions = Object.entries(
    plantCatalog
  ).map(([key2, def]) => ({
    key: key2,
    seedName: def?.seed?.name ?? "",
    cropName: def?.crop?.name ?? ""
  }));
  var lockerSeedEmojiByKey = /* @__PURE__ */ new Map();
  var lockerSeedEmojiBySeedName = /* @__PURE__ */ new Map();
  lockerSeedOptions.forEach((opt, index) => {
    const emoji = SEED_EMOJIS[index % SEED_EMOJIS.length];
    lockerSeedEmojiByKey.set(opt.key, emoji);
    if (opt.seedName) {
      lockerSeedEmojiBySeedName.set(opt.seedName, emoji);
    }
  });
  var getLockerSeedOptions = () => lockerSeedOptions;
  var getLockerSeedEmojiForKey = (key2) => {
    if (!key2) return void 0;
    return lockerSeedEmojiByKey.get(key2) ?? "\u2022";
  };
  var getLockerSeedEmojiForSeedName = (name) => {
    if (!name) return void 0;
    return lockerSeedEmojiBySeedName.get(name) ?? "\u2022";
  };
  function formatMutationLabel(key2) {
    const spaced = key2.replace(/_/g, " ").replace(/([a-z0-9])([A-Z])/g, "$1 $2").replace(/\s+/g, " ").trim();
    if (!spaced) return key2;
    return spaced.charAt(0).toUpperCase() + spaced.slice(1);
  }
  var WEATHER_MUTATION_LABELS = tileRefsMutationLabels ?? {};
  var WEATHER_MUTATIONS = Object.entries(
    tileRefsMutations
  ).filter((entry) => {
    const [key2, value] = entry;
    if (key2 === "Puddle" || key2 === "ThunderstruckGround") {
      return false;
    }
    return typeof value === "number" || typeof value === "string";
  }).map(([key2, value]) => ({
    key: key2,
    label: WEATHER_MUTATION_LABELS[key2] ?? formatMutationLabel(key2),
    tileRef: value,
    iconFactory: (options) => createWeatherBadge(key2, options)
  }));
  var createNoWeatherIcon = (options) => {
    const size = Math.max(24, options?.size ?? 48);
    const wrap = applyStyles(document.createElement("div"), {
      width: `${size}px`,
      height: `${size}px`,
      display: "grid",
      placeItems: "center"
    });
    const glyph = applyStyles(document.createElement("span"), {
      color: "#ff5c5c",
      fontSize: `${Math.round(size * 0.65)}px`,
      fontWeight: "700",
      textShadow: "0 1px 2px rgba(0, 0, 0, 0.6)",
      lineHeight: "1"
    });
    glyph.textContent = "\u2716";
    wrap.appendChild(glyph);
    return wrap;
  };
  WEATHER_MUTATIONS.unshift({
    key: NO_WEATHER_TAG,
    label: "No weather effect",
    tileRef: null,
    iconFactory: createNoWeatherIcon
  });
  var isWeatherMutationAvailable = (tag) => WEATHER_MUTATIONS.some((info) => info.key === tag);
  var WEATHER_RECIPE_GROUPS = {
    Wet: "condition",
    Chilled: "condition",
    Frozen: "condition",
    Thunderstruck: "condition",
    Dawnlit: "lighting",
    Amberlit: "lighting",
    Dawncharged: "lighting",
    Ambercharged: "lighting"
  };
  var WEATHER_RECIPE_GROUP_MEMBERS = {
    condition: ["Wet", "Chilled", "Frozen", "Thunderstruck"],
    lighting: ["Dawnlit", "Amberlit", "Dawncharged", "Ambercharged"]
  };
  function normalizeWeatherSelection(selection) {
    selection.forEach((tag) => {
      if (!isWeatherMutationAvailable(tag)) {
        selection.delete(tag);
      }
    });
  }
  function normalizeRecipeSelection(selection) {
    normalizeWeatherSelection(selection);
    const seen = /* @__PURE__ */ new Set();
    WEATHER_MUTATIONS.forEach((info) => {
      if (!selection.has(info.key)) return;
      const group = WEATHER_RECIPE_GROUPS[info.key];
      if (!group) return;
      if (seen.has(group)) {
        selection.delete(info.key);
      } else {
        seen.add(group);
      }
    });
  }
  var applyStyles = (el2, styles) => {
    Object.entries(styles).forEach(([prop, value]) => {
      el2.style[prop] = value;
    });
    return el2;
  };
  var weatherModeNameSeq = 0;
  function createEmojiIcon(symbol, size) {
    const wrap = applyStyles(document.createElement("span"), {
      width: `${size}px`,
      height: `${size}px`,
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      fontSize: `${Math.round(size * 0.75)}px`,
      lineHeight: "1"
    });
    wrap.textContent = symbol;
    wrap.setAttribute("aria-hidden", "true");
    return wrap;
  }
  function createSeedIcon(seedKey, options = {}) {
    const size = Math.max(12, options.size ?? 24);
    const fallback = options.fallback ?? getLockerSeedEmojiForKey(seedKey) ?? getLockerSeedEmojiForSeedName(seedKey) ?? "\u{1F331}";
    const wrap = applyStyles(document.createElement("span"), {
      width: `${size}px`,
      height: `${size}px`,
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center"
    });
    wrap.appendChild(createEmojiIcon(fallback, size));
    attachSpriteIcon(wrap, ["plant", "tallplant", "crop"], seedKey, size, "plant");
    return wrap;
  }
  function createEggIcon(eggId, label2, size = 32) {
    const fallback = "\u{1F95A}";
    const wrap = applyStyles(document.createElement("span"), {
      width: `${size}px`,
      height: `${size}px`,
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center"
    });
    wrap.appendChild(createEmojiIcon(fallback, size));
    const candidates = /* @__PURE__ */ new Set();
    const add = (value) => {
      if (!value) return;
      const trimmed = value.trim();
      if (!trimmed) return;
      candidates.add(trimmed);
      candidates.add(trimmed.replace(/\s+/g, ""));
      const last = trimmed.split(/[./]/).pop();
      if (last && last !== trimmed) {
        candidates.add(last);
        candidates.add(last.replace(/\s+/g, ""));
      }
    };
    add(eggId);
    add(label2);
    if (candidates.size) {
      attachSpriteIcon(wrap, ["pet"], Array.from(candidates), size, "locker-eggs");
    }
    return wrap;
  }
  function createWeatherBadge(tag, options = {}) {
    if (tag === NO_WEATHER_TAG) {
      return createNoWeatherIcon(options);
    }
    const size = Math.max(16, options.size ?? 32);
    const wrap = applyStyles(document.createElement("span"), {
      width: `${size}px`,
      height: `${size}px`,
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      borderRadius: "999px",
      background: "rgba(17,20,24,0.85)",
      border: "1px solid rgba(255,255,255,0.08)",
      fontSize: `${Math.round(size * 0.55)}px`,
      color: "#e7eef7",
      lineHeight: "1"
    });
    const label2 = WEATHER_MUTATION_LABELS[tag] ?? formatMutationLabel(tag);
    const fallback = options.fallback ?? label2.charAt(0);
    wrap.textContent = fallback || "?";
    wrap.title = label2;
    wrap.setAttribute("aria-label", label2);
    return wrap;
  }
  function createDefaultSettings() {
    return {
      minScalePct: 50,
      maxScalePct: 100,
      scaleLockMode: "RANGE",
      lockMode: "LOCK",
      minInventory: 91,
      avoidNormal: false,
      visualMutations: /* @__PURE__ */ new Set(),
      weatherMode: "ANY",
      weatherSelected: /* @__PURE__ */ new Set(),
      weatherRecipes: []
    };
  }
  function copySettings(target, source) {
    target.minScalePct = source.minScalePct;
    target.maxScalePct = source.maxScalePct;
    target.scaleLockMode = source.scaleLockMode;
    target.lockMode = source.lockMode;
    target.minInventory = source.minInventory;
    target.avoidNormal = source.avoidNormal;
    target.visualMutations.clear();
    source.visualMutations.forEach((v) => target.visualMutations.add(v));
    target.weatherMode = source.weatherMode;
    target.weatherSelected.clear();
    source.weatherSelected.forEach((v) => target.weatherSelected.add(v));
    target.weatherRecipes.length = 0;
    source.weatherRecipes.forEach((set3) => target.weatherRecipes.push(new Set(set3)));
  }
  function hydrateSettingsFromPersisted(target, persisted) {
    const src = persisted ?? {};
    const mode = src.scaleLockMode === "MINIMUM" ? "MINIMUM" : src.scaleLockMode === "MAXIMUM" ? "MAXIMUM" : src.scaleLockMode === "NONE" ? "NONE" : "RANGE";
    let minScale = Math.max(50, Math.min(100, Math.round(src.minScalePct ?? 50)));
    let maxScale = Math.max(50, Math.min(100, Math.round(src.maxScalePct ?? 100)));
    if (mode === "RANGE") {
      maxScale = Math.max(51, Math.min(100, maxScale));
      if (maxScale <= minScale) {
        if (minScale >= 99) {
          minScale = 99;
          maxScale = 100;
        } else {
          maxScale = Math.min(100, Math.max(51, minScale + 1));
        }
      }
    } else if (mode === "MINIMUM") {
      minScale = Math.max(50, Math.min(100, minScale));
    } else if (mode === "MAXIMUM") {
      maxScale = Math.max(50, Math.min(100, maxScale));
    }
    target.minScalePct = minScale;
    target.maxScalePct = maxScale;
    target.scaleLockMode = mode;
    target.lockMode = src.lockMode === "ALLOW" ? "ALLOW" : "LOCK";
    target.minInventory = Math.max(0, Math.min(999, Math.round(src.minInventory ?? 91)));
    target.avoidNormal = src.avoidNormal === true || src.includeNormal === false;
    target.visualMutations.clear();
    (src.visualMutations ?? []).forEach((mut) => {
      if (mut === "Gold" || mut === "Rainbow") target.visualMutations.add(mut);
    });
    target.weatherMode = src.weatherMode === "ALL" || src.weatherMode === "RECIPES" ? src.weatherMode : "ANY";
    target.weatherSelected.clear();
    (src.weatherSelected ?? []).forEach((tag) => {
      const weatherTag = tag;
      if (isWeatherMutationAvailable(weatherTag)) {
        target.weatherSelected.add(weatherTag);
      }
    });
    target.weatherRecipes.length = 0;
    (src.weatherRecipes ?? []).forEach((recipe) => {
      const set3 = /* @__PURE__ */ new Set();
      if (Array.isArray(recipe)) {
        recipe.forEach((tag) => {
          const weatherTag = tag;
          if (isWeatherMutationAvailable(weatherTag)) {
            set3.add(weatherTag);
          }
        });
      }
      target.weatherRecipes.push(set3);
    });
  }
  function serializeSettingsState(state3) {
    normalizeWeatherSelection(state3.weatherSelected);
    state3.weatherRecipes.forEach((set3) => normalizeRecipeSelection(set3));
    const mode = state3.scaleLockMode === "MINIMUM" ? "MINIMUM" : state3.scaleLockMode === "MAXIMUM" ? "MAXIMUM" : state3.scaleLockMode === "NONE" ? "NONE" : "RANGE";
    let minScale = Math.max(50, Math.min(100, Math.round(state3.minScalePct || 50)));
    let maxScale = Math.max(50, Math.min(100, Math.round(state3.maxScalePct || 100)));
    if (mode === "RANGE") {
      maxScale = Math.max(51, Math.min(100, maxScale));
      if (maxScale <= minScale) {
        if (minScale >= 99) {
          minScale = 99;
          maxScale = 100;
        } else {
          maxScale = Math.min(100, Math.max(51, minScale + 1));
        }
      }
    } else if (mode === "MINIMUM") {
      minScale = Math.max(50, Math.min(100, minScale));
    } else if (mode === "MAXIMUM") {
      maxScale = Math.max(50, Math.min(100, maxScale));
    }
    return {
      minScalePct: minScale,
      maxScalePct: maxScale,
      scaleLockMode: mode,
      lockMode: state3.lockMode === "ALLOW" ? "ALLOW" : "LOCK",
      minInventory: Math.max(0, Math.min(999, Math.round(state3.minInventory || 91))),
      avoidNormal: !!state3.avoidNormal,
      includeNormal: !state3.avoidNormal,
      visualMutations: Array.from(state3.visualMutations),
      weatherMode: state3.weatherMode,
      weatherSelected: Array.from(state3.weatherSelected),
      weatherRecipes: state3.weatherRecipes.map((set3) => Array.from(set3))
    };
  }
  var LockerMenuStore = class {
    constructor(initial) {
      __publicField(this, "global");
      __publicField(this, "overrides", /* @__PURE__ */ new Map());
      __publicField(this, "listeners", /* @__PURE__ */ new Set());
      __publicField(this, "syncing", false);
      this.global = { enabled: false, settings: createDefaultSettings(), hasPersistedSettings: true };
      this.syncFromService(initial);
    }
    applyPersisted(state3) {
      this.global.enabled = !!state3.enabled;
      hydrateSettingsFromPersisted(this.global.settings, state3.settings);
      this.global.hasPersistedSettings = true;
      const seen = /* @__PURE__ */ new Set();
      Object.entries(state3.overrides ?? {}).forEach(([key2, value]) => {
        const entry = this.ensureOverride(key2, { silent: true });
        entry.enabled = !!value?.enabled;
        hydrateSettingsFromPersisted(entry.settings, value?.settings);
        entry.hasPersistedSettings = true;
        seen.add(key2);
      });
      for (const key2 of Array.from(this.overrides.keys())) {
        if (!seen.has(key2)) {
          this.overrides.delete(key2);
        }
      }
    }
    subscribe(listener) {
      this.listeners.add(listener);
      return () => this.listeners.delete(listener);
    }
    emit() {
      for (const listener of this.listeners) {
        try {
          listener();
        } catch {
        }
      }
    }
    syncFromService(state3) {
      this.syncing = true;
      this.applyPersisted(state3);
      this.emit();
      this.syncing = false;
    }
    setGlobalEnabled(enabled) {
      this.global.enabled = !!enabled;
      this.persistGlobal();
      this.emit();
    }
    notifyGlobalSettingsChanged() {
      this.persistGlobal();
      this.emit();
    }
    ensureOverride(key2, opts = {}) {
      let entry = this.overrides.get(key2);
      if (!entry) {
        entry = { enabled: false, settings: createDefaultSettings(), hasPersistedSettings: false };
        this.overrides.set(key2, entry);
        if (!opts.silent) {
          this.emit();
        }
      }
      return entry;
    }
    getOverride(key2) {
      return this.overrides.get(key2);
    }
    setOverrideEnabled(key2, enabled) {
      const entry = this.ensureOverride(key2, { silent: true });
      entry.enabled = !!enabled;
      this.persistOverride(key2);
      this.emit();
    }
    notifyOverrideSettingsChanged(key2) {
      const entry = this.overrides.get(key2);
      if (!entry) return;
      entry.hasPersistedSettings = true;
      this.persistOverride(key2);
      this.emit();
    }
    removeOverride(key2) {
      if (!this.overrides.has(key2)) return;
      this.overrides.delete(key2);
      if (!this.syncing) {
        lockerService.removeOverride(key2);
        lockerService.recomputeCurrentSlot();
      }
      this.emit();
    }
    persistGlobal() {
      if (this.syncing) return;
      lockerService.setGlobalState({
        enabled: this.global.enabled,
        settings: serializeSettingsState(this.global.settings)
      });
      lockerService.recomputeCurrentSlot();
    }
    persistOverride(key2) {
      if (this.syncing) return;
      const entry = this.overrides.get(key2);
      if (!entry) {
        lockerService.removeOverride(key2);
      } else {
        lockerService.setOverride(key2, {
          enabled: entry.enabled,
          settings: serializeSettingsState(entry.settings)
        });
        entry.hasPersistedSettings = true;
      }
      lockerService.recomputeCurrentSlot();
    }
  };
  function setCheck(input, value) {
    input.checked = !!value;
  }
  function createWeatherMutationToggle({
    key: key2,
    label: label2,
    iconSize,
    dense,
    kind = "main",
    iconFactory
  }) {
    const isMain = kind === "main" && !dense;
    const gap = dense ? "3px" : isMain ? "3px" : "6px";
    const padding = dense ? "4px 6px" : isMain ? "6px 8px" : "10px 12px";
    const minWidth = dense ? "80px" : isMain ? "88px" : "120px";
    const wrapStyles = {
      position: "relative",
      display: "grid",
      justifyItems: "center",
      alignItems: "center",
      gap,
      padding,
      border: "1px solid rgba(255,255,255,0.10)",
      borderRadius: "10px",
      background: "rgba(255,255,255,0.02)",
      cursor: "pointer",
      minWidth,
      transition: "border-color 120ms ease, box-shadow 120ms ease, background 120ms ease",
      boxShadow: "none"
    };
    if (isMain) {
      wrapStyles.width = "100%";
    }
    const wrap = applyStyles(document.createElement("label"), wrapStyles);
    wrap.title = "Active filters influence harvest conditions";
    const input = document.createElement("input");
    input.type = "checkbox";
    applyStyles(input, {
      position: "absolute",
      inset: "0",
      opacity: "0",
      pointerEvents: "none",
      margin: "0"
    });
    input.dataset.weatherToggle = kind;
    wrap.appendChild(input);
    wrap.dataset.weatherToggle = kind;
    const computedIconSize = Math.max(24, iconSize ?? (dense ? 36 : isMain ? 52 : 72));
    const iconWrap = applyStyles(document.createElement("span"), {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center"
    });
    const fallbackIcon = iconFactory ? iconFactory({ size: computedIconSize, fallback: label2.charAt(0) || "?" }) : createWeatherBadge(key2, {
      size: computedIconSize,
      fallback: label2.charAt(0) || "?"
    });
    applyStyles(iconWrap, {
      filter: "drop-shadow(0 1px 1px rgba(0, 0, 0, 0.45))"
    });
    iconWrap.appendChild(fallbackIcon);
    wrap.appendChild(iconWrap);
    attachWeatherSpriteIcon(iconWrap, key2, computedIconSize);
    const caption = applyStyles(document.createElement("div"), {
      fontSize: dense ? "11px" : "11.5px",
      fontWeight: dense ? "500" : "600",
      opacity: "0.85",
      textAlign: "center"
    });
    caption.textContent = label2;
    wrap.appendChild(caption);
    const applyDisabledState = () => {
      if (input.disabled) {
        wrap.style.cursor = "default";
        wrap.style.opacity = "0.55";
        wrap.style.pointerEvents = "none";
      } else {
        wrap.style.cursor = "pointer";
        wrap.style.opacity = "";
        wrap.style.pointerEvents = "";
      }
    };
    const updateState = () => {
      if (input.checked) {
        applyStyles(wrap, {
          borderColor: "rgba(94,234,212,0.40)",
          boxShadow: "0 0 0 1px rgba(94,234,212,0.25) inset, 0 2px 6px rgba(0, 0, 0, 0.45)",
          background: "rgba(94,234,212,0.12)"
        });
      } else {
        applyStyles(wrap, {
          borderColor: "rgba(255,255,255,0.10)",
          boxShadow: "none",
          background: "rgba(255,255,255,0.02)"
        });
      }
      applyDisabledState();
    };
    const setChecked = (value) => {
      setCheck(input, value);
      updateState();
    };
    const setDisabled = (value) => {
      input.disabled = !!value;
      updateState();
    };
    input.addEventListener("change", updateState);
    input.addEventListener("mg-weather-toggle-refresh", updateState);
    updateState();
    return { key: key2, wrap, input, setChecked, setDisabled };
  }
  function styleBtnFullWidth(button, text) {
    button.textContent = text;
    button.style.flex = "1";
    button.style.margin = "0";
    button.style.padding = "6px 10px";
    button.style.borderRadius = "8px";
    button.style.border = "1px solid rgba(255,255,255,0.10)";
    button.style.background = "rgba(255,255,255,0.04)";
    button.style.color = "#e7eef7";
    button.style.fontSize = "13px";
    button.style.fontWeight = "600";
    button.style.cursor = "pointer";
    button.style.justifyContent = "center";
    button.onmouseenter = () => {
      button.style.borderColor = "rgba(94,234,212,0.35)";
      button.style.background = "rgba(94,234,212,0.08)";
    };
    button.onmouseleave = () => {
      button.style.borderColor = "rgba(255,255,255,0.10)";
      button.style.background = "rgba(255,255,255,0.04)";
    };
  }
  function styleBtnCompact(button, text) {
    button.textContent = text;
    button.style.margin = "0";
    button.style.padding = "4px 8px";
    button.style.borderRadius = "8px";
    button.style.border = "1px solid rgba(255,255,255,0.10)";
    button.style.background = "rgba(255,255,255,0.04)";
    button.style.color = "#e7eef7";
    button.style.fontSize = "12px";
    button.style.fontWeight = "600";
    button.style.cursor = "pointer";
    button.style.display = "inline-flex";
    button.style.alignItems = "center";
    button.style.justifyContent = "center";
    button.style.minWidth = "36px";
    button.onmouseenter = () => {
      button.style.borderColor = "rgba(94,234,212,0.35)";
      button.style.background = "rgba(94,234,212,0.08)";
    };
    button.onmouseleave = () => {
      button.style.borderColor = "rgba(255,255,255,0.10)";
      button.style.background = "rgba(255,255,255,0.04)";
    };
  }
  function createLockerSettingsCard(ui, state3, opts = {}) {
    const card2 = document.createElement("div");
    card2.dataset.lockerSettingsCard = "1";
    card2.style.border = "1px solid rgba(255,255,255,0.10)";
    card2.style.borderRadius = "10px";
    card2.style.padding = "12px";
    card2.style.display = "flex";
    card2.style.flexDirection = "column";
    card2.style.gap = "12px";
    card2.style.alignItems = "center";
    card2.style.overflow = "auto";
    card2.style.minHeight = "0";
    card2.style.width = "min(760px, 100%)";
    let recipesTitleElement = null;
    const updateRecipeTitleText = () => {
      if (!recipesTitleElement) return;
      const prefix = state3.lockMode === "ALLOW" ? "Allow" : "Lock";
      recipesTitleElement.textContent = `${prefix} when any recipe row matches (OR between rows)`;
    };
    const makeSection = (titleText, content) => {
      const section = document.createElement("div");
      section.style.display = "grid";
      section.style.justifyItems = "center";
      section.style.gap = "8px";
      section.style.textAlign = "center";
      section.style.border = "1px solid rgba(255,255,255,0.10)";
      section.style.borderRadius = "10px";
      section.style.padding = "10px";
      section.style.background = "rgba(255,255,255,0.04)";
      section.style.boxShadow = "none";
      section.style.width = "min(720px, 100%)";
      const heading = document.createElement("div");
      heading.textContent = titleText;
      heading.style.fontWeight = "600";
      heading.style.opacity = "0.95";
      section.append(heading, content);
      return section;
    };
    const centerRow = () => {
      const row = document.createElement("div");
      row.style.display = "flex";
      row.style.flexWrap = "wrap";
      row.style.justifyContent = "center";
      row.style.alignItems = "center";
      row.style.gap = "8px";
      return row;
    };
    const toLockMode = (value) => value === "allow" ? "ALLOW" : "LOCK";
    const fromLockMode = (mode) => mode === "ALLOW" ? "allow" : "lock";
    const lockModeRow = centerRow();
    lockModeRow.style.flexDirection = "column";
    lockModeRow.style.alignItems = "center";
    lockModeRow.style.gap = "10px";
    const lockModeHint = document.createElement("div");
    lockModeHint.style.fontSize = "12px";
    lockModeHint.style.opacity = "0.8";
    lockModeHint.style.textAlign = "center";
    let isProgrammaticLockMode = false;
    const lockModeSegmented = ui.segmented(
      [
        { value: "lock", label: "Lock" },
        { value: "allow", label: "Allow" }
      ],
      fromLockMode(state3.lockMode),
      (value) => {
        if (isProgrammaticLockMode) return;
        state3.lockMode = toLockMode(value);
        updateLockModeUI();
        opts.onChange?.();
      },
      { ariaLabel: "Harvest mode" }
    );
    lockModeRow.append(lockModeSegmented, lockModeHint);
    const updateLockModeUI = () => {
      const value = fromLockMode(state3.lockMode);
      const current = lockModeSegmented.get?.();
      if (current !== value) {
        isProgrammaticLockMode = true;
        try {
          lockModeSegmented.set?.(value);
        } finally {
          isProgrammaticLockMode = false;
        }
      }
      lockModeHint.textContent = value === "allow" ? "Harvest only when every active filter category matches" : "Harvest is locked whenever any active filter matches";
      updateRecipeTitleText();
    };
    const scaleRow = centerRow();
    scaleRow.style.flexDirection = "column";
    scaleRow.style.alignItems = "center";
    scaleRow.style.width = "100%";
    scaleRow.style.gap = "12px";
    const scaleModeRow = centerRow();
    scaleModeRow.style.flexWrap = "wrap";
    scaleModeRow.style.justifyContent = "center";
    scaleModeRow.style.gap = "12px";
    const minSlider = ui.slider(50, 100, 1, state3.minScalePct);
    applyStyles(minSlider, { width: "min(420px, 100%)" });
    const maxSlider = ui.slider(50, 100, 1, state3.maxScalePct);
    applyStyles(maxSlider, { width: "min(420px, 100%)" });
    const toMode = (value) => {
      switch (value) {
        case "minimum":
          return "MINIMUM";
        case "maximum":
          return "MAXIMUM";
        case "ranged":
          return "RANGE";
        default:
          return "NONE";
      }
    };
    const fromMode = (mode) => {
      switch (mode) {
        case "MINIMUM":
          return "minimum";
        case "MAXIMUM":
          return "maximum";
        case "RANGE":
          return "ranged";
        default:
          return "none";
      }
    };
    let isProgrammaticScaleMode = false;
    const initialScaleMode = fromMode(state3.scaleLockMode);
    const scaleModeSegmented = ui.segmented(
      [
        { value: "none", label: "None" },
        { value: "minimum", label: "Minimum" },
        { value: "maximum", label: "Maximum" },
        { value: "ranged", label: "Range" }
      ],
      initialScaleMode,
      (value) => {
        if (isProgrammaticScaleMode) return;
        applyScaleMode(toMode(value), true);
      },
      { ariaLabel: "Scale lock mode" }
    );
    scaleModeRow.append(scaleModeSegmented);
    const scaleSlider = ui.rangeDual(50, 100, 1, state3.minScalePct, state3.maxScalePct);
    applyStyles(scaleSlider.root, {
      width: "min(420px, 100%)",
      marginLeft: "auto",
      marginRight: "auto"
    });
    const scaleMinSlider = scaleSlider.min;
    const scaleMaxSlider = scaleSlider.max;
    const scaleMinValue = ui.label("50%");
    const scaleMaxValue = ui.label("100%");
    const scaleMinimumValue = ui.label("50%");
    const scaleMaximumValue = ui.label("100%");
    [scaleMinValue, scaleMaxValue, scaleMinimumValue, scaleMaximumValue].forEach((label2) => {
      label2.style.margin = "0";
      label2.style.fontWeight = "600";
    });
    const makeScaleValue = (labelText, valueLabel) => {
      const wrap = applyStyles(document.createElement("div"), {
        display: "flex",
        alignItems: "center",
        gap: "6px"
      });
      const label2 = ui.label(labelText);
      label2.style.margin = "0";
      label2.style.opacity = "0.9";
      wrap.append(label2, valueLabel);
      return wrap;
    };
    const scaleValues = applyStyles(document.createElement("div"), {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      width: "min(420px, 100%)",
      gap: "16px"
    });
    scaleValues.append(makeScaleValue("Min", scaleMinValue), makeScaleValue("Max", scaleMaxValue));
    const minControls = applyStyles(document.createElement("div"), {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap: "12px",
      width: "100%"
    });
    minControls.append(minSlider, makeScaleValue("Minimum", scaleMinimumValue));
    const maxControls = applyStyles(document.createElement("div"), {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap: "12px",
      width: "100%"
    });
    maxControls.append(maxSlider, makeScaleValue("Maximum", scaleMaximumValue));
    const rangeControls = applyStyles(document.createElement("div"), {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap: "12px",
      width: "100%"
    });
    rangeControls.append(scaleSlider.root, scaleValues);
    scaleRow.append(scaleModeRow, minControls, maxControls, rangeControls);
    const applyScaleRange = (commit2, notify2 = commit2) => {
      let minValue = parseInt(scaleMinSlider.value, 10);
      let maxValue = parseInt(scaleMaxSlider.value, 10);
      if (!Number.isFinite(minValue)) minValue = state3.minScalePct;
      if (!Number.isFinite(maxValue)) maxValue = state3.maxScalePct;
      minValue = Math.max(50, Math.min(99, minValue));
      maxValue = Math.max(51, Math.min(100, maxValue));
      if (maxValue <= minValue) {
        if (minValue >= 99) {
          minValue = 99;
          maxValue = 100;
        } else {
          maxValue = Math.min(100, Math.max(51, minValue + 1));
        }
      }
      scaleSlider.setValues(minValue, maxValue);
      scaleMinValue.textContent = `${minValue}%`;
      scaleMaxValue.textContent = `${maxValue}%`;
      if (commit2) {
        state3.minScalePct = minValue;
        state3.maxScalePct = maxValue;
        if (notify2) opts.onChange?.();
      }
    };
    const applyScaleMinimum = (commit2, notify2 = commit2) => {
      let minValue = parseInt(minSlider.value, 10);
      if (!Number.isFinite(minValue)) minValue = state3.minScalePct;
      minValue = Math.max(50, Math.min(100, minValue));
      minSlider.value = String(minValue);
      scaleMinimumValue.textContent = `${minValue}%`;
      if (commit2) {
        state3.minScalePct = minValue;
        if (notify2) opts.onChange?.();
      }
    };
    const applyScaleMaximum = (commit2, notify2 = commit2) => {
      let maxValue = parseInt(maxSlider.value, 10);
      if (!Number.isFinite(maxValue)) maxValue = state3.maxScalePct;
      maxValue = Math.max(50, Math.min(100, maxValue));
      maxSlider.value = String(maxValue);
      scaleMaximumValue.textContent = `${maxValue}%`;
      if (commit2) {
        state3.maxScalePct = maxValue;
        if (notify2) opts.onChange?.();
      }
    };
    const updateScaleModeUI = () => {
      const isRange = state3.scaleLockMode === "RANGE";
      const isMin = state3.scaleLockMode === "MINIMUM";
      const isMax = state3.scaleLockMode === "MAXIMUM";
      rangeControls.style.display = isRange ? "" : "none";
      minControls.style.display = isMin ? "" : "none";
      maxControls.style.display = isMax ? "" : "none";
      const segValue = fromMode(state3.scaleLockMode);
      if (scaleModeSegmented.get?.() !== segValue) {
        isProgrammaticScaleMode = true;
        try {
          scaleModeSegmented.set?.(segValue);
        } finally {
          isProgrammaticScaleMode = false;
        }
      }
    };
    const applyScaleMode = (mode, notify2) => {
      const prevMode = state3.scaleLockMode;
      state3.scaleLockMode = mode;
      if (mode === "RANGE") {
        scaleSlider.setValues(state3.minScalePct, state3.maxScalePct);
        applyScaleRange(prevMode !== mode, false);
      } else if (mode === "MINIMUM") {
        minSlider.value = String(state3.minScalePct);
        applyScaleMinimum(prevMode !== mode, false);
      } else if (mode === "MAXIMUM") {
        maxSlider.value = String(state3.maxScalePct);
        applyScaleMaximum(prevMode !== mode, false);
      }
      updateScaleModeUI();
      if (notify2 && prevMode !== mode) {
        opts.onChange?.();
      }
    };
    minSlider.addEventListener("input", () => applyScaleMinimum(false));
    minSlider.addEventListener("change", () => applyScaleMinimum(true));
    maxSlider.addEventListener("input", () => applyScaleMaximum(false));
    maxSlider.addEventListener("change", () => applyScaleMaximum(true));
    scaleMinSlider.addEventListener("input", () => applyScaleRange(false));
    scaleMaxSlider.addEventListener("input", () => applyScaleRange(false));
    scaleMinSlider.addEventListener("change", () => applyScaleRange(true));
    scaleMaxSlider.addEventListener("change", () => applyScaleRange(true));
    applyScaleRange(false);
    applyScaleMinimum(false);
    applyScaleMaximum(false);
    applyScaleMode(state3.scaleLockMode, false);
    const colorsRow = centerRow();
    colorsRow.style.flexWrap = "wrap";
    colorsRow.style.gap = "8px";
    const createColorButton = (label2, gradient) => {
      const button = document.createElement("button");
      button.type = "button";
      button.title = "Active filters influence harvest conditions";
      applyStyles(button, {
        padding: "6px 12px",
        borderRadius: "8px",
        border: "1px solid rgba(255,255,255,0.10)",
        background: "rgba(255,255,255,0.04)",
        color: "#e7eef7",
        fontWeight: "600",
        letterSpacing: "0.3px",
        transition: "border-color 120ms ease, box-shadow 120ms ease, background 120ms ease, opacity 120ms ease",
        boxShadow: "none",
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        gap: "6px",
        minWidth: "92px",
        cursor: "pointer"
      });
      const text = document.createElement("span");
      text.textContent = label2;
      if (gradient) {
        applyStyles(text, {
          backgroundImage: gradient,
          backgroundClip: "text",
          WebkitBackgroundClip: "text",
          color: "transparent",
          fontWeight: "700",
          textShadow: "0 0 6px rgba(0, 0, 0, 0.35)"
        });
      }
      button.appendChild(text);
      button.addEventListener("mouseenter", () => {
        if (button.disabled || button.dataset.active === "1") return;
        button.style.borderColor = "rgba(94,234,212,0.35)";
      });
      button.addEventListener("mouseleave", () => {
        if (button.dataset.active === "1") return;
        button.style.borderColor = "rgba(255,255,255,0.10)";
      });
      return button;
    };
    const btnNormal = createColorButton("Normal");
    const btnGold = createColorButton(
      "Gold",
      "linear-gradient(120deg, #f5d76e, #c9932b, #f9e9b6)"
    );
    const btnRainbow = createColorButton(
      "Rainbow",
      "linear-gradient(90deg, #ff6b6b, #f7d35c, #3fd3ff, #9b6bff, #ff6b6b)"
    );
    const updateColorButtonVisual = (button, active) => {
      button.dataset.active = active ? "1" : "0";
      button.style.borderColor = active ? "rgba(94,234,212,0.40)" : "rgba(255,255,255,0.10)";
      button.style.boxShadow = active ? "0 0 0 1px rgba(94,234,212,0.25) inset, 0 2px 6px rgba(0, 0, 0, 0.45)" : "none";
      button.style.background = active ? "rgba(94,234,212,0.12)" : "rgba(255,255,255,0.04)";
      button.style.opacity = button.disabled ? "0.55" : "";
      button.style.cursor = button.disabled ? "default" : "pointer";
    };
    const updateColorButtons = () => {
      updateColorButtonVisual(btnNormal, state3.avoidNormal);
      updateColorButtonVisual(btnGold, state3.visualMutations.has("Gold"));
      updateColorButtonVisual(btnRainbow, state3.visualMutations.has("Rainbow"));
    };
    btnNormal.addEventListener("click", () => {
      state3.avoidNormal = !state3.avoidNormal;
      updateColorButtons();
      opts.onChange?.();
    });
    btnGold.addEventListener("click", () => {
      if (state3.visualMutations.has("Gold")) state3.visualMutations.delete("Gold");
      else state3.visualMutations.add("Gold");
      updateColorButtons();
      opts.onChange?.();
    });
    btnRainbow.addEventListener("click", () => {
      if (state3.visualMutations.has("Rainbow")) state3.visualMutations.delete("Rainbow");
      else state3.visualMutations.add("Rainbow");
      updateColorButtons();
      opts.onChange?.();
    });
    colorsRow.append(btnNormal, btnGold, btnRainbow);
    const weatherGrid = applyStyles(document.createElement("div"), {
      display: "grid",
      gridTemplateColumns: "repeat(4, minmax(0, 1fr))",
      columnGap: "6px",
      rowGap: "6px",
      justifyItems: "stretch",
      width: "min(640px, 100%)",
      marginInline: "auto"
    });
    const applyWeatherSelection = (selection) => (tag, checked) => {
      if (checked) {
        selection.add(tag);
      } else {
        selection.delete(tag);
      }
      opts.onChange?.();
    };
    const updateMainWeatherSelection = applyWeatherSelection(state3.weatherSelected);
    const weatherToggles = WEATHER_MUTATIONS.map((info) => {
      const toggle = createWeatherMutationToggle({
        key: info.key,
        label: info.label,
        kind: "main",
        iconFactory: info.iconFactory
      });
      toggle.input.addEventListener(
        "change",
        () => updateMainWeatherSelection(info.key, toggle.input.checked)
      );
      weatherGrid.appendChild(toggle.wrap);
      return toggle;
    });
    const updateWeatherMutationsDisabled = () => {
      const disabled = card2.dataset.disabled === "1" || state3.weatherMode === "RECIPES";
      weatherGrid.style.opacity = disabled ? "0.55" : "";
      weatherGrid.style.pointerEvents = disabled ? "none" : "";
      weatherToggles.forEach((toggle) => toggle.setDisabled(disabled));
    };
    const weatherModeName = `locker-weather-mode-${++weatherModeNameSeq}`;
    const weatherModeRow = centerRow();
    const buildRadio = (value, label2) => {
      const wrap = document.createElement("label");
      wrap.style.display = "inline-flex";
      wrap.style.alignItems = "center";
      wrap.style.gap = "6px";
      const input = ui.radio(weatherModeName, value);
      const span = document.createElement("span");
      span.textContent = label2;
      wrap.append(input, span);
      input.addEventListener("change", () => {
        if (!input.checked) return;
        state3.weatherMode = value;
        recipesWrap.style.display = value === "RECIPES" ? "" : "none";
        updateWeatherMutationsDisabled();
        opts.onChange?.();
      });
      return { wrap, input };
    };
    const radioAny = buildRadio("ANY", "Any match (OR)");
    const radioAll = buildRadio("ALL", "All match (AND)");
    const radioRecipes = buildRadio("RECIPES", "Recipes (match rows)");
    weatherModeRow.append(radioAny.wrap, radioAll.wrap, radioRecipes.wrap);
    const recipesWrap = document.createElement("div");
    recipesWrap.style.display = "grid";
    recipesWrap.style.gap = "8px";
    recipesWrap.style.justifyItems = "center";
    recipesWrap.style.width = "min(720px, 100%)";
    const recipesHeader = centerRow();
    recipesHeader.style.width = "100%";
    recipesHeader.style.justifyContent = "space-between";
    const recipesTitle = document.createElement("div");
    recipesTitleElement = recipesTitle;
    updateRecipeTitleText();
    recipesTitle.style.fontWeight = "600";
    recipesTitle.style.opacity = "0.9";
    const btnAddRecipe = document.createElement("button");
    btnAddRecipe.style.maxWidth = "140px";
    styleBtnFullWidth(btnAddRecipe, "+ Recipe");
    recipesHeader.append(recipesTitle, btnAddRecipe);
    const recipesList = document.createElement("div");
    recipesList.style.display = "grid";
    recipesList.style.gap = "8px";
    recipesList.style.gridTemplateColumns = "repeat(auto-fit, minmax(320px, 1fr))";
    recipesList.style.justifyItems = "stretch";
    let editingRecipeIndex = null;
    let editingRecipeDraft = /* @__PURE__ */ new Set();
    const emptyRecipes = document.createElement("div");
    emptyRecipes.textContent = "No recipe rows yet.";
    emptyRecipes.style.fontSize = "12px";
    emptyRecipes.style.opacity = "0.7";
    emptyRecipes.style.textAlign = "center";
    const updateAddRecipeDisabled = () => {
      const editing = editingRecipeIndex !== null;
      const cardDisabled = card2.dataset.disabled === "1";
      btnAddRecipe.disabled = editing || cardDisabled;
      btnAddRecipe.style.opacity = editing ? "0.7" : "";
      btnAddRecipe.style.pointerEvents = editing ? "none" : "";
    };
    const startEditingRecipe = (index, base) => {
      editingRecipeIndex = index;
      editingRecipeDraft = new Set(base ?? []);
      normalizeRecipeSelection(editingRecipeDraft);
      repaintRecipes();
    };
    const cancelEditingRecipe = () => {
      editingRecipeIndex = null;
      editingRecipeDraft = /* @__PURE__ */ new Set();
      repaintRecipes();
    };
    const commitEditingRecipe = () => {
      if (editingRecipeIndex === null) return;
      const draft = new Set(editingRecipeDraft);
      normalizeRecipeSelection(draft);
      if (editingRecipeIndex === state3.weatherRecipes.length) {
        state3.weatherRecipes.push(draft);
      } else if (editingRecipeIndex >= 0 && editingRecipeIndex < state3.weatherRecipes.length) {
        state3.weatherRecipes[editingRecipeIndex] = draft;
      }
      editingRecipeIndex = null;
      editingRecipeDraft = /* @__PURE__ */ new Set();
      repaintRecipes();
      opts.onChange?.();
    };
    const deleteRecipeAt = (index) => {
      if (index < 0) return;
      if (index < state3.weatherRecipes.length) {
        state3.weatherRecipes.splice(index, 1);
      }
      if (editingRecipeIndex !== null) {
        if (index === editingRecipeIndex) {
          editingRecipeIndex = null;
          editingRecipeDraft = /* @__PURE__ */ new Set();
        } else if (index < editingRecipeIndex) {
          editingRecipeIndex -= 1;
        }
      }
      repaintRecipes();
      opts.onChange?.();
    };
    const buildRecipeBadge = (info) => {
      const { key: tag, label: label2 } = info;
      const badge = document.createElement("div");
      applyStyles(badge, {
        display: "inline-flex",
        alignItems: "center",
        gap: "6px",
        padding: "4px 10px",
        borderRadius: "999px",
        border: "1px solid rgba(255,255,255,0.10)",
        background: "rgba(255,255,255,0.04)",
        color: "#e7eef7",
        fontSize: "12px",
        fontWeight: "600",
        letterSpacing: "0.2px"
      });
      const iconWrap = applyStyles(document.createElement("span"), {
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center"
      });
      const fallbackIcon = info.iconFactory ? info.iconFactory({ size: 20, fallback: label2.charAt(0) || "?" }) : createWeatherBadge(tag, {
        size: 20,
        fallback: label2.charAt(0) || "?"
      });
      applyStyles(iconWrap, {
        filter: "drop-shadow(0 1px 1px rgba(0, 0, 0, 0.45))"
      });
      iconWrap.appendChild(fallbackIcon);
      attachWeatherSpriteIcon(iconWrap, tag, 20);
      const text = document.createElement("span");
      text.textContent = label2;
      badge.append(iconWrap, text);
      return badge;
    };
    const renderRecipeSummary = (container, selection) => {
      container.innerHTML = "";
      const badges = document.createElement("div");
      applyStyles(badges, {
        display: "flex",
        flexWrap: "wrap",
        gap: "6px",
        justifyContent: "flex-start"
      });
      let count = 0;
      WEATHER_MUTATIONS.forEach((info) => {
        if (!selection.has(info.key)) return;
        count += 1;
        badges.appendChild(buildRecipeBadge(info));
      });
      if (count === 0) {
        const empty = document.createElement("div");
        empty.textContent = "No weather mutation selected.";
        empty.style.fontSize = "12px";
        empty.style.opacity = "0.7";
        empty.style.textAlign = "left";
        badges.appendChild(empty);
      }
      container.appendChild(badges);
    };
    const applyDisabled = () => {
      const cardDisabled = card2.dataset.disabled === "1";
      const inputs = card2.querySelectorAll("input,button,select,textarea");
      inputs.forEach((el2) => {
        if (el2.dataset.weatherToggle === "main") {
          return;
        }
        el2.disabled = cardDisabled;
        el2.dispatchEvent(new Event("mg-weather-toggle-refresh"));
      });
      updateWeatherMutationsDisabled();
      updateColorButtons();
      card2.style.opacity = cardDisabled ? "0.55" : "";
      updateAddRecipeDisabled();
    };
    function buildRecipeToggleGrid(selection, onSelectionChange) {
      const toggleGrid = applyStyles(document.createElement("div"), {
        display: "grid",
        gridTemplateColumns: "repeat(4, minmax(80px, 1fr))",
        columnGap: "6px",
        rowGap: "6px",
        justifyItems: "center"
      });
      const toggles = /* @__PURE__ */ new Map();
      WEATHER_MUTATIONS.forEach((info) => {
        const toggle = createWeatherMutationToggle({
          key: info.key,
          label: info.label,
          iconSize: 40,
          dense: true,
          kind: "recipe",
          iconFactory: info.iconFactory
        });
        toggles.set(info.key, toggle);
        toggle.setChecked(selection.has(toggle.key));
        toggle.input.addEventListener("change", () => {
          const checked = toggle.input.checked;
          const group = WEATHER_RECIPE_GROUPS[toggle.key];
          if (checked && group) {
            WEATHER_RECIPE_GROUP_MEMBERS[group].forEach((other) => {
              if (other === toggle.key) return;
              if (!selection.has(other)) return;
              selection.delete(other);
              toggles.get(other)?.setChecked(false);
            });
          }
          if (checked) {
            selection.add(toggle.key);
          } else {
            selection.delete(toggle.key);
          }
          onSelectionChange();
        });
        toggleGrid.appendChild(toggle.wrap);
      });
      return toggleGrid;
    }
    function repaintRecipes() {
      recipesList.innerHTML = "";
      const hasDraftNew = editingRecipeIndex !== null && editingRecipeIndex === state3.weatherRecipes.length;
      const totalRows = state3.weatherRecipes.length + (hasDraftNew ? 1 : 0);
      if (totalRows === 0) {
        recipesList.appendChild(emptyRecipes);
        applyDisabled();
        return;
      }
      state3.weatherRecipes.forEach((set3, index) => {
        normalizeRecipeSelection(set3);
        const isEditing = editingRecipeIndex === index;
        const selection = isEditing ? editingRecipeDraft : set3;
        const row = applyStyles(document.createElement("div"), {
          display: "flex",
          gap: isEditing ? "10px" : "12px",
          border: "1px solid rgba(255,255,255,0.10)",
          borderRadius: "10px",
          padding: isEditing ? "12px" : "10px 12px",
          background: "rgba(255,255,255,0.02)",
          boxShadow: "none",
          width: "100%"
        });
        if (isEditing) {
          row.style.flexDirection = "column";
        } else {
          row.style.flexDirection = "row";
          row.style.alignItems = "center";
          row.style.justifyContent = "space-between";
          row.style.flexWrap = "wrap";
        }
        const summary = document.createElement("div");
        renderRecipeSummary(summary, selection);
        if (!isEditing) {
          summary.style.flex = "1 1 auto";
          summary.style.minWidth = "220px";
        }
        row.appendChild(summary);
        if (isEditing) {
          const toggleGrid = buildRecipeToggleGrid(selection, () => renderRecipeSummary(summary, selection));
          row.appendChild(toggleGrid);
          const actions = applyStyles(document.createElement("div"), {
            display: "flex",
            gap: "8px",
            width: "100%"
          });
          const btnCancel = document.createElement("button");
          styleBtnFullWidth(btnCancel, "\u274C");
          btnCancel.onclick = cancelEditingRecipe;
          const btnValidate = document.createElement("button");
          styleBtnFullWidth(btnValidate, "\u2714\uFE0F");
          btnValidate.onclick = commitEditingRecipe;
          actions.append(btnCancel, btnValidate);
          if (editingRecipeIndex !== null && editingRecipeIndex < state3.weatherRecipes.length) {
            const btnDelete = document.createElement("button");
            styleBtnFullWidth(btnDelete, "\u{1F5D1}\uFE0F");
            btnDelete.title = "Delete";
            btnDelete.setAttribute("aria-label", "Delete");
            btnDelete.onclick = () => deleteRecipeAt(index);
            actions.append(btnDelete);
          }
          row.appendChild(actions);
        } else {
          const actions = applyStyles(document.createElement("div"), {
            display: "flex",
            gap: "6px",
            alignItems: "center",
            justifyContent: "flex-end",
            flex: "0 0 auto"
          });
          actions.style.flexWrap = "nowrap";
          const btnEdit = document.createElement("button");
          styleBtnCompact(btnEdit, "\u270F\uFE0F");
          btnEdit.title = "Edit";
          btnEdit.setAttribute("aria-label", "Edit");
          btnEdit.onclick = () => startEditingRecipe(index, set3);
          const btnDelete = document.createElement("button");
          styleBtnCompact(btnDelete, "\u{1F5D1}\uFE0F");
          btnDelete.title = "Delete";
          btnDelete.setAttribute("aria-label", "Delete");
          btnDelete.onclick = () => deleteRecipeAt(index);
          actions.append(btnEdit, btnDelete);
          row.appendChild(actions);
        }
        recipesList.appendChild(row);
      });
      if (hasDraftNew && editingRecipeIndex !== null) {
        const selection = editingRecipeDraft;
        const row = applyStyles(document.createElement("div"), {
          display: "flex",
          flexDirection: "column",
          gap: "10px",
          border: "1px solid rgba(255,255,255,0.10)",
          borderRadius: "10px",
          padding: "12px",
          background: "rgba(255,255,255,0.02)",
          boxShadow: "none",
          width: "100%"
        });
        const summary = document.createElement("div");
        renderRecipeSummary(summary, selection);
        row.appendChild(summary);
        const toggleGrid = buildRecipeToggleGrid(selection, () => renderRecipeSummary(summary, selection));
        row.appendChild(toggleGrid);
        const actions = applyStyles(document.createElement("div"), {
          display: "flex",
          gap: "8px",
          width: "100%"
        });
        const btnCancel = document.createElement("button");
        styleBtnFullWidth(btnCancel, "\u274C");
        btnCancel.onclick = cancelEditingRecipe;
        const btnValidate = document.createElement("button");
        styleBtnFullWidth(btnValidate, "\u2714\uFE0F");
        btnValidate.onclick = commitEditingRecipe;
        actions.append(btnCancel, btnValidate);
        row.appendChild(actions);
        recipesList.appendChild(row);
      }
      applyDisabled();
    }
    btnAddRecipe.onclick = () => {
      startEditingRecipe(state3.weatherRecipes.length);
    };
    recipesWrap.append(recipesHeader, recipesList);
    card2.append(
      makeSection("Harvest mode", lockModeRow),
      makeSection("Filter by size", scaleRow),
      makeSection("Filter by color", colorsRow),
      makeSection("Filter by weather", weatherGrid),
      makeSection("Weather filter mode", weatherModeRow),
      makeSection("Weather recipes", recipesWrap)
    );
    const refresh = () => {
      updateLockModeUI();
      scaleSlider.setValues(state3.minScalePct, state3.maxScalePct);
      minSlider.value = String(state3.minScalePct);
      maxSlider.value = String(state3.maxScalePct);
      applyScaleRange(false);
      applyScaleMinimum(false);
      applyScaleMaximum(false);
      applyScaleMode(state3.scaleLockMode, false);
      updateColorButtons();
      weatherToggles.forEach((toggle) => toggle.setChecked(state3.weatherSelected.has(toggle.key)));
      radioAny.input.checked = state3.weatherMode === "ANY";
      radioAll.input.checked = state3.weatherMode === "ALL";
      radioRecipes.input.checked = state3.weatherMode === "RECIPES";
      recipesWrap.style.display = state3.weatherMode === "RECIPES" ? "" : "none";
      updateWeatherMutationsDisabled();
      repaintRecipes();
    };
    const setDisabled = (value) => {
      card2.dataset.disabled = value ? "1" : "0";
      applyDisabled();
    };
    refresh();
    return { root: card2, refresh, setDisabled };
  }
  function createRestrictionsTabRenderer(ui) {
    let state3 = lockerRestrictionsService.getState();
    let bonusFromMultiplier = null;
    let bonusFromPlayers = friendBonusPercentFromPlayers(1);
    let eggOptions = [];
    const disposables = [];
    let subsAttached = false;
    const clampPercent4 = (value) => Math.max(0, Math.min(FRIEND_BONUS_MAX, Math.round(value / FRIEND_BONUS_STEP) * FRIEND_BONUS_STEP));
    const resolveCurrentBonus = () => bonusFromMultiplier ?? bonusFromPlayers ?? 0;
    const layout = applyStyles(document.createElement("div"), {
      display: "grid",
      gap: "12px",
      justifyItems: "center",
      width: "100%",
      maxWidth: "1100px"
    });
    const card2 = ui.card("Friend bonus locker", {
      align: "stretch"
    });
    card2.root.style.width = "100%";
    card2.header.style.display = "flex";
    card2.header.style.alignItems = "center";
    card2.header.style.justifyContent = "space-between";
    const sliderWrap = applyStyles(document.createElement("div"), {
      display: "grid",
      gap: "6px"
    });
    const sliderHeader = ui.flexRow({ justify: "between", align: "center", fullWidth: true });
    const sliderTitle = document.createElement("div");
    sliderTitle.textContent = "Minimum friend bonus required\u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E \u200E ";
    sliderTitle.style.fontWeight = "600";
    const sliderValue = applyStyles(document.createElement("div"), {
      fontWeight: "700",
      color: "#ff7a1f",
      textShadow: "0 1px 1px rgba(0, 0, 0, 0.5)"
    });
    sliderHeader.append(sliderTitle, sliderValue);
    const initialRequiredPct = friendBonusPercentFromPlayers(state3.minRequiredPlayers) ?? 0;
    const slider = ui.slider(0, FRIEND_BONUS_MAX, FRIEND_BONUS_STEP, initialRequiredPct);
    slider.style.width = "100%";
    sliderWrap.append(sliderHeader, slider);
    const statusBadge = applyStyles(document.createElement("div"), {
      display: "inline-flex",
      alignItems: "center",
      gap: "6px",
      padding: "4px 10px",
      borderRadius: "999px",
      fontWeight: "700",
      fontSize: "12px",
      letterSpacing: "0.25px"
    });
    statusBadge.style.marginLeft = "auto";
    card2.header.appendChild(statusBadge);
    const statusText = applyStyles(document.createElement("div"), {
      fontSize: "12.5px",
      lineHeight: "1.5",
      opacity: "0.92"
    });
    card2.body.append(sliderWrap, statusText);
    layout.append(card2.root);
    const decorCard = ui.card("Decor pick locker", { align: "stretch" });
    decorCard.root.style.width = "100%";
    const decorRow = applyStyles(document.createElement("div"), {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      gap: "12px"
    });
    const decorText = applyStyles(document.createElement("div"), {
      display: "flex",
      flexDirection: "column",
      gap: "4px"
    });
    const decorSubtitle = document.createElement("div");
    decorSubtitle.textContent = "Prevents placed decors from being picked up";
    decorSubtitle.style.fontSize = "12.5px";
    decorSubtitle.style.opacity = "0.85";
    decorText.append(decorSubtitle);
    const decorToggle = ui.switch(state3.decorPickupLocked);
    decorToggle.addEventListener("change", () => {
      const locked = !!decorToggle.checked;
      state3.decorPickupLocked = locked;
      lockerRestrictionsService.setDecorPickupLocked(locked);
    });
    decorRow.append(decorText, decorToggle);
    decorCard.body.append(decorRow);
    layout.append(decorCard.root);
    const eggCard = ui.card("Egg hatch locker", { align: "stretch" });
    eggCard.root.style.width = "100%";
    const eggList = applyStyles(document.createElement("div"), {
      display: "grid",
      gap: "8px",
      width: "100%"
    });
    eggCard.body.append(eggList);
    layout.append(eggCard.root);
    const sellPetsCard = ui.card("Sell all pets protections", { align: "stretch" });
    sellPetsCard.root.style.width = "100%";
    const sellPetsIntro = document.createElement("div");
    sellPetsIntro.textContent = "Show a confirmation modal when protected pets are detected.";
    sellPetsIntro.style.fontSize = "12.5px";
    sellPetsIntro.style.opacity = "0.8";
    const sellPetsGrid = applyStyles(document.createElement("div"), {
      display: "grid",
      gap: "10px",
      marginTop: "6px"
    });
    const createRuleRow = (title, subtitle) => {
      const row = applyStyles(document.createElement("div"), {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        gap: "12px",
        padding: "8px 10px",
        border: "1px solid rgba(255,255,255,0.10)",
        borderRadius: "10px",
        background: "rgba(255,255,255,0.02)"
      });
      const text = applyStyles(document.createElement("div"), {
        display: "grid",
        gap: "2px"
      });
      const titleEl = document.createElement("div");
      titleEl.textContent = title;
      titleEl.style.fontWeight = "600";
      titleEl.style.fontSize = "13px";
      text.appendChild(titleEl);
      if (subtitle) {
        const sub = document.createElement("div");
        sub.textContent = subtitle;
        sub.style.fontSize = "12px";
        sub.style.opacity = "0.75";
        text.appendChild(sub);
      }
      const controls = applyStyles(document.createElement("div"), {
        display: "flex",
        alignItems: "center",
        gap: "8px"
      });
      row.append(text, controls);
      return { row, controls };
    };
    const sellRulesInitial = lockerRestrictionsService.getSellAllPetsRules();
    const sellEnableToggle = ui.switch(sellRulesInitial.enabled);
    const sellEnableRow = createRuleRow("Enable protection rules");
    sellEnableRow.controls.append(sellEnableToggle);
    const sellGoldToggle = ui.switch(sellRulesInitial.protectGold);
    const sellGoldRow = createRuleRow("Protect Gold mutation");
    sellGoldRow.controls.append(sellGoldToggle);
    const sellRainbowToggle = ui.switch(sellRulesInitial.protectRainbow);
    const sellRainbowRow = createRuleRow("Protect Rainbow mutation");
    sellRainbowRow.controls.append(sellRainbowToggle);
    const sellMaxStrToggle = ui.switch(sellRulesInitial.protectMaxStr);
    const sellMaxStrInput = ui.inputNumber(0, 100, 1, sellRulesInitial.maxStrThreshold);
    const sellMaxStrWrap = sellMaxStrInput.wrap;
    const sellMaxStrRow = createRuleRow("Protect pets with Max STR");
    sellMaxStrRow.controls.append(sellMaxStrToggle, sellMaxStrWrap);
    sellPetsGrid.append(sellEnableRow.row, sellGoldRow.row, sellRainbowRow.row, sellMaxStrRow.row);
    sellPetsCard.body.append(sellPetsIntro, sellPetsGrid);
    layout.append(sellPetsCard.root);
    const LOCKED_ICON = "\u{1F512}";
    const UNLOCKED_ICON = "\u{1F513}";
    const eggRowCache = /* @__PURE__ */ new Map();
    const emptyEggPlaceholder = applyStyles(document.createElement("div"), {
      opacity: "0.7",
      fontSize: "12px"
    });
    emptyEggPlaceholder.textContent = "No eggs detected in shop.";
    const updateEggToggleAppearance = (toggle, locked) => {
      toggle.textContent = locked ? LOCKED_ICON : UNLOCKED_ICON;
      toggle.style.background = locked ? "rgba(239,68,68,0.15)" : "rgba(16,185,129,0.15)";
      toggle.style.color = locked ? "#fca5a5" : "#9ef7c3";
    };
    let renderEggList;
    const createEggRow = (opt) => {
      const row = applyStyles(document.createElement("div"), {
        display: "grid",
        gridTemplateColumns: "auto auto 1fr",
        alignItems: "center",
        gap: "10px",
        padding: "8px 10px",
        border: "1px solid rgba(255,255,255,0.10)",
        borderRadius: "10px",
        background: "rgba(255,255,255,0.02)"
      });
      const toggle = document.createElement("button");
      toggle.type = "button";
      toggle.style.border = "1px solid rgba(255,255,255,0.10)";
      toggle.style.borderRadius = "10px";
      toggle.style.padding = "6px 10px";
      toggle.style.fontSize = "14px";
      toggle.style.fontWeight = "700";
      toggle.addEventListener("click", () => {
        const next = !Boolean(state3.eggLocks?.[opt.id]);
        state3.eggLocks = { ...state3.eggLocks || {}, [opt.id]: next };
        lockerRestrictionsService.setEggLock(opt.id, next);
        renderEggList();
      });
      const name = document.createElement("div");
      name.style.fontWeight = "600";
      name.style.color = "#e7eef7";
      const icon = createEggIcon(opt.id, opt.name, 32);
      row.append(toggle, icon, name);
      return { row, toggle, name };
    };
    renderEggList = () => {
      eggList.innerHTML = "";
      if (!eggOptions.length) {
        eggList.appendChild(emptyEggPlaceholder);
        return;
      }
      const fragment = document.createDocumentFragment();
      const seen = /* @__PURE__ */ new Set();
      eggOptions.forEach((opt) => {
        const id = opt.id;
        seen.add(id);
        let entry = eggRowCache.get(id);
        if (!entry) {
          entry = createEggRow(opt);
          eggRowCache.set(id, entry);
        }
        entry.name.textContent = opt.name || id;
        const locked = !!state3.eggLocks?.[id];
        updateEggToggleAppearance(entry.toggle, locked);
        fragment.appendChild(entry.row);
      });
      for (const id of Array.from(eggRowCache.keys())) {
        if (seen.has(id)) continue;
        const entry = eggRowCache.get(id);
        if (entry) {
          entry.row.remove();
        }
        eggRowCache.delete(id);
      }
      eggList.appendChild(fragment);
    };
    const updateSliderValue = (pct) => {
      slider.value = String(pct);
      sliderValue.textContent = `+${pct}%`;
    };
    const clampMaxStr = (value) => {
      if (!Number.isFinite(value)) return 0;
      return Math.max(0, Math.min(100, Math.round(value)));
    };
    const setRuleRowDisabled = (row, disabled) => {
      row.style.opacity = disabled ? "0.6" : "1";
    };
    const refreshSellAllPetsControls = () => {
      const rules = lockerRestrictionsService.getSellAllPetsRules();
      const enabled = rules.enabled !== false;
      const protectGold = rules.protectGold !== false;
      const protectRainbow = rules.protectRainbow !== false;
      const protectMaxStr = rules.protectMaxStr !== false;
      setCheck(sellEnableToggle, enabled);
      setCheck(sellGoldToggle, protectGold);
      setCheck(sellRainbowToggle, protectRainbow);
      setCheck(sellMaxStrToggle, protectMaxStr);
      sellMaxStrInput.value = String(clampMaxStr(rules.maxStrThreshold));
      sellGoldToggle.disabled = !enabled;
      sellRainbowToggle.disabled = !enabled;
      sellMaxStrToggle.disabled = !enabled;
      const maxStrDisabled = !enabled || !protectMaxStr;
      sellMaxStrInput.disabled = maxStrDisabled;
      sellMaxStrWrap.style.opacity = maxStrDisabled ? "0.6" : "1";
      sellMaxStrWrap.style.pointerEvents = maxStrDisabled ? "none" : "auto";
      setRuleRowDisabled(sellGoldRow.row, !enabled);
      setRuleRowDisabled(sellRainbowRow.row, !enabled);
      setRuleRowDisabled(sellMaxStrRow.row, !enabled);
    };
    const setStatusTone = (tone) => {
      const palette = tone === "success" ? { bg: "rgba(16,185,129,0.15)", border: "rgba(16,185,129,0.35)", color: "#9ef7c3" } : tone === "warn" ? { bg: "rgba(239,68,68,0.15)", border: "rgba(239,68,68,0.35)", color: "#fca5a5" } : { bg: "rgba(59,130,246,0.15)", border: "rgba(59,130,246,0.35)", color: "#a5c7ff" };
      statusBadge.style.background = palette.bg;
      statusBadge.style.border = `1px solid ${palette.border}`;
      statusBadge.style.color = palette.color;
    };
    const updateStatus = () => {
      const requiredPct = clampPercent4(friendBonusPercentFromPlayers(state3.minRequiredPlayers) ?? 0);
      const currentPct = resolveCurrentBonus();
      const requiredPlayers = state3.minRequiredPlayers;
      const currentPlayers = currentPct != null ? percentToRequiredFriendCount(currentPct) : null;
      const allowed = requiredPct <= 0 || currentPct != null && currentPct + 1e-4 >= requiredPct;
      if (requiredPct <= 0) {
        statusBadge.textContent = "Unlocked";
        setStatusTone("info");
        statusText.textContent = currentPct != null ? `Current friend bonus: ${currentPct}% (${currentPlayers} players).` : "Current friend bonus not detected yet.";
        return;
      }
      statusBadge.textContent = allowed ? "Sale allowed" : "Sale locked";
      setStatusTone(allowed ? "success" : "warn");
      statusText.textContent = allowed ? `Current bonus ${currentPct}% (${currentPlayers} players) meets the requirement (${requiredPct}%).` : `Requires ${requiredPct}% (${requiredPlayers} players) or more`;
    };
    const handleSliderInput = (commit2) => {
      const raw = Number(slider.value);
      const pct = clampPercent4(Number.isFinite(raw) ? raw : 0);
      updateSliderValue(pct);
      state3.minRequiredPlayers = percentToRequiredFriendCount(pct);
      updateStatus();
      if (commit2) {
        lockerRestrictionsService.setMinRequiredPlayers(state3.minRequiredPlayers);
      }
    };
    slider.addEventListener("input", () => handleSliderInput(false));
    slider.addEventListener("change", () => handleSliderInput(true));
    sellEnableToggle.addEventListener("change", () => {
      const enabled = !!sellEnableToggle.checked;
      lockerRestrictionsService.setSellAllPetsRules({ enabled });
      refreshSellAllPetsControls();
    });
    sellGoldToggle.addEventListener("change", () => {
      lockerRestrictionsService.setSellAllPetsRules({ protectGold: !!sellGoldToggle.checked });
    });
    sellRainbowToggle.addEventListener("change", () => {
      lockerRestrictionsService.setSellAllPetsRules({ protectRainbow: !!sellRainbowToggle.checked });
    });
    sellMaxStrToggle.addEventListener("change", () => {
      lockerRestrictionsService.setSellAllPetsRules({ protectMaxStr: !!sellMaxStrToggle.checked });
      refreshSellAllPetsControls();
    });
    sellMaxStrInput.addEventListener("change", () => {
      const next = clampMaxStr(Number(sellMaxStrInput.value));
      sellMaxStrInput.value = String(next);
      lockerRestrictionsService.setSellAllPetsRules({ maxStrThreshold: next });
    });
    const syncFromService = (next) => {
      state3 = { ...next };
      setCheck(decorToggle, state3.decorPickupLocked);
      updateSliderValue(friendBonusPercentFromPlayers(state3.minRequiredPlayers) ?? 0);
      updateStatus();
      renderEggList();
      refreshSellAllPetsControls();
    };
    const attachSubscriptions = async () => {
      if (subsAttached) return;
      subsAttached = true;
      try {
        const initialBonus = await Atoms.server.friendBonusMultiplier.get();
        bonusFromMultiplier = friendBonusPercentFromMultiplier(initialBonus);
      } catch {
      }
      try {
        const unsub = await Atoms.server.friendBonusMultiplier.onChange((next) => {
          bonusFromMultiplier = friendBonusPercentFromMultiplier(next);
          updateStatus();
        });
        if (typeof unsub === "function") disposables.push(unsub);
      } catch {
      }
      try {
        const initialPlayers = await Atoms.server.numPlayers.get();
        bonusFromPlayers = friendBonusPercentFromPlayers(initialPlayers);
      } catch {
      }
      try {
        const unsubPlayers = await Atoms.server.numPlayers.onChange((next) => {
          bonusFromPlayers = friendBonusPercentFromPlayers(next);
          updateStatus();
        });
        if (typeof unsubPlayers === "function") disposables.push(unsubPlayers);
      } catch {
      }
      const unsubService = lockerRestrictionsService.subscribe(syncFromService);
      disposables.push(unsubService);
      try {
        const initialEggShop = await Atoms.shop.eggShop.get();
        eggOptions = extractEggOptions(initialEggShop);
        renderEggList();
      } catch {
      }
      try {
        const unsubEggShop = await Atoms.shop.eggShop.onChange((next) => {
          eggOptions = extractEggOptions(next);
          renderEggList();
        });
        if (typeof unsubEggShop === "function") disposables.push(unsubEggShop);
      } catch {
      }
    };
    const render2 = (view) => {
      view.innerHTML = "";
      view.style.maxHeight = "54vh";
      view.style.overflow = "auto";
      view.append(layout);
      syncFromService(lockerRestrictionsService.getState());
      updateStatus();
      void attachSubscriptions();
    };
    const destroy = () => {
      while (disposables.length) {
        const dispose = disposables.pop();
        try {
          dispose?.();
        } catch {
        }
      }
    };
    return { render: render2, destroy };
  }
  function extractEggOptions(raw) {
    const seen = /* @__PURE__ */ new Set();
    const options = [];
    const add = (id, name) => {
      if (typeof id !== "string" || !id) return;
      if (seen.has(id)) return;
      seen.add(id);
      const label2 = typeof name === "string" && name || typeof raw?.names?.[id] === "string" && raw.names[id] || id;
      options.push({ id, name: label2 });
    };
    const walk = (node) => {
      if (!node || typeof node !== "object") return;
      if (Array.isArray(node)) {
        node.forEach(walk);
        return;
      }
      const candidate = node.eggId ?? node.id ?? null;
      add(candidate, node.name);
      for (const value of Object.values(node)) {
        if (value && typeof value === "object") walk(value);
      }
    };
    walk(raw);
    return options;
  }
  function createGeneralTabRenderer(ui, store) {
    const viewRoot = applyStyles(document.createElement("div"), {
      display: "flex",
      flexDirection: "column",
      gap: "12px",
      alignItems: "center",
      width: "100%"
    });
    const layout = applyStyles(document.createElement("div"), {
      display: "flex",
      flexDirection: "column",
      gap: "12px",
      alignItems: "center",
      width: "100%"
    });
    const header = applyStyles(document.createElement("div"), {
      display: "flex",
      alignItems: "center",
      gap: "10px",
      justifyContent: "space-between",
      border: "1px solid rgba(255,255,255,0.10)",
      borderRadius: "10px",
      padding: "12px 16px",
      background: "rgba(255,255,255,0.04)",
      boxShadow: "none",
      width: "min(760px, 100%)"
    });
    const textWrap = applyStyles(document.createElement("div"), {
      display: "flex",
      flexDirection: "column",
      gap: "4px"
    });
    const title = document.createElement("div");
    title.textContent = "Global locker";
    title.style.fontWeight = "600";
    title.style.fontSize = "15px";
    const subtitle = document.createElement("div");
    subtitle.textContent = "Set the rules for locking or allowing harvests using the filters below";
    subtitle.style.opacity = "0.8";
    subtitle.style.fontSize = "12px";
    textWrap.append(title, subtitle);
    const toggleWrap = applyStyles(document.createElement("label"), {
      display: "flex",
      alignItems: "center",
      gap: "8px"
    });
    const toggleLabel = ui.label("Enabled");
    toggleLabel.style.margin = "0";
    const toggle = ui.switch(store.global.enabled);
    toggleWrap.append(toggleLabel, toggle);
    header.append(textWrap, toggleWrap);
    const form = createLockerSettingsCard(ui, store.global.settings, {
      onChange: () => store.notifyGlobalSettingsChanged()
    });
    layout.append(header, form.root);
    viewRoot.append(layout);
    const update = () => {
      setCheck(toggle, store.global.enabled);
      form.setDisabled(!store.global.enabled);
      form.refresh();
    };
    toggle.addEventListener("change", () => {
      store.setGlobalEnabled(!!toggle.checked);
    });
    const unsubscribe2 = store.subscribe(() => {
      update();
    });
    update();
    const render2 = (view) => {
      view.innerHTML = "";
      view.style.maxHeight = "54vh";
      view.style.overflow = "auto";
      view.append(viewRoot);
      update();
    };
    return {
      render: render2,
      destroy: () => unsubscribe2()
    };
  }
  function createOverridesTabRenderer(ui, store) {
    const layout = applyStyles(document.createElement("div"), {
      display: "grid",
      gridTemplateColumns: "minmax(220px, 280px) minmax(0, 1fr)",
      gap: "10px",
      alignItems: "stretch",
      height: "54vh",
      overflow: "hidden"
    });
    const left = applyStyles(document.createElement("div"), {
      display: "grid",
      gridTemplateRows: "1fr",
      gap: "8px",
      minHeight: "0"
    });
    layout.appendChild(left);
    const list = applyStyles(document.createElement("div"), {
      display: "grid",
      gridTemplateColumns: "1fr",
      rowGap: "6px",
      overflow: "auto",
      paddingRight: "2px",
      border: "1px solid rgba(255,255,255,0.10)",
      borderRadius: "10px",
      padding: "6px"
    });
    left.appendChild(list);
    const right = applyStyles(document.createElement("div"), {
      display: "flex",
      flexDirection: "column",
      gap: "12px",
      minHeight: "0"
    });
    layout.appendChild(right);
    const detail = applyStyles(document.createElement("div"), {
      display: "grid",
      gap: "12px",
      justifyItems: "center",
      alignContent: "start",
      height: "100%",
      overflow: "auto"
    });
    right.appendChild(detail);
    let selectedKey = null;
    let renderedDetailKey = null;
    const detailScrollMemory = /* @__PURE__ */ new Map();
    const listButtons = /* @__PURE__ */ new Map();
    const getClampedScrollTop = (element) => {
      const max = Math.max(0, element.scrollHeight - element.clientHeight);
      return Math.max(0, Math.min(element.scrollTop, max));
    };
    const restoreScrollTop = (element, value) => {
      const max = Math.max(0, element.scrollHeight - element.clientHeight);
      const target = Math.max(0, Math.min(value, max));
      element.scrollTop = target;
      return target;
    };
    const updateDetailScrollMemory = (key2) => {
      const current = detailScrollMemory.get(key2) ?? { detail: 0, card: 0 };
      current.detail = getClampedScrollTop(detail);
      const currentCard = detail.querySelector('[data-locker-settings-card="1"]');
      if (currentCard) {
        current.card = getClampedScrollTop(currentCard);
      }
      detailScrollMemory.set(key2, current);
    };
    detail.addEventListener("scroll", () => {
      if (!renderedDetailKey) return;
      const memory = detailScrollMemory.get(renderedDetailKey) ?? { detail: 0, card: 0 };
      memory.detail = getClampedScrollTop(detail);
      detailScrollMemory.set(renderedDetailKey, memory);
    });
    const refreshListStyles = () => {
      listButtons.forEach(({ button, dot }, key2) => {
        const isSelected = selectedKey === key2;
        button.style.background = isSelected ? "rgba(94,234,212,0.15)" : "rgba(255,255,255,0.04)";
        dot.style.background = store.getOverride(key2)?.enabled ? "#2ecc71" : "#e74c3c";
      });
    };
    const renderList = () => {
      const previousScrollTop = getClampedScrollTop(list);
      list.innerHTML = "";
      const seeds = getLockerSeedOptions();
      if (!seeds.length) {
        const empty = document.createElement("div");
        empty.textContent = "No crops available.";
        empty.style.opacity = "0.7";
        empty.style.fontSize = "12px";
        empty.style.textAlign = "center";
        empty.style.padding = "16px";
        list.appendChild(empty);
        restoreScrollTop(list, previousScrollTop);
        selectedKey = null;
        return;
      }
      if (selectedKey && !seeds.some((opt) => opt.key === selectedKey)) {
        selectedKey = null;
      }
      listButtons.clear();
      const fragment = document.createDocumentFragment();
      seeds.forEach((opt) => {
        const button = document.createElement("button");
        button.className = "qmm-vtab";
        button.style.display = "grid";
        button.style.gridTemplateColumns = "16px 1fr auto";
        button.style.alignItems = "center";
        button.style.gap = "8px";
        button.style.textAlign = "left";
        button.style.padding = "6px 8px";
        button.style.borderRadius = "8px";
        button.style.border = "1px solid rgba(255,255,255,0.10)";
        button.style.background = selectedKey === opt.key ? "rgba(94,234,212,0.15)" : "rgba(255,255,255,0.04)";
        button.style.color = "#e7eef7";
        const dot = document.createElement("span");
        dot.className = "qmm-dot";
        dot.style.background = store.getOverride(opt.key)?.enabled ? "#2ecc71" : "#e74c3c";
        const label2 = document.createElement("span");
        label2.className = "label";
        label2.textContent = opt.cropName || opt.key;
        const icon = createSeedIcon(opt.key, { size: 24 });
        button.append(dot, label2, icon);
        listButtons.set(opt.key, { button, dot });
        button.onmouseenter = () => button.style.borderColor = "rgba(94,234,212,0.35)";
        button.onmouseleave = () => button.style.borderColor = "rgba(255,255,255,0.10)";
        button.onclick = () => {
          if (selectedKey === opt.key) return;
          selectedKey = opt.key;
          refreshListStyles();
          renderDetail();
        };
        fragment.appendChild(button);
      });
      list.appendChild(fragment);
      refreshListStyles();
      restoreScrollTop(list, previousScrollTop);
    };
    const renderDetail = () => {
      if (renderedDetailKey) {
        updateDetailScrollMemory(renderedDetailKey);
      }
      detail.innerHTML = "";
      if (!selectedKey) {
        const empty = document.createElement("div");
        empty.textContent = "Select a crop on the left to customise its locker settings.";
        empty.style.opacity = "0.7";
        empty.style.fontSize = "13px";
        empty.style.textAlign = "center";
        empty.style.padding = "32px 24px";
        empty.style.border = "1px dashed rgba(255,255,255,0.12)";
        empty.style.borderRadius = "10px";
        empty.style.width = "min(760px, 100%)";
        detail.appendChild(empty);
        renderedDetailKey = null;
        return;
      }
      const seeds = getLockerSeedOptions();
      const seed = seeds.find((opt) => opt.key === selectedKey);
      if (!seed) {
        selectedKey = null;
        renderedDetailKey = null;
        renderDetail();
        return;
      }
      const override = store.ensureOverride(selectedKey, { silent: true });
      const header = ui.flexRow({ justify: "between", align: "center", fullWidth: true });
      header.style.border = "1px solid rgba(255,255,255,0.10)";
      header.style.borderRadius = "10px";
      header.style.padding = "12px 16px";
      header.style.background = "rgba(255,255,255,0.04)";
      header.style.boxShadow = "none";
      header.style.width = "min(760px, 100%)";
      const titleWrap = ui.flexRow({ gap: 10, align: "center" });
      titleWrap.style.flexWrap = "nowrap";
      const title = document.createElement("div");
      title.textContent = seed.cropName || seed.key;
      title.style.fontWeight = "600";
      title.style.fontSize = "15px";
      const icon = createSeedIcon(seed.key, { size: 32 });
      titleWrap.append(icon, title);
      const toggleWrap = ui.flexRow({ gap: 8, align: "center" });
      toggleWrap.style.flexWrap = "nowrap";
      const toggleLabel = ui.label("Override");
      toggleLabel.style.margin = "0";
      const toggle = ui.switch(override.enabled);
      toggleWrap.append(toggleLabel, toggle);
      header.append(titleWrap, toggleWrap);
      const status = document.createElement("div");
      status.style.fontSize = "12px";
      status.style.opacity = "0.75";
      status.style.textAlign = "center";
      status.style.width = "min(760px, 100%)";
      const updateStatus = () => {
        status.textContent = override.enabled ? "This crop uses its own locker filters." : "Uses the global locker settings.";
      };
      const form = createLockerSettingsCard(ui, override.settings, {
        onChange: () => {
          if (selectedKey) {
            store.notifyOverrideSettingsChanged(selectedKey);
          }
        }
      });
      const applyEnabledState = () => {
        form.setDisabled(!override.enabled);
        form.refresh();
        updateStatus();
      };
      toggle.addEventListener("change", () => {
        if (!selectedKey) return;
        const wasEnabled = override.enabled;
        const nextEnabled = !!toggle.checked;
        if (nextEnabled && !wasEnabled && !override.hasPersistedSettings) {
          copySettings(override.settings, store.global.settings);
        }
        if (nextEnabled) {
          override.hasPersistedSettings = true;
        }
        store.setOverrideEnabled(selectedKey, nextEnabled);
      });
      applyEnabledState();
      detail.append(header, status, form.root);
      if (selectedKey) {
        const memory = detailScrollMemory.get(selectedKey) ?? { detail: 0, card: 0 };
        memory.detail = restoreScrollTop(detail, memory.detail);
        memory.card = restoreScrollTop(form.root, memory.card);
        detailScrollMemory.set(selectedKey, memory);
        const activeKey = selectedKey;
        form.root.addEventListener("scroll", () => {
          if (renderedDetailKey !== activeKey) return;
          const current = detailScrollMemory.get(activeKey) ?? { detail: getClampedScrollTop(detail), card: 0 };
          current.card = getClampedScrollTop(form.root);
          detailScrollMemory.set(activeKey, current);
        });
        renderedDetailKey = activeKey;
      }
    };
    renderList();
    renderDetail();
    const refresh = () => {
      refreshListStyles();
      renderDetail();
    };
    const unsubscribe2 = store.subscribe(refresh);
    const render2 = (view) => {
      view.innerHTML = "";
      view.append(layout);
      refresh();
    };
    return {
      render: render2,
      destroy: () => unsubscribe2()
    };
  }
  async function renderLockerMenu(container) {
    const ui = new Menu({ id: "locker", compact: true });
    ui.mount(container);
    const store = new LockerMenuStore(lockerService.getState());
    const restrictionsTab = createRestrictionsTabRenderer(ui);
    const generalTab = createGeneralTabRenderer(ui, store);
    const overridesTab = createOverridesTabRenderer(ui, store);
    ui.addTabs([
      { id: "locker-general", title: "General", render: (view) => generalTab.render(view) },
      { id: "locker-overrides", title: "Overrides", render: (view) => overridesTab.render(view) },
      { id: "locker-restrictions", title: "Restrictions", render: (view) => restrictionsTab.render(view) }
    ]);
    ui.switchTo("locker-general");
    const disposables = [];
    disposables.push(lockerService.subscribe((event) => store.syncFromService(event.state)));
    disposables.push(() => restrictionsTab.destroy());
    disposables.push(() => generalTab.destroy());
    disposables.push(() => overridesTab.destroy());
    const cleanup2 = () => {
      while (disposables.length) {
        const dispose = disposables.pop();
        try {
          dispose?.();
        } catch {
        }
      }
    };
    ui.on("unmounted", cleanup2);
  }

  // src/ui/menus/calculator.ts
  var ROOT_CLASS = "mg-crop-simulation";
  var SIZE_MIN = 50;
  var SIZE_MAX = 100;
  var SCALE_MIN = 1;
  var SCALE_MAX = 3;
  var COLOR_MUTATION_LABELS = ["None", "Gold", "Rainbow"];
  var WEATHER_CONDITION_LABELS = ["None", "Wet", "Chilled", "Frozen", "Thunderstruck"];
  var WEATHER_LIGHTING_LABELS = ["None", "Dawnlit", "Dawnbound", "Amberlit", "Amberbound"];
  var FRIEND_BONUS_LABELS = ["+0%", "+10%", "+20%", "+30%", "+40%", "+50%"];
  var FRIEND_BONUS_MIN_PLAYERS = 1;
  var FRIEND_BONUS_MAX_PLAYERS = FRIEND_BONUS_LABELS.length;
  var COLOR_SEGMENT_METADATA = {
    None: { mgColor: "none" },
    Gold: { mgColor: "gold" },
    Rainbow: { mgColor: "rainbow" }
  };
  var WEATHER_CONDITION_SEGMENT_METADATA = {
    None: { mgWeather: "none" },
    Wet: { mgWeather: "wet" },
    Chilled: { mgWeather: "chilled" },
    Frozen: { mgWeather: "frozen" },
    Thunderstruck: { mgWeather: "thunderstruck" }
  };
  var WEATHER_LIGHTING_SEGMENT_METADATA = {
    None: { mgLighting: "none" },
    Dawnlit: { mgLighting: "dawnlit" },
    Dawnbound: { mgLighting: "dawnbound" },
    Amberlit: { mgLighting: "amberlit" },
    Amberbound: { mgLighting: "amberbound" }
  };
  var MUTATION_SPRITE_OVERRIDES = {
    dawnlit: "Dawnlit",
    dawnbound: "Dawncharged",
    amberlit: "Ambershine",
    amberbound: "Ambercharged",
    thunderstruck: "Thunderstruck"
  };
  var segmentedUi = new Menu({ compact: true });
  var ensureMenuStyles = segmentedUi.ensureStyles;
  ensureMenuStyles?.call(segmentedUi);
  var priceFormatter = new Intl.NumberFormat("en-US");
  var weightFormatter = new Intl.NumberFormat("en-US", {
    minimumFractionDigits: 3,
    maximumFractionDigits: 3
  });
  var DEFAULT_STATE2 = {
    sizePercent: SIZE_MIN,
    color: "None",
    weatherCondition: "None",
    weatherLighting: "None",
    friendPlayers: FRIEND_BONUS_MIN_PLAYERS
  };
  var BASE_SPRITE_SIZE_PX = 96;
  var DEFAULT_SPRITE_CATEGORIES = ["tallplant", "plant", "crop"];
  var PLANT_PRIORITY_IDENTIFIERS = /* @__PURE__ */ new Set([
    "dawncelestial",
    "mooncelestial",
    "dawnbinder",
    "moonbinder",
    "dawnbinderbulb",
    "moonbinderbulb",
    "dawnbinderpod",
    "moonbinderpod"
  ]);
  var CROP_SIMULATION_CSS = `
.${ROOT_CLASS} {
  display: none;
  width: min(100%, 500px);
  padding: 12px 14px;
  color: #e2e8f0;
  display: flex;
  flex-direction: column;
  gap: 10px;
  font-family: "Inter", system-ui, -apple-system, "Segoe UI", sans-serif;
  position: relative;
  z-index: 2000;
  pointer-events: auto;
}
.${ROOT_CLASS} .mg-crop-simulation__header {
  display: flex;
  align-items: baseline;
  justify-content: space-between;
  gap: 8px;
}
.${ROOT_CLASS} .mg-crop-simulation__title {
  font-size: 13px;
  font-weight: 600;
  letter-spacing: 0.03em;
  text-transform: uppercase;
  color: #f8fafc;
}
.${ROOT_CLASS} .mg-crop-simulation__crop-name {
  font-size: 13px;
  font-weight: 600;
  color: #5eead4;
  text-transform: capitalize;
}
.${ROOT_CLASS} .mg-crop-simulation__sprite-section {
  display: flex;
  flex-direction: column;
}
.${ROOT_CLASS} .mg-crop-simulation__sprite-box {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 12px;
}
.${ROOT_CLASS} .mg-crop-simulation__sprite {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: ${BASE_SPRITE_SIZE_PX}px;
  height: ${BASE_SPRITE_SIZE_PX}px;
  position: relative;
  flex-shrink: 0;
  --mg-crop-simulation-scale: 1;
  transform-origin: center;
  transform: scale(var(--mg-crop-simulation-scale));
}
.${ROOT_CLASS} .mg-crop-simulation__sprite-layer,
.${ROOT_CLASS} .mg-crop-simulation__sprite-fallback {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
}
.${ROOT_CLASS} .mg-crop-simulation__sprite-layer img {
  width: 100%;
  height: 100%;
  object-fit: contain;
  image-rendering: pixelated;
}
.${ROOT_CLASS} .mg-crop-simulation__sprite-layer--base {
  z-index: 1;
}
.${ROOT_CLASS} .mg-crop-simulation__sprite-layer--overlay {
  z-index: 2;
  transform: translateY(-4px);
}
.${ROOT_CLASS} .mg-crop-simulation__sprite-layer--overlay-lighting {
  transform: translateY(-30px);
}
.${ROOT_CLASS} .mg-crop-simulation__sprite-fallback {
  z-index: 0;
  font-size: 42px;
}
.${ROOT_CLASS} .mg-crop-simulation__sprite[data-mg-has-sprite="1"] .mg-crop-simulation__sprite-fallback {
  opacity: 0;
}
.${ROOT_CLASS} .mg-crop-simulation__slider-container {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  gap: 6px;
}
.${ROOT_CLASS} .mg-crop-simulation__slider-row {
  display: flex;
  align-items: center;
  gap: 8px;
}
.${ROOT_CLASS} .mg-crop-simulation__slider-label {
  font-size: 12px;
  color: rgba(226, 232, 240, 0.82);
  flex: 0 0 auto;
}
.${ROOT_CLASS} .mg-crop-simulation__slider-value {
  margin-left: auto;
  font-size: 12px;
  font-variant-numeric: tabular-nums;
  color: #f8fafc;
  text-align: right;
  width: 4ch;
  min-width: 4ch;
  flex: 0 0 4ch;
  white-space: nowrap;
}
.${ROOT_CLASS} .mg-crop-simulation__slider-weight {
  font-size: 11px;
  color: rgba(148, 163, 184, 0.82);
  font-variant-numeric: tabular-nums;
  text-align: center;
  white-space: nowrap;
}
.${ROOT_CLASS} .mg-crop-simulation__slider {
  flex: 1 1 auto;
  min-width: 0;
  accent-color: #5eead4;
}
.${ROOT_CLASS} .mg-crop-simulation__price {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  font-weight: 700;
  font-size: 14px;
  color: #ffd84d;
  align-self: flex-start;
  margin-top: auto;
}
.${ROOT_CLASS} .mg-crop-simulation__price-icon {
  width: 20px;
  height: 20px;
  flex: 0 0 auto;
  display: inline-block;
  user-select: none;
  pointer-events: none;
}
.${ROOT_CLASS} .mg-crop-simulation__price-value {
  line-height: 1;
}
.${ROOT_CLASS} .mg-crop-simulation__section-title {
  font-size: 11px;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  color: rgba(148, 163, 184, 0.9);
}
.${ROOT_CLASS}.mg-crop-simulation--calculator {
  align-items: center;
}
.${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-calculator__layout {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  gap: 12px;
  width: min(440px, 100%);
  margin: 0 auto;
}
.${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-calculator__section {
  display: grid;
  gap: 10px;
  padding: 12px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.10);
  background: rgba(255,255,255,0.04);
  box-shadow: none;
  justify-items: stretch;
}
.${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-calculator__section-heading {
  font-size: 11px;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  color: rgba(226, 232, 240, 0.82);
  font-weight: 600;
  text-align: center;
}
.${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-calculator__section--preview {
  justify-items: center;
  text-align: center;
}
.${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-calculator__section--preview .mg-crop-simulation__slider-row {
  width: 100%;
}
.${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-calculator__mutations-weather {
  display: grid;
  gap: 8px;
}
.${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-calculator__mutations-heading {
  font-size: 10px;
  letter-spacing: 0.05em;
  text-transform: uppercase;
  color: rgba(148, 163, 184, 0.82);
  text-align: center;
}
.${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-simulation__price {
  margin-top: 0;
}
.${ROOT_CLASS} .mg-crop-simulation__segmented {
  display: flex;
  width: 100%;
}
.${ROOT_CLASS} .mg-crop-simulation__segmented-control {
  --qmm-bg-soft: rgba(11, 15, 19, 0.8);
  --qmm-border-2: rgba(148, 163, 184, 0.28);
  --qmm-text: #e2e8f0;
  --qmm-text-dim: rgba(148, 163, 184, 0.82);
  --seg-pad: 6px;
  --seg-fill: rgba(56, 191, 248, 0.02);
  --seg-stroke-color: rgba(255, 255, 255, 0.49);
  flex: 1 1 auto;
  min-width: 0;
  width: 100%;
}
.${ROOT_CLASS} .mg-crop-simulation__segmented-control .qmm-seg__btn {
  font-size: 11px;
  letter-spacing: 0.02em;
  font-weight: 600;
  flex: 1 1 0;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  min-width: 0;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="none"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="none"].active {
  color: rgba(148, 163, 184, 0.92);
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="gold"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="gold"].active {
  color: #facc15;
  font-weight: 700;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="gold"] .qmm-seg__btn-label,
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="gold"].active .qmm-seg__btn-label {
  color: transparent;
  background-image: linear-gradient(90deg, #fef08a, #facc15, #fef08a);
  background-clip: text;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-size: 100% 100%;
  background-repeat: no-repeat;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="rainbow"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="rainbow"].active {
  color: #fbbf24;
  font-weight: 700;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="rainbow"] .qmm-seg__btn-label,
.${ROOT_CLASS} .qmm-seg__btn[data-mg-color="rainbow"].active .qmm-seg__btn-label {
  color: transparent;
  background-image: linear-gradient(90deg, #f87171, #fbbf24, #34d399, #5eead4, #c084fc);
  background-clip: text;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-size: 100% 100%;
  background-repeat: no-repeat;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-weather="none"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-weather="none"].active,
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="none"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="none"].active {
  color: rgba(148, 163, 184, 0.92);
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-weather="wet"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-weather="wet"].active {
  color: #5AF6F5;
  font-weight: 700;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-weather="chilled"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-weather="chilled"].active {
  color: #AFE0F6;
  font-weight: 700;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-weather="frozen"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-weather="frozen"].active {
  color: #AABEFF;
  font-weight: 700;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-weather="thunderstruck"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-weather="thunderstruck"].active {
  color: rgb(16, 141, 163);
  font-weight: 700;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="dawnlit"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="dawnlit"].active {
  color: #7864B4;
  font-weight: 700;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="dawnbound"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="dawnbound"].active {
  color: #9785CB;
  font-weight: 700;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="amberlit"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="amberlit"].active {
  color: #A04632;
  font-weight: 700;
}
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="amberbound"],
.${ROOT_CLASS} .qmm-seg__btn[data-mg-lighting="amberbound"].active {
  color: #F06E50;
  font-weight: 700;
}
.${ROOT_CLASS} .mg-crop-simulation__mutations-section {
  display: flex;
  flex-direction: column;
  gap: 6px;
}
`;
  var cropSimulationStyleEl = null;
  function ensureCropSimulationStyles() {
    if (cropSimulationStyleEl) return;
    cropSimulationStyleEl = addStyle(CROP_SIMULATION_CSS);
  }
  function buildSpriteCandidates3(primary, option) {
    const candidates = /* @__PURE__ */ new Set();
    const addCandidate = (value) => {
      if (!value) return;
      const trimmed = String(value).trim();
      if (!trimmed) return;
      candidates.add(trimmed);
      candidates.add(trimmed.replace(/\W+/g, ""));
    };
    addCandidate(primary);
    if (option) {
      addCandidate(option.seedName);
      addCandidate(option.cropName);
    }
    const baseCandidates = Array.from(candidates).map((value) => value.replace(/icon$/i, "")).filter(Boolean);
    const expanded = Array.from(
      /* @__PURE__ */ new Set([
        ...baseCandidates.map((value) => `${value}Icon`),
        ...Array.from(candidates)
      ])
    ).filter(Boolean);
    return expanded.length ? expanded : [primary];
  }
  function getSpriteCategoriesForKey(key2, ...alts) {
    const candidates = [key2, ...alts];
    for (const candidate of candidates) {
      const normalized = typeof candidate === "string" ? candidate.trim().toLowerCase() : "";
      if (normalized && PLANT_PRIORITY_IDENTIFIERS.has(normalized)) {
        return ["plant", "tallplant", "crop"];
      }
    }
    return [...DEFAULT_SPRITE_CATEGORIES];
  }
  function ensureCropSpriteLayers(el2) {
    let fallback = el2.querySelector(".mg-crop-simulation__sprite-fallback");
    if (!fallback) {
      fallback = document.createElement("span");
      fallback.className = "mg-crop-simulation__sprite-fallback";
      el2.appendChild(fallback);
    }
    let layer = el2.querySelector(".mg-crop-simulation__sprite-layer--base");
    if (!layer) {
      layer = document.createElement("span");
      layer.className = "mg-crop-simulation__sprite-layer mg-crop-simulation__sprite-layer--base";
      el2.appendChild(layer);
    }
    return { fallback, layer };
  }
  function syncCropSpriteLoadedState(el2, layer) {
    if (layer.childElementCount > 0) {
      el2.dataset.mgHasSprite = "1";
    } else {
      delete el2.dataset.mgHasSprite;
    }
  }
  function resetCropSimulationSprite(el2) {
    el2.innerHTML = "";
    delete el2.dataset.mgHasSprite;
  }
  function createSeedSpriteIcon(option, fallback, size, logTag) {
    const wrap = applyStyles2(document.createElement("span"), {
      width: `${size}px`,
      height: `${size}px`,
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center"
    });
    wrap.textContent = fallback && fallback.trim().length > 0 ? fallback : "??";
    const candidates = buildSpriteCandidates3(option.key, option);
    const categories = getSpriteCategoriesForKey(option?.key, option?.seedName, option?.cropName);
    attachSpriteIcon(wrap, categories, candidates, size, logTag);
    return wrap;
  }
  function applyCropSimulationSprite(el2, speciesKey, options = {}) {
    const { fallback, layer } = ensureCropSpriteLayers(el2);
    const fallbackText = typeof options.fallback === "string" && options.fallback.trim().length > 0 ? options.fallback : "??";
    fallback.textContent = fallbackText;
    if (!speciesKey) {
      layer.replaceChildren();
      syncCropSpriteLoadedState(el2, layer);
      return;
    }
    const candidates = options.candidates && options.candidates.length ? options.candidates : buildSpriteCandidates3(speciesKey);
    const mutations = Array.isArray(options.mutations) && options.mutations.length ? options.mutations : void 0;
    const categories = options.categories && options.categories.length ? options.categories : getSpriteCategoriesForKey(speciesKey);
    const updateLoadedState = () => syncCropSpriteLoadedState(el2, layer);
    updateLoadedState();
    attachSpriteIcon(
      layer,
      categories,
      candidates,
      BASE_SPRITE_SIZE_PX,
      "calculator",
      {
        mutations,
        onSpriteApplied: updateLoadedState
      }
    );
  }
  var applyStyles2 = (el2, styles) => {
    const toKebab = (s) => s.startsWith("--") ? s : s.replace(/[A-Z]/g, (m) => "-" + m.toLowerCase());
    for (const [key2, value] of Object.entries(styles)) {
      el2.style.setProperty(toKebab(key2), value);
    }
    return el2;
  };
  var calculatorStyleEl = null;
  function ensureCalculatorStyles() {
    ensureCropSimulationStyles();
    if (calculatorStyleEl) return;
    calculatorStyleEl = addStyle(`
    .${ROOT_CLASS}.mg-crop-simulation--calculator {
      width: 100%;
      max-width: none;
      min-width: 0;
      position: relative;
    }
    .${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-simulation__price {
      justify-content: center;
      margin: 0 0 12px;
      font-size: 20px;
      gap: 10px;
    }
    .${ROOT_CLASS}.mg-crop-simulation--calculator .mg-crop-simulation__price-value {
      font-size: 20px;
    }
    .mg-crop-calculator__placeholder {
      font-size: 13px;
      text-align: center;
      opacity: 0.7;
      padding: 24px 12px;
    }
    .mg-crop-calculator__source-hint {
      font-size: 11px;
      color: rgba(226, 232, 240, 0.7);
      text-align: center;
      margin-top: 20px;
      padding-bottom: 4px;
    }
    .mg-crop-calculator__source-hint a {
      color: #5eead4;
      text-decoration: underline;
    }
  `);
  }
  function clamp3(value, min, max) {
    return Math.min(max, Math.max(min, value));
  }
  function coerceLabel(label2, allowed) {
    const normalized = typeof label2 === "string" ? label2.trim().toLowerCase() : "";
    for (const candidate of allowed) {
      if (candidate.toLowerCase() === normalized) {
        return candidate;
      }
    }
    return allowed[0];
  }
  function clampFriendPlayers(players) {
    if (typeof players !== "number" || !Number.isFinite(players)) {
      return FRIEND_BONUS_MIN_PLAYERS;
    }
    const rounded = Math.round(players);
    return clamp3(rounded, FRIEND_BONUS_MIN_PLAYERS, FRIEND_BONUS_MAX_PLAYERS);
  }
  function friendPlayersToLabel(players) {
    const clamped = clampFriendPlayers(players);
    return FRIEND_BONUS_LABELS[clamped - 1] ?? FRIEND_BONUS_LABELS[0];
  }
  function labelToFriendPlayers(label2) {
    const coerced = coerceLabel(label2, FRIEND_BONUS_LABELS);
    const index = FRIEND_BONUS_LABELS.indexOf(coerced);
    const players = index >= 0 ? index + 1 : FRIEND_BONUS_MIN_PLAYERS;
    return clamp3(players, FRIEND_BONUS_MIN_PLAYERS, FRIEND_BONUS_MAX_PLAYERS);
  }
  function setSpriteScale(el2, sizePercent) {
    const clamped = clamp3(Math.round(sizePercent), SIZE_MIN, SIZE_MAX);
    const scale = clamped / 100;
    el2.style.setProperty("--mg-crop-simulation-scale", scale.toString());
  }
  function applySizePercent(refs, sizePercent, maxScale, baseWeight) {
    const clamped = clamp3(Math.round(sizePercent), SIZE_MIN, SIZE_MAX);
    refs.sizeSlider.value = String(clamped);
    refs.sizeValue.textContent = `${clamped}%`;
    setSpriteScale(refs.sprite, clamped);
    if (typeof maxScale === "number" && Number.isFinite(maxScale) && maxScale > SCALE_MIN) {
      refs.sizeSlider.dataset.maxScale = String(maxScale);
    } else {
      delete refs.sizeSlider.dataset.maxScale;
    }
    const [minWeight, maxWeight] = computeWeightRange(baseWeight, clamped, maxScale);
    refs.sizeWeight.textContent = formatWeightRange(minWeight, maxWeight);
  }
  function formatCoinValue(value) {
    if (typeof value !== "number" || !Number.isFinite(value)) return "\u2014";
    const safe = Math.max(0, Math.round(value));
    return priceFormatter.format(safe);
  }
  function formatCoinRange(min, max) {
    const minValue = typeof min === "number" && Number.isFinite(min) ? Math.max(0, min) : null;
    const maxValue = typeof max === "number" && Number.isFinite(max) ? Math.max(0, max) : null;
    if (minValue == null && maxValue == null) return "\u2014";
    if (minValue == null) return formatCoinValue(maxValue);
    if (maxValue == null) return formatCoinValue(minValue);
    if (Math.round(minValue) === Math.round(maxValue)) {
      return formatCoinValue(minValue);
    }
    return `${formatCoinValue(minValue)} \u2013 ${formatCoinValue(maxValue)}`;
  }
  function computeWeightRange(baseWeight, sizePercent, maxScale) {
    const numericWeight = typeof baseWeight === "number" ? baseWeight : Number(baseWeight);
    if (!Number.isFinite(numericWeight) || numericWeight == null || numericWeight <= 0) {
      return [null, null];
    }
    const scale = sizePercentToScale(sizePercent, maxScale);
    if (!Number.isFinite(scale) || scale <= 0) {
      return [null, null];
    }
    const minWeight = numericWeight * scale;
    const safeMax = typeof maxScale === "number" && Number.isFinite(maxScale) && maxScale > SCALE_MIN ? maxScale : SCALE_MIN;
    const variation = 1 + Math.max(0, (safeMax - scale) * 0.02);
    const maxWeight = minWeight * variation;
    return [minWeight, maxWeight];
  }
  function formatWeight(value) {
    if (typeof value !== "number" || !Number.isFinite(value) || value <= 0) return null;
    const formatted = weightFormatter.format(value);
    return formatted.replace(/(\.\d*?[1-9])0+$/u, "$1").replace(/\.0+$/u, "");
  }
  function formatWeightRange(min, max) {
    const minFormatted = formatWeight(min);
    const maxFormatted = formatWeight(max);
    if (!minFormatted && !maxFormatted) return "\u2014";
    if (!maxFormatted || minFormatted === maxFormatted) {
      return `${minFormatted ?? maxFormatted} kg`;
    }
    return `${minFormatted ?? "\u2014"} \u2013 ${maxFormatted} kg`;
  }
  function sizePercentToScale(sizePercent, maxScale) {
    const numeric = Number(sizePercent);
    if (!Number.isFinite(numeric)) return SCALE_MIN;
    const clampedPercent = clamp3(numeric, SIZE_MIN, SIZE_MAX);
    const safeMax = typeof maxScale === "number" && Number.isFinite(maxScale) && maxScale > SCALE_MIN ? maxScale : SCALE_MAX;
    if (safeMax <= SCALE_MIN) return SCALE_MIN;
    const normalized = (clampedPercent - SIZE_MIN) / (SIZE_MAX - SIZE_MIN);
    const scale = SCALE_MIN + normalized * (safeMax - SCALE_MIN);
    return Number.isFinite(scale) ? scale : SCALE_MIN;
  }
  function createSegmentedControl(labels, selectedLabel, interactive, onSelect, ariaLabel) {
    const coerced = coerceLabel(selectedLabel, labels);
    const items = labels.map((label2) => ({ value: label2, label: label2, disabled: !interactive }));
    const segmented = segmentedUi.segmented(
      items,
      coerced,
      interactive && onSelect ? (value) => onSelect(value) : void 0,
      { ariaLabel, fullWidth: true }
    );
    segmented.classList.add("mg-crop-simulation__segmented-control");
    return segmented;
  }
  function applySegmentedButtonMetadata(segmented, metadata) {
    const buttons = segmented.querySelectorAll(".qmm-seg__btn");
    buttons.forEach((button) => {
      const label2 = button.textContent?.trim();
      if (!label2) return;
      const meta = metadata[label2];
      if (!meta) return;
      Object.entries(meta).forEach(([key2, value]) => {
        if (!value) return;
        button.dataset[key2] = value;
      });
    });
  }
  function getMutationsForState(state3) {
    const mutations = [];
    if (state3.color !== "None") mutations.push(state3.color);
    if (state3.weatherCondition !== "None") mutations.push(state3.weatherCondition);
    if (state3.weatherLighting !== "None") mutations.push(state3.weatherLighting);
    return mutations.map((label2) => normalizeMutationLabelForSprite(label2));
  }
  function normalizeMutationLabelForSprite(label2) {
    const normalized = label2.trim();
    if (!normalized) return normalized;
    const overridden = MUTATION_SPRITE_OVERRIDES[normalized.toLowerCase()];
    return overridden ?? normalized;
  }
  function computePrice(speciesKey, state3, percent, maxScale) {
    const scale = sizePercentToScale(percent, maxScale);
    if (!Number.isFinite(scale) || scale <= 0) return null;
    const mutations = getMutationsForState(state3);
    const friendPlayers = clampFriendPlayers(state3.friendPlayers);
    const pricingOptions = { ...DefaultPricing, friendPlayers };
    const value = estimateProduceValue(speciesKey, scale, mutations, pricingOptions);
    return Number.isFinite(value) && value > 0 ? value : null;
  }
  function getMaxScaleForSpecies(key2) {
    const entry = plantCatalog[key2];
    const candidates = [entry?.crop?.maxScale, entry?.plant?.maxScale, entry?.seed?.maxScale];
    for (const candidate of candidates) {
      const numeric = typeof candidate === "number" ? candidate : Number(candidate);
      if (Number.isFinite(numeric) && numeric > 0) {
        return numeric;
      }
    }
    return null;
  }
  function getBaseWeightForSpecies(key2) {
    const entry = plantCatalog[key2];
    const candidates = [
      entry?.produce?.baseWeight,
      entry?.crop?.baseWeight,
      entry?.item?.baseWeight,
      entry?.seed?.baseWeight
    ];
    for (const candidate of candidates) {
      const numeric = typeof candidate === "number" ? candidate : Number(candidate);
      if (Number.isFinite(numeric) && numeric > 0) {
        return numeric;
      }
    }
    return null;
  }
  async function renderCalculatorMenu(container) {
    ensureCalculatorStyles();
    const ui = new Menu({ id: "calculator", compact: true });
    ui.addTab("crops", "Crops", (root) => {
      root.innerHTML = "";
      root.style.padding = "8px";
      root.style.boxSizing = "border-box";
      root.style.height = "66vh";
      root.style.overflow = "auto";
      root.style.display = "grid";
      const layout = applyStyles2(document.createElement("div"), {
        display: "grid",
        gridTemplateColumns: "minmax(220px, 280px) minmax(0, 1fr)",
        gap: "10px",
        alignItems: "stretch",
        height: "100%",
        overflow: "hidden"
      });
      root.appendChild(layout);
      const left = applyStyles2(document.createElement("div"), {
        display: "grid",
        gridTemplateRows: "minmax(0, 1fr)",
        minHeight: "0",
        flex: "0 0 260px",
        minWidth: "220px",
        maxWidth: "280px"
      });
      layout.appendChild(left);
      const list = applyStyles2(document.createElement("div"), {
        display: "grid",
        gridTemplateColumns: "1fr",
        overflow: "auto",
        paddingRight: "2px",
        border: "1px solid rgba(255,255,255,0.10)",
        borderRadius: "10px",
        minHeight: "0",
        // important
        height: "100%"
        // pour que overflow: auto prenne effet
      });
      left.appendChild(list);
      const right = applyStyles2(document.createElement("div"), {
        display: "flex",
        flexDirection: "column",
        minHeight: "0",
        flex: "1 1 auto"
      });
      layout.appendChild(right);
      const detailScroll = applyStyles2(document.createElement("div"), {
        flex: "1 1 auto",
        overflow: "auto",
        display: "flex",
        justifyContent: "center"
      });
      right.appendChild(detailScroll);
      const simulationRoot = document.createElement("div");
      simulationRoot.className = `${ROOT_CLASS} mg-crop-simulation--visible mg-crop-simulation--calculator`;
      const detailLayout = document.createElement("div");
      detailLayout.className = "mg-crop-calculator__layout";
      const createSection = (title, extraClass) => {
        const section = document.createElement("div");
        section.className = "mg-crop-calculator__section";
        if (extraClass) {
          section.classList.add(extraClass);
        }
        if (title) {
          const heading = document.createElement("div");
          heading.className = "mg-crop-calculator__section-heading";
          heading.textContent = title;
          section.appendChild(heading);
        }
        return section;
      };
      const previewSection = createSection(null, "mg-crop-calculator__section--preview");
      const priceRow = document.createElement("div");
      priceRow.className = "mg-crop-simulation__price";
      const priceIcon = document.createElement("img");
      priceIcon.className = "mg-crop-simulation__price-icon";
      priceIcon.src = coin.img64;
      priceIcon.alt = "";
      priceIcon.decoding = "async";
      priceIcon.loading = "lazy";
      priceIcon.setAttribute("aria-hidden", "true");
      priceIcon.draggable = false;
      const priceValue = document.createElement("span");
      priceValue.className = "mg-crop-simulation__price-value";
      priceValue.textContent = "\u2014";
      priceRow.append(priceIcon, priceValue);
      const spriteSection = document.createElement("div");
      spriteSection.className = "mg-crop-simulation__sprite-section";
      const spriteBox = document.createElement("div");
      spriteBox.className = "mg-crop-simulation__sprite-box";
      const sprite = document.createElement("span");
      sprite.className = "mg-crop-simulation__sprite";
      spriteBox.appendChild(sprite);
      const sliderContainer = document.createElement("div");
      sliderContainer.className = "mg-crop-simulation__slider-container";
      const sliderRow = document.createElement("div");
      sliderRow.className = "mg-crop-simulation__slider-row";
      const sliderLabel = document.createElement("span");
      sliderLabel.className = "mg-crop-simulation__slider-label";
      sliderLabel.textContent = "Size";
      const slider = ui.slider(SIZE_MIN, SIZE_MAX, 1, SIZE_MIN);
      slider.classList.add("mg-crop-simulation__slider");
      slider.disabled = true;
      const sliderValue = document.createElement("span");
      sliderValue.className = "mg-crop-simulation__slider-value";
      sliderValue.textContent = `${SIZE_MIN}%`;
      const sliderWeight = document.createElement("span");
      sliderWeight.className = "mg-crop-simulation__slider-weight";
      sliderWeight.textContent = "\u2014";
      sliderRow.append(sliderLabel, slider, sliderValue);
      sliderContainer.append(sliderRow, sliderWeight);
      spriteSection.append(spriteBox, sliderContainer);
      previewSection.appendChild(spriteSection);
      const mutationsSection = createSection("Mutations");
      const colorList = document.createElement("div");
      colorList.className = "mg-crop-simulation__segmented";
      mutationsSection.appendChild(colorList);
      const weatherContainer = document.createElement("div");
      weatherContainer.className = "mg-crop-calculator__mutations-weather";
      const weatherConditions = document.createElement("div");
      weatherConditions.className = "mg-crop-simulation__segmented";
      const weatherLighting = document.createElement("div");
      weatherLighting.className = "mg-crop-simulation__segmented";
      weatherContainer.append(weatherConditions, weatherLighting);
      mutationsSection.appendChild(weatherContainer);
      const friendBonusSection = createSection("Friend bonus", "mg-crop-calculator__section--friend-bonus");
      const friendBonus = document.createElement("div");
      friendBonus.className = "mg-crop-simulation__segmented";
      friendBonusSection.appendChild(friendBonus);
      detailLayout.append(
        priceRow,
        previewSection,
        mutationsSection,
        friendBonusSection
      );
      simulationRoot.appendChild(detailLayout);
      detailScroll.appendChild(simulationRoot);
      const sourceHint = document.createElement("div");
      sourceHint.className = "mg-crop-calculator__source-hint";
      sourceHint.innerHTML = `
      Based on
      <a href="https://daserix.github.io/magic-garden-calculator" target="_blank" rel="noreferrer noopener">
        Daserix&apos; Magic Garden Calculators
      </a>
    `;
      root.appendChild(sourceHint);
      const refs = {
        root: simulationRoot,
        sprite,
        sizeSlider: slider,
        sizeValue: sliderValue,
        sizeWeight: sliderWeight,
        colorMutations: colorList,
        weatherConditions,
        weatherLighting,
        friendBonus,
        priceValue
      };
      const states = /* @__PURE__ */ new Map();
      const optionByKey = /* @__PURE__ */ new Map();
      const options = getLockerSeedOptions();
      options.forEach((opt) => optionByKey.set(opt.key, opt));
      const getStateForKey = (key2) => {
        const existing = states.get(key2);
        if (existing) return existing;
        const state3 = { ...DEFAULT_STATE2 };
        states.set(key2, state3);
        return state3;
      };
      let selectedKey = null;
      let currentMaxScale = null;
      let currentBaseWeight = null;
      const listButtons = /* @__PURE__ */ new Map();
      const refreshListStyles = () => {
        listButtons.forEach(({ button, dot }, key2) => {
          const isSelected = selectedKey === key2;
          button.style.background = isSelected ? "rgba(94,234,212,0.15)" : "rgba(255,255,255,0.04)";
          button.style.borderColor = isSelected ? "rgba(94,234,212,0.35)" : "rgba(255,255,255,0.10)";
          dot.style.background = isSelected ? "rgba(94,234,212,0.85)" : "rgba(255,255,255,0.20)";
        });
      };
      function renderColorSegment(state3, interactive) {
        const active = state3?.color ?? COLOR_MUTATION_LABELS[0];
        const segmented = createSegmentedControl(
          COLOR_MUTATION_LABELS,
          active,
          interactive,
          interactive ? (label2) => {
            if (!selectedKey) return;
            const target = getStateForKey(selectedKey);
            target.color = coerceLabel(label2, COLOR_MUTATION_LABELS);
            renderColorSegment(target, true);
            renderWeatherConditions(target, true);
            renderWeatherLighting(target, true);
            updateSprite();
            updateOutputs();
          } : void 0,
          "Mutations"
        );
        applySegmentedButtonMetadata(segmented, COLOR_SEGMENT_METADATA);
        refs.colorMutations.innerHTML = "";
        refs.colorMutations.appendChild(segmented);
      }
      function renderWeatherConditions(state3, interactive) {
        const active = state3?.weatherCondition ?? WEATHER_CONDITION_LABELS[0];
        const segmented = createSegmentedControl(
          WEATHER_CONDITION_LABELS,
          active,
          interactive,
          interactive ? (label2) => {
            if (!selectedKey) return;
            const target = getStateForKey(selectedKey);
            target.weatherCondition = coerceLabel(label2, WEATHER_CONDITION_LABELS);
            renderWeatherConditions(target, true);
            updateSprite();
            updateOutputs();
          } : void 0,
          "Weather condition"
        );
        applySegmentedButtonMetadata(segmented, WEATHER_CONDITION_SEGMENT_METADATA);
        refs.weatherConditions.innerHTML = "";
        refs.weatherConditions.appendChild(segmented);
      }
      function renderWeatherLighting(state3, interactive) {
        const active = state3?.weatherLighting ?? WEATHER_LIGHTING_LABELS[0];
        const segmented = createSegmentedControl(
          WEATHER_LIGHTING_LABELS,
          active,
          interactive,
          interactive ? (label2) => {
            if (!selectedKey) return;
            const target = getStateForKey(selectedKey);
            target.weatherLighting = coerceLabel(label2, WEATHER_LIGHTING_LABELS);
            renderWeatherLighting(target, true);
            updateSprite();
            updateOutputs();
          } : void 0,
          "Weather lighting"
        );
        applySegmentedButtonMetadata(segmented, WEATHER_LIGHTING_SEGMENT_METADATA);
        refs.weatherLighting.innerHTML = "";
        refs.weatherLighting.appendChild(segmented);
      }
      function renderFriendBonus(state3, interactive) {
        const active = friendPlayersToLabel(state3?.friendPlayers ?? FRIEND_BONUS_MIN_PLAYERS);
        const segmented = createSegmentedControl(
          FRIEND_BONUS_LABELS,
          active,
          interactive,
          interactive ? (label2) => {
            if (!selectedKey) return;
            const target = getStateForKey(selectedKey);
            target.friendPlayers = labelToFriendPlayers(label2);
            renderFriendBonus(target, true);
            updateOutputs();
          } : void 0,
          "Friend bonus"
        );
        refs.friendBonus.innerHTML = "";
        refs.friendBonus.appendChild(segmented);
      }
      function updateOutputs() {
        const key2 = selectedKey;
        if (!key2) {
          refs.priceValue.textContent = "\u2014";
          return;
        }
        const state3 = getStateForKey(key2);
        const min = computePrice(key2, state3, state3.sizePercent, currentMaxScale);
        const maxPercent = Math.min(SIZE_MAX, state3.sizePercent + 1);
        const max = computePrice(key2, state3, maxPercent, currentMaxScale);
        refs.priceValue.textContent = formatCoinRange(min, max);
      }
      function updateSprite() {
        const key2 = selectedKey;
        if (!key2) {
          resetCropSimulationSprite(refs.sprite);
          return;
        }
        const state3 = getStateForKey(key2);
        const option = optionByKey.get(key2);
        const fallbackEmoji = getLockerSeedEmojiForKey(key2) || (option?.seedName ? getLockerSeedEmojiForSeedName(option.seedName) : void 0) || "\u{1F331}";
        const mutations = getMutationsForState(state3);
        const candidates = buildSpriteCandidates3(key2, option);
        const categories = getSpriteCategoriesForKey(key2, option?.seedName, option?.cropName);
        applyCropSimulationSprite(refs.sprite, key2, {
          fallback: fallbackEmoji,
          candidates,
          mutations,
          categories
        });
      }
      function renderDetail() {
        const key2 = selectedKey;
        if (!key2) {
          resetCropSimulationSprite(refs.sprite);
          refs.sizeSlider.disabled = true;
          currentBaseWeight = null;
          applySizePercent(refs, SIZE_MIN, null, currentBaseWeight);
          renderColorSegment(null, false);
          renderWeatherConditions(null, false);
          renderWeatherLighting(null, false);
          renderFriendBonus(null, false);
          refs.priceValue.textContent = "\u2014";
          return;
        }
        currentMaxScale = getMaxScaleForSpecies(key2);
        currentBaseWeight = getBaseWeightForSpecies(key2);
        const state3 = getStateForKey(key2);
        refs.sizeSlider.disabled = false;
        applySizePercent(refs, state3.sizePercent, currentMaxScale, currentBaseWeight);
        renderColorSegment(state3, true);
        renderWeatherConditions(state3, true);
        renderWeatherLighting(state3, true);
        renderFriendBonus(state3, true);
        updateSprite();
        updateOutputs();
      }
      slider.addEventListener("input", () => {
        if (!selectedKey) return;
        const state3 = getStateForKey(selectedKey);
        const raw = Number(slider.value);
        const value = clamp3(Math.round(raw), SIZE_MIN, SIZE_MAX);
        state3.sizePercent = value;
        applySizePercent(refs, value, currentMaxScale, currentBaseWeight);
        updateOutputs();
      });
      function renderList() {
        const previous = list.scrollTop;
        list.innerHTML = "";
        listButtons.clear();
        if (!options.length) {
          const empty = document.createElement("div");
          empty.className = "mg-crop-calculator__placeholder";
          empty.textContent = "No crops available.";
          list.appendChild(empty);
          selectedKey = null;
          currentMaxScale = null;
          renderDetail();
          return;
        }
        if (selectedKey && !options.some((opt) => opt.key === selectedKey)) {
          selectedKey = options[0].key;
          currentMaxScale = getMaxScaleForSpecies(selectedKey);
        }
        if (!selectedKey) {
          selectedKey = options[0].key;
          currentMaxScale = getMaxScaleForSpecies(selectedKey);
        }
        const fragment = document.createDocumentFragment();
        options.forEach((opt) => {
          const button = document.createElement("button");
          button.className = "qmm-vtab";
          button.style.display = "grid";
          button.style.gridTemplateColumns = "16px 1fr auto";
          button.style.alignItems = "center";
          button.style.gap = "8px";
          button.style.textAlign = "left";
          button.style.padding = "6px 8px";
          button.style.marginBottom = "6px";
          button.style.borderRadius = "8px";
          button.style.border = "1px solid rgba(255,255,255,0.10)";
          button.style.background = selectedKey === opt.key ? "rgba(94,234,212,0.15)" : "rgba(255,255,255,0.04)";
          button.style.color = "#e7eef7";
          const dot = document.createElement("span");
          dot.className = "qmm-dot";
          dot.style.background = selectedKey === opt.key ? "rgba(94,234,212,0.85)" : "rgba(255,255,255,0.20)";
          const label2 = document.createElement("span");
          label2.className = "label";
          label2.textContent = opt.cropName || opt.key;
          const fallbackEmoji = getLockerSeedEmojiForKey(opt.key) || getLockerSeedEmojiForSeedName(opt.seedName) || "\u{1F331}";
          const sprite2 = createSeedSpriteIcon(opt, fallbackEmoji, 24, "calculator-list");
          button.append(dot, label2, sprite2);
          button.onmouseenter = () => {
            button.style.borderColor = "rgba(94,234,212,0.35)";
            button.style.background = selectedKey === opt.key ? "rgba(94,234,212,0.18)" : "rgba(255,255,255,0.07)";
          };
          button.onmouseleave = () => {
            button.style.borderColor = "rgba(255,255,255,0.10)";
            button.style.background = selectedKey === opt.key ? "rgba(94,234,212,0.15)" : "rgba(255,255,255,0.04)";
          };
          button.onclick = () => {
            if (selectedKey === opt.key) return;
            selectedKey = opt.key;
            currentMaxScale = getMaxScaleForSpecies(opt.key);
            refreshListStyles();
            renderDetail();
            updateOutputs();
          };
          listButtons.set(opt.key, { button, dot });
          fragment.appendChild(button);
        });
        list.appendChild(fragment);
        list.scrollTop = previous;
        refreshListStyles();
        renderDetail();
      }
      renderList();
    });
    ui.mount(container);
  }

  // src/ui/menus/notifier.ts
  var rulePopover = null;
  var detachRuleDocHandler = null;
  var detachRuleKeyBlocker = null;
  var detachRuleWheelBlocker = null;
  var detachRuleDragHandler = null;
  var closeRuleEditor = () => {
    if (rulePopover) {
      try {
        rulePopover.remove();
      } catch {
      }
      rulePopover = null;
    }
    if (detachRuleDocHandler) {
      detachRuleDocHandler();
      detachRuleDocHandler = null;
    }
    if (detachRuleKeyBlocker) {
      detachRuleKeyBlocker();
      detachRuleKeyBlocker = null;
    }
    if (detachRuleWheelBlocker) {
      detachRuleWheelBlocker();
      detachRuleWheelBlocker = null;
    }
    if (detachRuleDragHandler) {
      detachRuleDragHandler();
      detachRuleDragHandler = null;
    }
  };
  var setSwitchCapState = (wrap, capped) => {
    if (capped) {
      wrap.setAttribute("aria-disabled", "true");
      wrap.style.opacity = "0.5";
      wrap.style.pointerEvents = "none";
      wrap.style.cursor = "not-allowed";
      wrap.title = "Max owned \u2014 notifications disabled";
    } else {
      wrap.removeAttribute("aria-disabled");
      wrap.style.opacity = "";
      wrap.style.pointerEvents = "";
      wrap.style.cursor = "";
      wrap.removeAttribute("title");
    }
  };
  var createSwitch = (onToggle) => {
    const wrap = document.createElement("label");
    wrap.style.display = "inline-flex";
    wrap.style.alignItems = "center";
    wrap.style.justifyContent = "center";
    wrap.style.width = "100%";
    wrap.style.padding = "4px 6px";
    wrap.style.userSelect = "none";
    wrap.setAttribute("role", "switch");
    wrap.setAttribute("aria-checked", "false");
    const box = document.createElement("span");
    box.style.position = "relative";
    box.style.width = "42px";
    box.style.height = "24px";
    box.style.borderRadius = "999px";
    box.style.background = "#1f2328";
    box.style.border = "1px solid #4446";
    box.style.display = "inline-block";
    box.style.boxShadow = "inset 0 0 0 1px #0005";
    const knob = document.createElement("span");
    knob.style.position = "absolute";
    knob.style.top = "50%";
    knob.style.left = "3px";
    knob.style.transform = "translateY(-50%)";
    knob.style.width = "18px";
    knob.style.height = "18px";
    knob.style.borderRadius = "50%";
    knob.style.background = "#e7eef7";
    knob.style.boxShadow = "0 1px 2px rgba(0,0,0,.7)";
    knob.style.transition = "left 160ms ease, transform 160ms ease";
    const input = document.createElement("input");
    input.type = "checkbox";
    input.style.position = "absolute";
    input.style.opacity = "0";
    input.style.pointerEvents = "none";
    input.tabIndex = -1;
    const apply = (on) => {
      input.checked = on;
      wrap.setAttribute("aria-checked", on ? "true" : "false");
      knob.style.left = on ? "21px" : "3px";
      knob.style.transform = on ? "translateY(-50%) scale(1.02)" : "translateY(-50%) scale(1)";
      if (on) {
        box.style.background = "linear-gradient(180deg, #2b5cff, #1e40ff)";
        box.style.borderColor = "#7aa2ff";
        box.style.boxShadow = "0 0 0 2px #7aa2ff55, inset 0 0 0 1px #0005";
      } else {
        box.style.background = "#1f2328";
        box.style.borderColor = "#4446";
        box.style.boxShadow = "inset 0 0 0 1px #0005";
      }
    };
    input.disabled = true;
    wrap.addEventListener("mousedown", (e) => e.preventDefault());
    wrap.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      apply(!input.checked);
      onToggle?.(input.checked);
    });
    box.appendChild(knob);
    wrap.appendChild(input);
    wrap.appendChild(box);
    apply(false);
    return wrap;
  };
  var setSwitchVisual = (wrap, checked) => {
    const input = wrap.querySelector("input");
    const box = wrap.querySelector("span");
    const knob = box?.querySelector("span");
    if (!input || !box || !knob) return;
    input.checked = !!checked;
    knob.style.left = checked ? "21px" : "3px";
    knob.style.transform = checked ? "translateY(-50%) scale(1.02)" : "translateY(-50%) scale(1)";
    if (checked) {
      box.style.background = "linear-gradient(180deg, #2b5cff, #1e40ff)";
      box.style.borderColor = "#7aa2ff";
      box.style.boxShadow = "0 0 0 2px #7aa2ff55, inset 0 0 0 1px #0005";
      wrap.setAttribute("aria-checked", "true");
    } else {
      box.style.background = "#1f2328";
      box.style.borderColor = "#4446";
      box.style.boxShadow = "inset 0 0 0 1px #0005";
      wrap.setAttribute("aria-checked", "false");
    }
  };
  var wrapCell = (child) => {
    const d = document.createElement("div");
    d.style.display = "flex";
    d.style.alignItems = "center";
    d.style.justifyContent = "center";
    d.style.borderBottom = "1px solid #ffffff12";
    d.style.padding = "4px 6px";
    d.style.boxSizing = "border-box";
    d.appendChild(child);
    return d;
  };
  var mkHeadCell = (txt, align = "center") => {
    const el2 = document.createElement("div");
    el2.textContent = txt;
    el2.style.fontWeight = "600";
    el2.style.opacity = "0.9";
    el2.style.padding = "4px 6px";
    el2.style.display = "flex";
    el2.style.alignItems = "center";
    el2.style.justifyContent = align === "left" ? "flex-start" : "center";
    return el2;
  };
  function rarityBadge(raw) {
    const rarity2 = String(raw || "").trim();
    const key2 = (() => {
      const k = rarity2.toLowerCase();
      if (k === "mythical") return "Mythical";
      if (k === "celestial") return "Celestial";
      if (k === "divine") return "Divine";
      if (k === "legendary") return "Legendary";
      if (k === "rare") return "Rare";
      if (k === "uncommon") return "Uncommon";
      if (k === "common") return "Common";
      return rarity2 || "\u2014";
    })();
    const COLORS = {
      Common: "#E7E7E7",
      Uncommon: "#67BD4D",
      Rare: "#0071C6",
      Legendary: "#FFC734",
      Mythical: "#9944A7",
      Divine: "#FF7835",
      Celestial: null
    };
    const darkText = /* @__PURE__ */ new Set(["Common", "Uncommon", "Legendary", "Divine"]);
    const el2 = document.createElement("div");
    el2.textContent = key2;
    Object.assign(el2.style, {
      display: "inline-flex",
      justifyContent: "center",
      alignItems: "center",
      padding: "4px 8px",
      borderRadius: "5px",
      fontSize: "12px",
      fontWeight: "700",
      margin: "2px auto",
      color: darkText.has(key2) ? "#0b0b0b" : "#ffffff",
      boxShadow: "0 0 0 1px #0006 inset",
      lineHeight: "1.1",
      whiteSpace: "nowrap"
    });
    if (key2 === "Celestial") {
      if (!document.getElementById("qws-celestial-kf")) {
        const style3 = document.createElement("style");
        style3.id = "qws-celestial-kf";
        style3.textContent = `
@keyframes qwsCelestialShift {
  0%   { background-position: 0% 50%; }
  50%  { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}`;
        document.head.appendChild(style3);
      }
      el2.style.background = `linear-gradient(130deg,
      rgb(0,180,216) 0%,
      rgb(124,42,232) 40%,
      rgb(160,0,126) 60%,
      rgb(255,215,0) 100%)`;
      el2.style.backgroundSize = "200% 200%";
      el2.style.animation = "qwsCelestialShift 4s linear infinite";
    } else {
      el2.style.background = COLORS[key2] || "#444";
    }
    return el2;
  }
  var applyRuleState = (itemCell, ruleCell, rule) => {
    const gearBtn = ruleCell?.querySelector("button[data-role='rule']") ?? null;
    const hint = itemCell.querySelector('[data-role="rule-hint"]');
    const hasRule = !!(rule && (rule.sound || rule.volume != null || rule.playbackMode || rule.stopMode || rule.loopIntervalMs != null));
    const summary = hasRule ? formatRuleSummary(rule) : "";
    if (gearBtn) {
      gearBtn.dataset.active = hasRule ? "1" : "0";
      gearBtn.title = hasRule && summary ? `Custom rule \u2014 ${summary}` : "Custom rule";
    }
    if (hint) {
      if (hasRule && summary) {
        hint.textContent = summary;
        hint.style.visibility = "visible";
      } else {
        hint.textContent = "";
        hint.style.visibility = "hidden";
      }
    }
  };
  var openRuleEditor = (ui, row, anchor) => {
    closeRuleEditor();
    const pop = document.createElement("div");
    pop.className = "qws-rule-popover";
    Object.assign(pop.style, {
      position: "fixed",
      zIndex: "var(--qws-z-popover)",
      minWidth: "260px",
      maxWidth: "320px",
      padding: "14px 16px",
      borderRadius: "14px",
      border: "1px solid #32404e",
      background: "linear-gradient(180deg, #111923, #0b131c)",
      boxShadow: "0 16px 40px rgba(0,0,0,0.45)"
    });
    const margin = 12;
    const clampPosition = (value, min, max) => {
      if (!Number.isFinite(min) || !Number.isFinite(max)) return value;
      if (max >= min) {
        return Math.min(Math.max(value, min), max);
      }
      return Math.min(Math.max(value, max), min);
    };
    const applyPosition = (left2, top2) => {
      const width2 = pop.offsetWidth;
      const height2 = pop.offsetHeight;
      const boundedLeft = clampPosition(left2, margin, window.innerWidth - width2 - margin);
      const boundedTop = clampPosition(top2, margin, window.innerHeight - height2 - margin);
      pop.style.left = `${Math.round(boundedLeft)}px`;
      pop.style.top = `${Math.round(boundedTop)}px`;
      return { left: boundedLeft, top: boundedTop };
    };
    const header = document.createElement("div");
    header.style.display = "flex";
    header.style.justifyContent = "space-between";
    header.style.alignItems = "flex-start";
    header.style.gap = "12px";
    header.style.cursor = "move";
    header.style.userSelect = "none";
    header.style.touchAction = "none";
    const titleWrap = document.createElement("div");
    const title = document.createElement("div");
    title.textContent = row.name;
    title.style.fontWeight = "700";
    title.style.fontSize = "14px";
    title.style.lineHeight = "1.2";
    const subtitle = document.createElement("div");
    subtitle.textContent = row.type;
    subtitle.style.opacity = "0.7";
    subtitle.style.fontSize = "12px";
    titleWrap.append(title, subtitle);
    const closeBtn = document.createElement("button");
    closeBtn.type = "button";
    closeBtn.textContent = "\u2715";
    Object.assign(closeBtn.style, {
      background: "transparent",
      border: "none",
      color: "#c8d7e8",
      fontSize: "16px",
      lineHeight: "1",
      cursor: "pointer"
    });
    closeBtn.addEventListener("click", (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      closeRuleEditor();
    });
    header.append(titleWrap, closeBtn);
    let dragState = null;
    const onDragMove = (ev) => {
      if (!dragState) return;
      if (ev.pointerId !== dragState.pointerId) return;
      const dx = ev.clientX - dragState.startX;
      const dy = ev.clientY - dragState.startY;
      applyPosition(dragState.baseLeft + dx, dragState.baseTop + dy);
    };
    const stopDrag = (ev) => {
      if (!dragState) return;
      if (ev && ev.pointerId !== dragState.pointerId) return;
      document.removeEventListener("pointermove", onDragMove);
      document.removeEventListener("pointerup", stopDrag);
      document.removeEventListener("pointercancel", stopDrag);
      try {
        header.releasePointerCapture(dragState.pointerId);
      } catch {
      }
      dragState = null;
    };
    const onPointerDown = (ev) => {
      if (ev.button !== 0) return;
      const target = ev.target;
      if (target && closeBtn.contains(target)) return;
      if (dragState) stopDrag();
      const rect = pop.getBoundingClientRect();
      dragState = {
        pointerId: ev.pointerId,
        startX: ev.clientX,
        startY: ev.clientY,
        baseLeft: rect.left,
        baseTop: rect.top
      };
      try {
        header.setPointerCapture(ev.pointerId);
      } catch {
      }
      document.addEventListener("pointermove", onDragMove);
      document.addEventListener("pointerup", stopDrag);
      document.addEventListener("pointercancel", stopDrag);
      ev.preventDefault();
    };
    header.addEventListener("pointerdown", onPointerDown);
    detachRuleDragHandler = () => {
      header.removeEventListener("pointerdown", onPointerDown);
      stopDrag();
    };
    pop.appendChild(header);
    const current = NotifierService.getRule(row.id);
    const defaults = audio.getPlaybackSettings(row.context);
    const contextDefaults = row.context === "shops" || row.context === "weather" ? NotifierService.getContextStopDefaults(row.context) : { stopMode: "manual", stopRepeats: null, loopIntervalMs: defaults.loopIntervalMs };
    const allowPurchase = row.context === "shops";
    const defaultSoundName = (() => {
      const label2 = (defaults.defaultSoundName || "").trim();
      return label2 || "Default";
    })();
    const formatModeLabel = (mode) => mode === "loop" ? "Loop" : "One-shot";
    const defaultModeLabel = formatModeLabel(defaults.mode);
    const defaultIntervalMs = Math.max(
      150,
      Math.floor(contextDefaults.loopIntervalMs ?? defaults.loopIntervalMs ?? 150)
    );
    const soundField = document.createElement("div");
    soundField.className = "qws-rule-field";
    const soundLabel = document.createElement("label");
    soundLabel.textContent = "Sound";
    const soundSelect = document.createElement("select");
    soundSelect.className = "qmm-input";
    soundSelect.style.width = "100%";
    const populateSoundOptions = () => {
      const selected = current?.sound ?? "";
      soundSelect.innerHTML = "";
      const optDefault = document.createElement("option");
      optDefault.value = "";
      optDefault.textContent = defaultSoundName;
      soundSelect.appendChild(optDefault);
      const names = audio.listSounds();
      for (const name of names) {
        if (name === defaultSoundName && selected !== name) continue;
        const opt = document.createElement("option");
        opt.value = name;
        opt.textContent = name;
        soundSelect.appendChild(opt);
      }
      if (selected && !names.includes(selected)) {
        const extra = document.createElement("option");
        extra.value = selected;
        extra.textContent = selected.length > 32 ? `${selected.slice(0, 29)}\u2026` : selected;
        extra.dataset.extra = "1";
        soundSelect.appendChild(extra);
      }
      soundSelect.value = selected;
    };
    populateSoundOptions();
    soundField.append(soundLabel, soundSelect);
    pop.appendChild(soundField);
    const baseVolume = Math.max(0, Math.min(1, defaults.volume || 0));
    const defaultVolumePct = Math.round(baseVolume * 100);
    const volumeField = document.createElement("div");
    volumeField.className = "qws-rule-field";
    const volumeLabel = document.createElement("label");
    volumeLabel.textContent = "Volume";
    const volumeWrap = document.createElement("div");
    volumeWrap.style.display = "flex";
    volumeWrap.style.alignItems = "center";
    volumeWrap.style.gap = "10px";
    const volumeRange = document.createElement("input");
    volumeRange.type = "range";
    volumeRange.min = "0";
    volumeRange.max = "100";
    volumeRange.step = "1";
    volumeRange.style.width = "100%";
    const volumeValue = document.createElement("span");
    volumeValue.style.minWidth = "38px";
    volumeValue.style.textAlign = "right";
    const applyVolumeDisplay = (value) => {
      const clamped = Math.max(0, Math.min(100, Math.round(value)));
      volumeRange.value = String(clamped);
      volumeValue.textContent = `${clamped}%`;
    };
    const initialVolume = current?.volume != null ? current.volume : baseVolume;
    applyVolumeDisplay(Math.round(Math.max(0, Math.min(1, initialVolume)) * 100));
    volumeRange.addEventListener("input", () => {
      const raw = Number(volumeRange.value);
      const clamped = Number.isFinite(raw) ? Math.max(0, Math.min(100, Math.round(raw))) : defaultVolumePct;
      applyVolumeDisplay(clamped);
    });
    const volumeHint = document.createElement("div");
    volumeHint.textContent = `Default: ${defaultVolumePct}%`;
    volumeHint.style.opacity = "0.7";
    volumeHint.style.fontSize = "11px";
    volumeHint.style.marginTop = "4px";
    volumeWrap.append(volumeRange, volumeValue);
    volumeField.append(volumeLabel, volumeWrap, volumeHint);
    pop.appendChild(volumeField);
    const modeField = document.createElement("div");
    modeField.className = "qws-rule-field";
    const modeLabel = document.createElement("label");
    modeLabel.textContent = "Playback mode";
    const modeSelect = document.createElement("select");
    modeSelect.className = "qmm-input";
    const modeOptions = allowPurchase ? defaults.mode === "loop" ? ["loop", "oneshot"] : ["oneshot", "loop"] : ["oneshot"];
    modeOptions.forEach((value) => {
      const opt = document.createElement("option");
      opt.value = value;
      opt.textContent = formatModeLabel(value);
      modeSelect.appendChild(opt);
    });
    const initialMode = allowPurchase ? current?.playbackMode ?? defaults.mode : "oneshot";
    modeSelect.value = initialMode === "loop" && !allowPurchase ? "oneshot" : initialMode;
    if (!allowPurchase) modeSelect.disabled = true;
    modeField.append(modeLabel, modeSelect);
    pop.appendChild(modeField);
    let stopSelect = null;
    const stopField = document.createElement("div");
    stopField.className = "qws-rule-field";
    if (allowPurchase) {
      const stopLabel = document.createElement("label");
      stopLabel.textContent = "Stop condition";
      stopSelect = document.createElement("select");
      stopSelect.className = "qmm-input";
      const stopOption = document.createElement("option");
      stopOption.value = "purchase";
      stopOption.textContent = "Until purchase";
      stopSelect.appendChild(stopOption);
      const initialStopMode = current?.stopMode ?? contextDefaults.stopMode;
      stopSelect.value = initialStopMode === "purchase" ? "purchase" : "purchase";
      stopField.append(stopLabel, stopSelect);
      pop.appendChild(stopField);
    }
    const intervalField = document.createElement("div");
    intervalField.className = "qws-rule-field";
    const intervalLabel = document.createElement("label");
    intervalLabel.textContent = "Loop interval (ms)";
    const intervalInput = document.createElement("input");
    intervalInput.type = "number";
    intervalInput.className = "qmm-input";
    intervalInput.min = "150";
    intervalInput.step = "50";
    intervalInput.placeholder = String(defaultIntervalMs);
    intervalInput.value = current?.loopIntervalMs != null ? String(current.loopIntervalMs) : "";
    intervalInput.inputMode = "numeric";
    intervalField.append(intervalLabel, intervalInput);
    if (allowPurchase) pop.appendChild(intervalField);
    const enforceIntegerOnly = (input) => {
      input.addEventListener("keydown", (ev) => {
        ev.stopPropagation();
        ev.stopImmediatePropagation();
        if (ev.ctrlKey || ev.metaKey || ev.altKey) return;
        const key2 = ev.key;
        if (/^[0-9]$/.test(key2)) return;
        if (key2 === "Backspace" || key2 === "Delete" || key2 === "Tab" || key2 === "Enter" || key2 === "ArrowLeft" || key2 === "ArrowRight" || key2 === "ArrowUp" || key2 === "ArrowDown" || key2 === "Home" || key2 === "End") {
          return;
        }
        ev.preventDefault();
      });
      input.addEventListener("input", () => {
        const sanitized = input.value.replace(/\D+/g, "");
        if (sanitized !== input.value) input.value = sanitized;
      });
    };
    enforceIntegerOnly(intervalInput);
    const resolveMode = () => {
      const raw = modeSelect.value;
      if (raw === "oneshot" || raw === "loop") return raw;
      return allowPurchase ? defaults.mode : "oneshot";
    };
    const resolveStop = () => {
      if (!allowPurchase) return "purchase";
      const raw = stopSelect?.value;
      if (raw === "purchase") return "purchase";
      return "purchase";
    };
    const updateLoopVisibility = () => {
      if (!allowPurchase) {
        stopField.style.display = "none";
        intervalField.style.display = "none";
        return;
      }
      const mode = resolveMode();
      const showLoop = mode === "loop";
      stopField.style.display = showLoop ? "grid" : "none";
      intervalField.style.display = showLoop ? "grid" : "none";
    };
    const forceLoopMode = () => {
      if (!allowPurchase) return;
      if (modeSelect.value === "loop") return;
      modeSelect.value = "loop";
      updateLoopVisibility();
    };
    modeSelect.addEventListener("change", () => {
      updateLoopVisibility();
    });
    if (allowPurchase && stopSelect) {
      stopSelect.addEventListener("change", () => {
        forceLoopMode();
      });
    }
    if (allowPurchase) intervalInput.addEventListener("input", forceLoopMode);
    updateLoopVisibility();
    const hint = document.createElement("div");
    hint.textContent = "Use defaults by leaving values unchanged (matching the default volume keeps it inherited).";
    hint.style.opacity = "0.7";
    hint.style.fontSize = "12px";
    pop.appendChild(hint);
    const actions = document.createElement("div");
    actions.className = "qws-rule-actions";
    const clearBtn = ui.btn("Clear", { variant: "ghost", size: "sm" });
    clearBtn.addEventListener("click", (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      NotifierService.clearRule(row.id);
      closeRuleEditor();
    });
    if (!current) ui.setButtonEnabled(clearBtn, false);
    const saveBtn = ui.btn("Save", { variant: "primary", size: "sm" });
    saveBtn.addEventListener("click", (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      const sound = soundSelect.value?.trim() || null;
      const modeRaw = modeSelect.value || "";
      const stopRaw = stopSelect?.value || "";
      const intervalRaw = intervalInput.value?.trim();
      const volRaw = Math.max(0, Math.min(100, parseInt(volumeRange.value || "", 10) || 0));
      const volRatio = volRaw / 100;
      let playbackMode = modeRaw === "oneshot" || modeRaw === "loop" ? modeRaw : null;
      if (playbackMode === defaults.mode) playbackMode = null;
      let stopMode = allowPurchase ? stopRaw === "purchase" ? "purchase" : null : null;
      if (stopMode != null && stopMode === contextDefaults.stopMode) {
        stopMode = null;
      }
      let loopIntervalMs = null;
      if (allowPurchase && intervalRaw) {
        const parsed = Number(intervalRaw);
        if (Number.isFinite(parsed)) {
          const normalized = Math.max(150, Math.min(1e4, Math.floor(parsed)));
          if (normalized !== defaultIntervalMs) loopIntervalMs = normalized;
        }
      }
      let volume = null;
      if (Math.abs(volRatio - baseVolume) > 1e-3) {
        volume = Math.max(0, Math.min(1, volRatio));
      }
      if (allowPurchase && !playbackMode && defaults.mode !== "loop" && (stopMode != null || loopIntervalMs != null)) {
        playbackMode = "loop";
      }
      NotifierService.setRule(row.id, {
        sound,
        volume,
        playbackMode,
        stopMode,
        loopIntervalMs
      });
      closeRuleEditor();
    });
    actions.append(clearBtn, saveBtn);
    pop.appendChild(actions);
    document.body.appendChild(pop);
    const anchorRect = anchor.getBoundingClientRect();
    const width = pop.offsetWidth;
    const height = pop.offsetHeight;
    let left = anchorRect.right - width;
    let top = anchorRect.bottom + 8;
    if (left < margin) left = margin;
    if (left + width > window.innerWidth - margin) left = window.innerWidth - width - margin;
    if (top + height > window.innerHeight - margin) top = anchorRect.top - height - 8;
    if (top < margin) top = margin;
    applyPosition(left, top);
    const onDocPointer = (ev) => {
      const target = ev.target;
      if (!target) return;
      if (pop.contains(target)) return;
      if (anchor.contains(target)) return;
      closeRuleEditor();
    };
    setTimeout(() => document.addEventListener("pointerdown", onDocPointer, true));
    detachRuleDocHandler = () => document.removeEventListener("pointerdown", onDocPointer, true);
    const keyBlocker = (ev) => {
      if (!rulePopover) return;
      if (rulePopover.contains(ev.target)) return;
      ev.stopImmediatePropagation();
    };
    document.addEventListener("keydown", keyBlocker, true);
    detachRuleKeyBlocker = () => document.removeEventListener("keydown", keyBlocker, true);
    const wheelBlocker = (ev) => {
      const t = ev.target;
      if (rulePopover && t && rulePopover.contains(t)) {
        ev.stopImmediatePropagation();
      }
    };
    document.addEventListener("wheel", wheelBlocker, { capture: true, passive: true });
    detachRuleWheelBlocker = () => {
      document.removeEventListener("wheel", wheelBlocker, { capture: true });
    };
    rulePopover = pop;
  };
  function renderSettingsTab(view, ui) {
    view.innerHTML = "";
    void PetAlertService.start().catch(() => {
    });
    const section = (title) => {
      const card2 = ui.card(title, { tone: "muted" });
      card2.body.style.display = "grid";
      card2.body.style.gap = "10px";
      return card2;
    };
    const row = (labelTxt, control, opts) => {
      const { root: r, label: label2 } = ui.formRow(labelTxt, control, { alignTop: opts?.alignTop, labelWidth: "160px" });
      label2.style.opacity = "0.9";
      label2.style.fontWeight = "600";
      return r;
    };
    const radio = (name, value, text) => {
      const chip = ui.toggleChip(text, { type: "radio", name, value });
      chip.root.classList.add("qmm-radio-chip");
      return { label: chip.root, input: chip.input };
    };
    const makeSelect = (id) => {
      const sel = ui.select({ id, width: "180px" });
      return sel;
    };
    const playIconBtn = (title = "Play") => {
      return ui.btn("", { icon: "\u25B6", size: "sm", tooltip: title, ariaLabel: title });
    };
    const smallBtn2 = (txt) => ui.btn(txt, { size: "sm" });
    const errorBar = () => ui.errorBar();
    const root = document.createElement("div");
    Object.assign(root.style, {
      display: "grid",
      gridTemplateRows: "1fr",
      gap: "12px",
      height: "54vh",
      minHeight: "0",
      overflow: "hidden"
    });
    view.appendChild(root);
    const s1 = section("Audio & Playback");
    root.appendChild(s1.root);
    const contextControls = {};
    const contextOrder = [
      { key: "shops", label: "Shops", allowPurchase: true, showStop: true },
      { key: "weather", label: "Weather", allowPurchase: false },
      { key: "pets", label: "Pets", allowPurchase: true, showStop: false }
    ];
    for (const cfg of contextOrder) {
      const card2 = document.createElement("div");
      Object.assign(card2.style, {
        display: "grid",
        gap: "12px",
        padding: "16px",
        borderRadius: "12px",
        border: "1px solid #1f2429",
        background: "#111821"
      });
      const heading = document.createElement("div");
      heading.textContent = cfg.label;
      heading.style.fontWeight = "700";
      heading.style.fontSize = "14px";
      heading.style.letterSpacing = "0.02em";
      card2.appendChild(heading);
      const defaultWrap = document.createElement("div");
      defaultWrap.style.display = "flex";
      defaultWrap.style.alignItems = "center";
      defaultWrap.style.gap = "8px";
      const select2 = makeSelect(`ap.defaultSound.${cfg.key}`);
      select2.dataset.soundSelect = cfg.key;
      const playBtn = playIconBtn(`Play ${cfg.label.toLowerCase()} sound`);
      defaultWrap.append(select2, playBtn);
      card2.appendChild(row("Default sound", defaultWrap));
      const volumeWrap = document.createElement("div");
      volumeWrap.style.display = "flex";
      volumeWrap.style.alignItems = "center";
      volumeWrap.style.gap = "10px";
      const volumeRange = document.createElement("input");
      volumeRange.type = "range";
      volumeRange.min = "0";
      volumeRange.max = "100";
      volumeRange.step = "1";
      volumeRange.style.width = "220px";
      const volumeValue = document.createElement("span");
      volumeValue.style.minWidth = "32px";
      volumeValue.style.textAlign = "right";
      volumeWrap.append(volumeRange, volumeValue);
      card2.appendChild(row("Volume", volumeWrap));
      const modeWrap = document.createElement("div");
      modeWrap.style.display = "flex";
      modeWrap.style.gap = "12px";
      const modeOne = radio(`ap.mode.${cfg.key}`, "oneshot", "One-shot");
      modeWrap.append(modeOne.label);
      let modeLoop = null;
      if (cfg.allowPurchase) {
        modeLoop = radio(`ap.mode.${cfg.key}`, "loop", "Loop");
        modeWrap.append(modeLoop.label);
      }
      card2.appendChild(row("Playback mode", modeWrap));
      let stopRow;
      let loopInput;
      let loopWrap;
      if (cfg.allowPurchase) {
        const stopWrap = document.createElement("div");
        stopWrap.style.display = "flex";
        stopWrap.style.flexDirection = "column";
        stopWrap.style.gap = "10px";
        const stopInfo = document.createElement("div");
        stopInfo.textContent = cfg.showStop === false ? "Loops keep repeating; stop manually by disabling the alert." : "Loops stop automatically when the item is purchased.";
        stopInfo.style.opacity = "0.75";
        stopInfo.style.fontSize = "12px";
        stopInfo.style.lineHeight = "1.4";
        if (cfg.key !== "pets") {
          loopWrap = document.createElement("div");
          loopWrap.style.display = "flex";
          loopWrap.style.flexDirection = "column";
          loopWrap.style.gap = "4px";
          const loopTitle = document.createElement("div");
          loopTitle.textContent = "Loop interval";
          loopTitle.style.opacity = "0.8";
          loopTitle.style.fontSize = "12px";
          loopTitle.style.fontWeight = "600";
          const loopBox = document.createElement("div");
          loopBox.style.display = "inline-flex";
          loopBox.style.alignItems = "center";
          loopBox.style.gap = "8px";
          loopInput = document.createElement("input");
          loopInput.type = "number";
          loopInput.min = "150";
          loopInput.max = "10000";
          loopInput.step = "50";
          loopInput.style.width = "100px";
          loopInput.style.textAlign = "center";
          const loopLabel = document.createElement("span");
          loopLabel.textContent = "ms between plays";
          loopLabel.style.opacity = "0.85";
          loopBox.append(loopInput, loopLabel);
          loopWrap.append(loopTitle, loopBox);
          stopWrap.append(stopInfo, loopWrap);
        } else {
          stopWrap.append(stopInfo);
        }
        if (cfg.showStop !== false) {
          stopRow = row("Stop condition", stopWrap);
        } else {
          stopRow = row("Loop interval", stopWrap);
        }
        card2.appendChild(stopRow);
      } else {
        const info = document.createElement("div");
        info.textContent = "Weather alerts play once per trigger.";
        info.style.opacity = "0.75";
        info.style.fontSize = "12px";
        info.style.lineHeight = "1.4";
        card2.appendChild(row("Details", info));
      }
      contextControls[cfg.key] = {
        container: card2,
        select: select2,
        playBtn,
        volumeRange,
        volumeValue,
        modeOneshot: modeOne.input,
        modeLoop: modeLoop?.input,
        stopRow,
        loopInput,
        loopWrap
      };
      s1.body.appendChild(card2);
    }
    const s1Err = errorBar();
    s1.body.appendChild(s1Err.el);
    const s2 = section("Sound library");
    root.appendChild(s2.root);
    const importRow = document.createElement("div");
    Object.assign(importRow.style, {
      display: "flex",
      flexDirection: "column",
      gap: "12px",
      width: "100%"
    });
    const fileInput = document.createElement("input");
    fileInput.type = "file";
    fileInput.accept = "audio/*";
    fileInput.multiple = true;
    fileInput.style.display = "none";
    const fileCard = document.createElement("div");
    Object.assign(fileCard.style, {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center",
      gap: "6px",
      padding: "18px 22px",
      width: "100%",
      minHeight: "110px",
      borderRadius: "14px",
      border: "1px dashed #5d6a7d",
      background: "linear-gradient(180deg, #0b141c, #091018)",
      transition: "border-color 0.2s ease, background 0.2s ease, box-shadow 0.2s ease",
      cursor: "pointer",
      textAlign: "center"
    });
    fileCard.tabIndex = 0;
    fileCard.setAttribute("role", "button");
    fileCard.setAttribute("aria-label", "Select audio files");
    const fileCardTitle = document.createElement("div");
    fileCardTitle.textContent = "Select audio files";
    Object.assign(fileCardTitle.style, {
      fontWeight: "600",
      fontSize: "14px",
      letterSpacing: "0.02em"
    });
    const fileStatus = document.createElement("div");
    const defaultStatusText = "Click to browse or drop files";
    fileStatus.textContent = defaultStatusText;
    Object.assign(fileStatus.style, {
      fontSize: "12px",
      opacity: "0.75"
    });
    fileCard.append(fileCardTitle, fileStatus);
    const setFileCardActive = (active) => {
      if (active) {
        fileCard.style.borderColor = "#6fc3ff";
        fileCard.style.boxShadow = "0 0 0 3px #6fc3ff22";
        fileCard.style.background = "linear-gradient(180deg, #102030, #0b1826)";
      } else {
        fileCard.style.borderColor = "#5d6a7d";
        fileCard.style.boxShadow = "none";
        fileCard.style.background = "linear-gradient(180deg, #0b141c, #091018)";
      }
    };
    fileCard.addEventListener("mouseenter", () => setFileCardActive(true));
    fileCard.addEventListener("mouseleave", () => setFileCardActive(document.activeElement === fileCard));
    fileCard.addEventListener("focus", () => setFileCardActive(true));
    fileCard.addEventListener("blur", () => setFileCardActive(false));
    fileCard.addEventListener("dragover", (ev) => {
      ev.preventDefault();
      setFileCardActive(true);
      if (ev.dataTransfer) ev.dataTransfer.dropEffect = "copy";
    });
    fileCard.addEventListener("dragleave", () => setFileCardActive(document.activeElement === fileCard));
    const triggerFileSelect = () => fileInput.click();
    fileCard.addEventListener("click", triggerFileSelect);
    fileCard.addEventListener("keydown", (ev) => {
      if (ev.key === "Enter" || ev.key === " ") {
        ev.preventDefault();
        triggerFileSelect();
      }
    });
    const displaySelection = (files) => {
      if (!files || !files.length) {
        fileStatus.textContent = defaultStatusText;
        return;
      }
      fileStatus.textContent = files.length === 1 ? files[0].name : `${files.length} files selected`;
    };
    fileCard.addEventListener("drop", async (ev) => {
      ev.preventDefault();
      const files = ev.dataTransfer?.files || null;
      displaySelection(files);
      await handleFiles(files);
      displaySelection(null);
      setFileCardActive(document.activeElement === fileCard);
    });
    importRow.append(fileInput, fileCard);
    s2.body.appendChild(importRow);
    const tip = document.createElement("div");
    tip.textContent = "MP3, WAV, OGG \u2014 limited to \u2264 10 s and \u2264 200 KB.";
    tip.style.opacity = "0.75";
    tip.style.fontSize = "12px";
    s2.body.appendChild(tip);
    const listWrap = document.createElement("div");
    Object.assign(listWrap.style, {
      display: "grid",
      gridTemplateRows: "auto 1fr",
      gap: "6px",
      border: "1px solid #4445",
      borderRadius: "10px",
      background: "#10161c",
      padding: "10px"
    });
    const listHeader = document.createElement("div");
    Object.assign(listHeader.style, {
      display: "grid",
      gridTemplateColumns: "minmax(0, 1fr) auto",
      gap: "12px",
      fontSize: "12px",
      letterSpacing: "0.05em",
      textTransform: "uppercase",
      opacity: "0.65",
      paddingBottom: "4px",
      borderBottom: "1px solid #ffffff14"
    });
    const headName = document.createElement("span");
    headName.textContent = "Sound";
    const headActions = document.createElement("span");
    headActions.textContent = "Actions";
    headActions.style.justifySelf = "end";
    listHeader.append(headName, headActions);
    const listBody = document.createElement("div");
    Object.assign(listBody.style, {
      display: "flex",
      flexDirection: "column",
      gap: "6px",
      maxHeight: "240px",
      overflowY: "auto",
      paddingRight: "4px",
      minHeight: "0",
      padding: "4px 0"
    });
    listWrap.append(listHeader, listBody);
    s2.body.appendChild(listWrap);
    const s2Err = errorBar();
    s2.body.appendChild(s2Err.el);
    const sanitizeLoopInput = (input, fallback) => {
      const trimmed = (input.value || "").trim();
      const raw = trimmed ? Number(trimmed) : NaN;
      const normalized = Number.isFinite(raw) ? raw : fallback;
      const clamped = Math.max(150, Math.min(1e4, Math.floor(normalized)));
      input.value = String(clamped);
      return clamped;
    };
    const updateStopVisibility = (context) => {
      const controls = contextControls[context];
      const loopChecked = controls.modeLoop?.checked ?? false;
      if (controls.stopRow) controls.stopRow.style.display = loopChecked ? "" : "none";
      if (controls.loopWrap) controls.loopWrap.style.display = loopChecked ? "flex" : "none";
    };
    const applyMode = (context, mode) => {
      if (context === "weather" && mode === "loop") {
        audio.setPlaybackMode("oneshot", context);
        contextControls[context].modeOneshot.checked = true;
        contextControls[context].modeLoop && (contextControls[context].modeLoop.checked = false);
        updateStopVisibility(context);
        return;
      }
      audio.setPlaybackMode(mode, context);
      updateStopVisibility(context);
    };
    const applyShopsStop = () => {
      const controls = contextControls.shops;
      if (!controls.loopInput) return;
      const loopMs = sanitizeLoopInput(controls.loopInput, audio.getLoopInterval("shops"));
      audio.setLoopInterval(loopMs, "shops");
      if (!controls.modeLoop?.checked) {
        if (controls.modeLoop) controls.modeLoop.checked = true;
        controls.modeOneshot.checked = false;
        applyMode("shops", "loop");
      }
      audio.setStopPurchase("shops");
      NotifierService.setContextStopDefaults("shops", { stopMode: "purchase", stopRepeats: null, loopIntervalMs: loopMs });
      return loopMs;
    };
    for (const cfg of contextOrder) {
      const controls = contextControls[cfg.key];
      controls.select.addEventListener("change", () => {
        audio.setDefaultSoundByName(controls.select.value, cfg.key);
        renderLibList();
      });
      controls.playBtn.addEventListener("click", () => {
        audio.trigger("preview", { sound: controls.select.value }, cfg.key).catch(() => {
        });
      });
      controls.volumeRange.addEventListener("input", () => {
        const value = Math.max(0, Math.min(100, parseInt(controls.volumeRange.value || "0", 10) || 0));
        controls.volumeValue.textContent = `${value}%`;
        audio.setVolume(value / 100, cfg.key);
      });
      controls.modeOneshot.addEventListener("change", () => {
        if (!controls.modeOneshot.checked) return;
        applyMode(cfg.key, "oneshot");
        if (cfg.key === "shops") {
          const loopMs = controls.loopInput ? sanitizeLoopInput(controls.loopInput, audio.getLoopInterval("shops")) : audio.getLoopInterval("shops");
          audio.setLoopInterval(loopMs, "shops");
          audio.setStopManual("shops");
          NotifierService.setContextStopDefaults("shops", { stopMode: "manual", stopRepeats: null, loopIntervalMs: loopMs });
        }
      });
      controls.modeLoop?.addEventListener("change", () => {
        if (!controls.modeLoop?.checked) return;
        applyMode(cfg.key, "loop");
        if (cfg.key === "shops") applyShopsStop();
      });
      if (cfg.allowPurchase) {
        controls.loopInput?.addEventListener("change", applyShopsStop);
        controls.loopInput?.addEventListener("blur", applyShopsStop);
      }
    }
    const refreshAllSoundSelects = () => {
      const names = audio.listSounds();
      const applyOptions = (sel, context) => {
        const current = sel.value;
        sel.innerHTML = "";
        for (const n of names) {
          const option = document.createElement("option");
          option.value = n;
          option.textContent = n;
          sel.appendChild(option);
        }
        const preferred = audio.getDefaultSoundName(context);
        if (names.includes(current)) sel.value = current;
        else if (preferred && names.includes(preferred)) sel.value = preferred;
        else if (names.length) sel.value = names[0];
      };
      for (const cfg of contextOrder) {
        applyOptions(contextControls[cfg.key].select, cfg.key);
      }
      const all = Array.from(document.querySelectorAll("select[data-sound-select]"));
      for (const sel of all) {
        const ctx2 = sel.dataset.soundSelect || "shops";
        if (contextControls[ctx2]?.select === sel) continue;
        applyOptions(sel, ctx2);
      }
    };
    const renderLibList = () => {
      listBody.replaceChildren();
      const names = audio.listSounds();
      if (!names.length) {
        const empty = document.createElement("div");
        empty.textContent = "No sounds in the library.";
        empty.style.opacity = "0.75";
        empty.style.textAlign = "center";
        empty.style.padding = "12px 6px";
        listBody.appendChild(empty);
        return;
      }
      const defaultShops = audio.getDefaultSoundName("shops");
      const defaultWeather = audio.getDefaultSoundName("weather");
      for (const name of names) {
        const row2 = document.createElement("div");
        Object.assign(row2.style, {
          display: "grid",
          gridTemplateColumns: "minmax(0, 1fr) auto",
          gap: "12px",
          alignItems: "center",
          padding: "8px 10px",
          borderRadius: "8px",
          border: "1px solid #1f2429",
          background: "#151b22"
        });
        const info = document.createElement("div");
        Object.assign(info.style, {
          display: "flex",
          alignItems: "center",
          gap: "8px",
          minWidth: "0"
        });
        const title = document.createElement("span");
        title.textContent = name;
        title.style.fontWeight = "600";
        title.style.overflow = "hidden";
        title.style.textOverflow = "ellipsis";
        title.style.whiteSpace = "nowrap";
        info.appendChild(title);
        const badges = document.createElement("div");
        badges.style.display = "flex";
        badges.style.gap = "6px";
        const makeBadge = (label2) => {
          const badge = document.createElement("span");
          badge.textContent = label2;
          Object.assign(badge.style, {
            fontSize: "11px",
            padding: "2px 6px",
            borderRadius: "999px",
            background: "#2b5cff33",
            border: "1px solid #2b5cff66",
            color: "#9cbcff",
            fontWeight: "600",
            textTransform: "uppercase",
            letterSpacing: "0.04em"
          });
          return badge;
        };
        const isShopsDefault = defaultShops === name;
        const isWeatherDefault = defaultWeather === name;
        const isPetsDefault = audio.getDefaultSoundName("pets") === name;
        if (isShopsDefault) badges.appendChild(makeBadge("Shops"));
        if (isWeatherDefault) badges.appendChild(makeBadge("Weather"));
        if (isPetsDefault) badges.appendChild(makeBadge("Pets"));
        if (badges.childElementCount) info.appendChild(badges);
        if (isShopsDefault || isWeatherDefault || isPetsDefault) {
          row2.style.borderColor = "#2b5cff99";
          row2.style.boxShadow = "0 0 0 1px #2b5cff33";
        }
        const actions = document.createElement("div");
        Object.assign(actions.style, {
          display: "flex",
          gap: "6px",
          justifyContent: "flex-end",
          flexWrap: "wrap"
        });
        const btnPlay = smallBtn2("\u25B6");
        const btnSetShops = smallBtn2("Set shops");
        const btnSetWeather = smallBtn2("Set weather");
        const btnSetPets = smallBtn2("Set pets");
        const btnDel = smallBtn2("Remove");
        btnPlay.title = "Preview";
        btnSetShops.title = "Set as shops default";
        btnSetWeather.title = "Set as weather default";
        btnSetPets.title = "Set as pets default";
        btnDel.title = "Remove from library";
        const isProtected = typeof audio.isProtectedSound === "function" && audio.isProtectedSound(name);
        if (isProtected || isShopsDefault || isWeatherDefault) {
          btnDel.disabled = true;
          btnDel.style.opacity = "0.6";
          if (isProtected) btnDel.title = "Built-in sound cannot be removed";
          else btnDel.title = "Currently used as default";
        }
        btnPlay.onclick = () => audio.trigger("preview", { sound: name }, "shops").catch(() => {
        });
        btnSetShops.onclick = () => {
          audio.setDefaultSoundByName(name, "shops");
          refreshAllSoundSelects();
          renderLibList();
        };
        btnSetWeather.onclick = () => {
          audio.setDefaultSoundByName(name, "weather");
          refreshAllSoundSelects();
          renderLibList();
        };
        btnSetPets.onclick = () => {
          audio.setDefaultSoundByName(name, "pets");
          refreshAllSoundSelects();
          renderLibList();
        };
        btnDel.onclick = () => {
          audio.unregisterSound(name);
          refreshAllSoundSelects();
          renderLibList();
        };
        actions.append(btnPlay, btnSetShops, btnSetWeather, btnSetPets, btnDel);
        row2.append(info, actions);
        listBody.appendChild(row2);
      }
    };
    const syncContext = (context) => {
      const controls = contextControls[context];
      const settings = audio.getPlaybackSettings(context);
      const names = audio.listSounds();
      if (settings.defaultSoundName && names.includes(settings.defaultSoundName)) {
        controls.select.value = settings.defaultSoundName;
      }
      const volPercent = Math.round(settings.volume * 100);
      controls.volumeRange.value = String(volPercent);
      controls.volumeValue.textContent = `${volPercent}%`;
      if (controls.modeLoop && settings.mode === "loop") controls.modeLoop.checked = true;
      else controls.modeOneshot.checked = true;
      const defaults = context === "shops" || context === "weather" ? NotifierService.getContextStopDefaults(context) : { stopMode: "manual", stopRepeats: null, loopIntervalMs: settings.loopIntervalMs };
      const fallbackLoop = Math.max(
        150,
        Math.min(1e4, Math.floor(defaults.loopIntervalMs || settings.loopIntervalMs || 150))
      );
      const loopMs = controls.loopInput ? sanitizeLoopInput(controls.loopInput, fallbackLoop) : fallbackLoop;
      audio.setLoopInterval(loopMs, context);
      if (context === "shops") {
        if (controls.modeLoop?.checked) {
          audio.setStopPurchase("shops");
          NotifierService.setContextStopDefaults("shops", { stopMode: "purchase", stopRepeats: null, loopIntervalMs: loopMs });
        } else {
          audio.setStopManual("shops");
          NotifierService.setContextStopDefaults("shops", { stopMode: "manual", stopRepeats: null, loopIntervalMs: loopMs });
        }
      } else if (context === "weather") {
        applyMode("weather", "oneshot");
        audio.setStopManual("weather");
        NotifierService.setContextStopDefaults("weather", { stopMode: "manual", stopRepeats: null, loopIntervalMs: loopMs });
      } else if (context === "pets") {
        audio.setLoopInterval(loopMs, "pets");
        audio.setStopManual("pets");
      }
      updateStopVisibility(context);
    };
    const syncFromAudio = () => {
      refreshAllSoundSelects();
      syncContext("shops");
      syncContext("weather");
      syncContext("pets");
      renderLibList();
    };
    const handleFiles = async (files) => {
      s2Err.clear();
      if (!files || !files.length) return;
      const added = [];
      for (const f of Array.from(files)) {
        try {
          const res = await audio.importFileAsSound(f, {
            maxBytes: 200 * 1024,
            maxSeconds: 10,
            bitrates: [48e3, 32e3, 2e4, 12e3, 8e3],
            maxInputBytes: 8 * 1024 * 1024
          });
          added.push(res.name);
        } catch (e) {
          s2Err.show(`Failed for "${f.name}": ${e?.message || e}`);
        }
      }
      if (added.length) {
        refreshAllSoundSelects();
        renderLibList();
        for (const cfg of contextOrder) {
          if (!audio.getDefaultSoundName(cfg.key)) {
            audio.setDefaultSoundByName(added[0], cfg.key);
          }
        }
        refreshAllSoundSelects();
        renderLibList();
      }
      fileInput.value = "";
    };
    fileInput.onchange = async () => {
      const files = fileInput.files;
      displaySelection(files);
      await handleFiles(files);
      displaySelection(null);
      setFileCardActive(document.activeElement === fileCard);
    };
    syncFromAudio();
    const scroller = document.createElement("div");
    Object.assign(scroller.style, {
      overflow: "auto",
      minHeight: "0",
      height: "100%",
      display: "grid",
      gap: "12px"
    });
    scroller.append(s1.root, s2.root);
    root.appendChild(scroller);
    view.__cleanup__ = (() => {
      const prev = view.__cleanup__;
      return () => {
        try {
          prev?.();
        } catch {
        }
      };
    })();
  }
  function renderShopTab(view, ui) {
    view.innerHTML = "";
    view.style.cssText = "";
    if (!document.getElementById("qws-rule-style")) {
      const style3 = document.createElement("style");
      style3.id = "qws-rule-style";
      style3.textContent = `
:root {
  /* PATCH: z-index centralis\xE9 */
  --qws-z-popover: 99999999999999;
}

/* PATCH: bouton engrenage carr\xE9, centr\xE9, plus gros */
.qws-rule-btn {
  display: inline-grid;
  place-items: center;
  width: 32px;
  height: 32px;
  padding: 0;
  border-radius: 8px;
  line-height: 1;
  font-size: 18px; /* taille de l'ic\xF4ne */
  min-width: 32px; /* \xE9vite les r\xE9tr\xE9cissements */
  box-sizing: border-box;
}
.qws-rule-btn[data-active="1"] {
  background: linear-gradient(180deg, #1b2735, #101821);
  box-shadow: 0 0 0 1px #658dff88 inset;
  color: #c7daff;
}

/* PATCH: popover toujours devant */
.qws-rule-popover {
  position: fixed !important;
  z-index: var(--qws-z-popover) !important;
  display: flex;
  flex-direction: column;
  gap: 10px;
  color: #f1f6ff;
}
.qws-rule-popover .qws-rule-field {
  display: grid;
  gap: 6px;
}
.qws-rule-popover .qws-rule-field label {
  font-weight: 600;
  font-size: 13px;
}
.qws-rule-popover .qws-rule-actions {
  display: flex;
  justify-content: space-between;
  gap: 8px;
}

/* PATCH: r\xE9serve un espace pour le r\xE9sum\xE9 afin d'\xE9viter tout shift */
[data-role="rule-hint"] {
  min-height: 1.2em;  /* ~1 ligne r\xE9serv\xE9e */
}
`;
      document.head.appendChild(style3);
    }
    const wrap = document.createElement("div");
    Object.assign(wrap.style, {
      display: "grid",
      gridTemplateRows: "auto 1fr",
      gap: "10px",
      height: "54vh",
      overflow: "hidden",
      minHeight: "0",
      position: "relative"
    });
    view.appendChild(wrap);
    const header = document.createElement("div");
    header.style.display = "flex";
    header.style.flexWrap = "wrap";
    header.style.alignItems = "center";
    header.style.gap = "10px";
    header.style.rowGap = "8px";
    wrap.appendChild(header);
    const lblType = ui.label("Type");
    const selType = document.createElement("select");
    selType.className = "qmm-input";
    selType.style.minWidth = "140px";
    selType.id = "shop.filter.type";
    [
      ["all", "All"],
      ["seed", "Seeds"],
      ["egg", "Eggs"],
      ["tool", "Tools"],
      ["decor", "Decor"]
    ].forEach(([v, t]) => {
      const o = document.createElement("option");
      o.value = v;
      o.textContent = t;
      selType.appendChild(o);
    });
    selType.value = "all";
    const lblRarity = ui.label("Rarity");
    const selRarity = document.createElement("select");
    selRarity.className = "qmm-input";
    selRarity.style.minWidth = "160px";
    selRarity.id = "shop.filter.rarity";
    [
      ["all", "All"],
      ["common", "Common"],
      ["uncommon", "Uncommon"],
      ["rare", "Rare"],
      ["legendary", "Legendary"],
      ["mythical", "Mythical"],
      ["divine", "Divine"],
      ["celestial", "Celestial"]
    ].forEach(([v, t]) => {
      const o = document.createElement("option");
      o.value = v;
      o.textContent = t;
      selRarity.appendChild(o);
    });
    selRarity.value = "all";
    const followedBadge = document.createElement("div");
    followedBadge.id = "shop.followedCount";
    followedBadge.textContent = "Followed: 0";
    followedBadge.title = "Items with Overlay enabled";
    followedBadge.style.padding = "6px 10px";
    followedBadge.style.borderRadius = "999px";
    followedBadge.style.border = "1px solid #4445";
    followedBadge.style.background = "#1f2328";
    followedBadge.style.color = "#e7eef7";
    followedBadge.style.fontWeight = "600";
    followedBadge.style.marginLeft = "auto";
    followedBadge.style.width = "115px";
    header.append(lblType, selType, lblRarity, selRarity, followedBadge);
    const card2 = document.createElement("div");
    card2.style.border = "1px solid #4445";
    card2.style.borderRadius = "10px";
    card2.style.padding = "10px";
    card2.style.background = "#0f1318";
    card2.style.overflow = "hidden";
    card2.style.display = "grid";
    card2.style.gridTemplateRows = "auto 1fr";
    card2.style.minHeight = "0";
    wrap.appendChild(card2);
    const headerGrid = document.createElement("div");
    const COLS = "minmax(200px, 1fr) 9rem 7rem 8rem";
    headerGrid.style.display = "grid";
    headerGrid.style.gridTemplateColumns = COLS;
    headerGrid.style.justifyContent = "start";
    headerGrid.style.columnGap = "0";
    headerGrid.style.borderBottom = "1px solid #ffffff1a";
    headerGrid.style.padding = "0 0 4px 0";
    headerGrid.style.position = "sticky";
    headerGrid.style.top = "0";
    headerGrid.append(
      mkHeadCell("Item", "left"),
      mkHeadCell("Rarity"),
      mkHeadCell("Notify"),
      mkHeadCell("Custom rules")
    );
    card2.appendChild(headerGrid);
    const bodyGrid = document.createElement("div");
    bodyGrid.style.display = "grid";
    bodyGrid.style.gridTemplateColumns = COLS;
    bodyGrid.style.justifyContent = "start";
    bodyGrid.style.gridAutoRows = "auto";
    bodyGrid.style.alignContent = "start";
    bodyGrid.style.minHeight = "0";
    bodyGrid.style.height = "100%";
    bodyGrid.style.overflow = "auto";
    bodyGrid.style.overscrollBehavior = "contain";
    bodyGrid.style.width = "100%";
    bodyGrid.style.scrollbarGutter = "stable";
    card2.appendChild(bodyGrid);
    const refreshRulesUI = () => {
      const kids = Array.from(bodyGrid.children);
      for (let i = 0; i + 3 < kids.length; i += 4) {
        const itemCell = kids[i];
        const ruleCell = kids[i + 3];
        const id = itemCell?.dataset?.id;
        if (!id) continue;
        applyRuleState(itemCell, ruleCell ?? null, NotifierService.getRule(id));
      }
    };
    const softUpdateRenderedRows = (next) => {
      const byId = new Map(next.rows.map((r) => [r.id, r]));
      const kids = Array.from(bodyGrid.children);
      for (let i = 0; i + 3 < kids.length; i += 4) {
        const itemCell = kids[i];
        const popupCell = kids[i + 2];
        const ruleCell = kids[i + 3];
        const id = itemCell.dataset.id;
        const row = byId.get(id);
        if (!row) continue;
        const popupSwitch = popupCell.querySelector("label");
        if (popupSwitch) setSwitchVisual(popupSwitch, !!row.popup);
        itemCell.dataset.follow = row.followed ? "1" : "0";
        applyRuleState(itemCell, ruleCell ?? null, NotifierService.getRule(id));
        const capped = NotifierService.isIdCapped?.(id) ?? false;
        if (popupSwitch) setSwitchCapState(popupSwitch, capped);
      }
    };
    const syncHeaderToScrollbar = () => {
      const sbw = bodyGrid.offsetWidth - bodyGrid.clientWidth;
      headerGrid.style.boxSizing = "border-box";
      headerGrid.style.paddingRight = `${sbw}px`;
    };
    syncHeaderToScrollbar();
    const resizeObserver = new ResizeObserver(syncHeaderToScrollbar);
    resizeObserver.observe(bodyGrid);
    const onResize = () => syncHeaderToScrollbar();
    window.addEventListener("resize", onResize);
    const lastSeenRefs = /* @__PURE__ */ new Map();
    let state3 = null;
    let renderedIds = /* @__PURE__ */ new Set();
    const getFilters = () => ({
      type: selType.value || "all",
      rarity: selRarity.value || "all"
    });
    const passesFilters = (rows) => NotifierService.filterRows(rows, getFilters());
    const mkItemCell = (row) => {
      const wrap2 = document.createElement("div");
      Object.assign(wrap2.style, {
        display: "flex",
        alignItems: "center",
        gap: "6px",
        padding: "4px 6px",
        borderBottom: "1px solid #ffffff12"
      });
      const ICON = 40;
      const iconWrap = document.createElement("div");
      Object.assign(iconWrap.style, {
        width: `${ICON}px`,
        height: `${ICON}px`,
        flex: `0 0 ${ICON}px`,
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        borderRadius: "8px",
        background: "#101820",
        marginRight: "6px",
        aspectRatio: "1 / 1"
      });
      const iconFallback = row.type === "Seed" ? "\u{1F331}" : row.type === "Egg" ? "\u{1F95A}" : row.type === "Tool" ? "\u{1F9F0}" : "\u{1F3E0}";
      const icon = document.createElement("span");
      icon.textContent = iconFallback;
      icon.style.fontSize = `${ICON - 10}px`;
      icon.setAttribute("aria-hidden", "true");
      iconWrap.appendChild(icon);
      const spriteCategories = row.type === "Seed" ? ["seed"] : row.type === "Egg" ? ["pet"] : row.type === "Tool" ? ["item"] : row.type === "Decor" ? ["decor"] : null;
      if (spriteCategories) {
        const baseId = row.id.split(":")[1] ?? row.name ?? row.id;
        const candidatesSet = /* @__PURE__ */ new Set();
        const addCandidate = (value) => {
          if (!value) return;
          const trimmed = value.trim();
          if (!trimmed) return;
          candidatesSet.add(trimmed);
          candidatesSet.add(trimmed.replace(/\s+/g, ""));
          if (row.type === "Seed" || row.type === "Egg") {
            const stripped = trimmed.replace(/(?:seed|egg)$/i, "").trim();
            if (stripped) {
              candidatesSet.add(stripped);
              candidatesSet.add(stripped.replace(/\s+/g, ""));
            }
          }
        };
        addCandidate(baseId);
        addCandidate(row.id);
        addCandidate(row.name);
        const candidates = Array.from(candidatesSet).filter(Boolean);
        if (candidates.length) {
          attachSpriteIcon(iconWrap, spriteCategories, candidates, ICON, "alerts");
        }
      }
      const col = document.createElement("div");
      Object.assign(col.style, {
        display: "flex",
        flexDirection: "column",
        gap: "2px",
        lineHeight: "1.15",
        minWidth: "0",
        // autorise l'ellipsis
        flex: "1 1 auto"
      });
      const title = document.createElement("div");
      title.textContent = row.name;
      Object.assign(title.style, {
        fontWeight: "700",
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
      });
      const sub = document.createElement("div");
      sub.textContent = row.type;
      sub.style.opacity = "0.7";
      sub.style.fontSize = "12px";
      const ruleHint = document.createElement("div");
      ruleHint.dataset.role = "rule-hint";
      ruleHint.style.display = "none";
      ruleHint.style.opacity = "0.75";
      ruleHint.style.fontSize = "11px";
      ruleHint.style.whiteSpace = "nowrap";
      ruleHint.style.overflow = "hidden";
      ruleHint.style.textOverflow = "ellipsis";
      ruleHint.style.minHeight = "1.2em";
      ruleHint.style.visibility = "hidden";
      col.append(title, sub, ruleHint);
      wrap2.append(iconWrap, col);
      return wrap2;
    };
    const addRow = (row) => {
      const itemCell = mkItemCell(row);
      itemCell.dataset.id = row.id;
      itemCell.dataset.type = row.type;
      itemCell.dataset.follow = row.followed ? "1" : "0";
      itemCell.dataset.context = "shops";
      const rarityCell = document.createElement("div");
      rarityCell.style.display = "flex";
      rarityCell.style.alignItems = "center";
      rarityCell.style.justifyContent = "center";
      rarityCell.style.borderBottom = "1px solid #ffffff12";
      rarityCell.appendChild(rarityBadge(String(row.rarity ?? "\u2014")));
      const popupSwitch = createSwitch((on) => {
        try {
          NotifierService.setPopup(row.id, !!on);
        } catch {
        }
        const cur = NotifierService.getPref(row.id);
        itemCell.dataset.follow = cur.followed ? "1" : "0";
      });
      setSwitchVisual(popupSwitch, !!row.popup);
      popupSwitch.style.padding = "0";
      const popupCell = wrapCell(popupSwitch);
      const capped = NotifierService.isIdCapped?.(row.id) ?? false;
      setSwitchCapState(popupSwitch, capped);
      const gearBtn = ui.btn("", {
        icon: "\u2699",
        size: "sm",
        tooltip: "Custom rule",
        ariaLabel: `Custom rule for ${row.name}`
      });
      gearBtn.dataset.role = "rule";
      gearBtn.classList.add("qws-rule-btn");
      gearBtn.addEventListener("click", (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        openRuleEditor(ui, {
          id: row.id,
          name: row.name,
          type: row.type,
          context: "shops"
        }, gearBtn);
      });
      const ruleCell = wrapCell(gearBtn);
      ruleCell.dataset.role = "rule-cell";
      bodyGrid.append(itemCell, rarityCell, popupCell, ruleCell);
      applyRuleState(itemCell, ruleCell, NotifierService.getRule(row.id));
    };
    function clearBody() {
      closeRuleEditor();
      bodyGrid.innerHTML = "";
      renderedIds = /* @__PURE__ */ new Set();
    }
    function renderEmpty() {
      const empty = document.createElement("div");
      empty.textContent = "No items.";
      empty.style.opacity = "0.75";
      empty.style.gridColumn = "1 / -1";
      empty.style.padding = "8px";
      bodyGrid.appendChild(empty);
    }
    function rebuildGrid() {
      clearBody();
      if (!state3) {
        renderEmpty();
        return;
      }
      const rows = passesFilters(state3.rows);
      if (!rows.length) {
        renderEmpty();
      } else {
        rows.forEach((r) => {
          addRow(r);
          renderedIds.add(r.id);
        });
      }
      refreshRulesUI();
      followedBadge.textContent = `Followed: ${state3.counts.followed}`;
      syncHeaderToScrollbar();
    }
    function softUpdateBadge(next) {
      followedBadge.textContent = `Followed: ${next.counts.followed}`;
    }
    function filteredIdSet(s) {
      const set3 = /* @__PURE__ */ new Set();
      for (const r of passesFilters(s.rows)) set3.add(r.id);
      return set3;
    }
    let unsub = null;
    let unsubRules = null;
    (async () => {
      try {
        await NotifierService.start();
      } catch {
      }
      unsub = await NotifierService.onChangeNow((s) => {
        const prev = state3;
        state3 = s;
        if (!prev) {
          rebuildGrid();
          softUpdateRenderedRows(state3);
          return;
        }
        const prevIds = renderedIds;
        const nextIds = filteredIdSet(s);
        let needRebuild = false;
        if (prevIds.size !== nextIds.size) needRebuild = true;
        else {
          for (const id of nextIds) if (!prevIds.has(id)) {
            needRebuild = true;
            break;
          }
        }
        if (needRebuild) {
          rebuildGrid();
        } else {
          softUpdateBadge(s);
          softUpdateRenderedRows(s);
        }
      });
      try {
        unsubRules = await NotifierService.onRulesChangeNow(() => refreshRulesUI());
      } catch {
      }
    })();
    const onFilterChange = () => {
      if (state3) rebuildGrid();
    };
    selType.onchange = onFilterChange;
    selRarity.onchange = onFilterChange;
    view.__cleanup__ = (() => {
      const prev = view.__cleanup__;
      return () => {
        try {
          unsub?.();
        } catch {
        }
        try {
          unsubRules?.();
        } catch {
        }
        try {
          resizeObserver.disconnect();
        } catch {
        }
        try {
          window.removeEventListener("resize", onResize);
        } catch {
        }
        try {
          closeRuleEditor();
        } catch {
        }
        try {
          prev?.();
        } catch {
        }
      };
    })();
  }
  function renderPetAlertsTab(view, ui) {
    view.innerHTML = "";
    void PetAlertService.start().catch(() => {
    });
    const card2 = document.createElement("div");
    Object.assign(card2.style, {
      display: "grid",
      gridTemplateColumns: "minmax(220px, 260px) minmax(0, 1fr)",
      gap: "10px",
      alignItems: "stretch",
      height: "54vh",
      overflow: "hidden",
      border: "1px solid #4445",
      borderRadius: "10px",
      padding: "10px",
      background: "#0f1318"
    });
    view.appendChild(card2);
    const petList = document.createElement("div");
    Object.assign(petList.style, {
      display: "grid",
      gridTemplateColumns: "1fr",
      rowGap: "6px",
      overflow: "auto",
      padding: "6px",
      border: "1px solid #4445",
      borderRadius: "10px"
    });
    card2.appendChild(petList);
    const right = document.createElement("div");
    Object.assign(right.style, {
      display: "flex",
      flexDirection: "column",
      gap: "10px",
      overflow: "auto",
      minHeight: "0"
    });
    card2.appendChild(right);
    let pets = [];
    let unsubPets2 = null;
    let generalEnabled = PetAlertService.isGeneralEnabled();
    const formRow = (labelTxt, control) => {
      const { root } = ui.formRow(labelTxt, control, { labelWidth: "180px" });
      return root;
    };
    const generalCard = ui.card("General notifications", { tone: "muted", align: "stretch" });
    generalCard.body.style.display = "grid";
    generalCard.body.style.gap = "10px";
    const generalRow = ui.flexRow({ justify: "start", gap: 10 });
    const generalSw = ui.switch(PetAlertService.isGeneralEnabled());
    const generalLbl = document.createElement("div");
    generalLbl.textContent = "Use a shared threshold for all pets";
    generalLbl.style.opacity = "0.9";
    generalRow.append(generalSw, generalLbl);
    generalCard.body.append(formRow("Enable general", generalRow));
    const generalInput = ui.inputNumber(1, 100, 1, PetAlertService.getGeneralThresholdPct());
    generalCard.body.append(formRow("General threshold (%)", generalInput.wrap ?? generalInput));
    right.appendChild(generalCard.root);
    const syncGeneralUI = () => {
      generalEnabled = PetAlertService.isGeneralEnabled();
      generalSw.checked = generalEnabled;
      generalInput.value = String(PetAlertService.getGeneralThresholdPct());
    };
    generalSw.onchange = () => {
      PetAlertService.setGeneralEnabled(generalSw.checked);
      syncGeneralUI();
    };
    generalInput.addEventListener("change", () => {
      const next = Math.max(1, Math.min(100, Number(generalInput.value) || PetAlertService.getGeneralThresholdPct()));
      generalInput.value = String(PetAlertService.setGeneralThresholdPct(next));
    });
    syncGeneralUI();
    const renderPetList = () => {
      petList.innerHTML = "";
      if (!pets.length) {
        const empty = document.createElement("div");
        empty.textContent = "No active pets.";
        empty.style.opacity = "0.75";
        petList.appendChild(empty);
        return;
      }
      for (const pet of pets) {
        const slot = pet?.slot ?? {};
        const name = String(slot?.name || slot?.petSpecies || "Pet");
        const hunger = PetsService.getHungerPctFor(pet);
        const hungerText = Number.isFinite(hunger) ? `${hunger}%` : "\u2014";
        const row = document.createElement("div");
        row.style.display = "flex";
        row.style.alignItems = "center";
        row.style.justifyContent = "space-between";
        row.style.gap = "10px";
        row.style.width = "100%";
        row.style.textAlign = "left";
        row.style.padding = "6px 8px";
        row.style.borderRadius = "8px";
        row.style.border = "1px solid #4445";
        row.style.background = "#121820";
        const left = document.createElement("div");
        left.style.display = "flex";
        left.style.alignItems = "center";
        left.style.gap = "8px";
        left.style.minWidth = "0";
        const avatar2 = document.createElement("div");
        avatar2.style.width = "40px";
        avatar2.style.height = "40px";
        avatar2.style.borderRadius = "8px";
        avatar2.style.display = "inline-flex";
        avatar2.style.alignItems = "center";
        avatar2.style.justifyContent = "center";
        avatar2.style.background = "#111821";
        avatar2.style.border = "1px solid #1f2429";
        avatar2.style.overflow = "hidden";
        const useEmojiFallback = () => {
          avatar2.replaceChildren();
          const span = document.createElement("span");
          span.textContent = "\u{1F43E}";
          span.style.fontSize = "28px";
          span.setAttribute("aria-hidden", "true");
          avatar2.appendChild(span);
        };
        const setIcon = (species2, mutations2) => {
          const speciesLabel = String(species2 ?? "").trim();
          avatar2.replaceChildren();
          if (!speciesLabel) {
            useEmojiFallback();
            return;
          }
          const span = document.createElement("span");
          span.textContent = speciesLabel.charAt(0).toUpperCase() || "\u0110Y?\xF3";
          span.style.fontSize = "28px";
          span.setAttribute("aria-hidden", "true");
          avatar2.appendChild(span);
          attachSpriteIcon(avatar2, ["pet"], [speciesLabel], 36, "alerts-pet", {
            mutations: Array.isArray(mutations2) ? mutations2 : void 0
          });
        };
        const species = String(slot?.petSpecies || "");
        const mutations = slot?.mutations ?? pet?.mutations;
        setIcon(species, Array.isArray(mutations) ? mutations : void 0);
        const titleWrap = document.createElement("div");
        titleWrap.style.display = "flex";
        titleWrap.style.flexDirection = "column";
        titleWrap.style.gap = "2px";
        titleWrap.style.minWidth = "0";
        const title = document.createElement("div");
        title.textContent = name;
        title.style.fontWeight = "600";
        title.style.overflow = "hidden";
        title.style.textOverflow = "ellipsis";
        title.style.whiteSpace = "nowrap";
        titleWrap.append(title);
        left.append(avatar2, titleWrap);
        const hungerValue = document.createElement("div");
        hungerValue.textContent = hungerText;
        hungerValue.style.fontWeight = "700";
        hungerValue.style.color = "#FFD84D";
        row.append(left, hungerValue);
        petList.appendChild(row);
      }
    };
    (async () => {
      try {
        unsubPets2 = await PetsService.onPetsChangeNow((arr) => {
          pets = Array.isArray(arr) ? arr.slice(0, 3) : [];
          renderPetList();
        });
      } catch {
        pets = [];
        renderPetList();
      }
    })();
    view.__cleanup__ = (() => {
      const prev = view.__cleanup__;
      return () => {
        try {
          unsubPets2?.();
        } catch {
        }
        try {
          prev?.();
        } catch {
        }
      };
    })();
  }
  function renderWeatherTab(view, ui) {
    view.innerHTML = "";
    view.style.cssText = "";
    const wrap = document.createElement("div");
    Object.assign(wrap.style, {
      display: "grid",
      gridTemplateRows: "1fr",
      height: "54vh",
      overflow: "hidden",
      minHeight: "0"
    });
    view.appendChild(wrap);
    const card2 = document.createElement("div");
    card2.style.border = "1px solid #4445";
    card2.style.borderRadius = "10px";
    card2.style.padding = "10px";
    card2.style.background = "#0f1318";
    card2.style.overflow = "hidden";
    card2.style.display = "grid";
    card2.style.gridTemplateRows = "auto 1fr";
    card2.style.minHeight = "0";
    wrap.appendChild(card2);
    const headerGrid = document.createElement("div");
    const COLS = "minmax(240px, 1fr) 9rem 7rem 8rem";
    headerGrid.style.display = "grid";
    headerGrid.style.gridTemplateColumns = COLS;
    headerGrid.style.justifyContent = "start";
    headerGrid.style.columnGap = "0";
    headerGrid.style.borderBottom = "1px solid #ffffff1a";
    headerGrid.style.padding = "0 0 4px 0";
    headerGrid.style.position = "sticky";
    headerGrid.style.top = "0";
    headerGrid.append(
      mkHeadCell("Weather", "left"),
      mkHeadCell("Last seen"),
      mkHeadCell("Notify"),
      mkHeadCell("Custom rules")
    );
    card2.appendChild(headerGrid);
    const bodyGrid = document.createElement("div");
    bodyGrid.style.display = "grid";
    bodyGrid.style.gridTemplateColumns = COLS;
    bodyGrid.style.justifyContent = "start";
    bodyGrid.style.gridAutoRows = "auto";
    bodyGrid.style.alignContent = "start";
    bodyGrid.style.minHeight = "0";
    bodyGrid.style.height = "100%";
    bodyGrid.style.overflow = "auto";
    bodyGrid.style.overscrollBehavior = "contain";
    bodyGrid.style.width = "100%";
    bodyGrid.style.scrollbarGutter = "stable";
    card2.appendChild(bodyGrid);
    const weatherLastSeenRefs = /* @__PURE__ */ new Map();
    const refreshRulesUI = () => {
      const kids = Array.from(bodyGrid.children);
      for (let i = 0; i + 3 < kids.length; i += 4) {
        const itemCell = kids[i];
        const ruleCell = kids[i + 3];
        const id = itemCell?.dataset?.id;
        if (!id) continue;
        applyRuleState(itemCell, ruleCell ?? null, NotifierService.getRule(id));
      }
    };
    const syncHeaderToScrollbar = () => {
      const sbw = bodyGrid.offsetWidth - bodyGrid.clientWidth;
      headerGrid.style.boxSizing = "border-box";
      headerGrid.style.paddingRight = `${sbw}px`;
    };
    syncHeaderToScrollbar();
    const resizeObserver = new ResizeObserver(syncHeaderToScrollbar);
    resizeObserver.observe(bodyGrid);
    const onResize = () => syncHeaderToScrollbar();
    window.addEventListener("resize", onResize);
    const makeItemCell = (row) => {
      const wrapCellDiv = document.createElement("div");
      Object.assign(wrapCellDiv.style, {
        display: "flex",
        alignItems: "center",
        gap: "8px",
        padding: "6px",
        borderBottom: "1px solid #ffffff12"
      });
      const ICON = 40;
      const iconWrap = document.createElement("div");
      Object.assign(iconWrap.style, {
        width: `${ICON}px`,
        height: `${ICON}px`,
        flex: `0 0 ${ICON}px`,
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        borderRadius: "8px",
        background: "#101820"
      });
      const weatherIcon = document.createElement("span");
      weatherIcon.textContent = row.name.trim().charAt(0) || "\u{1F326}";
      weatherIcon.style.fontSize = `${ICON - 8}px`;
      weatherIcon.setAttribute("aria-hidden", "true");
      iconWrap.appendChild(weatherIcon);
      const weatherCategories = ["ui", "weather", "mutation"];
      const candidateSet = /* @__PURE__ */ new Set();
      const addCandidate = (value) => {
        if (!value) return;
        const trimmed = value.trim();
        if (trimmed) {
          candidateSet.add(trimmed);
          candidateSet.add(trimmed.replace(/\s+/g, ""));
        }
      };
      addCandidate(row.name);
      addCandidate(row.atomValue);
      addCandidate(row.id);
      const bases = Array.from(candidateSet).map((value) => value.replace(/icon$/i, ""));
      const candidates = Array.from(
        new Set(
          bases.map((base) => `${base}Icon`).concat(Array.from(candidateSet))
        ).values()
      ).filter(Boolean);
      if (candidates.length) {
        attachSpriteIcon(iconWrap, weatherCategories, candidates, ICON, "alerts-weather");
      }
      const col = document.createElement("div");
      Object.assign(col.style, {
        display: "flex",
        flexDirection: "column",
        gap: "4px",
        lineHeight: "1.2",
        minWidth: "0",
        flex: "1 1 auto"
      });
      const headerRow = document.createElement("div");
      Object.assign(headerRow.style, {
        display: "flex",
        alignItems: "center",
        gap: "6px",
        minWidth: "0"
      });
      const title = document.createElement("div");
      title.textContent = row.name;
      Object.assign(title.style, {
        fontWeight: "700",
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap",
        flex: "1 1 auto"
      });
      headerRow.appendChild(title);
      if (row.isCurrent) {
        const badge = document.createElement("span");
        badge.textContent = "Current";
        Object.assign(badge.style, {
          fontSize: "11px",
          padding: "2px 6px",
          borderRadius: "999px",
          background: "#2b5cff33",
          border: "1px solid #2b5cff66",
          color: "#9cbcff",
          fontWeight: "600",
          whiteSpace: "nowrap"
        });
        headerRow.appendChild(badge);
      }
      const mutationsLabel = document.createElement("div");
      mutationsLabel.textContent = "Mutations";
      Object.assign(mutationsLabel.style, {
        fontSize: "11px",
        opacity: "0.7",
        fontWeight: "600"
      });
      const mutationsList = document.createElement("div");
      Object.assign(mutationsList.style, {
        display: "flex",
        flexWrap: "wrap",
        gap: "6px",
        alignItems: "flex-start",
        fontSize: "12px",
        lineHeight: "1.3",
        opacity: row.mutations.length ? "0.85" : "0.6"
      });
      if (row.mutations.length) {
        for (const mutation of row.mutations) {
          const chip = document.createElement("span");
          chip.textContent = formatWeatherMutation(mutation);
          Object.assign(chip.style, {
            display: "inline-flex",
            alignItems: "center",
            padding: "2px 8px",
            borderRadius: "999px",
            background: "#ffffff12",
            whiteSpace: "nowrap"
          });
          mutationsList.appendChild(chip);
        }
      } else {
        const chip = document.createElement("span");
        chip.textContent = "No mutation effects.";
        chip.style.whiteSpace = "nowrap";
        mutationsList.appendChild(chip);
      }
      const ruleHint = document.createElement("div");
      ruleHint.dataset.role = "rule-hint";
      ruleHint.style.opacity = "0.75";
      ruleHint.style.fontSize = "11px";
      ruleHint.style.whiteSpace = "nowrap";
      ruleHint.style.overflow = "hidden";
      ruleHint.style.textOverflow = "ellipsis";
      ruleHint.style.minHeight = "1.2em";
      ruleHint.style.visibility = "hidden";
      col.append(headerRow, mutationsLabel, mutationsList, ruleHint);
      wrapCellDiv.append(iconWrap, col);
      if (row.isCurrent) {
        wrapCellDiv.style.background = "linear-gradient(180deg, #1b2735, #141d25)";
        wrapCellDiv.style.borderRadius = "8px";
      }
      return wrapCellDiv;
    };
    const addRow = (row) => {
      const itemCell = makeItemCell(row);
      itemCell.dataset.id = row.id;
      itemCell.dataset.context = "weather";
      itemCell.dataset.current = row.isCurrent ? "1" : "0";
      const lastSeenInfo = document.createElement("div");
      const { label: label2, title } = formatLastSeen(row.lastSeen, row.isCurrent);
      lastSeenInfo.textContent = label2;
      lastSeenInfo.title = title;
      lastSeenInfo.style.fontWeight = "600";
      lastSeenInfo.style.opacity = label2 === "Never" ? "0.7" : "1";
      lastSeenInfo.style.whiteSpace = "nowrap";
      const lastSeenCell = wrapCell(lastSeenInfo);
      weatherLastSeenRefs.set(row.id, lastSeenInfo);
      const notifySwitch = createSwitch((on) => {
        try {
          NotifierService.setWeatherNotify(row.id, !!on);
        } catch {
        }
      });
      setSwitchVisual(notifySwitch, !!row.notify);
      notifySwitch.style.padding = "0";
      const notifyCell = wrapCell(notifySwitch);
      const gearBtn = ui.btn("", {
        icon: "\u2699",
        size: "sm",
        tooltip: "Custom rule",
        ariaLabel: `Custom rule for ${row.name}`
      });
      gearBtn.dataset.role = "rule";
      gearBtn.classList.add("qws-rule-btn");
      gearBtn.addEventListener("click", (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        openRuleEditor(ui, {
          id: row.id,
          name: row.name,
          type: row.type,
          context: "weather"
        }, gearBtn);
      });
      const ruleCell = wrapCell(gearBtn);
      ruleCell.dataset.role = "rule-cell";
      bodyGrid.append(itemCell, lastSeenCell, notifyCell, ruleCell);
      applyRuleState(itemCell, ruleCell, NotifierService.getRule(row.id));
    };
    const clearGrid = () => {
      closeRuleEditor();
      bodyGrid.innerHTML = "";
      weatherLastSeenRefs.clear();
    };
    const renderEmpty = () => {
      const empty = document.createElement("div");
      empty.textContent = "No weather entries.";
      empty.style.opacity = "0.75";
      empty.style.gridColumn = "1 / -1";
      empty.style.padding = "8px";
      bodyGrid.appendChild(empty);
    };
    let state3 = null;
    let stateSig = "";
    const updateDynamicWeatherStats = () => {
      if (!state3) return;
      for (const row of state3.rows) {
        const target = weatherLastSeenRefs.get(row.id);
        if (target) {
          const { label: label2, title } = formatLastSeen(row.lastSeen, row.isCurrent);
          target.textContent = label2;
          target.title = title;
          target.style.opacity = label2 === "Never" ? "0.7" : "1";
        }
      }
    };
    const rebuildGrid = () => {
      clearGrid();
      if (!state3 || !state3.rows.length) {
        renderEmpty();
      } else {
        state3.rows.forEach(addRow);
        refreshRulesUI();
      }
      syncHeaderToScrollbar();
      updateDynamicWeatherStats();
    };
    let unsubWeather = null;
    let unsubRules = null;
    (async () => {
      try {
        await NotifierService.start();
      } catch {
      }
      try {
        unsubWeather = await NotifierService.onWeatherChangeNow((next) => {
          state3 = next;
          stateSig = weatherStateSignature(next.rows);
          rebuildGrid();
        });
      } catch {
      }
      try {
        unsubRules = await NotifierService.onRulesChangeNow(() => refreshRulesUI());
      } catch {
      }
    })();
    const refreshWeatherState = async () => {
      try {
        const next = await NotifierService.getWeatherState();
        const nextSig = weatherStateSignature(next.rows);
        const changed = nextSig !== stateSig;
        state3 = next;
        stateSig = nextSig;
        if (changed) rebuildGrid();
        else updateDynamicWeatherStats();
      } catch {
      }
    };
    const dynamicTimer = window.setInterval(updateDynamicWeatherStats, 3e4);
    const weatherRefreshTimer = window.setInterval(() => {
      void refreshWeatherState();
    }, 6e4);
    view.__cleanup__ = (() => {
      const prev = view.__cleanup__;
      return () => {
        try {
          unsubWeather?.();
        } catch {
        }
        try {
          unsubRules?.();
        } catch {
        }
        try {
          resizeObserver.disconnect();
        } catch {
        }
        try {
          window.removeEventListener("resize", onResize);
        } catch {
        }
        try {
          window.clearInterval(dynamicTimer);
        } catch {
        }
        try {
          window.clearInterval(weatherRefreshTimer);
        } catch {
        }
        try {
          closeRuleEditor();
        } catch {
        }
        try {
          prev?.();
        } catch {
        }
      };
    })();
  }
  function renderNotifierMenu(root) {
    const ui = new Menu({ id: "alerts", compact: true, windowSelector: ".qws-win" });
    ui.addTab("shops", "\u{1F6D2} Shops", (view) => renderShopTab(view, ui));
    ui.addTab("weather", "\u{1F326} Weather", (view) => renderWeatherTab(view, ui));
    ui.addTab("pets", "\u{1F43E} Pets", (view) => renderPetAlertsTab(view, ui));
    ui.addTab("settings", "\u2699\uFE0F Settings", (view) => renderSettingsTab(view, ui));
    ui.mount(root);
  }

  // src/ui/menus/stats.ts
  init_atoms();
  var NF_INT = new Intl.NumberFormat("en-US");
  var formatInt = (value) => NF_INT.format(Math.max(0, Math.floor(value || 0)));
  var DURATION_ABILITIES = /* @__PURE__ */ new Set([
    "egggrowthboost",
    "egggrowthboostii_new",
    "egggrowthboostii",
    "plantgrowthboost",
    "plantgrowthboostii"
  ]);
  var XP_ABILITIES = /* @__PURE__ */ new Set([
    "petxpboost",
    "petxpboostii",
    "petageboost",
    "petageboostii"
  ]);
  var STRENGTH_ABILITIES = /* @__PURE__ */ new Set(["pethatchsizeboost", "pethatchsizeboostii"]);
  var HUNGER_ABILITIES = /* @__PURE__ */ new Set([
    "hungerrestore",
    "hungerrestoreii",
    "hungerboost",
    "hungerboostii"
  ]);
  function isPlainRecord(value) {
    return typeof value === "object" && value !== null;
  }
  function isGardenStatsSectionEmpty(garden2) {
    return (garden2.totalPlanted ?? 0) <= 0 && (garden2.totalHarvested ?? 0) <= 0 && (garden2.totalDestroyed ?? 0) <= 0 && (garden2.watercanUsed ?? 0) <= 0 && (garden2.waterTimeSavedMs ?? 0) <= 0;
  }
  function isShopStatsSectionEmpty(shops2) {
    return (shops2.seedsBought ?? 0) <= 0 && (shops2.decorBought ?? 0) <= 0 && (shops2.eggsBought ?? 0) <= 0 && (shops2.toolsBought ?? 0) <= 0 && (shops2.cropsSoldCount ?? 0) <= 0 && (shops2.cropsSoldValue ?? 0) <= 0 && (shops2.petsSoldCount ?? 0) <= 0 && (shops2.petsSoldValue ?? 0) <= 0;
  }
  function isPetStatsSectionEmpty(stats) {
    const entries = Object.values(stats.pets?.hatchedByType ?? {});
    if (entries.length === 0) return true;
    return entries.every((counts) => {
      if (!counts) return true;
      const normal = Number(counts.normal) || 0;
      const gold = Number(counts.gold) || 0;
      const rainbow = Number(counts.rainbow) || 0;
      return normal <= 0 && gold <= 0 && rainbow <= 0;
    });
  }
  async function readInventoryQuantity(atom, label2) {
    try {
      const raw = await atom.get();
      if (!Array.isArray(raw)) return 0;
      let total = 0;
      for (const entry of raw) {
        if (!entry || typeof entry !== "object") continue;
        const quantity = Number(entry.quantity);
        if (Number.isFinite(quantity) && quantity > 0) {
          total += Math.max(0, Math.floor(quantity));
        }
      }
      return total;
    } catch (error) {
      console.warn(`[StatsMenu] Failed to read ${label2} inventory`, error);
      return 0;
    }
  }
  async function initGarden(stats) {
    if (!isGardenStatsSectionEmpty(stats.garden)) return;
    let state3;
    try {
      state3 = await garden.get();
    } catch (error) {
      console.warn("[StatsMenu] Failed to read garden data", error);
      return;
    }
    if (!state3 || !isPlainRecord(state3.tileObjects)) return;
    let totalPlanted = 0;
    for (const value of Object.values(state3.tileObjects)) {
      if (!isPlainRecord(value)) continue;
      const objectType = typeof value.objectType === "string" ? value.objectType.toLowerCase() : "";
      if (objectType === "plant") {
        totalPlanted += 1;
      }
    }
    if (totalPlanted <= 0) return;
    StatsService.update((draft) => {
      if (!isGardenStatsSectionEmpty(draft.garden)) return;
      draft.garden.totalPlanted = totalPlanted;
    });
  }
  async function initShops(stats) {
    if (!isShopStatsSectionEmpty(stats.shops)) return;
    let state3 = null;
    try {
      state3 = await garden.get();
    } catch (error) {
      console.warn("[StatsMenu] Failed to read garden data", error);
    }
    let seedsBought = 0;
    let eggsBought = 0;
    let decorBought = 0;
    let toolsBought = 0;
    if (state3 && isPlainRecord(state3.tileObjects)) {
      for (const value of Object.values(state3.tileObjects)) {
        if (!isPlainRecord(value)) continue;
        const objectType = typeof value.objectType === "string" ? value.objectType.toLowerCase() : "";
        if (objectType === "plant") {
          seedsBought += 1;
        } else if (objectType === "egg") {
          eggsBought += 1;
        }
      }
    }
    if (state3 && isPlainRecord(state3.boardwalkTileObjects)) {
      for (const value of Object.values(state3.boardwalkTileObjects)) {
        if (value != null) {
          decorBought += 1;
        }
      }
    }
    const [seedInventoryQty2, toolInventoryQty, eggInventoryQty, decorInventoryQty2] = await Promise.all([
      readInventoryQuantity(mySeedInventory, "seed"),
      readInventoryQuantity(myToolInventory, "tool"),
      readInventoryQuantity(myEggInventory, "egg"),
      readInventoryQuantity(myDecorInventory, "decor")
    ]);
    seedsBought += seedInventoryQty2;
    eggsBought += eggInventoryQty;
    decorBought += decorInventoryQty2;
    toolsBought += toolInventoryQty;
    if (seedsBought <= 0 && eggsBought <= 0 && decorBought <= 0 && toolsBought <= 0) return;
    StatsService.update((draft) => {
      if (!isShopStatsSectionEmpty(draft.shops)) return;
      if (seedsBought > 0 && (draft.shops.seedsBought ?? 0) <= 0) {
        draft.shops.seedsBought = seedsBought;
      }
      if (eggsBought > 0 && (draft.shops.eggsBought ?? 0) <= 0) {
        draft.shops.eggsBought = eggsBought;
      }
      if (decorBought > 0 && (draft.shops.decorBought ?? 0) <= 0) {
        draft.shops.decorBought = decorBought;
      }
      if (toolsBought > 0 && (draft.shops.toolsBought ?? 0) <= 0) {
        draft.shops.toolsBought = toolsBought;
      }
    });
  }
  function getInventoryItems(raw) {
    if (Array.isArray(raw)) return raw;
    if (isPlainRecord(raw) && Array.isArray(raw.items)) {
      return raw.items;
    }
    return [];
  }
  function determinePetMutationType(mutations) {
    if (!Array.isArray(mutations)) return "normal";
    let hasGold = false;
    for (const mutation of mutations) {
      if (typeof mutation !== "string") continue;
      const normalized = mutation.trim().toLowerCase();
      if (normalized === "rainbow") {
        return "rainbow";
      }
      if (normalized === "gold") {
        hasGold = true;
      }
    }
    return hasGold ? "gold" : "normal";
  }
  async function initPets(stats) {
    if (!isPetStatsSectionEmpty(stats)) return;
    let inventory;
    try {
      inventory = await myInventory.get();
    } catch (error) {
      console.warn("[StatsMenu] Failed to read inventory data", error);
      inventory = null;
    }
    let activePetsRaw;
    try {
      activePetsRaw = await myPetInfos.get();
    } catch (error) {
      console.warn("[StatsMenu] Failed to read active pet data", error);
      activePetsRaw = null;
    }
    const items = getInventoryItems(inventory);
    const activePets = Array.isArray(activePetsRaw) ? activePetsRaw : [];
    if (items.length === 0 && activePets.length === 0) return;
    const countsBySpecies = /* @__PURE__ */ new Map();
    for (const item of items) {
      if (!isPlainRecord(item)) continue;
      const itemType = typeof item.itemType === "string" ? item.itemType.toLowerCase() : "";
      if (itemType !== "pet") continue;
      const speciesRaw = typeof item.petSpecies === "string" ? item.petSpecies : null;
      const species = speciesRaw?.trim();
      if (!species) continue;
      const key2 = species.toLowerCase();
      const counts = countsBySpecies.get(key2) ?? { normal: 0, gold: 0, rainbow: 0 };
      const rarityKey = determinePetMutationType(item.mutations);
      counts[rarityKey] = (counts[rarityKey] ?? 0) + 1;
      countsBySpecies.set(key2, counts);
    }
    for (const entry of activePets) {
      if (!isPlainRecord(entry)) continue;
      const slot = isPlainRecord(entry.slot) ? entry.slot : null;
      if (!slot) continue;
      const speciesRaw = typeof slot.petSpecies === "string" ? slot.petSpecies : null;
      const species = speciesRaw?.trim();
      if (!species) continue;
      const key2 = species.toLowerCase();
      const counts = countsBySpecies.get(key2) ?? { normal: 0, gold: 0, rainbow: 0 };
      const rarityKey = determinePetMutationType(slot.mutations);
      counts[rarityKey] = (counts[rarityKey] ?? 0) + 1;
      countsBySpecies.set(key2, counts);
    }
    let hasCounts = false;
    for (const counts of countsBySpecies.values()) {
      if ((counts.normal ?? 0) > 0 || (counts.gold ?? 0) > 0 || (counts.rainbow ?? 0) > 0) {
        hasCounts = true;
        break;
      }
    }
    if (!hasCounts) return;
    StatsService.update((draft) => {
      if (!isPetStatsSectionEmpty(draft)) return;
      for (const [speciesKey, counts] of countsBySpecies) {
        if ((counts.normal ?? 0) <= 0 && (counts.gold ?? 0) <= 0 && (counts.rainbow ?? 0) <= 0) {
          continue;
        }
        const entry = draft.pets.hatchedByType[speciesKey] ?? { normal: 0, gold: 0, rainbow: 0 };
        entry.normal = (entry.normal ?? 0) + (counts.normal ?? 0);
        entry.gold = (entry.gold ?? 0) + (counts.gold ?? 0);
        entry.rainbow = (entry.rainbow ?? 0) + (counts.rainbow ?? 0);
        draft.pets.hatchedByType[speciesKey] = entry;
      }
    });
  }
  function formatAbilityTotalValue(abilityId, totalValue) {
    const normalized = abilityId.toLowerCase();
    const safeValue = Number.isFinite(totalValue) ? Math.max(0, totalValue) : 0;
    if (DURATION_ABILITIES.has(normalized)) {
      return formatDuration(safeValue);
    }
    if (XP_ABILITIES.has(normalized)) {
      return `${formatInt(safeValue)} XP`;
    }
    if (STRENGTH_ABILITIES.has(normalized)) {
      return `${formatInt(safeValue)} strength`;
    }
    if (HUNGER_ABILITIES.has(normalized)) {
      const rounded = Math.round(safeValue);
      const isWholeNumber = Math.abs(safeValue - rounded) < 1e-6;
      const formatted = isWholeNumber ? formatInt(rounded) : safeValue.toFixed(1);
      return `${formatted}% hunger`;
    }
    return formatPrice(safeValue) ?? formatInt(safeValue);
  }
  var STATS_WINDOW_MIN_WIDTH = 560;
  var LS_STATS_COLLAPSE_KEY = "menu:stats:collapsed";
  var collapseStateCache = null;
  function getStatsStorage() {
    try {
      if (typeof window !== "undefined" && window.localStorage) {
        return window.localStorage;
      }
    } catch {
    }
    try {
      if (typeof localStorage !== "undefined") {
        return localStorage;
      }
    } catch {
    }
    return null;
  }
  function readCollapseState() {
    const storage = getStatsStorage();
    if (!storage) return {};
    try {
      const raw = storage.getItem(LS_STATS_COLLAPSE_KEY);
      if (!raw) return {};
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== "object") return {};
      const entries = Object.entries(parsed).filter((entry) => {
        return typeof entry[1] === "boolean";
      });
      return Object.fromEntries(entries);
    } catch (error) {
      console.warn("[StatsMenu] Failed to read collapse state", error);
      return {};
    }
  }
  function writeCollapseState(state3) {
    const storage = getStatsStorage();
    if (!storage) return;
    try {
      storage.setItem(LS_STATS_COLLAPSE_KEY, JSON.stringify(state3));
    } catch (error) {
      console.warn("[StatsMenu] Failed to save collapse state", error);
    }
  }
  function getCollapseState() {
    if (!collapseStateCache) {
      collapseStateCache = readCollapseState();
    }
    return collapseStateCache;
  }
  function getSectionCollapsed(id, fallback) {
    const state3 = getCollapseState();
    const value = state3[id];
    return typeof value === "boolean" ? value : fallback;
  }
  function setSectionCollapsed(id, collapsed) {
    const current = getCollapseState();
    if (current[id] === collapsed) return;
    const next = { ...current, [id]: collapsed };
    collapseStateCache = next;
    writeCollapseState(next);
  }
  var DATE_TIME_FORMATTER = new Intl.DateTimeFormat(void 0, {
    dateStyle: "medium",
    timeStyle: "short"
  });
  var RELATIVE_TIME_FORMATTER = new Intl.RelativeTimeFormat(void 0, {
    numeric: "auto"
  });
  var RARITY_ORDER2 = [
    rarity.Common,
    rarity.Uncommon,
    rarity.Rare,
    rarity.Legendary,
    rarity.Mythic,
    rarity.Divine,
    rarity.Celestial
  ];
  var RARITY_BORDER_COLORS = {
    [rarity.Common]: "#E7E7E7",
    [rarity.Uncommon]: "#67BD4D",
    [rarity.Rare]: "#0071C6",
    [rarity.Legendary]: "#FFC734",
    [rarity.Mythic]: "#9944A7",
    [rarity.Divine]: "#FF7835",
    [rarity.Celestial]: "#7C2AE8"
  };
  function createCollapsibleCard(ui, title, opts = {}) {
    const card2 = ui.card(title, { tone: "muted", align: "stretch", subtitle: opts.subtitle, icon: opts.icon });
    card2.root.classList.add("qmm-card--collapsible");
    const toggle = document.createElement("button");
    toggle.type = "button";
    toggle.className = "qmm-btn qmm-btn--ghost qmm-btn--sm stats-collapse-toggle";
    toggle.style.marginLeft = "auto";
    const toggleIcon = document.createElement("span");
    toggleIcon.className = "stats-collapse-toggle__icon";
    toggleIcon.setAttribute("aria-hidden", "true");
    const toggleLabel = document.createElement("span");
    toggleLabel.className = "stats-collapse-toggle__label";
    toggle.append(toggleIcon, toggleLabel);
    const titleElement = card2.header.querySelector(".qmm-card__title");
    if (titleElement) titleElement.insertAdjacentElement("afterend", toggle);
    else card2.header.appendChild(toggle);
    const storageId = opts.storageId?.trim() || null;
    let currentAnimation = null;
    const stopAnimation = () => {
      if (!currentAnimation) return;
      currentAnimation.cancel();
      currentAnimation = null;
    };
    const animateBody = (collapsed) => {
      const body = card2.body;
      stopAnimation();
      const prefersReducedMotion = typeof window.matchMedia === "function" && window.matchMedia("(prefers-reduced-motion: reduce)").matches;
      if (prefersReducedMotion) {
        body.style.display = collapsed ? "none" : "grid";
        body.style.height = "";
        body.style.opacity = "";
        body.style.overflow = "";
        return;
      }
      const easing = "cubic-bezier(0.33, 1, 0.68, 1)";
      const duration = 220;
      body.style.overflow = "hidden";
      if (!collapsed) {
        body.style.display = "grid";
        body.style.height = "0px";
        body.style.opacity = "0";
        const targetHeight = body.scrollHeight;
        currentAnimation = body.animate(
          [
            { height: "0px", opacity: 0 },
            { height: `${targetHeight}px`, opacity: 1 }
          ],
          { duration, easing, fill: "forwards" }
        );
      } else {
        const startHeight = body.offsetHeight;
        body.style.height = `${startHeight}px`;
        body.style.opacity = "1";
        currentAnimation = body.animate(
          [
            { height: `${startHeight}px`, opacity: 1 },
            { height: "0px", opacity: 0 }
          ],
          { duration, easing, fill: "forwards" }
        );
      }
      if (!currentAnimation) {
        body.style.display = collapsed ? "none" : "grid";
        body.style.height = "";
        body.style.opacity = "";
        body.style.overflow = "";
        return;
      }
      currentAnimation.onfinish = () => {
        if (collapsed) {
          body.style.display = "none";
          body.style.opacity = "";
        } else {
          body.style.display = "grid";
          body.style.opacity = "";
        }
        body.style.height = "";
        body.style.overflow = "";
        currentAnimation = null;
      };
      currentAnimation.oncancel = () => {
        body.style.height = "";
        body.style.opacity = "";
        body.style.overflow = "";
        if (collapsed) {
          body.style.display = "none";
        }
        currentAnimation = null;
      };
    };
    const setCollapsed = (collapsed, persist2 = true, animate = true) => {
      if (!animate) {
        stopAnimation();
        card2.body.style.display = collapsed ? "none" : "grid";
        card2.body.style.height = "";
        card2.body.style.opacity = "";
        card2.body.style.overflow = "";
      } else {
        animateBody(collapsed);
      }
      card2.root.dataset.collapsed = collapsed ? "true" : "false";
      toggle.setAttribute("aria-expanded", String(!collapsed));
      const verb = collapsed ? "Show" : "Hide";
      const label2 = `${verb} ${title}`;
      toggleLabel.textContent = verb;
      toggle.setAttribute("aria-label", label2);
      toggle.title = label2;
      card2.root.classList.toggle("is-collapsed", collapsed);
      if (persist2 && storageId) {
        setSectionCollapsed(storageId, collapsed);
      }
    };
    const defaultCollapsed = !!opts.startCollapsed;
    const initialCollapsed = storageId ? getSectionCollapsed(storageId, defaultCollapsed) : defaultCollapsed;
    setCollapsed(initialCollapsed, false, false);
    toggle.addEventListener("click", () => {
      const collapsed = card2.root.dataset.collapsed === "true";
      setCollapsed(!collapsed);
    });
    return { root: card2.root, body: card2.body, header: card2.header, setCollapsed };
  }
  function createMetricGrid(rows) {
    const grid = document.createElement("div");
    grid.className = "stats-metric-grid";
    for (const row of rows) {
      const card2 = document.createElement("div");
      card2.className = "stats-metric";
      if (row.hint) card2.title = row.hint;
      const label2 = document.createElement("span");
      label2.className = "stats-metric__label";
      label2.textContent = row.label;
      const value = document.createElement("span");
      value.className = "stats-metric__value qmm-num";
      value.textContent = row.value;
      card2.append(label2, value);
      grid.appendChild(card2);
    }
    return grid;
  }
  function createWeatherNameCell(entry) {
    const wrapper = document.createElement("span");
    wrapper.className = "stats-weather__name";
    const iconWrap = document.createElement("span");
    iconWrap.className = "stats-weather__icon";
    const initials = entry.label?.trim().charAt(0) || "\u2014";
    iconWrap.textContent = initials.toUpperCase();
    if (entry.label) {
      iconWrap.setAttribute("aria-label", entry.label);
      iconWrap.setAttribute("title", entry.label);
    }
    const categories = ["ui"];
    const normalized = entry.lookupId.replace(/\s+/g, "");
    const sanitize = (value) => value.replace(/[^a-zA-Z0-9]/g, "");
    const bases = Array.from(
      new Set(
        [
          sanitize(entry.lookupId),
          normalized,
          entry.lookupId.replace(/Icon$/i, ""),
          normalized.replace(/Icon$/i, "")
        ].filter(Boolean)
      )
    );
    const candidates = Array.from(
      new Set(
        bases.map((base) => `${base}Icon`).filter((candidate) => candidate.includes("Icon"))
      )
    );
    if (candidates.length === 0) {
      candidates.push(`${normalized || sanitize(entry.lookupId)}Icon`);
    }
    attachSpriteIcon(iconWrap, categories, candidates, 28, "stats-weather");
    const label2 = document.createElement("span");
    label2.className = "stats-weather__label";
    label2.textContent = entry.label;
    wrapper.append(iconWrap, label2);
    return { content: wrapper };
  }
  function createStatList(columns, rows) {
    const container = document.createElement("div");
    container.className = "stats-list";
    const toTemplate = (column) => {
      if (column.width) return column.width;
      if (column.minWidth) return `minmax(${column.minWidth}, 1fr)`;
      return "minmax(0, 1fr)";
    };
    const template = columns.map(toTemplate).join(" ");
    const header = document.createElement("div");
    header.className = "stats-list__row stats-list__row--header";
    header.style.gridTemplateColumns = template;
    for (const column of columns) {
      const cell = document.createElement("span");
      cell.className = "stats-list__cell";
      const align = column.align ?? "left";
      if (align !== "left") cell.classList.add(`stats-list__cell--align-${align}`);
      if (column.headerClassName) cell.classList.add(column.headerClassName);
      cell.textContent = column.label;
      header.appendChild(cell);
    }
    container.appendChild(header);
    for (const row of rows) {
      const rowEl = document.createElement("div");
      rowEl.className = "stats-list__row";
      rowEl.style.gridTemplateColumns = template;
      row.forEach((cellData, index) => {
        const column = columns[index];
        const cell = document.createElement("span");
        cell.className = "stats-list__cell";
        const align = cellData.align ?? column.align ?? "left";
        if (align !== "left") {
          cell.classList.add(`stats-list__cell--align-${align}`);
          if (align === "right") cell.classList.add("qmm-num");
        }
        if (cellData.hint) cell.title = cellData.hint;
        const hasContent = Boolean(cellData.content);
        if (cellData.content) {
          cell.appendChild(cellData.content);
        }
        if (cellData.text != null) {
          if (hasContent) {
            const textSpan = document.createElement("span");
            textSpan.textContent = cellData.text;
            cell.appendChild(textSpan);
          } else {
            cell.textContent = cellData.text;
          }
        } else if (!hasContent) {
          cell.textContent = "";
        }
        rowEl.appendChild(cell);
      });
      container.appendChild(rowEl);
    }
    return container;
  }
  function formatDuration(ms) {
    const value = Math.max(0, ms || 0);
    if (value < 1e3) return `${formatInt(value)} ms`;
    const seconds = value / 1e3;
    if (seconds < 60) return `${seconds.toFixed(1)} s`;
    const minutes = seconds / 60;
    if (minutes < 60) return `${minutes.toFixed(1)} min`;
    const hours = minutes / 60;
    return `${hours.toFixed(1)} h`;
  }
  function formatDateTime(ms) {
    return DATE_TIME_FORMATTER.format(new Date(ms));
  }
  function renderMetaSection(ui, root, stats) {
    const card2 = ui.card("\u{1F5D3}\uFE0F Tracking", {
      tone: "muted",
      align: "stretch",
      compactHeader: true
    });
    const createdAt = Number.isFinite(stats.createdAt) ? Math.max(0, Math.floor(stats.createdAt)) : 0;
    const hasCreatedAt = createdAt > 0;
    const row = ui.flexRow({ align: "center", gap: 12, className: "stats-meta" });
    const label2 = document.createElement("span");
    label2.className = "stats-meta__label";
    label2.textContent = "Tracking started:";
    row.appendChild(label2);
    const value = document.createElement("strong");
    value.className = "stats-meta__value";
    value.textContent = hasCreatedAt ? formatDateTime(createdAt) : "Unavailable";
    row.appendChild(value);
    const resetButton = ui.btn("RESET", { variant: "danger" });
    resetButton.style.marginLeft = "auto";
    resetButton.addEventListener("click", () => {
      const freshStats = StatsService.reset();
      void initGarden(freshStats);
      void initShops(freshStats);
      void initPets(freshStats);
    });
    row.appendChild(resetButton);
    card2.body.appendChild(row);
    root.appendChild(card2.root);
  }
  function renderGardenSection(ui, root, stats) {
    const card2 = createCollapsibleCard(ui, "\u{1F331} Garden", {
      subtitle: "Field activity",
      storageId: "garden"
    });
    const rows = [
      { label: "Total planted", value: formatInt(stats.garden.totalPlanted) },
      { label: "Total harvested", value: formatInt(stats.garden.totalHarvested) },
      { label: "Total destroyed", value: formatInt(stats.garden.totalDestroyed) },
      { label: "Watering can Used", value: formatInt(stats.garden.watercanUsed) },
      {
        label: "Water time saved",
        value: formatDuration(stats.garden.waterTimeSavedMs),
        hint: `${formatInt(stats.garden.waterTimeSavedMs)} ms`
      }
    ];
    card2.body.appendChild(createMetricGrid(rows));
    root.appendChild(card2.root);
  }
  function renderShopSection(ui, root, stats) {
    const card2 = createCollapsibleCard(ui, "\u{1F3EA} Shops", {
      subtitle: "Purchases & sales",
      storageId: "shops"
    });
    const rows = [
      { label: "Seeds bought", value: formatInt(stats.shops.seedsBought) },
      { label: "Tools bought", value: formatInt(stats.shops.toolsBought) },
      { label: "Eggs bought", value: formatInt(stats.shops.eggsBought) },
      { label: "Decor bought", value: formatInt(stats.shops.decorBought) },
      { label: "Crops sold", value: `${formatInt(stats.shops.cropsSoldCount)} items` },
      {
        label: "Crop revenue",
        value: formatPrice(stats.shops.cropsSoldValue) ?? formatInt(stats.shops.cropsSoldValue)
      },
      { label: "Pets sold", value: `${formatInt(stats.shops.petsSoldCount)} pets` },
      {
        label: "Pet revenue",
        value: formatPrice(stats.shops.petsSoldValue) ?? formatInt(stats.shops.petsSoldValue)
      }
    ];
    card2.body.appendChild(createMetricGrid(rows));
    root.appendChild(card2.root);
  }
  function createPetRarityGroups() {
    const map2 = /* @__PURE__ */ new Map();
    for (const rarityKey of RARITY_ORDER2) {
      map2.set(rarityKey, []);
    }
    for (const species of Object.keys(petCatalog)) {
      const info = petCatalog[species];
      const rarityValue = info?.rarity ?? rarity.Common;
      const list = map2.get(rarityValue) ?? [];
      list.push(species);
      map2.set(rarityValue, list);
    }
    for (const list of map2.values()) {
      list.sort((a, b) => a.localeCompare(b));
    }
    return map2;
  }
  function createPetSpeciesCell(species) {
    const wrapper = document.createElement("span");
    wrapper.className = "stats-pet__species";
    const iconWrap = document.createElement("span");
    iconWrap.className = "stats-pet__icon";
    iconWrap.textContent = species?.trim().charAt(0).toUpperCase() || "?";
    iconWrap.setAttribute("aria-hidden", "true");
    attachSpriteIcon(iconWrap, ["pet"], species, 28, "stats-pet");
    const label2 = document.createElement("span");
    label2.className = "stats-pet__label";
    label2.textContent = species;
    wrapper.append(iconWrap, label2);
    return { content: wrapper };
  }
  function createPetTotalValueCell(total) {
    const value = document.createElement("span");
    value.className = "stats-pet__total-value qmm-num";
    value.textContent = formatInt(total);
    return { content: value, align: "center" };
  }
  function createPetTotalsLabelCell(label2) {
    const value = document.createElement("span");
    value.className = "stats-pet__total-label";
    value.textContent = label2;
    return { content: value };
  }
  function renderPetSection(ui, root, stats) {
    const card2 = createCollapsibleCard(ui, "\u{1F43E} Pets", {
      subtitle: "Hatching overview",
      storageId: "pets"
    });
    const groups2 = createPetRarityGroups();
    for (const rarityKey of RARITY_ORDER2) {
      const speciesList = groups2.get(rarityKey) ?? [];
      if (!speciesList.length) continue;
      const group = document.createElement("div");
      group.className = "stats-pet-group";
      group.style.setProperty("--stats-pet-group-border-color", RARITY_BORDER_COLORS[rarityKey]);
      const summary = document.createElement("div");
      summary.className = "stats-pet-group__summary";
      summary.textContent = "";
      const badge = rarityBadge(rarityKey);
      badge.style.margin = "0";
      summary.appendChild(badge);
      group.appendChild(summary);
      const content = document.createElement("div");
      content.className = "stats-pet-group__content";
      const columns = [
        { label: "Species", width: "2.2fr" },
        { label: "Normal", align: "center", width: "1fr" },
        { label: "Gold", align: "center", width: "1fr", headerClassName: "stats-list__header-label--gold" },
        {
          label: "Rainbow",
          align: "center",
          width: "1fr",
          headerClassName: "stats-list__header-label--rainbow"
        },
        { label: "Total", align: "center", width: "1fr" }
      ];
      const rows = [];
      let totalNormal = 0;
      let totalGold = 0;
      let totalRainbow = 0;
      for (const species of speciesList) {
        const key2 = species.toLowerCase();
        const counts = stats.pets.hatchedByType[key2] ?? { normal: 0, gold: 0, rainbow: 0 };
        totalNormal += counts.normal;
        totalGold += counts.gold;
        totalRainbow += counts.rainbow;
        const total = counts.normal + counts.gold + counts.rainbow;
        rows.push([
          createPetSpeciesCell(species),
          { text: formatInt(counts.normal), align: "center" },
          { text: formatInt(counts.gold), align: "center" },
          { text: formatInt(counts.rainbow), align: "center" },
          createPetTotalValueCell(total)
        ]);
      }
      const totalAll = totalNormal + totalGold + totalRainbow;
      rows.push([
        createPetTotalsLabelCell("Total"),
        createPetTotalValueCell(totalNormal),
        createPetTotalValueCell(totalGold),
        createPetTotalValueCell(totalRainbow),
        createPetTotalValueCell(totalAll)
      ]);
      content.appendChild(createStatList(columns, rows));
      group.appendChild(content);
      card2.body.appendChild(group);
    }
    root.appendChild(card2.root);
  }
  function renderAbilitySection(ui, root, stats) {
    const card2 = createCollapsibleCard(ui, "\u{1F9E0} Abilities", {
      subtitle: "Trigger counts",
      storageId: "abilities"
    });
    const abilityIds = Object.keys(petAbilities).sort((a, b) => {
      const nameA = petAbilities[a]?.name ?? a;
      const nameB = petAbilities[b]?.name ?? b;
      return nameA.localeCompare(nameB);
    });
    const columns = [
      { label: "Ability", width: "2.2fr" },
      { label: "Triggers", align: "right", width: "1fr" },
      { label: "Value", align: "right", width: "1.2fr" }
    ];
    const rows = [];
    for (const id of abilityIds) {
      const info = petAbilities[id];
      const statsEntry = stats.abilities[id] ?? { triggers: 0, totalValue: 0 };
      const formatted = formatAbilityTotalValue(id, statsEntry.totalValue);
      rows.push([
        { text: info?.name ?? id, hint: info?.description },
        { text: formatInt(statsEntry.triggers) },
        { text: formatted }
      ]);
    }
    card2.body.appendChild(createStatList(columns, rows));
    root.appendChild(card2.root);
  }
  function renderWeatherSection(ui, root, stats) {
    const card2 = createCollapsibleCard(ui, "\u26C5 Weather", {
      subtitle: "Events overview",
      storageId: "weather"
    });
    const columns = [
      { label: "Weather", width: "2fr" },
      { label: "TOTAL", align: "right", width: "1fr" }
    ];
    const rows = [];
    const weatherEntries = Object.keys(weatherCatalog).map((key2) => {
      const info = weatherCatalog[key2];
      const label2 = info?.atomValue ?? key2;
      const lower = key2.toLowerCase();
      const entry = stats.weather[lower] ?? { triggers: 0 };
      const lookupId = label2 && label2.trim() || key2;
      return {
        key: lower,
        label: label2,
        triggers: entry.triggers,
        lookupId
      };
    }).sort((a, b) => a.label.localeCompare(b.label));
    for (const entry of weatherEntries) {
      rows.push([
        createWeatherNameCell({ label: entry.label, lookupId: entry.lookupId }),
        { text: formatInt(entry.triggers) }
      ]);
    }
    card2.body.appendChild(createStatList(columns, rows));
    root.appendChild(card2.root);
  }
  function renderStatsMenu(container) {
    const root = container;
    if (typeof root.__statsCleanup === "function") {
      try {
        root.__statsCleanup();
      } catch (error) {
        console.error("[StatsMenu] Cleanup error", error);
      }
      root.__statsCleanup = void 0;
    }
    const prevRoot = container.firstElementChild;
    const prevView = prevRoot?.classList.contains("qmm") ? prevRoot.querySelector(".qmm-views") ?? null : null;
    const previousScrollTop = prevView ? prevView.scrollTop : null;
    let rafId = null;
    let unsubscribed = false;
    let unsubscribe2 = () => {
    };
    const cleanup2 = () => {
      if (unsubscribed) return;
      unsubscribed = true;
      try {
        unsubscribe2();
      } catch (error) {
        console.error("[StatsMenu] Unsubscribe error", error);
      }
      if (rafId !== null) {
        cancelAnimationFrame(rafId);
        rafId = null;
      }
      if (root.__statsCleanup === cleanup2) {
        root.__statsCleanup = void 0;
      }
    };
    unsubscribe2 = StatsService.subscribe(() => {
      if (!root.isConnected) {
        cleanup2();
        return;
      }
      if (rafId !== null) return;
      rafId = requestAnimationFrame(() => {
        rafId = null;
        renderStatsMenu(container);
      });
    });
    root.__statsCleanup = cleanup2;
    const ui = new Menu({ id: "stats", compact: true });
    ui.mount(container);
    const win = ui.root.closest(".qws-win");
    if (win) {
      win.style.minWidth = `${STATS_WINDOW_MIN_WIDTH}px`;
    }
    const paddingStyle = getComputedStyle(container);
    const paddingLeft = Number.parseFloat(paddingStyle.paddingLeft) || 0;
    const paddingRight = Number.parseFloat(paddingStyle.paddingRight) || 0;
    const minContentWidth = Math.max(0, STATS_WINDOW_MIN_WIDTH - paddingLeft - paddingRight);
    container.style.minWidth = `${minContentWidth}px`;
    const view = ui.root.querySelector(".qmm-views");
    if (!view) return;
    view.innerHTML = "";
    view.style.display = "grid";
    view.style.gap = "12px";
    view.style.padding = "4px 0";
    view.style.minHeight = "0";
    view.style.alignContent = "start";
    view.style.maxHeight = "54vh";
    const stats = StatsService.getSnapshot();
    initGarden(stats).catch((error) => {
      console.error("[StatsMenu] Failed to initialize garden stats", error);
    });
    initShops(stats).catch((error) => {
      console.error("[StatsMenu] Failed to initialize shop stats", error);
    });
    initPets(stats).catch((error) => {
      console.error("[StatsMenu] Failed to initialize pet stats", error);
    });
    renderMetaSection(ui, view, stats);
    renderGardenSection(ui, view, stats);
    renderShopSection(ui, view, stats);
    renderPetSection(ui, view, stats);
    renderAbilitySection(ui, view, stats);
    renderWeatherSection(ui, view, stats);
    if (previousScrollTop !== null) {
      view.scrollTop = previousScrollTop;
    }
  }

  // src/ui/menus/pets.ts
  init_atoms();
  function getAbilityChipColors2(id) {
    const key2 = String(id || "");
    const base = (PetsService.getAbilityNameWithoutLevel?.(key2) || "").replace(/[\s\-_]+/g, "").toLowerCase();
    const is = (prefix) => key2.startsWith(prefix) || base === prefix.toLowerCase();
    if (is("MoonKisser")) {
      return {
        bg: "rgba(250,166,35,0.9)",
        hover: "rgba(250,166,35,1)"
      };
    }
    if (is("DawnKisser")) {
      return {
        bg: "rgba(162,92,242,0.9)",
        hover: "rgba(162,92,242,1)"
      };
    }
    if (is("ProduceScaleBoost") || is("SnowyCropSizeBoost")) {
      return { bg: "rgba(34,139,34,0.9)", hover: "rgba(34,139,34,1)" };
    }
    if (is("PlantGrowthBoost") || is("SnowyPlantGrowthBoost") || is("DawnPlantGrowthBoost") || is("AmberPlantGrowthBoost")) {
      return { bg: "rgba(0,128,128,0.9)", hover: "rgba(0,128,128,1)" };
    }
    if (is("EggGrowthBoost") || is("SnowyEggGrowthBoost")) {
      return { bg: "rgba(180,90,240,0.9)", hover: "rgba(180,90,240,1)" };
    }
    if (is("PetAgeBoost")) {
      return { bg: "rgba(147,112,219,0.9)", hover: "rgba(147,112,219,1)" };
    }
    if (is("PetHatchSizeBoost")) {
      return { bg: "rgba(128,0,128,0.9)", hover: "rgba(128,0,128,1)" };
    }
    if (is("PetXpBoost") || is("SnowyPetXpBoost")) {
      return { bg: "rgba(30,144,255,0.9)", hover: "rgba(30,144,255,1)" };
    }
    if (is("HungerBoost") || is("SnowyHungerBoost")) {
      return { bg: "rgba(255,20,147,0.9)", hover: "rgba(255,20,147,1)" };
    }
    if (is("HungerRestore") || is("SnowyHungerRestore")) {
      return { bg: "rgba(255,105,180,0.9)", hover: "rgba(255,105,180,1)" };
    }
    if (is("SellBoost")) {
      return { bg: "rgba(220,20,60,0.9)", hover: "rgba(220,20,60,1)" };
    }
    if (is("CoinFinder") || is("SnowyCoinFinder")) {
      return { bg: "rgba(180,150,0,0.9)", hover: "rgba(180,150,0,1)" };
    }
    if (is("SeedFinder")) {
      return {
        bg: "rgba(168,102,38,0.9)",
        hover: "rgba(168,102,38,1)"
      };
    }
    if (is("ProduceMutationBoost") || is("SnowyCropMutationBoost") || is("DawnBoost") || is("AmberMoonBoost")) {
      return { bg: "rgba(140,15,70,0.9)", hover: "rgba(140,15,70,1)" };
    }
    if (is("PetMutationBoost")) {
      return { bg: "rgba(160,50,100,0.9)", hover: "rgba(160,50,100,1)" };
    }
    if (is("DoubleHarvest")) {
      return { bg: "rgba(0,120,180,0.9)", hover: "rgba(0,120,180,1)" };
    }
    if (is("DoubleHatch")) {
      return { bg: "rgba(60,90,180,0.9)", hover: "rgba(60,90,180,1)" };
    }
    if (is("ProduceEater")) {
      return { bg: "rgba(255,69,0,0.9)", hover: "rgba(255,69,0,1)" };
    }
    if (is("ProduceRefund")) {
      return { bg: "rgba(255,99,71,0.9)", hover: "rgba(255,99,71,1)" };
    }
    if (is("PetRefund")) {
      return { bg: "rgba(0,80,120,0.9)", hover: "rgba(0,80,120,1)" };
    }
    if (is("Copycat")) {
      return { bg: "rgba(255,140,0,0.9)", hover: "rgba(255,140,0,1)" };
    }
    if (is("GoldGranter")) {
      return {
        bg: "linear-gradient(135deg, rgba(225,200,55,0.9) 0%, rgba(225,180,10,0.9) 40%, rgba(215,185,45,0.9) 70%, rgba(210,185,45,0.9) 100%)",
        hover: "linear-gradient(135deg, rgba(220,200,70,1) 0%, rgba(210,175,5,1) 40%, rgba(210,185,55,1) 70%, rgba(200,175,30,1) 100%)"
      };
    }
    if (is("RainbowGranter")) {
      return {
        bg: "linear-gradient(45deg, rgba(200,0,0,0.9), rgba(200,120,0,0.9), rgba(160,170,30,0.9), rgba(60,170,60,0.9), rgba(50,170,170,0.9), rgba(40,150,180,0.9), rgba(20,90,180,0.9), rgba(70,30,150,0.9))",
        hover: "linear-gradient(45deg, rgba(200,0,0,1), rgba(200,120,0,1), rgba(160,170,30,1), rgba(60,170,60,1), rgba(50,170,170,1), rgba(40,150,180,1), rgba(20,90,180,1), rgba(70,30,150,1))"
      };
    }
    if (is("RainDance")) {
      return { bg: "rgba(76,204,204,0.9)", hover: "rgba(76,204,204,1)" };
    }
    if (is("SnowGranter")) {
      return { bg: "rgba(144,184,204,0.9)", hover: "rgba(144,184,204,1)" };
    }
    if (is("FrostGranter")) {
      return { bg: "rgba(148,160,204,0.9)", hover: "rgba(148,160,204,1)" };
    }
    if (is("DawnlitGranter")) {
      return { bg: "rgba(196,124,180,0.9)", hover: "rgba(196,124,180,1)" };
    }
    if (is("AmberlitGranter")) {
      return { bg: "rgba(204,144,96,0.9)", hover: "rgba(204,144,96,1)" };
    }
    return {
      bg: "rgba(100,100,100,0.9)",
      hover: "rgba(150,150,150,1)"
    };
  }
  function renderManagerTab(view, ui) {
    view.innerHTML = "";
    let teams = [];
    let selectedId = null;
    let activeTeamId = null;
    let activePetIdSet = /* @__PURE__ */ new Set();
    let isApplyingTeam = false;
    let draggingIdx = null;
    let overInsertIdx = null;
    let draggingHeight = 0;
    let invCacheMap = null;
    const lastRenderedSlotIds = [null, null, null];
    const miniSpriteCache = /* @__PURE__ */ new Map();
    const mkMiniIcon = (pet) => {
      const size = 18;
      const holder = document.createElement("div");
      Object.assign(holder.style, {
        width: `${size}px`,
        height: `${size}px`,
        borderRadius: "6px",
        background: "#161b22",
        border: "1px solid #ffffff10",
        display: "grid",
        placeItems: "center",
        overflow: "hidden",
        boxShadow: "0 1px 0 #000 inset",
        fontSize: "10px",
        color: "#e2e8f0"
      });
      if (!pet) {
        holder.style.opacity = "0.35";
        holder.textContent = "\xB7";
        return holder;
      }
      const species = pet.petSpecies || "";
      const mutKey = Array.isArray(pet.mutations) ? pet.mutations.join(",") : "";
      const cacheKey = `${species}|${mutKey}`;
      const applyImg = (dataUrl) => {
        const img = document.createElement("img");
        img.src = dataUrl;
        img.width = size;
        img.height = size;
        img.alt = "";
        img.draggable = false;
        img.style.width = `${size}px`;
        img.style.height = `${size}px`;
        img.style.objectFit = "contain";
        img.style.imageRendering = "auto";
        holder.replaceChildren(img);
      };
      const cached = miniSpriteCache.get(cacheKey);
      if (cached) {
        applyImg(cached);
        return holder;
      }
      attachSpriteIcon(holder, ["pet"], species, size, "pet-team-mini", {
        mutations: pet.mutations,
        onSpriteApplied: (img) => {
          miniSpriteCache.set(cacheKey, img.src);
        },
        onNoSpriteFound: () => {
          holder.textContent = (species || pet.name || "pet").charAt(0).toUpperCase();
        }
      });
      return holder;
    };
    function applySubtleBorder(btn, hex, alpha = 0.22) {
      const toRgba = (h, a) => {
        const m = h.replace("#", "");
        const r = parseInt(m.length === 3 ? m[0] + m[0] : m.slice(0, 2), 16);
        const g = parseInt(m.length === 3 ? m[1] + m[1] : m.slice(2, 4), 16);
        const b = parseInt(m.length === 3 ? m[2] + m[2] : m.slice(4, 6), 16);
        return `rgba(${r},${g},${b},${a})`;
      };
      const border = toRgba(hex, alpha);
      btn.style.border = `1px solid ${border}`;
      btn.style.background = "#1f2328";
      btn.style.boxShadow = "none";
      btn.style.transition = "none";
    }
    const framed = (title, content) => {
      const cardSection = ui.card(title, { tone: "muted", align: "center" });
      cardSection.body.append(content);
      cardSection.root.style.maxWidth = "720px";
      return cardSection.root;
    };
    const row = (opts) => ui.flexRow({ justify: opts?.justify ?? "center" });
    const wrap = document.createElement("div");
    wrap.style.display = "grid";
    wrap.style.gridTemplateColumns = "minmax(220px, 280px) minmax(0, 1fr)";
    wrap.style.gap = "10px";
    wrap.style.alignItems = "stretch";
    wrap.style.height = "54vh";
    wrap.style.overflow = "hidden";
    view.appendChild(wrap);
    const left = document.createElement("div");
    left.style.display = "grid";
    left.style.gridTemplateRows = "1fr auto";
    left.style.gap = "8px";
    left.style.minHeight = "0";
    wrap.appendChild(left);
    const teamList = document.createElement("div");
    teamList.style.display = "flex";
    teamList.style.flexDirection = "column";
    teamList.style.gap = "6px";
    teamList.style.overflow = "auto";
    teamList.style.padding = "6px";
    teamList.style.border = "1px solid #4445";
    teamList.style.borderRadius = "10px";
    teamList.style.scrollBehavior = "smooth";
    teamList.style.minHeight = "0";
    left.appendChild(teamList);
    const footer = document.createElement("div");
    footer.style.display = "flex";
    footer.style.gap = "6px";
    left.appendChild(footer);
    const btnNew = ui.btn("\u2795 New", { variant: "primary", size: "sm" });
    btnNew.id = "pets.teams.new";
    btnNew.style.flex = "1 1 0";
    const btnDel = ui.btn("\u{1F5D1}\uFE0F Delete", { variant: "danger", size: "sm" });
    btnDel.id = "pets.teams.delete";
    btnDel.style.flex = "1 1 0";
    applySubtleBorder(btnNew, "#22c55e", 0.22);
    applySubtleBorder(btnDel, "#ef4444", 0.22);
    footer.append(btnNew, btnDel);
    function getSelectedTeam() {
      return teams.find((t) => t.id === selectedId) || null;
    }
    function computeInsertIndex(clientY) {
      const children = Array.from(teamList.children);
      if (!children.length) return 0;
      const first = children[0].getBoundingClientRect();
      if (clientY < first.top + first.height / 2) return 0;
      for (let i = 0; i < children.length; i++) {
        const rect = children[i].getBoundingClientRect();
        const mid = rect.top + rect.height / 2;
        if (clientY < mid) return i;
      }
      return children.length;
    }
    function abilitiesBadge(abilities) {
      const wrap2 = document.createElement("span");
      wrap2.style.display = "inline-flex";
      wrap2.style.alignItems = "center";
      wrap2.style.lineHeight = "1";
      const SPACING_PX = 8;
      const SIZE_PX = 12;
      const RADIUS_PX = 3;
      const ids = Array.isArray(abilities) ? abilities.filter(Boolean) : [];
      if (!ids.length) {
        const empty = document.createElement("span");
        empty.textContent = "No ability";
        empty.style.opacity = "0.75";
        empty.style.fontSize = "12px";
        wrap2.appendChild(empty);
        return wrap2;
      }
      ids.forEach((id, i) => {
        const chip = document.createElement("span");
        const { bg, hover } = getAbilityChipColors2(id);
        chip.title = PetsService.getAbilityName(id) || id;
        chip.setAttribute("aria-label", chip.title);
        Object.assign(chip.style, {
          display: "inline-block",
          width: `${SIZE_PX}px`,
          height: `${SIZE_PX}px`,
          borderRadius: `${RADIUS_PX}px`,
          marginRight: i === ids.length - 1 ? "0" : `${SPACING_PX}px`,
          background: bg,
          transition: "transform 80ms ease, box-shadow 120ms ease, background 120ms ease",
          cursor: "default",
          boxShadow: "0 0 0 1px #0006 inset, 0 0 0 1px #ffffff1a"
        });
        chip.onmouseenter = () => {
          chip.style.background = hover;
          chip.style.transform = "scale(1.08)";
          chip.style.boxShadow = "0 0 0 1px #0006 inset, 0 0 0 1px #ffffff33";
        };
        chip.onmouseleave = () => {
          chip.style.background = bg;
          chip.style.transform = "none";
          chip.style.boxShadow = "0 0 0 1px #0006 inset, 0 0 0 1px #ffffff1a";
        };
        wrap2.appendChild(chip);
      });
      return wrap2;
    }
    function applyLiveTransforms() {
      const children = Array.from(teamList.children);
      children.forEach((el2) => el2.style.transform = "");
      if (draggingIdx === null || overInsertIdx === null) return;
      const from = draggingIdx;
      const to = overInsertIdx;
      children.forEach((el2, idx) => {
        el2.style.transition = "transform 120ms ease";
        if (idx === from) return;
        if (to > from && idx > from && idx < to) {
          el2.style.transform = `translateY(${-draggingHeight}px)`;
        }
        if (to < from && idx >= to && idx < from) {
          el2.style.transform = `translateY(${draggingHeight}px)`;
        }
      });
    }
    function clearLiveTransforms() {
      Array.from(teamList.children).forEach((el2) => {
        el2.style.transform = "";
        el2.style.transition = "";
      });
    }
    async function refreshActiveIds() {
      activeTeamId = null;
      activePetIdSet = /* @__PURE__ */ new Set();
      try {
        const pets = await PetsService.getPets();
        const equipIds = Array.isArray(pets) ? pets.map((p) => String(p?.slot?.id || "")).filter(Boolean) : [];
        activePetIdSet = new Set(equipIds);
        for (const t of teams) {
          const tIds = (t.slots || []).filter(Boolean);
          if (tIds.length !== equipIds.length) continue;
          let same = true;
          for (const id of tIds) {
            if (!activePetIdSet.has(id)) {
              same = false;
              break;
            }
          }
          if (same) {
            activeTeamId = t.id;
            break;
          }
        }
      } catch {
      }
    }
    function updateSelectedVisuals() {
      const children = Array.from(teamList.children);
      children.forEach((el2) => {
        const id = el2.dataset.teamId || "";
        el2.style.background = id === selectedId ? "#2a313a" : "#1f2328";
      });
      updateSelectedVisuals();
    }
    async function refreshTeamList(skipDetectActive = false) {
      if (!skipDetectActive) {
        await refreshActiveIds();
      }
      clearLiveTransforms();
      draggingIdx = null;
      overInsertIdx = null;
      draggingHeight = 0;
      teamList.innerHTML = "";
      if (!teams.length) {
        const empty = document.createElement("div");
        empty.textContent = "No teams yet. Create one!";
        empty.style.opacity = "0.75";
        empty.style.textAlign = "center";
        empty.style.padding = "8px";
        teamList.appendChild(empty);
        hydrateEditor(null);
        return;
      }
      teams.forEach((t, idx) => {
        const item = document.createElement("div");
        const isActive = t.id === activeTeamId;
        item.dataset.index = String(idx);
        item.dataset.teamId = t.id;
        item.textContent = "";
        item.style.height = "36px";
        item.style.lineHeight = "36px";
        item.style.padding = "0 10px";
        item.style.border = "1px solid #ffffff15";
        item.style.borderRadius = "6px";
        item.style.cursor = "pointer";
        item.style.fontSize = "13px";
        item.style.overflow = "hidden";
        item.style.whiteSpace = "nowrap";
        item.style.textOverflow = "ellipsis";
        item.style.display = "flex";
        item.style.flex = "0 0 auto";
        item.style.gap = "8px";
        item.style.alignItems = "center";
        item.style.background = t.id === selectedId ? "#2a313a" : "#1f2328";
        const dot = document.createElement("span");
        dot.style.width = "10px";
        dot.style.height = "10px";
        dot.style.borderRadius = "50%";
        dot.style.boxShadow = "0 0 0 1px #0006 inset";
        dot.style.background = isActive ? "#48d170" : "#64748b";
        dot.title = isActive ? "This team is currently active" : "Inactive team";
        const label2 = document.createElement("span");
        label2.textContent = t.name || "(unnamed)";
        label2.style.overflow = "hidden";
        label2.style.textOverflow = "ellipsis";
        label2.style.whiteSpace = "nowrap";
        label2.style.flex = "1 1 0";
        const minis = document.createElement("div");
        minis.style.display = "flex";
        minis.style.gap = "4px";
        minis.style.alignItems = "center";
        minis.style.marginLeft = "auto";
        const map2 = invCacheMap ?? /* @__PURE__ */ new Map();
        const slots = Array.isArray(t.slots) ? t.slots.slice(0, 3) : [];
        slots.forEach((id) => {
          const pet = id != null ? map2.get(String(id)) ?? null : null;
          minis.appendChild(mkMiniIcon(pet));
        });
        if (slots.length < 3) {
          for (let i = slots.length; i < 3; i += 1) minis.appendChild(mkMiniIcon(null));
        }
        item.append(dot, label2, minis);
        const grab = document.createElement("span");
        grab.className = "qmm-grab";
        grab.title = "Drag to reorder";
        grab.setAttribute("aria-label", "Drag to reorder");
        grab.innerHTML = "";
        for (let i = 0; i < 6; i += 1) {
          const dot2 = document.createElement("span");
          dot2.className = "qmm-grab-dot";
          grab.appendChild(dot2);
        }
        grab.draggable = true;
        item.onmouseenter = () => item.style.borderColor = "#6aa1";
        item.onmouseleave = () => item.style.borderColor = "#ffffff15";
        item.onclick = (ev) => {
          if (ev.__byDrag) return;
          const changed = selectedId !== t.id;
          if (changed) {
            selectedId = t.id;
            refreshTeamList(true);
          }
          void hydrateEditor(getSelectedTeam());
        };
        grab.addEventListener("dragstart", (ev) => {
          draggingIdx = idx;
          draggingHeight = item.getBoundingClientRect().height;
          item.classList.add("qmm-dragging");
          ev.dataTransfer?.setData("text/plain", String(idx));
          if (ev.dataTransfer) ev.dataTransfer.effectAllowed = "move";
          try {
            const ghost = item.cloneNode(true);
            ghost.style.width = `${item.getBoundingClientRect().width}px`;
            ghost.style.position = "absolute";
            ghost.style.top = "-9999px";
            document.body.appendChild(ghost);
            ev.dataTransfer.setDragImage(ghost, ghost.offsetWidth / 2, ghost.offsetHeight / 2);
            setTimeout(() => document.body.removeChild(ghost), 0);
          } catch {
          }
        });
        grab.addEventListener("dragend", () => {
          item.classList.remove("qmm-dragging");
          clearLiveTransforms();
          draggingIdx = null;
          overInsertIdx = null;
        });
        item.addEventListener("dragover", (ev) => {
          ev.preventDefault();
          if (ev.dataTransfer) ev.dataTransfer.dropEffect = "move";
          if (draggingIdx === null) return;
          const idxOver = Number(ev.currentTarget.dataset.index || -1);
          if (idxOver < 0) return;
          const rect = item.getBoundingClientRect();
          const mid = rect.top + rect.height / 2;
          const insertIdx = ev.clientY < mid ? idxOver : idxOver + 1;
          const clamped = Math.max(0, Math.min(teams.length, insertIdx));
          if (overInsertIdx !== clamped) {
            overInsertIdx = clamped;
            applyLiveTransforms();
          }
          const edge = 28;
          const listRect = teamList.getBoundingClientRect();
          if (ev.clientY < listRect.top + edge) teamList.scrollTop -= 18;
          else if (ev.clientY > listRect.bottom - edge) teamList.scrollTop += 18;
        });
        item.addEventListener("drop", (ev) => {
          ev.preventDefault();
          ev.__byDrag = true;
          if (draggingIdx === null) return;
          let target = overInsertIdx ?? computeInsertIndex(ev.clientY);
          if (target > draggingIdx) target -= 1;
          target = Math.max(0, Math.min(teams.length - 1, target));
          if (target !== draggingIdx) {
            const a = teams.slice();
            const [it] = a.splice(draggingIdx, 1);
            a.splice(target, 0, it);
            teams = a;
            try {
              PetsService.setTeamsOrder(teams.map((x) => x.id));
            } catch {
            }
          }
          clearLiveTransforms();
          draggingIdx = null;
          overInsertIdx = null;
          draggingHeight = 0;
          refreshTeamList();
        });
        item.appendChild(grab);
        teamList.appendChild(item);
      });
    }
    teamList.addEventListener("dragover", (e) => {
      e.preventDefault();
      if (e.dataTransfer) e.dataTransfer.dropEffect = "move";
      if (draggingIdx === null) return;
      const idx = computeInsertIndex(e.clientY);
      if (overInsertIdx !== idx) {
        overInsertIdx = idx;
        applyLiveTransforms();
      }
      const edge = 28;
      const listRect = teamList.getBoundingClientRect();
      if (e.clientY < listRect.top + edge) teamList.scrollTop -= 18;
      else if (e.clientY > listRect.bottom - edge) teamList.scrollTop += 18;
    });
    teamList.addEventListener("drop", (e) => {
      e.preventDefault();
      if (draggingIdx === null) return;
      let target = overInsertIdx ?? computeInsertIndex(e.clientY);
      if (target > draggingIdx) target -= 1;
      target = Math.max(0, Math.min(teams.length - 1, target));
      if (target !== draggingIdx) {
        const a = teams.slice();
        const [it] = a.splice(draggingIdx, 1);
        a.splice(target, 0, it);
        teams = a;
        try {
          PetsService.setTeamsOrder(teams.map((x) => x.id));
        } catch {
        }
      }
      clearLiveTransforms();
      draggingIdx = null;
      overInsertIdx = null;
      draggingHeight = 0;
      refreshTeamList();
    });
    btnNew.onclick = () => {
      const created = PetsService.createTeam("New Team");
      selectedId = created.id;
      refreshTeamList();
      hydrateEditor(getSelectedTeam());
    };
    btnDel.onclick = () => {
      if (!selectedId) return;
      const ok = PetsService.deleteTeam(selectedId);
      if (!ok) return;
    };
    let unsubTeams = null;
    (async () => {
      try {
        unsubTeams = await PetsService.onTeamsChangeNow(async (all) => {
          teams = Array.isArray(all) ? all.slice() : [];
          if (selectedId && !teams.some((t) => t.id === selectedId)) {
            selectedId = teams[0]?.id ?? null;
          }
          if (!selectedId && teams.length) selectedId = teams[0].id;
          refreshTeamList();
          setTeamsForHotkeys(teams);
          await PetsService.getInventoryPets().catch(() => []);
          await hydrateEditor(getSelectedTeam());
        });
      } catch {
      }
    })();
    const right = document.createElement("div");
    right.style.display = "grid";
    right.style.gridTemplateRows = "auto 1fr";
    right.style.gap = "10px";
    right.style.minHeight = "0";
    wrap.appendChild(right);
    const header = document.createElement("div");
    header.style.display = "flex";
    header.style.alignItems = "center";
    header.style.gap = "8px";
    const headerTitle = document.createElement("div");
    headerTitle.textContent = "Team editor \u2014 ";
    headerTitle.style.fontWeight = "700";
    headerTitle.style.fontSize = "14px";
    const btnUseTeam = document.createElement("button");
    btnUseTeam.id = "pets.teams.useThisTeam";
    btnUseTeam.textContent = "Use this team";
    btnUseTeam.style.padding = "6px 10px";
    btnUseTeam.style.borderRadius = "8px";
    btnUseTeam.style.border = "1px solid #4445";
    btnUseTeam.style.background = "#1f2328";
    btnUseTeam.style.color = "#e7eef7";
    btnUseTeam.style.cursor = "pointer";
    btnUseTeam.onmouseenter = () => btnUseTeam.style.borderColor = "#6aa1";
    btnUseTeam.onmouseleave = () => btnUseTeam.style.borderColor = "#4445";
    btnUseTeam.disabled = true;
    header.append(headerTitle, btnUseTeam);
    right.appendChild(header);
    const card2 = document.createElement("div");
    card2.style.border = "1px solid #4445";
    card2.style.borderRadius = "10px";
    card2.style.padding = "10px";
    card2.style.display = "flex";
    card2.style.flexDirection = "column";
    card2.style.gap = "12px";
    card2.style.overflow = "auto";
    card2.style.minHeight = "0";
    card2.style.background = "#0f1318";
    right.appendChild(card2);
    const secName = (() => {
      const r = row();
      r.style.width = "100%";
      const nameInput = ui.inputText("Team name", "");
      nameInput.id = "pets.teams.editor.name";
      nameInput.style.flex = "1";
      nameInput.style.minWidth = "0";
      r.append(nameInput);
      card2.appendChild(framed("\u{1F3F7}\uFE0F Team name", r));
      return { nameInput };
    })();
    const secSearch = (() => {
      const wrapOuter = document.createElement("div");
      wrapOuter.style.display = "flex";
      wrapOuter.style.flexDirection = "column";
      wrapOuter.style.gap = "10px";
      wrapOuter.style.alignItems = "center";
      let isProgrammaticModeSet = false;
      let currentMode = "ability";
      const seg = ui.segmented(
        [
          { value: "ability", label: "\u2728 Ability" },
          { value: "species", label: "\u{1F9EC} Species" }
        ],
        "ability",
        async (val) => {
          if (isProgrammaticModeSet) return;
          currentMode = val;
          await rebuildOptionsFromInventory();
          select2.value = "";
          applyFilterToTeam();
        },
        { ariaLabel: "Search mode" }
      );
      const select2 = document.createElement("select");
      select2.className = "qmm-input";
      select2.id = "pets.teams.filter.select";
      select2.style.minWidth = "260px";
      const getMode = () => currentMode;
      const setMode = (m) => {
        currentMode = m;
        isProgrammaticModeSet = true;
        seg.set(m);
        isProgrammaticModeSet = false;
      };
      const rebuildOptionsFromInventory = async () => {
        const prev = select2.value;
        const inv = await PetsService.getInventoryPets().catch(() => []);
        select2.innerHTML = "";
        const opt0 = document.createElement("option");
        opt0.value = "";
        opt0.textContent = "\u2014 No filter \u2014";
        select2.appendChild(opt0);
        if (getMode() === "ability") {
          const nameSet = /* @__PURE__ */ new Set();
          for (const p of inv) {
            const abs = Array.isArray(p?.abilities) ? p.abilities.filter(Boolean) : [];
            for (const id of abs) {
              const base = PetsService.getAbilityNameWithoutLevel?.(id) || "";
              if (base) nameSet.add(base);
            }
          }
          for (const name of Array.from(nameSet).sort((a, b) => a.localeCompare(b))) {
            const o = document.createElement("option");
            o.value = name;
            o.textContent = name;
            select2.appendChild(o);
          }
        } else {
          const set3 = /* @__PURE__ */ new Set();
          for (const p of inv) {
            const sp = String(p?.petSpecies || "").trim();
            if (sp) set3.add(sp);
          }
          for (const v of Array.from(set3).sort((a, b) => a.localeCompare(b))) {
            const o = document.createElement("option");
            o.value = v;
            o.textContent = v.charAt(0).toUpperCase() + v.slice(1);
            select2.appendChild(o);
          }
        }
        if (Array.from(select2.options).some((o) => o.value === prev)) select2.value = prev;
      };
      const applyFilterToTeam = () => {
        const t = getSelectedTeam();
        if (!t) return;
        const val = (select2.value || "").trim();
        const raw = getMode() === "ability" ? val ? `ab:${val}` : "" : val ? `sp:${val}` : "";
        PetsService.setTeamSearch(t.id, raw);
      };
      select2.addEventListener("change", applyFilterToTeam);
      wrapOuter.append(seg, select2);
      card2.appendChild(framed("\u{1F50D} Search", wrapOuter));
      const ensureOptionExists = (val, pretty) => {
        const v = (val || "").trim();
        if (!v) return;
        const has = Array.from(select2.options).some((o) => o.value === v);
        if (!has) {
          const o = document.createElement("option");
          o.value = v;
          o.textContent = pretty ?? v;
          select2.appendChild(o);
        }
      };
      return {
        getMode,
        setMode,
        select: select2,
        rebuild: rebuildOptionsFromInventory,
        apply: applyFilterToTeam,
        setFromSearchString(s) {
          const m = (s || "").match(/^(ab|sp):\s*(.*)$/i);
          if (!m) {
            setMode("ability");
            select2.value = "";
            return;
          }
          const mode = m[1].toLowerCase() === "ab" ? "ability" : "species";
          const val = (m[2] || "").trim();
          setMode(mode);
          ensureOptionExists(val, mode === "species" ? val.charAt(0).toUpperCase() + val.slice(1) : val);
          select2.value = val;
        }
      };
    })();
    const secSlots = (() => {
      const grid = document.createElement("div");
      grid.style.display = "grid";
      grid.style.gridTemplateColumns = "1fr";
      grid.style.rowGap = "10px";
      grid.style.justifyItems = "center";
      const mkRow = (idx) => {
        const root = document.createElement("div");
        const BTN = 28;
        const ICON = 40;
        root.style.display = "grid";
        root.style.gridTemplateColumns = `${ICON}px minmax(0,1fr) ${BTN}px ${BTN}px`;
        root.style.alignItems = "center";
        root.style.gap = "8px";
        root.style.width = "min(560px, 100%)";
        root.style.border = "1px solid #4445";
        root.style.borderRadius = "10px";
        root.style.padding = "8px 10px";
        root.style.background = "#0f1318";
        const iconWrap = document.createElement("div");
        Object.assign(iconWrap.style, {
          width: `${ICON}px`,
          height: `${ICON}px`,
          display: "inline-flex",
          alignItems: "center",
          justifyContent: "center"
        });
        const useEmojiFallback = () => {
          iconWrap.replaceChildren();
          const span = document.createElement("span");
          span.textContent = "\u{1F43E}";
          span.style.fontSize = `${Math.max(ICON - 6, 12)}px`;
          span.setAttribute("aria-hidden", "true");
          iconWrap.appendChild(span);
        };
        const setIcon = (species, mutations) => {
          const speciesLabel = String(species ?? "").trim();
          if (!speciesLabel) {
            iconWrap.replaceChildren();
            iconWrap.dataset.iconKey = "";
            useEmojiFallback();
            return;
          }
          const mutKey = Array.isArray(mutations) ? mutations.join(",") : "";
          const key2 = `${speciesLabel}|${mutKey}`;
          if (iconWrap.dataset.iconKey === key2 && iconWrap.querySelector("img")) {
            return;
          }
          iconWrap.dataset.iconKey = key2;
          attachSpriteIcon(iconWrap, ["pet"], speciesLabel, ICON, "pet-slot", {
            mutations,
            onNoSpriteFound: () => {
              iconWrap.replaceChildren();
              useEmojiFallback();
            }
          });
        };
        const left2 = document.createElement("div");
        left2.style.display = "flex";
        left2.style.flexDirection = "column";
        left2.style.gap = "6px";
        left2.style.minWidth = "0";
        const nameEl = document.createElement("div");
        nameEl.style.fontWeight = "700";
        nameEl.textContent = "None";
        nameEl.style.overflow = "hidden";
        nameEl.style.textOverflow = "ellipsis";
        nameEl.style.whiteSpace = "nowrap";
        let abilitiesEl = abilitiesBadge([]);
        abilitiesEl.style.display = "inline-block";
        left2.append(nameEl, abilitiesEl);
        const btnChoose = document.createElement("button");
        btnChoose.textContent = "+";
        Object.assign(btnChoose.style, {
          width: `${BTN}px`,
          minWidth: `${BTN}px`,
          height: `${BTN}px`,
          padding: "0",
          fontSize: "16px",
          lineHeight: "1",
          borderRadius: "10px",
          boxShadow: "none",
          display: "grid",
          placeItems: "center"
        });
        btnChoose.title = "Choose a pet";
        btnChoose.setAttribute("aria-label", "Choose a pet");
        const btnClear2 = document.createElement("button");
        btnClear2.textContent = "\u2212";
        Object.assign(btnClear2.style, {
          width: `${BTN}px`,
          minWidth: `${BTN}px`,
          height: `${BTN}px`,
          padding: "0",
          fontSize: "16px",
          lineHeight: "1",
          borderRadius: "10px",
          boxShadow: "none",
          display: "grid",
          placeItems: "center"
        });
        btnClear2.title = "Remove this pet";
        btnClear2.setAttribute("aria-label", "Remove this pet");
        root.append(iconWrap, left2, btnChoose, btnClear2);
        function update(p) {
          if (!p) {
            nameEl.textContent = "None";
            setIcon(void 0);
            const fresh2 = abilitiesBadge([]);
            fresh2.style.display = "inline-block";
            left2.replaceChild(fresh2, left2.children[1]);
            abilitiesEl = fresh2;
            return;
          }
          const species = String(p.petSpecies || "").trim();
          const muts = Array.isArray(p.mutations) ? p.mutations : [];
          setIcon(species, muts);
          const speciesLabel = species ? species.charAt(0).toUpperCase() + species.slice(1) : "";
          nameEl.textContent = p.name?.trim() || speciesLabel || "Pet";
          const abs = Array.isArray(p.abilities) ? p.abilities.filter(Boolean) : [];
          const fresh = abilitiesBadge(abs);
          fresh.style.display = "inline-block";
          left2.replaceChild(fresh, left2.children[1]);
          abilitiesEl = fresh;
        }
        btnChoose.onclick = async () => {
          const t = getSelectedTeam();
          if (!t) return;
          btnChoose.disabled = true;
          btnClear2.disabled = true;
          ui.setWindowVisible(false);
          try {
            await PetsService.chooseSlotPet(t.id, idx);
            await repaintSlots(getSelectedTeam());
          } finally {
            ui.setWindowVisible(true);
            btnChoose.disabled = false;
            btnClear2.disabled = false;
          }
        };
        btnClear2.onclick = async () => {
          const t = getSelectedTeam();
          if (!t) return;
          const next = t.slots.slice(0, 3);
          next[idx] = null;
          PetsService.saveTeam({ id: t.id, slots: next });
          await repaintSlots(t);
        };
        return { root, nameEl, abilitiesEl, btnChoose, btnClear: btnClear2, update };
      };
      const r0 = mkRow(0);
      const r1 = mkRow(1);
      const r2 = mkRow(2);
      grid.append(r0.root, r1.root, r2.root);
      const extra = document.createElement("div");
      extra.style.display = "flex";
      extra.style.gap = "6px";
      extra.style.justifyContent = "center";
      const btnUseCurrent = ui.btn("Current active", { variant: "primary" });
      btnUseCurrent.id = "pets.teams.useCurrent";
      btnUseCurrent.style.minWidth = "140px";
      const btnClear = ui.btn("Clear slots", { variant: "secondary" });
      btnClear.id = "pets.teams.clearSlots";
      btnClear.style.minWidth = "140px";
      const DARK_BG = "#0f1318";
      extra.append(btnUseCurrent, btnClear);
      Object.assign(btnUseCurrent.style, {
        width: "auto",
        fontSize: "16px",
        borderRadius: "10px",
        background: DARK_BG,
        boxShadow: "none"
      });
      Object.assign(btnClear.style, {
        width: "auto",
        fontSize: "16px",
        borderRadius: "10px",
        background: DARK_BG,
        boxShadow: "none"
      });
      const wrapSlots = document.createElement("div");
      wrapSlots.style.display = "flex";
      wrapSlots.style.flexDirection = "column";
      wrapSlots.style.gap = "8px";
      wrapSlots.append(grid, extra);
      card2.appendChild(framed("\u26A1 Active pets (3 slots)", wrapSlots));
      return {
        rows: [r0, r1, r2],
        btnUseCurrent,
        btnClear
      };
    })();
    async function repaintSlots(sourceTeam) {
      const t = sourceTeam ?? getSelectedTeam();
      if (!t) return;
      let inv = await PetsService.getInventoryPets().catch(() => null);
      if (!inv || inv.length === 0) {
      } else {
        invCacheMap = /* @__PURE__ */ new Map();
        for (const p of inv) {
          const id = p?.id != null ? String(p.id) : "";
          if (id) invCacheMap.set(id, p);
        }
      }
      const map2 = invCacheMap ?? /* @__PURE__ */ new Map();
      [0, 1, 2].forEach((i) => {
        const id = t.slots[i] || null;
        if (!id) {
          if (lastRenderedSlotIds[i] !== null) {
            secSlots.rows[i].update(null);
            lastRenderedSlotIds[i] = null;
          }
          return;
        }
        const pet = map2.get(id);
        if (!pet) return;
        if (lastRenderedSlotIds[i] === id) return;
        secSlots.rows[i].update(pet);
        lastRenderedSlotIds[i] = id;
      });
    }
    async function hydrateEditor(team) {
      const has = !!team;
      secName.nameInput.disabled = !has;
      secSlots.btnClear.disabled = !has;
      secSlots.btnUseCurrent.disabled = !has;
      btnUseTeam.disabled = !has;
      if (has) {
        const saved = PetsService.getTeamSearch(team.id) || "";
        const m = saved.match(/^(ab|sp):\s*(.*)$/i);
        const mode = m ? m[1].toLowerCase() === "ab" ? "ability" : "species" : "ability";
        secSearch.setMode(mode);
        await secSearch.rebuild();
        if (m) secSearch.setFromSearchString(saved);
      } else {
        await secSearch.rebuild();
      }
      if (!has) {
        secSlots.rows.forEach((r) => r.update(null));
        secName.nameInput.value = "";
        return;
      }
      secName.nameInput.value = String(team.name || "");
      await repaintSlots(team);
    }
    const saveNameNow = () => {
      const t = getSelectedTeam();
      if (!t) return;
      const nextName = secName.nameInput.value.trim();
      if (nextName === t.name) return;
      t.name = nextName;
      PetsService.saveTeam({ id: t.id, name: nextName });
      refreshTeamList(true);
    };
    secName.nameInput.addEventListener("input", () => saveNameNow());
    secName.nameInput.addEventListener("keydown", (ev) => {
      if (ev.key === "Enter") {
        ev.currentTarget.blur();
        saveNameNow();
      }
    });
    secName.nameInput.addEventListener("blur", () => saveNameNow());
    secSlots.btnUseCurrent.onclick = async () => {
      const t = getSelectedTeam();
      if (!t) return;
      try {
        const arr = await PetsService.getPets();
        const list = Array.isArray(arr) ? arr : [];
        const ids = list.map((p) => String(p?.slot?.id || "")).filter((x) => !!x).slice(0, 3);
        const nextSlots = [ids[0] || null, ids[1] || null, ids[2] || null];
        PetsService.saveTeam({ id: t.id, slots: nextSlots });
        await repaintSlots(t);
      } catch {
      }
    };
    secSlots.btnClear.onclick = async () => {
      const t = getSelectedTeam();
      if (!t) return;
      PetsService.saveTeam({ id: t.id, slots: [null, null, null] });
      await repaintSlots(t);
    };
    function sameSet(a, b) {
      if (a.length !== b.length) return false;
      const s = new Set(a);
      for (const x of b) if (!s.has(x)) return false;
      return true;
    }
    async function waitForActiveTeam(team, timeoutMs = 2e3) {
      const target = (team.slots || []).filter(Boolean);
      const t0 = performance.now();
      while (performance.now() - t0 < timeoutMs) {
        const pets = await PetsService.getPets().catch(() => null);
        const equip = Array.isArray(pets) ? pets.map((p) => String(p?.slot?.id || "")).filter(Boolean) : [];
        if (sameSet(equip, target)) return true;
        await new Promise((r) => setTimeout(r, 80));
      }
      return false;
    }
    btnUseTeam.onclick = async () => {
      const t = getSelectedTeam();
      if (!t) return;
      try {
        isApplyingTeam = true;
        activeTeamId = t.id;
        await refreshTeamList(true);
        await PetsService.useTeam(t.id);
        await waitForActiveTeam(t);
        await hydrateEditor(getSelectedTeam());
        await refreshTeamList();
      } catch (e) {
        console.warn("[Pets] Use this team failed:", e);
        await refreshTeamList();
      } finally {
        isApplyingTeam = false;
      }
    };
    let unsubPets2 = null;
    (async () => {
      try {
        unsubPets2 = await onActivePetsStructuralChangeNow(async () => {
          if (isApplyingTeam) return;
          await repaintSlots(getSelectedTeam());
          await refreshTeamList();
        });
      } catch {
      }
    })();
    installPetTeamHotkeysOnce(async (teamId) => {
      const t = teams.find((tt) => tt.id === teamId) || null;
      try {
        isApplyingTeam = true;
        if (t) {
          activeTeamId = t.id;
          await refreshTeamList(true);
        }
        await PetsService.useTeam(teamId);
        if (t) await waitForActiveTeam(t);
        await hydrateEditor(getSelectedTeam());
        await refreshTeamList();
      } catch (e) {
        console.warn("[Pets] hotkey useTeam failed:", e);
        await refreshTeamList();
      } finally {
        isApplyingTeam = false;
      }
    });
    view.__cleanup__ = (() => {
      const prev = view.__cleanup__;
      return () => {
        try {
          unsubTeams?.();
        } catch {
        }
        try {
          unsubPets2?.();
        } catch {
        }
        try {
          prev?.();
        } catch {
        }
      };
    })();
  }
  function renderFeedingTab(view, ui) {
    view.innerHTML = "";
    const wrap = document.createElement("div");
    wrap.style.display = "grid";
    wrap.style.gridTemplateColumns = "minmax(220px, 280px) minmax(0, 1fr)";
    wrap.style.gap = "10px";
    wrap.style.alignItems = "stretch";
    wrap.style.height = "54vh";
    wrap.style.minHeight = "0";
    view.appendChild(wrap);
    const left = document.createElement("div");
    left.style.display = "flex";
    left.style.flexDirection = "column";
    left.style.height = "100%";
    left.style.minHeight = "0";
    wrap.appendChild(left);
    const vtabs = ui.vtabs({
      emptyText: "No pets found.",
      fillAvailableHeight: true,
      renderItem: (item, btn) => {
        btn.innerHTML = "";
        btn.style.gridTemplateColumns = "24px 1fr auto";
        btn.style.gap = "10px";
        const size = 22;
        const iconWrap = document.createElement("div");
        Object.assign(iconWrap.style, {
          width: `${size}px`,
          height: `${size}px`,
          borderRadius: "6px",
          background: "#161b22",
          border: "1px solid #ffffff10",
          display: "grid",
          placeItems: "center",
          overflow: "hidden",
          boxShadow: "0 1px 0 #000 inset",
          fontSize: "11px",
          color: "#e2e8f0"
        });
        const label2 = String(item.title || "Pet");
        iconWrap.textContent = label2.charAt(0).toUpperCase();
        attachSpriteIcon(iconWrap, ["pet"], item.id, size, "pet-feeding-list", {
          onNoSpriteFound: () => {
            iconWrap.textContent = label2.charAt(0).toUpperCase();
          }
        });
        const textWrap = document.createElement("div");
        textWrap.style.display = "flex";
        textWrap.style.flexDirection = "column";
        textWrap.style.gap = "2px";
        textWrap.style.minWidth = "0";
        const titleEl = document.createElement("div");
        titleEl.textContent = label2;
        titleEl.style.whiteSpace = "nowrap";
        titleEl.style.overflow = "hidden";
        titleEl.style.textOverflow = "ellipsis";
        textWrap.appendChild(titleEl);
        const rarity2 = String(item.rarity || "").trim();
        const badge = rarity2 ? rarityBadge(rarity2) : null;
        if (badge) {
          badge.style.margin = "0";
          badge.style.alignSelf = "center";
        }
        btn.append(iconWrap, textWrap);
        if (badge) btn.appendChild(badge);
      }
    });
    vtabs.root.style.flex = "1 1 auto";
    vtabs.root.style.minHeight = "0";
    left.appendChild(vtabs.root);
    const right = document.createElement("div");
    right.style.display = "flex";
    right.style.flexDirection = "column";
    right.style.gap = "10px";
    right.style.minHeight = "0";
    wrap.appendChild(right);
    const panelCard = document.createElement("div");
    panelCard.style.border = "1px solid #4445";
    panelCard.style.borderRadius = "10px";
    panelCard.style.padding = "10px";
    panelCard.style.background = "#0f1318";
    panelCard.style.display = "flex";
    panelCard.style.flexDirection = "column";
    panelCard.style.gap = "8px";
    right.appendChild(panelCard);
    const panelTitle = document.createElement("div");
    panelTitle.textContent = "Pet panel buttons";
    panelTitle.style.fontWeight = "600";
    panelCard.appendChild(panelTitle);
    const panelBody = document.createElement("div");
    panelBody.style.display = "flex";
    panelBody.style.flexDirection = "column";
    panelBody.style.gap = "6px";
    panelCard.appendChild(panelBody);
    const settings = getPetPanelButtonSettings();
    const addToggle = (label2, key2, checked) => {
      const row = document.createElement("div");
      row.style.display = "flex";
      row.style.alignItems = "center";
      row.style.justifyContent = "space-between";
      row.style.gap = "10px";
      row.style.padding = "4px 0";
      const text = document.createElement("div");
      text.textContent = label2;
      text.style.fontSize = "13px";
      const sw = ui.switch(checked);
      sw.addEventListener("change", () => {
        const next = setPetPanelButtonSettings({ [key2]: sw.checked });
        sw.checked = next[key2];
        applyPetPanelButtonVisibility();
      });
      row.append(text, sw);
      panelBody.appendChild(row);
    };
    addToggle("Show Instant Feed button", "instantFeed", settings.instantFeed);
    addToggle("Show Feed from Inventory button", "feedFromInventory", settings.feedFromInventory);
    const card2 = document.createElement("div");
    card2.style.border = "1px solid #4445";
    card2.style.borderRadius = "10px";
    card2.style.padding = "10px";
    card2.style.background = "#0f1318";
    card2.style.display = "grid";
    card2.style.gridTemplateRows = "auto 1fr";
    card2.style.minHeight = "0";
    right.appendChild(card2);
    const header = document.createElement("div");
    header.style.display = "flex";
    header.style.flexDirection = "column";
    header.style.gap = "4px";
    header.style.marginBottom = "8px";
    card2.appendChild(header);
    const title = document.createElement("div");
    title.textContent = "Instant feed options";
    title.style.fontWeight = "600";
    header.appendChild(title);
    const subtitle = document.createElement("div");
    subtitle.textContent = "Allow or block crops for the Instant Feed button.";
    subtitle.style.opacity = "0.7";
    subtitle.style.fontSize = "12px";
    header.appendChild(subtitle);
    const body = document.createElement("div");
    body.style.display = "flex";
    body.style.flexDirection = "column";
    body.style.gap = "6px";
    body.style.overflow = "auto";
    body.style.minHeight = "0";
    card2.appendChild(body);
    const petItems = Object.keys(petCatalog).map((species) => {
      const entry = petCatalog[species];
      const name = String(entry?.name || species);
      return {
        id: species,
        title: name,
        rarity: entry?.rarity
      };
    });
    vtabs.setItems(petItems);
    if (petItems.length) vtabs.select(petItems[0].id);
    const renderCrops = (species) => {
      body.innerHTML = "";
      if (!species) {
        const empty = document.createElement("div");
        empty.textContent = "Select a pet to configure instant feed crops.";
        empty.style.opacity = "0.75";
        body.appendChild(empty);
        return;
      }
      const compatibles = PetsService.getCompatibleCropsForSpecies(species) ?? [];
      const seen = /* @__PURE__ */ new Set();
      const list = compatibles.map((c) => String(c || "")).filter((c) => c && !seen.has(c) && seen.add(c));
      if (!list.length) {
        const empty = document.createElement("div");
        empty.textContent = "No compatible crops for this pet.";
        empty.style.opacity = "0.75";
        body.appendChild(empty);
        return;
      }
      const cropEntries = list.map((crop) => {
        const entry = plantCatalog[crop];
        const name = String(entry?.name || crop);
        return { crop, name };
      }).sort((a, b) => a.name.localeCompare(b.name));
      cropEntries.forEach(({ crop, name }) => {
        const row = document.createElement("div");
        row.style.display = "grid";
        row.style.gridTemplateColumns = "1fr auto";
        row.style.alignItems = "center";
        row.style.gap = "8px";
        row.style.padding = "6px 4px";
        row.style.borderBottom = "1px solid #ffffff12";
        const labelWrap = document.createElement("div");
        labelWrap.style.display = "flex";
        labelWrap.style.flexDirection = "column";
        labelWrap.style.gap = "2px";
        const nameEl = document.createElement("div");
        nameEl.textContent = name;
        nameEl.style.fontSize = "13px";
        labelWrap.appendChild(nameEl);
        if (name !== crop) {
          const idEl = document.createElement("div");
          idEl.textContent = crop;
          idEl.style.fontSize = "11px";
          idEl.style.opacity = "0.6";
          labelWrap.appendChild(idEl);
        }
        const sw = ui.switch(PetsService.isInstantFeedCropAllowed(species, crop));
        sw.addEventListener("change", () => {
          PetsService.setInstantFeedCropAllowed(species, crop, sw.checked);
        });
        row.append(labelWrap, sw);
        body.appendChild(row);
      });
    };
    vtabs.onSelect((id) => {
      renderCrops(id);
    });
    renderCrops(petItems[0]?.id ?? null);
  }
  function renderLogsTab(view, ui) {
    view.innerHTML = "";
    const wrap = document.createElement("div");
    wrap.style.display = "grid";
    wrap.style.gridTemplateRows = "auto 1fr";
    wrap.style.gap = "10px";
    wrap.style.height = "54vh";
    view.appendChild(wrap);
    const header = document.createElement("div");
    header.style.display = "flex";
    header.style.flexWrap = "wrap";
    header.style.alignItems = "center";
    header.style.gap = "8px";
    header.style.border = "1px solid #4445";
    header.style.borderRadius = "10px";
    header.style.padding = "8px 10px";
    header.style.background = "#0f1318";
    wrap.appendChild(header);
    const selAbility = ui.select({ id: "pets.logs.filter.ability", width: "200px" });
    const selSort = ui.select({ id: "pets.logs.sort", width: "140px" });
    [["desc", "Newest first"], ["asc", "Oldest first"]].forEach(([v, t]) => {
      const o = document.createElement("option");
      o.value = v;
      o.textContent = t;
      selSort.appendChild(o);
    });
    selSort.value = "desc";
    const inputSearch = ui.inputText("search (pet / ability / details)", "");
    inputSearch.id = "pets.logs.search";
    inputSearch.style.minWidth = "220px";
    const btnClear = ui.btn("\u{1F9F9} Clear", { size: "sm" });
    btnClear.id = "pets.logs.clear";
    btnClear.style.flex = "0 0 auto";
    header.append(
      ui.label("Ability"),
      selAbility,
      ui.label("Sort"),
      selSort,
      inputSearch,
      btnClear
    );
    const card2 = document.createElement("div");
    card2.style.border = "1px solid #4445";
    card2.style.borderRadius = "10px";
    card2.style.padding = "10px";
    card2.style.background = "#0f1318";
    card2.style.overflow = "hidden";
    card2.style.display = "grid";
    card2.style.gridTemplateRows = "auto 1fr";
    card2.style.minHeight = "0";
    wrap.appendChild(card2);
    const headerGrid = document.createElement("div");
    headerGrid.style.display = "grid";
    headerGrid.style.gridTemplateColumns = "140px 220px 200px minmax(0,1fr)";
    headerGrid.style.columnGap = "0";
    headerGrid.style.borderBottom = "1px solid #ffffff1a";
    headerGrid.style.padding = "0 0 6px 0";
    function mkHeadCell2(txt, align = "center") {
      const el2 = document.createElement("div");
      el2.textContent = txt;
      el2.style.fontWeight = "600";
      el2.style.opacity = "0.9";
      el2.style.padding = "6px 8px";
      el2.style.textAlign = align;
      return el2;
    }
    headerGrid.append(
      mkHeadCell2("Date & Time"),
      mkHeadCell2("Pet"),
      mkHeadCell2("Ability"),
      mkHeadCell2("Details", "left")
    );
    card2.appendChild(headerGrid);
    const bodyGrid = document.createElement("div");
    bodyGrid.style.display = "grid";
    bodyGrid.style.gridTemplateColumns = "140px 220px 200px minmax(0,1fr)";
    bodyGrid.style.gridAutoRows = "auto";
    bodyGrid.style.alignContent = "start";
    bodyGrid.style.overflow = "auto";
    bodyGrid.style.width = "100%";
    bodyGrid.style.minHeight = "0";
    card2.appendChild(bodyGrid);
    const sessionStart = PetsService.getAbilityLogsSessionStart?.() ?? 0;
    let logs = [];
    let abilityFilter = "";
    let sortDir = "desc";
    let q = "";
    const petSpriteCache = /* @__PURE__ */ new Map();
    const mkPetIcon = (log2) => {
      const size = 22;
      const holder = document.createElement("div");
      Object.assign(holder.style, {
        width: `${size}px`,
        height: `${size}px`,
        borderRadius: "8px",
        background: "#161b22",
        border: "1px solid #ffffff10",
        display: "grid",
        placeItems: "center",
        overflow: "hidden",
        boxShadow: "0 1px 0 #000 inset",
        fontSize: "11px",
        color: "#e2e8f0",
        flex: "0 0 auto"
      });
      const species = String(log2.species || "").trim();
      const mutations = Array.isArray(log2.mutations) ? log2.mutations.map((m) => String(m ?? "").trim()).filter(Boolean) : [];
      const mutKey = mutations.length ? mutations.map((m) => m.toLowerCase()).sort().join(",") : "";
      const cacheKey = mutKey ? `${species}|${mutKey}` : species;
      const applyImg = (src) => {
        const img = document.createElement("img");
        img.src = src;
        img.width = size;
        img.height = size;
        img.alt = "";
        img.draggable = false;
        img.style.width = `${size}px`;
        img.style.height = `${size}px`;
        img.style.objectFit = "contain";
        img.style.imageRendering = "auto";
        holder.replaceChildren(img);
      };
      const cached = cacheKey ? petSpriteCache.get(cacheKey) : void 0;
      if (cached) {
        applyImg(cached);
        return holder;
      }
      const letter = (log2.petName || species || "pet").charAt(0).toUpperCase();
      holder.textContent = letter || "\u{1F43E}";
      if (species) {
        attachSpriteIcon(holder, ["pet"], species, size, "pet-log", {
          mutations,
          onSpriteApplied: (img) => {
            petSpriteCache.set(cacheKey, img.src);
          }
        });
      }
      return holder;
    };
    function rebuildAbilityOptions() {
      const current = selAbility.value;
      selAbility.innerHTML = "";
      const opts = [["", "All abilities"], ...PetsService.getSeenAbilityIds().map((a) => [a, a])];
      for (const [v, t] of opts) {
        const o = document.createElement("option");
        o.value = v;
        o.textContent = t;
        selAbility.appendChild(o);
      }
      selAbility.value = opts.some(([v]) => v === current) ? current : "";
    }
    function formatDateMMDDYY(timestamp) {
      const value = Number(timestamp);
      if (!Number.isFinite(value)) return "";
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) return "";
      const mm = String(date.getMonth() + 1).padStart(2, "0");
      const dd = String(date.getDate()).padStart(2, "0");
      const yy = String(date.getFullYear() % 100).padStart(2, "0");
      return `${mm}/${dd}/${yy}`;
    }
    function cell(txt, align = "center") {
      const el2 = document.createElement("div");
      el2.textContent = txt;
      el2.style.padding = "6px 8px";
      el2.style.display = "flex";
      el2.style.flexDirection = "column";
      el2.style.justifyContent = "center";
      el2.style.alignItems = align === "left" ? "flex-start" : "center";
      el2.style.textAlign = align;
      el2.style.whiteSpace = align === "left" ? "pre-wrap" : "normal";
      el2.style.wordBreak = align === "left" ? "break-word" : "normal";
      el2.style.borderBottom = "1px solid #ffffff12";
      return el2;
    }
    function row(log2) {
      const time = cell("", "center");
      time.style.gap = "2px";
      const dateLine = document.createElement("div");
      const timeLine = document.createElement("div");
      const hasDate = typeof log2.date === "string" && log2.date.trim().length > 0;
      if (hasDate) dateLine.textContent = log2.date ?? "";
      timeLine.textContent = log2.time12;
      if (hasDate) time.appendChild(dateLine);
      time.appendChild(timeLine);
      const petLabel = log2.petName || log2.species || "Pet";
      const pet = cell("", "center");
      pet.style.flexDirection = "row";
      pet.style.alignItems = "center";
      pet.style.gap = "8px";
      const petIcon = mkPetIcon(log2);
      const petText = document.createElement("span");
      petText.textContent = petLabel;
      petText.style.whiteSpace = "nowrap";
      petText.style.overflow = "hidden";
      petText.style.textOverflow = "ellipsis";
      pet.append(petIcon, petText);
      const abName = cell(log2.abilityName || log2.abilityId, "center");
      const detText = typeof log2.data === "string" ? log2.data : (() => {
        try {
          return JSON.stringify(log2.data);
        } catch {
          return "";
        }
      })();
      const det = cell(detText, "left");
      if (log2.isActiveSession) {
        [time, pet, abName, det].forEach((el2) => {
          el2.style.background = "rgba(89, 162, 255, 0.14)";
        });
      }
      bodyGrid.append(time, pet, abName, det);
    }
    const normAbilityKey = (s) => String(s ?? "").toLowerCase().replace(/\s+/g, "").replace(/([ivx]+)$/i, "");
    function applyFilters() {
      let arr = logs.slice();
      if (abilityFilter && abilityFilter.trim()) {
        const f = normAbilityKey(abilityFilter);
        arr = arr.filter((l) => {
          const idKey = normAbilityKey(l.abilityId);
          const nameKey = normAbilityKey(PetsService.getAbilityNameWithoutLevel(l.abilityId));
          return idKey === f || nameKey === f;
        });
      }
      if (q && q.trim()) {
        const qq = q.toLowerCase();
        arr = arr.filter((l) => {
          const pet = (l.petName || l.species || "").toLowerCase();
          const abName = (l.abilityName || "").toLowerCase();
          const abId = (l.abilityId || "").toLowerCase();
          const det = (typeof l.data === "string" ? l.data : (() => {
            try {
              return JSON.stringify(l.data);
            } catch {
              return "";
            }
          })()).toLowerCase();
          return pet.includes(qq) || abName.includes(qq) || abId.includes(qq) || det.includes(qq) || (l.petId || "").toLowerCase().includes(qq);
        });
      }
      arr.sort(
        (a, b) => sortDir === "asc" ? a.performedAt - b.performedAt : b.performedAt - a.performedAt
      );
      return arr;
    }
    function repaint() {
      bodyGrid.innerHTML = "";
      const arr = applyFilters();
      if (!arr.length) {
        const empty = document.createElement("div");
        empty.textContent = "No logs yet.";
        empty.style.opacity = "0.75";
        empty.style.gridColumn = "1 / -1";
        empty.style.padding = "8px";
        bodyGrid.appendChild(empty);
        return;
      }
      arr.forEach(row);
      if (sortDir === "asc") bodyGrid.scrollTop = bodyGrid.scrollHeight + 32;
      else bodyGrid.scrollTop = 0;
    }
    selAbility.onchange = () => {
      abilityFilter = selAbility.value;
      repaint();
    };
    selSort.onchange = () => {
      sortDir = selSort.value || "desc";
      repaint();
    };
    inputSearch.addEventListener("input", () => {
      q = inputSearch.value.trim();
      repaint();
    });
    btnClear.onclick = () => {
      try {
        PetsService.clearAbilityLogs();
      } catch {
      }
    };
    let stopWatcher = null;
    let unsubLogs = null;
    (async () => {
      try {
        stopWatcher = await PetsService.startAbilityLogsWatcher();
        rebuildAbilityOptions();
        unsubLogs = PetsService.onAbilityLogs((all) => {
          logs = all.map((e) => ({
            petId: e.petId,
            petName: e.name ?? null,
            species: e.species ?? null,
            mutations: Array.isArray(e.mutations) ? e.mutations.slice() : void 0,
            abilityId: e.abilityId,
            abilityName: e.abilityName,
            data: e.data,
            performedAt: e.performedAt,
            date: formatDateMMDDYY(e.performedAt),
            time12: e.time12,
            isActiveSession: sessionStart > 0 && e.performedAt >= sessionStart
          }));
          rebuildAbilityOptions();
          repaint();
        });
      } catch {
      }
    })();
    view.__cleanup__ = (() => {
      const prev = view.__cleanup__;
      return () => {
        try {
          unsubLogs?.();
        } catch {
        }
        try {
          stopWatcher?.();
        } catch {
        }
        try {
          prev?.();
        } catch {
        }
      };
    })();
    repaint();
  }
  function renderPetsMenu(root) {
    const ui = new Menu({ id: "pets", compact: true, windowSelector: ".qws-win" });
    ui.mount(root);
    ui.addTab("manager", "\u{1F9F0} Manager", (view) => renderManagerTab(view, ui));
    ui.addTab("feeding", "\u{1F356} Feeding", (view) => renderFeedingTab(view, ui));
    ui.addTab("logs", "\u{1F4DD} Logs", (view) => renderLogsTab(view, ui));
  }

  // src/ui/menus/misc.ts
  init_atoms();
  var formatShortDuration = (seconds) => {
    if (seconds <= 0) return "Instant";
    const sec = Math.max(0, Math.round(seconds));
    if (sec < 60) return `${sec} s`;
    const m = Math.floor(sec / 60);
    const r = sec % 60;
    if (r === 0) return `${m} min`;
    return `${m} min ${r} s`;
  };
  var NF_US2 = new Intl.NumberFormat("en-US");
  var formatNum2 = (n) => NF_US2.format(Math.max(0, Math.floor(n || 0)));
  var formatDurationShort = (ms) => {
    if (ms < 1e3) return `${ms} ms`;
    const seconds = ms / 1e3;
    if (seconds < 10) return `${seconds.toFixed(1)} s`;
    return `${Math.round(seconds)} s`;
  };
  var formatFinishTime = (timestamp) => new Date(timestamp).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" });
  var EXTRA_ESTIMATE_BUFFER_PER_DELETE_MS = 10;
  var buildEstimateSentence = (count, delayMs, finishTimestamp) => {
    if (count <= 0 || delayMs <= 0) return "";
    const durationMs = count * (delayMs + EXTRA_ESTIMATE_BUFFER_PER_DELETE_MS);
    const durationText = formatDurationShort(durationMs);
    if (!finishTimestamp) return ` \xB7 Estimated time ${durationText}`;
    return ` \xB7 Estimated time ${durationText} (${formatFinishTime(finishTimestamp)})`;
  };
  async function renderMiscMenu(container) {
    const ui = new Menu({ id: "misc", compact: true });
    ui.mount(container);
    const view = ui.root.querySelector(".qmm-views");
    view.innerHTML = "";
    view.style.display = "grid";
    view.style.minHeight = "0";
    view.style.justifyItems = "center";
    view.style.padding = "8px 0";
    const applyStyles3 = (el2, styles) => {
      Object.assign(el2.style, styles);
      return el2;
    };
    const createPill = (text) => {
      const pill = applyStyles3(document.createElement("div"), {
        padding: "3px 8px",
        borderRadius: "999px",
        border: "1px solid #2b3340",
        background: "#141b22",
        fontSize: "12px",
        fontWeight: "600",
        color: "#dbe7ff",
        whiteSpace: "nowrap"
      });
      pill.textContent = text;
      return pill;
    };
    const createSettingRow = (title, description, control) => {
      const row = applyStyles3(document.createElement("div"), {
        display: "grid",
        gridTemplateColumns: "minmax(0, 1fr) auto",
        alignItems: "center",
        gap: "12px",
        padding: "10px 12px",
        border: "1px solid #2b3340",
        borderRadius: "10px",
        background: "#0f1318"
      });
      const text = applyStyles3(document.createElement("div"), {
        display: "grid",
        gap: "2px"
      });
      const titleEl = document.createElement("div");
      titleEl.textContent = title;
      titleEl.style.fontWeight = "600";
      titleEl.style.fontSize = "13px";
      text.appendChild(titleEl);
      if (description) {
        const desc = document.createElement("div");
        desc.textContent = description;
        desc.style.fontSize = "12px";
        desc.style.opacity = "0.72";
        text.appendChild(desc);
      }
      const controls = applyStyles3(document.createElement("div"), {
        display: "flex",
        alignItems: "center",
        justifyContent: "flex-end",
        gap: "8px",
        flexWrap: "wrap"
      });
      controls.appendChild(control);
      row.append(text, controls);
      return { row, controls };
    };
    const styleCard = (card2) => {
      card2.root.style.width = "100%";
      card2.root.style.maxWidth = "100%";
      card2.root.style.minWidth = "0";
      card2.body.style.display = "grid";
      card2.body.style.gap = "10px";
    };
    const header = applyStyles3(document.createElement("div"), {
      width: "100%",
      maxWidth: "1040px",
      display: "grid",
      gap: "4px",
      padding: "10px 14px",
      borderRadius: "12px",
      border: "1px solid #2b3340",
      background: "linear-gradient(135deg, #1c222b 0%, #121820 100%)",
      boxShadow: "0 8px 24px rgba(0,0,0,0.35)"
    });
    const headerTitle = document.createElement("div");
    headerTitle.textContent = "Misc controls";
    headerTitle.style.fontSize = "16px";
    headerTitle.style.fontWeight = "700";
    const headerSubtitle = document.createElement("div");
    headerSubtitle.textContent = "Utility toggles and bulk tools.";
    headerSubtitle.style.fontSize = "12.5px";
    headerSubtitle.style.opacity = "0.75";
    header.append(headerTitle, headerSubtitle);
    const page = applyStyles3(document.createElement("div"), {
      width: "100%",
      maxWidth: "1040px",
      display: "grid",
      gap: "12px",
      alignItems: "start"
    });
    const grid = applyStyles3(document.createElement("div"), {
      display: "grid",
      gridTemplateColumns: "repeat(auto-fit, minmax(320px, 1fr))",
      gap: "12px",
      width: "100%",
      alignItems: "start"
    });
    const secAutoReco = (() => {
      const card2 = ui.card("Auto reconnect", {
        tone: "muted",
        align: "stretch",
        subtitle: "Reconnect automatically when the session is kicked."
      });
      styleCard(card2);
      const toggle = ui.switch(MiscService.readAutoRecoEnabled(false));
      const toggleRow = createSettingRow(
        "Enabled",
        "Attempts to log back in after a session conflict.",
        toggle
      );
      const initialSeconds = Math.round(MiscService.getAutoRecoDelayMs() / 1e3);
      const slider = ui.slider(0, 300, 30, initialSeconds);
      slider.style.width = "100%";
      const sliderValue = createPill(formatShortDuration(initialSeconds));
      sliderValue.style.minWidth = "72px";
      sliderValue.style.textAlign = "center";
      const sliderControl = applyStyles3(document.createElement("div"), {
        display: "grid",
        gridTemplateColumns: "1fr auto",
        gap: "8px",
        alignItems: "center",
        minWidth: "220px"
      });
      sliderControl.append(slider, sliderValue);
      const sliderRow = createSettingRow(
        "Delay",
        "Wait time before reconnecting.",
        sliderControl
      );
      const hint = document.createElement("div");
      hint.style.opacity = "0.8";
      hint.style.fontSize = "12px";
      hint.style.lineHeight = "1.35";
      const clampSeconds = (value) => Math.max(0, Math.min(300, Math.round(value / 30) * 30));
      const syncToggle = () => {
        const on = !!toggle.checked;
        slider.disabled = !on;
        MiscService.writeAutoRecoEnabled(on);
        hint.textContent = on ? "Automatically log back in if this account is disconnected because it was opened in another session." : "Auto reconnect on session conflict is turned off.";
      };
      const updateSlider = (raw, persist2) => {
        const seconds = clampSeconds(raw);
        slider.value = String(seconds);
        sliderValue.textContent = formatShortDuration(seconds);
        if (persist2) MiscService.setAutoRecoDelayMs(seconds * 1e3);
        syncToggle();
      };
      toggle.addEventListener("change", syncToggle);
      slider.addEventListener("input", () => updateSlider(Number(slider.value), false));
      slider.addEventListener("change", () => updateSlider(Number(slider.value), true));
      syncToggle();
      card2.body.append(toggleRow.row, sliderRow.row, hint);
      return card2.root;
    })();
    const secPlayer = (() => {
      const card2 = ui.card("Player controls", {
        tone: "muted",
        align: "stretch",
        subtitle: "Movement helpers for walking and testing."
      });
      styleCard(card2);
      const ghostSwitch = ui.switch(MiscService.readGhostEnabled(false));
      ghostSwitch.id = "player.ghostMode";
      const delayInput = ui.inputNumber(10, 1e3, 5, 50);
      delayInput.id = "player.moveDelay";
      const delayWrap = delayInput.wrap ?? delayInput;
      delayWrap.style && (delayWrap.style.margin = "0");
      delayInput.style && (delayInput.style.width = "84px");
      const ghostRow = createSettingRow(
        "Ghost mode",
        "Ignores collisions while you move.",
        ghostSwitch
      );
      const delayRow = createSettingRow(
        "Move delay (ms)",
        "Lower values feel faster.",
        delayWrap
      );
      const ghost = MiscService.createGhostController();
      delayInput.value = String(MiscService.getGhostDelayMs());
      delayInput.addEventListener("change", () => {
        const v = Math.max(10, Math.min(1e3, Math.floor(Number(delayInput.value) || 50)));
        delayInput.value = String(v);
        ghost.setSpeed?.(v);
        MiscService.setGhostDelayMs(v);
      });
      if (ghostSwitch.checked) ghost.start();
      ghostSwitch.onchange = () => {
        const on = !!ghostSwitch.checked;
        MiscService.writeGhostEnabled(on);
        on ? ghost.start() : ghost.stop();
      };
      card2.root.__cleanup__ = () => {
        try {
          ghost.stop();
        } catch {
        }
      };
      card2.body.append(ghostRow.row, delayRow.row);
      return card2.root;
    })();
    const secInventoryReserve = (() => {
      const card2 = ui.card("Inventory guard", {
        tone: "muted",
        align: "stretch",
        subtitle: "Keep a slot open for swaps and bulk actions."
      });
      styleCard(card2);
      const toggle = ui.switch(MiscService.readInventorySlotReserveEnabled(false));
      const row = createSettingRow(
        "Keep 1 slot free",
        "Blocks actions that would add a new inventory entry at 99/100.",
        toggle
      );
      toggle.addEventListener("change", () => {
        MiscService.writeInventorySlotReserveEnabled(!!toggle.checked);
      });
      card2.body.append(row.row);
      return card2.root;
    })();
    const secStorage = (() => {
      const card2 = ui.card("Storage auto-store", {
        tone: "muted",
        align: "stretch",
        subtitle: "Move items into storage when a matching stack already exists."
      });
      styleCard(card2);
      const seedToggle = ui.switch(MiscService.readAutoStoreSeedSiloEnabled(false));
      const seedRow = createSettingRow(
        "Seed Silo",
        "Auto-store seeds when the species already exists in the silo.",
        seedToggle
      );
      const decorToggle = ui.switch(MiscService.readAutoStoreDecorShedEnabled(false));
      const decorRow = createSettingRow(
        "Decor Shed",
        "Auto-store decor when the item already exists in the shed.",
        decorToggle
      );
      seedToggle.addEventListener("change", () => {
        MiscService.setAutoStoreSeedSiloEnabled(!!seedToggle.checked);
      });
      decorToggle.addEventListener("change", () => {
        MiscService.setAutoStoreDecorShedEnabled(!!decorToggle.checked);
      });
      card2.body.append(seedRow.row, decorRow.row);
      return card2.root;
    })();
    const secSeed = (() => {
      const grid2 = applyStyles3(document.createElement("div"), {
        display: "grid",
        gap: "10px"
      });
      const selValue = createPill("0 species - 0 seeds");
      selValue.id = "misc.seedDeleter.summary";
      const summaryRow = createSettingRow(
        "Selected",
        "Review the current seed selection before deleting.",
        selValue
      );
      grid2.append(summaryRow.row);
      const actions = ui.flexRow({ gap: 6 });
      actions.style.flexWrap = "wrap";
      const btnSelect = ui.btn("Select seeds", { variant: "primary", size: "sm" });
      const btnDelete = ui.btn("Delete", { variant: "danger", size: "sm", disabled: true });
      const btnClear = ui.btn("Clear", { size: "sm", disabled: true });
      actions.append(btnSelect, btnDelete, btnClear);
      const actionsRow = createSettingRow(
        "Actions",
        "Pick, clear, or delete the selected seeds.",
        actions
      );
      grid2.append(actionsRow.row);
      const statusLine = createPill("Idle");
      statusLine.style.fontWeight = "600";
      const controlRow = ui.flexRow({ gap: 6 });
      controlRow.style.flexWrap = "wrap";
      const btnPause = ui.btn("Pause", { size: "sm" });
      const btnPlay = ui.btn("Play", { size: "sm" });
      const btnStop = ui.btn("Stop", { size: "sm", variant: "ghost" });
      btnPause.onclick = () => {
        MiscService.pauseSeedDeletion();
        updateSeedControlState();
      };
      btnPlay.onclick = () => {
        MiscService.resumeSeedDeletion();
        updateSeedControlState();
      };
      btnStop.onclick = () => {
        MiscService.cancelSeedDeletion();
        updateSeedControlState();
      };
      controlRow.append(btnPause, btnPlay, btnStop);
      const statusControls = applyStyles3(document.createElement("div"), {
        display: "flex",
        alignItems: "center",
        gap: "8px",
        flexWrap: "wrap",
        justifyContent: "flex-end"
      });
      statusControls.append(controlRow, statusLine);
      const statusRow = createSettingRow(
        "Status",
        "Pause or stop the current delete flow.",
        statusControls
      );
      grid2.append(statusRow.row);
      const seedStatus = { species: "-", done: 0, total: 0, remaining: 0 };
      const describeSeedStatus = () => {
        const running = MiscService.isSeedDeletionRunning();
        const paused = MiscService.isSeedDeletionPaused();
        const target = seedStatus.species || "-";
        const base = `${target} (${seedStatus.done}/${seedStatus.total})`;
        if (!running) return "Idle";
        return paused ? `Paused - ${base}` : base;
      };
      const updateSeedStatusUI = () => {
        statusLine.textContent = describeSeedStatus();
      };
      const updateSeedControlState = () => {
        const running = MiscService.isSeedDeletionRunning();
        const paused = MiscService.isSeedDeletionPaused();
        btnPause.disabled = !running || paused;
        btnPlay.disabled = !running || !paused;
        btnStop.disabled = !running;
        updateSeedStatusUI();
      };
      let seedEstimatedFinish = null;
      let seedSummaryTimer = null;
      const clearSeedSummaryTimer = () => {
        if (seedSummaryTimer !== null) {
          clearTimeout(seedSummaryTimer);
          seedSummaryTimer = null;
        }
      };
      const scheduleSeedSummaryRefresh = () => {
        clearSeedSummaryTimer();
        seedSummaryTimer = window.setTimeout(() => updateSummaryUI(), 1e3);
      };
      const onSeedProgress = (event) => {
        const detail = event.detail;
        seedStatus.species = detail.species;
        seedStatus.done = detail.done;
        seedStatus.total = detail.total;
        seedStatus.remaining = detail.remainingForSpecies;
        updateSeedStatusUI();
        updateSeedControlState();
      };
      const onSeedComplete = () => {
        seedStatus.species = "-";
        seedStatus.done = 0;
        seedStatus.total = 0;
        seedStatus.remaining = 0;
        updateSeedStatusUI();
        updateSeedControlState();
      };
      const onSeedPaused = () => updateSeedControlState();
      const onSeedResumed = () => updateSeedControlState();
      window.addEventListener("qws:seeddeleter:progress", onSeedProgress);
      window.addEventListener("qws:seeddeleter:done", onSeedComplete);
      window.addEventListener("qws:seeddeleter:error", onSeedComplete);
      window.addEventListener("qws:seeddeleter:paused", onSeedPaused);
      window.addEventListener("qws:seeddeleter:resumed", onSeedResumed);
      const cleanupSeedListeners = () => {
        window.removeEventListener("qws:seeddeleter:progress", onSeedProgress);
        window.removeEventListener("qws:seeddeleter:done", onSeedComplete);
        window.removeEventListener("qws:seeddeleter:error", onSeedComplete);
        window.removeEventListener("qws:seeddeleter:paused", onSeedPaused);
        window.removeEventListener("qws:seeddeleter:resumed", onSeedResumed);
      };
      updateSeedStatusUI();
      updateSeedControlState();
      function readSelection() {
        const sel = MiscService.getCurrentSeedSelection?.() || [];
        const speciesCount = sel.length;
        let totalQty = 0;
        for (const it of sel) totalQty += Math.max(0, Math.floor(it?.qty || 0));
        return { sel, speciesCount, totalQty };
      }
      function updateSummaryUI() {
        const { speciesCount, totalQty } = readSelection();
        const seedDelayMs = DEFAULT_SEED_DELETE_DELAY_MS;
        const estimateMs = totalQty * (seedDelayMs + EXTRA_ESTIMATE_BUFFER_PER_DELETE_MS);
        const isRunning = MiscService.isSeedDeletionRunning();
        const finishTimestamp = isRunning ? seedEstimatedFinish : estimateMs > 0 ? Date.now() + estimateMs : null;
        const estimateText = buildEstimateSentence(totalQty, seedDelayMs, finishTimestamp);
        selValue.textContent = `${speciesCount} species - ${formatNum2(totalQty)} seeds${estimateText}`;
        const has = speciesCount > 0 && totalQty > 0;
        ui.setButtonEnabled(btnDelete, has);
        ui.setButtonEnabled(btnClear, has);
        if (!isRunning && totalQty > 0) {
          scheduleSeedSummaryRefresh();
        } else {
          clearSeedSummaryTimer();
        }
      }
      btnSelect.onclick = async () => {
        try {
          await Atoms.inventory.myPossiblyNoLongerValidSelectedItemIndex.set(null);
        } catch {
        }
        await MiscService.openSeedSelectorFlow(ui.setWindowVisible.bind(ui));
        updateSummaryUI();
      };
      btnClear.onclick = () => {
        try {
          MiscService.clearSeedSelection?.();
        } catch {
        }
        updateSummaryUI();
      };
      btnDelete.onclick = async () => {
        const { totalQty } = readSelection();
        const seedDelayMs = DEFAULT_SEED_DELETE_DELAY_MS;
        const estimateMs = totalQty * (seedDelayMs + EXTRA_ESTIMATE_BUFFER_PER_DELETE_MS);
        seedEstimatedFinish = estimateMs > 0 ? Date.now() + estimateMs : null;
        clearSeedSummaryTimer();
        const deletionPromise = MiscService.deleteSelectedSeeds({ delayMs: seedDelayMs });
        updateSummaryUI();
        await deletionPromise;
        seedEstimatedFinish = null;
        updateSummaryUI();
      };
      const card2 = ui.card("Seed deleter", {
        tone: "muted",
        align: "stretch",
        subtitle: "Bulk delete seeds from inventory."
      });
      styleCard(card2);
      card2.body.append(grid2);
      card2.root.__cleanup__ = () => {
        clearSeedSummaryTimer();
        cleanupSeedListeners();
      };
      return card2.root;
    })();
    const secDecor = (() => {
      const grid2 = applyStyles3(document.createElement("div"), {
        display: "grid",
        gap: "10px"
      });
      const selValue = createPill("0 decor - 0 items");
      selValue.id = "misc.decorDeleter.summary";
      const summaryRow = createSettingRow(
        "Selected",
        "Review the current decor selection before deleting.",
        selValue
      );
      grid2.append(summaryRow.row);
      const actions = ui.flexRow({ gap: 6 });
      actions.style.flexWrap = "wrap";
      const btnSelect = ui.btn("Select decor", { variant: "primary", size: "sm" });
      const btnDelete = ui.btn("Delete", { variant: "danger", size: "sm", disabled: true });
      const btnClear = ui.btn("Clear", { size: "sm", disabled: true });
      actions.append(btnSelect, btnDelete, btnClear);
      const actionsRow = createSettingRow(
        "Actions",
        "Pick, clear, or delete the selected decor.",
        actions
      );
      grid2.append(actionsRow.row);
      const statusLine = createPill("Idle");
      statusLine.style.fontWeight = "600";
      const controlRow = ui.flexRow({ gap: 6 });
      controlRow.style.flexWrap = "wrap";
      const btnPause = ui.btn("Pause", { size: "sm" });
      const btnPlay = ui.btn("Play", { size: "sm" });
      const btnStop = ui.btn("Stop", { size: "sm", variant: "ghost" });
      btnPause.onclick = () => {
        MiscService.pauseDecorDeletion();
        updateDecorControlState();
      };
      btnPlay.onclick = () => {
        MiscService.resumeDecorDeletion();
        updateDecorControlState();
      };
      btnStop.onclick = () => {
        MiscService.cancelDecorDeletion();
        updateDecorControlState();
      };
      controlRow.append(btnPause, btnPlay, btnStop);
      const statusControls = applyStyles3(document.createElement("div"), {
        display: "flex",
        alignItems: "center",
        gap: "8px",
        flexWrap: "wrap",
        justifyContent: "flex-end"
      });
      statusControls.append(controlRow, statusLine);
      const statusRow = createSettingRow(
        "Status",
        "Pause or stop the current delete flow.",
        statusControls
      );
      grid2.append(statusRow.row);
      const decorStatus = { name: "-", done: 0, total: 0, remaining: 0 };
      const describeDecorStatus = () => {
        const running = MiscService.isDecorDeletionRunning();
        const paused = MiscService.isDecorDeletionPaused();
        const target = decorStatus.name || "-";
        const base = `${target} (${decorStatus.done}/${decorStatus.total})`;
        if (!running) return "Idle";
        return paused ? `Paused - ${base}` : base;
      };
      const updateDecorStatusUI = () => {
        statusLine.textContent = describeDecorStatus();
      };
      const updateDecorControlState = () => {
        const running = MiscService.isDecorDeletionRunning();
        const paused = MiscService.isDecorDeletionPaused();
        btnPause.disabled = !running || paused;
        btnPlay.disabled = !running || !paused;
        btnStop.disabled = !running;
        updateDecorStatusUI();
      };
      const onDecorProgress = (event) => {
        const detail = event.detail;
        decorStatus.name = detail.decorId;
        decorStatus.done = detail.done;
        decorStatus.total = detail.total;
        decorStatus.remaining = detail.remainingForDecor;
        updateDecorStatusUI();
        updateDecorControlState();
      };
      const onDecorComplete = () => {
        decorStatus.name = "-";
        decorStatus.done = 0;
        decorStatus.total = 0;
        decorStatus.remaining = 0;
        updateDecorStatusUI();
        updateDecorControlState();
      };
      const onDecorPaused = () => updateDecorControlState();
      const onDecorResumed = () => updateDecorControlState();
      window.addEventListener("qws:decordeleter:progress", onDecorProgress);
      window.addEventListener("qws:decordeleter:done", onDecorComplete);
      window.addEventListener("qws:decordeleter:error", onDecorComplete);
      window.addEventListener("qws:decordeleter:paused", onDecorPaused);
      window.addEventListener("qws:decordeleter:resumed", onDecorResumed);
      const cleanupDecorListeners = () => {
        window.removeEventListener("qws:decordeleter:progress", onDecorProgress);
        window.removeEventListener("qws:decordeleter:done", onDecorComplete);
        window.removeEventListener("qws:decordeleter:error", onDecorComplete);
        window.removeEventListener("qws:decordeleter:paused", onDecorPaused);
        window.removeEventListener("qws:decordeleter:resumed", onDecorResumed);
      };
      updateDecorStatusUI();
      updateDecorControlState();
      let decorEstimatedFinish = null;
      let decorSummaryTimer = null;
      const clearDecorSummaryTimer = () => {
        if (decorSummaryTimer !== null) {
          clearTimeout(decorSummaryTimer);
          decorSummaryTimer = null;
        }
      };
      const scheduleDecorSummaryRefresh = () => {
        clearDecorSummaryTimer();
        decorSummaryTimer = window.setTimeout(() => updateSummaryUI(), 1e3);
      };
      function readSelection() {
        const sel = MiscService.getCurrentDecorSelection?.() || [];
        const decorCount = sel.length;
        let totalQty = 0;
        for (const it of sel) totalQty += Math.max(0, Math.floor(it?.qty || 0));
        return { sel, decorCount, totalQty };
      }
      function updateSummaryUI() {
        const { decorCount, totalQty } = readSelection();
        const decorDelayMs = DEFAULT_DECOR_DELETE_DELAY_MS * 2;
        const estimateMs = totalQty * (decorDelayMs + EXTRA_ESTIMATE_BUFFER_PER_DELETE_MS);
        const isRunning = MiscService.isDecorDeletionRunning();
        const finishTimestamp = isRunning ? decorEstimatedFinish : estimateMs > 0 ? Date.now() + estimateMs : null;
        const estimateText = buildEstimateSentence(totalQty, decorDelayMs, finishTimestamp);
        selValue.textContent = `${decorCount} decor - ${formatNum2(totalQty)} items${estimateText}`;
        const has = decorCount > 0 && totalQty > 0;
        ui.setButtonEnabled(btnDelete, has);
        ui.setButtonEnabled(btnClear, has);
        if (!isRunning && totalQty > 0) {
          scheduleDecorSummaryRefresh();
        } else {
          clearDecorSummaryTimer();
        }
      }
      btnSelect.onclick = async () => {
        try {
          await Atoms.inventory.myPossiblyNoLongerValidSelectedItemIndex.set(null);
        } catch {
        }
        await MiscService.openDecorSelectorFlow(ui.setWindowVisible.bind(ui));
        updateSummaryUI();
      };
      btnDelete.onclick = async () => {
        const { totalQty } = readSelection();
        const decorDelayMs = DEFAULT_DECOR_DELETE_DELAY_MS * 2;
        const estimateMs = totalQty * (decorDelayMs + EXTRA_ESTIMATE_BUFFER_PER_DELETE_MS);
        decorEstimatedFinish = estimateMs > 0 ? Date.now() + estimateMs : null;
        clearDecorSummaryTimer();
        const deletionPromise = MiscService.deleteSelectedDecor?.({ delayMs: DEFAULT_DECOR_DELETE_DELAY_MS });
        updateSummaryUI();
        if (deletionPromise) await deletionPromise;
        decorEstimatedFinish = null;
        updateSummaryUI();
      };
      btnClear.onclick = () => {
        try {
          MiscService.clearDecorSelection?.();
        } catch {
        }
        updateSummaryUI();
      };
      const card2 = ui.card("Decor deleter", {
        tone: "muted",
        align: "stretch",
        subtitle: "Bulk delete decor from inventory."
      });
      styleCard(card2);
      card2.body.append(grid2);
      card2.root.__cleanup__ = () => {
        clearDecorSummaryTimer();
        cleanupDecorListeners();
      };
      return card2.root;
    })();
    secSeed.style.gridColumn = "1 / -1";
    secDecor.style.gridColumn = "1 / -1";
    grid.append(secAutoReco, secPlayer, secInventoryReserve, secStorage, secSeed, secDecor);
    page.append(header, grid);
    view.appendChild(page);
    view.__cleanup__ = () => {
      try {
        secPlayer.__cleanup__?.();
      } catch {
      }
      try {
        secSeed.__cleanup__?.();
      } catch {
      }
      try {
        secDecor.__cleanup__?.();
      } catch {
      }
    };
  }

  // src/services/settings.ts
  var STORAGE_KEY = "aries_backups";
  var MAX_BACKUPS = 25;
  var DEFAULT_VERSION = 1;
  function generateId() {
    if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
      return crypto.randomUUID();
    }
    return `${Date.now().toString(36)}-${Math.random().toString(36).slice(2)}`;
  }
  function ensureVersion(snapshot) {
    const next = { ...snapshot };
    if (!Number.isFinite(next.version)) {
      next.version = DEFAULT_VERSION;
    }
    return next;
  }
  function readRawStorage() {
    try {
      if (typeof GM_getValue === "function") {
        return GM_getValue(STORAGE_KEY, "[]") ?? "[]";
      }
      if (typeof window !== "undefined" && typeof window.localStorage !== "undefined") {
        return window.localStorage.getItem(STORAGE_KEY) ?? "[]";
      }
    } catch {
    }
    return "[]";
  }
  function writeRawStorage(payload) {
    try {
      if (typeof GM_setValue === "function") {
        GM_setValue(STORAGE_KEY, payload);
        return;
      }
      if (typeof window !== "undefined" && typeof window.localStorage !== "undefined") {
        window.localStorage.setItem(STORAGE_KEY, payload);
      }
    } catch {
    }
  }
  function readBackups() {
    const raw = readRawStorage();
    try {
      const parsed = JSON.parse(raw);
      if (Array.isArray(parsed)) {
        return parsed;
      }
    } catch {
    }
    return [];
  }
  function persistBackups(backups) {
    writeRawStorage(JSON.stringify(backups));
  }
  function listBackups() {
    const entries = readBackups();
    return [...entries].sort((a, b) => b.timestamp - a.timestamp);
  }
  function saveBackup(name) {
    const normalizedName = name.trim() || `Backup ${(/* @__PURE__ */ new Date()).toLocaleString()}`;
    const current = ensureVersion(getAriesStorage());
    const entry = {
      id: generateId(),
      name: normalizedName,
      timestamp: Date.now(),
      data: current
    };
    const next = [entry, ...readBackups()].slice(0, MAX_BACKUPS);
    persistBackups(next);
    return { success: true, message: "Backup saved.", backup: entry };
  }
  function loadBackup(id) {
    const entry = readBackups().find((backup) => backup.id === id);
    if (!entry) {
      return { success: false, message: "Backup not found." };
    }
    try {
      saveAriesStorage(entry.data);
      return { success: true, message: "Backup loaded. Reload the game to apply the changes." };
    } catch (error) {
      return {
        success: false,
        message: `Failed to load backup (${error instanceof Error ? error.message : "unknown error"}).`
      };
    }
  }
  function deleteBackup(id) {
    const next = readBackups().filter((backup) => backup.id !== id);
    if (next.length === readBackups().length) {
      return { success: false, message: "Backup not found." };
    }
    persistBackups(next);
    return { success: true, message: "Backup deleted." };
  }
  function exportAllSettings() {
    const current = ensureVersion(getAriesStorage());
    return JSON.stringify(current, null, 2);
  }
  function importSettings(payload) {
    const trimmed = payload.trim();
    if (!trimmed) {
      return { success: false, message: "Payload is empty." };
    }
    let parsed;
    try {
      parsed = JSON.parse(trimmed);
    } catch (error) {
      return {
        success: false,
        message: `Invalid JSON (${error instanceof Error ? error.message : "unknown error"}).`
      };
    }
    if (!parsed || typeof parsed !== "object") {
      return { success: false, message: "JSON payload must be an object." };
    }
    try {
      const normalized = ensureVersion(parsed);
      saveAriesStorage(normalized);
      return { success: true, message: "Settings applied. Reload the game to apply the changes." };
    } catch (error) {
      return {
        success: false,
        message: `Failed to import settings (${error instanceof Error ? error.message : "unknown error"}).`
      };
    }
  }

  // src/ui/menus/settings.ts
  init_page_context();
  function createActionButton(label2) {
    const button = document.createElement("button");
    button.type = "button";
    button.textContent = label2;
    button.style.borderRadius = "6px";
    button.style.border = "1px solid rgba(255,255,255,0.2)";
    button.style.background = "rgba(255,255,255,0.04)";
    button.style.color = "inherit";
    button.style.fontWeight = "600";
    button.style.fontSize = "13px";
    button.style.padding = "6px 12px";
    button.style.cursor = "pointer";
    button.addEventListener("mouseenter", () => button.style.background = "rgba(255,255,255,0.08)");
    button.addEventListener("mouseleave", () => button.style.background = "rgba(255,255,255,0.04)");
    return button;
  }
  function createStatusLine() {
    const line = document.createElement("div");
    line.style.fontSize = "13px";
    line.style.minHeight = "18px";
    line.style.opacity = "0.9";
    return line;
  }
  function showStatus(line, result) {
    line.textContent = result.message;
    line.style.color = result.success ? "#8bf1b5" : "#ff9c9c";
  }
  function formatBackupDate(value) {
    return new Date(value).toLocaleDateString();
  }
  function copyTextToClipboard(text) {
    if (navigator.clipboard?.writeText) {
      navigator.clipboard.writeText(text);
      return;
    }
    const textarea = document.createElement("textarea");
    textarea.value = text;
    textarea.style.position = "fixed";
    textarea.style.left = "-9999px";
    document.body.appendChild(textarea);
    textarea.select();
    document.execCommand("copy");
    textarea.remove();
  }
  function downloadJSONFile(filename, payload) {
    if (typeof GM_download === "function") {
      try {
        const encoded = encodeURIComponent(payload);
        const url = `data:application/json;charset=utf-8,${encoded}`;
        GM_download({ name: filename, url, saveAs: true });
        return;
      } catch {
      }
    }
    const win = pageWindow || window;
    const safePayload = JSON.stringify(payload);
    const safeFilename = JSON.stringify(filename);
    const script = `(function(){try{const data=${safePayload};const name=${safeFilename};const blob=new Blob([data],{type:"application/json"});const url=URL.createObjectURL(blob);const a=document.createElement("a");a.href=url;a.download=name;a.style.display="none";const parent=document.body||document.documentElement||document;parent.appendChild(a);a.click();a.remove();URL.revokeObjectURL(url);}catch(e){console.error("[settings] download:",e)}})();`;
    try {
      win.eval(script);
      return;
    } catch {
    }
    try {
      const doc = win.document || document;
      const root = doc.body || doc.documentElement || document.body;
      const blob = new Blob([payload], { type: "application/json" });
      const url = (win.URL || URL).createObjectURL(blob);
      const a = doc.createElement("a");
      a.href = url;
      a.download = filename;
      a.style.display = "none";
      if (root) {
        root.appendChild(a);
      }
      a.click();
      if (root) {
        root.removeChild(a);
      }
      (win.URL || URL).revokeObjectURL(url);
    } catch {
      copyTextToClipboard(payload);
    }
  }
  function exportBackupData(entry) {
    const json = JSON.stringify(entry.data, null, 2);
    const filename = `${entry.name || "aries-backup"}-${entry.id}.json`;
    downloadJSONFile(filename, json);
  }
  function createBackupRow(entry, statusLine, listHolder) {
    const container = document.createElement("div");
    container.style.display = "flex";
    container.style.flexDirection = "column";
    container.style.gap = "6px";
    container.style.padding = "10px";
    container.style.borderRadius = "8px";
    container.style.border = "1px solid rgba(255,255,255,0.08)";
    container.style.background = "rgba(255,255,255,0.01)";
    const header = document.createElement("div");
    header.style.display = "flex";
    header.style.justifyContent = "space-between";
    header.style.alignItems = "baseline";
    header.style.flexWrap = "wrap";
    header.style.gap = "8px";
    const title = document.createElement("div");
    title.textContent = entry.name;
    title.style.fontWeight = "600";
    title.style.fontSize = "13px";
    const date = document.createElement("div");
    date.innerHTML = `<strong>Created:</strong> ${formatBackupDate(entry.timestamp)}`;
    date.style.fontSize = "11px";
    date.style.opacity = "0.65";
    header.append(title, date);
    const actions = document.createElement("div");
    actions.style.display = "flex";
    actions.style.gap = "6px";
    actions.style.flexWrap = "wrap";
    const loadButton = createActionButton("Load");
    loadButton.addEventListener("click", () => {
      const result = loadBackup(entry.id);
      showStatus(statusLine, result);
    });
    const deleteButton = createActionButton("Delete");
    deleteButton.addEventListener("click", () => {
      const result = deleteBackup(entry.id);
      showStatus(statusLine, result);
      refreshBackupList(statusLine, listHolder);
    });
    const exportButton = createActionButton("Export");
    exportButton.addEventListener("click", () => {
      exportBackupData(entry);
      showStatus(statusLine, { success: true, message: "Backup exported." });
    });
    actions.append(loadButton, deleteButton);
    actions.append(exportButton);
    container.append(header, actions);
    return container;
  }
  function refreshBackupList(statusLine, listHolder) {
    const backups = listBackups();
    listHolder.innerHTML = "";
    if (!backups.length) {
      const empty = document.createElement("div");
      empty.textContent = "No backups saved yet.";
      empty.style.opacity = "0.6";
      listHolder.appendChild(empty);
      return;
    }
    backups.forEach((entry) => {
      const row = createBackupRow(entry, statusLine, listHolder);
      listHolder.appendChild(row);
    });
  }
  function renderDataTab(view, ui) {
    view.innerHTML = "";
    const layout = document.createElement("div");
    layout.style.display = "flex";
    layout.style.flexDirection = "column";
    layout.style.gap = "12px";
    const ioCard = ui.card("Import / Export", {
      description: "Import or export the mod settings directly through JSON files."
    });
    const card2 = ui.card("Backup", {
      description: "Save our settings directly inside the mod storage for easy restores."
    });
    ioCard.body.style.display = "flex";
    ioCard.body.style.flexDirection = "column";
    ioCard.body.style.gap = "10px";
    card2.body.style.display = "flex";
    card2.body.style.flexDirection = "column";
    card2.body.style.gap = "10px";
    const ioStatus = createStatusLine();
    const exportButton = createActionButton("Export Settings");
    exportButton.style.width = "100%";
    exportButton.style.boxSizing = "border-box";
    exportButton.addEventListener("click", () => {
      const payload = exportAllSettings();
      const filename = `aries-settings-${Date.now()}.json`;
      downloadJSONFile(filename, payload);
      showStatus(ioStatus, { success: true, message: "Settings exported as JSON file." });
    });
    const importWrapper = document.createElement("div");
    importWrapper.style.display = "flex";
    importWrapper.style.flexDirection = "column";
    importWrapper.style.gap = "8px";
    const fileInput = document.createElement("input");
    fileInput.type = "file";
    fileInput.accept = ".json,application/json,text/plain";
    fileInput.style.display = "none";
    const fileCard = document.createElement("div");
    Object.assign(fileCard.style, {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center",
      gap: "6px",
      padding: "18px 22px",
      width: "100%",
      minHeight: "110px",
      borderRadius: "14px",
      border: "1px dashed #5d6a7d",
      background: "linear-gradient(180deg, #0b141c, #091018)",
      transition: "border-color 0.2s ease, background 0.2s ease, box-shadow 0.2s ease",
      cursor: "pointer",
      textAlign: "center"
    });
    fileCard.tabIndex = 0;
    fileCard.setAttribute("role", "button");
    fileCard.setAttribute("aria-label", "Import settings JSON");
    const fileCardTitle = document.createElement("div");
    fileCardTitle.textContent = "Import settings";
    Object.assign(fileCardTitle.style, {
      fontWeight: "600",
      fontSize: "14px",
      letterSpacing: "0.02em"
    });
    const fileStatus = document.createElement("div");
    const defaultStatusText = "Drop a JSON file or click to browse.";
    fileStatus.textContent = defaultStatusText;
    Object.assign(fileStatus.style, {
      fontSize: "12px",
      opacity: "0.75"
    });
    fileCard.append(fileCardTitle, fileStatus);
    const setFileCardActive = (active) => {
      if (active) {
        fileCard.style.borderColor = "#6fc3ff";
        fileCard.style.boxShadow = "0 0 0 3px #6fc3ff22";
        fileCard.style.background = "linear-gradient(180deg, #102030, #0b1826)";
      } else {
        fileCard.style.borderColor = "#5d6a7d";
        fileCard.style.boxShadow = "none";
        fileCard.style.background = "linear-gradient(180deg, #0b141c, #091018)";
      }
    };
    const triggerFileSelect = () => fileInput.click();
    fileCard.addEventListener("mouseenter", () => setFileCardActive(true));
    fileCard.addEventListener("mouseleave", () => setFileCardActive(document.activeElement === fileCard));
    fileCard.addEventListener("focus", () => setFileCardActive(true));
    fileCard.addEventListener("blur", () => setFileCardActive(false));
    fileCard.addEventListener("click", triggerFileSelect);
    fileCard.addEventListener("keydown", (ev) => {
      if (ev.key === "Enter" || ev.key === " ") {
        ev.preventDefault();
        triggerFileSelect();
      }
    });
    fileCard.addEventListener("dragover", (ev) => {
      ev.preventDefault();
      setFileCardActive(true);
      if (ev.dataTransfer) ev.dataTransfer.dropEffect = "copy";
    });
    fileCard.addEventListener("dragleave", () => setFileCardActive(document.activeElement === fileCard));
    const displaySelection = (files) => {
      if (!files || !files.length) {
        fileStatus.textContent = defaultStatusText;
        return;
      }
      fileStatus.textContent = files.length === 1 ? files[0].name : `${files.length} files selected`;
    };
    const handleFiles = async (files) => {
      if (!files || !files.length) return;
      const file = files[0];
      try {
        const text = await file.text();
        const result = importSettings(text);
        showStatus(ioStatus, result);
      } catch (error) {
        showStatus(ioStatus, {
          success: false,
          message: `Failed to read file (${error instanceof Error ? error.message : "unknown error"}).`
        });
      } finally {
        fileInput.value = "";
      }
    };
    fileCard.addEventListener("drop", async (ev) => {
      ev.preventDefault();
      const files = ev.dataTransfer?.files || null;
      displaySelection(files);
      await handleFiles(files);
      displaySelection(null);
      setFileCardActive(document.activeElement === fileCard);
    });
    fileInput.onchange = async () => {
      const files = fileInput.files;
      displaySelection(files);
      await handleFiles(files);
      displaySelection(null);
      setFileCardActive(document.activeElement === fileCard);
    };
    importWrapper.append(fileInput, fileCard);
    ioCard.body.append(importWrapper, ioStatus, exportButton);
    layout.appendChild(ioCard.root);
    const controlRow = document.createElement("div");
    controlRow.style.display = "flex";
    controlRow.style.gap = "8px";
    controlRow.style.alignItems = "center";
    const nameInput = document.createElement("input");
    nameInput.type = "text";
    nameInput.placeholder = "Backup name";
    nameInput.style.flex = "1";
    nameInput.style.borderRadius = "6px";
    nameInput.style.border = "1px solid rgba(255,255,255,0.08)";
    nameInput.style.background = "rgba(255,255,255,0.02)";
    nameInput.style.color = "inherit";
    nameInput.style.padding = "8px 10px";
    nameInput.style.fontSize = "13px";
    const saveButton = createActionButton("Save");
    const controlStatus = createStatusLine();
    const backupListHolder = document.createElement("div");
    backupListHolder.style.display = "flex";
    backupListHolder.style.flexDirection = "column";
    backupListHolder.style.gap = "10px";
    saveButton.addEventListener("click", () => {
      const result = saveBackup(nameInput.value);
      showStatus(controlStatus, result);
      if (result.success) {
        nameInput.value = "";
        refreshBackupList(controlStatus, backupListHolder);
      }
    });
    controlRow.append(nameInput, saveButton);
    card2.body.append(controlRow, controlStatus, backupListHolder);
    layout.appendChild(card2.root);
    view.appendChild(layout);
    refreshBackupList(controlStatus, backupListHolder);
  }
  function describeSurface(env) {
    if (!env) return "n/a";
    return env.surface === "discord" ? "Discord" : "Web";
  }
  function describePlatform(env, nav) {
    if (!env) return "n/a";
    if (env.platform === "desktop") {
      return "Desktop";
    }
    if (env.platform === "mobile") {
      const ua = nav?.userAgent ?? "";
      if (/tablet|ipad|playbook|silk|kindle/i.test(ua)) {
        return "Mobile (Tablet)";
      }
      if (/mobile|iphone|ipod|android/i.test(ua)) {
        return "Mobile (Phone)";
      }
      return "Mobile";
    }
    return env.platform;
  }
  function detectOsLabel(nav) {
    const platform = nav?.platform ?? "";
    const userAgent = nav?.userAgent ?? "";
    const target = `${platform} ${userAgent}`.toLowerCase();
    if (!target.trim()) {
      return "n/a";
    }
    if (/windows/.test(target)) return "Windows";
    if (/mac os|macintosh|darwin/.test(target)) return "macOS";
    if (/android/.test(target) && !/windows/.test(target)) return "Android";
    if (/iphone|ipad|ipod/.test(target)) return "iOS";
    if (/linux/.test(target) && !/android/.test(target)) return "Linux";
    if (/cros/.test(target)) return "Chrome OS";
    if (/freebsd/.test(target)) return "FreeBSD";
    if (/sunos|solaris/.test(target)) return "Solaris";
    return nav?.platform || nav?.userAgent || "Unknown";
  }
  function renderInfosTab(view, _ui) {
    view.innerHTML = "";
    const safeWindow = typeof window !== "undefined" ? window : null;
    const safeNavigator = typeof navigator !== "undefined" ? navigator : null;
    const safeLocation = typeof location !== "undefined" ? location : null;
    const environment = safeWindow ? detectEnvironment() : null;
    const resolvedGameVersion = gameVersion ?? "unknown";
    const resolvedModVersion = getLocalVersion() ?? "unknown";
    const header = document.createElement("div");
    header.style.display = "flex";
    header.style.flexDirection = "column";
    header.style.alignItems = "center";
    header.style.gap = "6px";
    header.style.padding = "18px 0 14px";
    header.style.textAlign = "center";
    const headerTitle = document.createElement("div");
    headerTitle.textContent = "Arie's Mod";
    headerTitle.style.fontSize = "18px";
    headerTitle.style.fontWeight = "700";
    headerTitle.style.color = "#e7eef7";
    headerTitle.style.letterSpacing = "-0.3px";
    const versionBadge = document.createElement("div");
    versionBadge.textContent = `v${resolvedModVersion}`;
    versionBadge.style.display = "inline-block";
    versionBadge.style.padding = "2px 10px";
    versionBadge.style.borderRadius = "999px";
    versionBadge.style.background = "rgba(94,234,212,0.12)";
    versionBadge.style.border = "1px solid rgba(94,234,212,0.25)";
    versionBadge.style.color = "#5eead4";
    versionBadge.style.fontSize = "11px";
    versionBadge.style.fontWeight = "600";
    versionBadge.style.letterSpacing = "0.3px";
    const headerSub = document.createElement("div");
    headerSub.textContent = "Browser userscript for MagicGarden";
    headerSub.style.fontSize = "11px";
    headerSub.style.color = "rgba(231,238,247,0.45)";
    headerSub.style.marginTop = "2px";
    header.append(headerTitle, versionBadge, headerSub);
    view.appendChild(header);
    const sep = document.createElement("div");
    sep.style.height = "1px";
    sep.style.background = "rgba(255,255,255,0.07)";
    sep.style.margin = "0 0 12px";
    view.appendChild(sep);
    const runtimeRows = [
      ["Game version", resolvedGameVersion],
      ["Host", environment?.host ?? safeLocation?.hostname ?? "n/a"],
      ["Surface", describeSurface(environment)],
      ["Platform", describePlatform(environment, safeNavigator)],
      ["OS", detectOsLabel(safeNavigator)]
    ];
    const grid = document.createElement("div");
    grid.style.display = "flex";
    grid.style.flexDirection = "column";
    grid.style.borderRadius = "10px";
    grid.style.border = "1px solid rgba(255,255,255,0.07)";
    grid.style.overflow = "hidden";
    grid.style.marginBottom = "14px";
    runtimeRows.forEach(([label2, value], i) => {
      const row = document.createElement("div");
      row.style.display = "flex";
      row.style.justifyContent = "space-between";
      row.style.alignItems = "center";
      row.style.padding = "8px 12px";
      row.style.background = i % 2 === 0 ? "rgba(255,255,255,0.02)" : "transparent";
      const labelEl = document.createElement("span");
      labelEl.textContent = label2;
      labelEl.style.fontSize = "12px";
      labelEl.style.color = "rgba(231,238,247,0.5)";
      const valueEl = document.createElement("span");
      valueEl.textContent = value;
      valueEl.style.fontSize = "12px";
      valueEl.style.fontWeight = "600";
      valueEl.style.color = "#e7eef7";
      row.append(labelEl, valueEl);
      grid.appendChild(row);
    });
    view.appendChild(grid);
    const supportBlock = document.createElement("div");
    supportBlock.style.display = "flex";
    supportBlock.style.flexDirection = "column";
    supportBlock.style.alignItems = "center";
    supportBlock.style.gap = "10px";
    supportBlock.style.padding = "16px 12px";
    supportBlock.style.borderRadius = "10px";
    supportBlock.style.border = "1px solid rgba(255,255,255,0.07)";
    supportBlock.style.background = "rgba(255,255,255,0.02)";
    const supportText = document.createElement("div");
    supportText.style.fontSize = "12px";
    supportText.style.lineHeight = "1.5";
    supportText.style.color = "rgba(231,238,247,0.55)";
    supportText.style.textAlign = "center";
    supportText.textContent = "Some features rely on paid server hosting. If you enjoy the mod, a coffee is always appreciated!";
    const kofiUrl = "https://ko-fi.com/E1E11TWTM1";
    const isDiscord = environment?.surface === "discord";
    const kofiButton = document.createElement("a");
    kofiButton.href = kofiUrl;
    kofiButton.target = "_blank";
    kofiButton.rel = "noopener noreferrer";
    kofiButton.title = "Buy Me a Coffee at ko-fi.com";
    kofiButton.style.transition = "opacity 0.15s ease, transform 0.15s ease";
    if (isDiscord) {
      kofiButton.textContent = "\u2615 Support on Ko-fi";
      kofiButton.style.display = "inline-flex";
      kofiButton.style.alignItems = "center";
      kofiButton.style.padding = "8px 20px";
      kofiButton.style.borderRadius = "8px";
      kofiButton.style.background = "rgba(94,234,212,0.1)";
      kofiButton.style.border = "1px solid rgba(94,234,212,0.28)";
      kofiButton.style.color = "#5eead4";
      kofiButton.style.fontSize = "13px";
      kofiButton.style.fontWeight = "600";
      kofiButton.style.textDecoration = "none";
      kofiButton.style.cursor = "pointer";
    } else {
      kofiButton.style.display = "inline-block";
      kofiButton.style.border = "0";
      const kofiImg = document.createElement("img");
      kofiImg.src = "https://storage.ko-fi.com/cdn/kofi5.png?v=6";
      kofiImg.alt = "Buy Me a Coffee at ko-fi.com";
      kofiImg.height = 36;
      kofiImg.style.height = "36px";
      kofiImg.style.border = "0";
      kofiImg.style.display = "block";
      kofiButton.appendChild(kofiImg);
    }
    kofiButton.addEventListener("click", (event) => {
      if (isDiscord && typeof GM_openInTab === "function") {
        event.preventDefault();
        GM_openInTab(kofiUrl, { active: true });
      }
    });
    kofiButton.addEventListener("mouseenter", () => {
      kofiButton.style.opacity = "0.82";
      kofiButton.style.transform = "translateY(-2px)";
    });
    kofiButton.addEventListener("mouseleave", () => {
      kofiButton.style.opacity = "1";
      kofiButton.style.transform = "translateY(0)";
    });
    supportBlock.append(supportText, kofiButton);
    view.appendChild(supportBlock);
  }
  function renderSettingsMenu(container) {
    const ui = new Menu({ id: "settings", compact: true });
    ui.mount(container);
    ui.addTabs([
      { id: "settings-data", title: "Settings", render: (root) => renderDataTab(root, ui) },
      { id: "settings-infos", title: "Infos", render: (root) => renderInfosTab(root, ui) }
    ]);
    ui.switchTo("settings-data");
  }

  // src/services/tools.ts
  var TOOL_LIST = [
    {
      id: "aries-mod-intro",
      title: "Arie's Mod introduction",
      description: "Visual guide for the mod with the main features highlighted",
      url: "https://i.imgur.com/LZL6zPj.jpeg",
      icon: "",
      showInlinePreview: true,
      tags: ["guide", "mod"],
      creators: [
        {
          name: "Bella",
          avatar: "https://cdn.discordapp.com/avatars/1400054123969380354/241dfc8a181b9e4b9dab6f1ac4f7567a.webp"
        }
      ]
    },
    {
      id: "wiki",
      title: "Magic Garden Wiki",
      description: "Community-curated documentation for plants, mechanics, weather, and more.",
      url: "https://magicgarden.wiki/Main_Page",
      icon: "https://i.imgur.com/0LXKEzh.png",
      tags: ["guide", "utility"],
      creators: [
        {
          name: "Community"
        }
      ]
    },
    {
      id: "qpm",
      title: "QPM Mod Menu",
      description: "Mod/userscript focused on game stats, adding pet analytics, inventory helpers and shop/weather tracking",
      url: "",
      icon: "",
      tags: ["mod"],
      actions: [
        {
          label: "Github",
          url: "https://github.com/ryandt2305-cpu/QPM-GR/"
        },
        {
          label: "Install",
          url: "https://github.com/ryandt2305-cpu/QPM-GR/raw/refs/heads/master/dist/QPM.user.js"
        }
      ],
      creators: [
        {
          name: "Tokyo",
          avatar: "https://cdn.discordapp.com/avatars/511094276613210122/c2af3c8ff2123724ba49b7e897d0ce97.png"
        }
      ]
    },
    {
      id: "calculator",
      title: "Daserix' Magic Garden Calculators",
      description: "Calculate crop value based on size and mutations, with garden import for total optimisation stats",
      url: "https://daserix.github.io/magic-garden-calculator/",
      icon: "https://i.imgur.com/xXPqRgK.png",
      tags: ["utility"],
      creators: [
        {
          name: "Daserix",
          avatar: "https://cdn.discordapp.com/avatars/266245650662817793/09de28b070e0a107eb1bea1fe015afc3.webp"
        }
      ]
    },
    {
      id: "mg-android-notifier",
      title: "Magic Garden Notifier",
      description: "Android app that sends push notifications/alarms when selected shop items restock, with configurable thresholds and background monitoring",
      url: "",
      icon: "https://i.imgur.com/l3NHmc5.png",
      tags: ["utility", "android"],
      actions: [
        {
          label: "Github",
          url: "https://github.com/Daserix/magic-garden-notifier-releases"
        },
        {
          label: "Install",
          url: "https://github.com/Daserix/magic-garden-notifier-releases/releases/download/v1.1.0/mg-notifier-1.1.0.apk"
        }
      ],
      creators: [
        {
          name: "Daserix",
          avatar: "https://cdn.discordapp.com/avatars/266245650662817793/09de28b070e0a107eb1bea1fe015afc3.png"
        }
      ]
    },
    {
      id: "guide-1b",
      title: "Making Your First 1B",
      description: "Beginner-friendly step-by-step guide to earning your first 1B coins, covering early crop choices, key pets, and long-term strategy",
      url: "https://i.imgur.com/gs6Karj.png",
      icon: "",
      showInlinePreview: true,
      tags: ["guide"],
      creators: [
        {
          name: "Bella",
          avatar: "https://cdn.discordapp.com/avatars/1400054123969380354/241dfc8a181b9e4b9dab6f1ac4f7567a.png"
        }
      ]
    },
    {
      id: "visual-guides",
      title: "Visual guides",
      description: "Visual guides covering crops/multiplier stacking and pet info (eggs, hatch rates, abilities), plus beginner tips to avoid common mistakes",
      url: "",
      icon: "",
      tags: ["guide"],
      actions: [
        {
          label: "Crops & Multipliers",
          url: "https://i.imgur.com/86TuVYh.jpeg",
          showInlinePreview: true
        },
        {
          label: "Pets",
          url: "https://i.imgur.com/bx2qX8i.jpeg",
          showInlinePreview: true
        },
        {
          label: "Winter event",
          url: "https://i.imgur.com/Ew9xBk6.jpeg",
          showInlinePreview: true
        }
      ],
      creators: [
        {
          name: "Foraged Rituals",
          avatar: "https://cdn.discordapp.com/avatars/1065631808072450164/40be204333c0f3f7c5f3ce1d8636ff77.png"
        }
      ]
    },
    {
      id: "pet-diet-visual-guides",
      title: "Pet diet visual guides",
      description: "Rarity-based pet diet guides focused on food restoration percentages",
      url: "",
      icon: "",
      showInlinePreview: true,
      tags: ["guide"],
      actions: [
        {
          label: "Common",
          url: "https://i.imgur.com/sOXepq1.jpeg",
          showInlinePreview: true
        },
        {
          label: "Uncommon",
          url: "https://i.imgur.com/3weyngx.jpeg",
          showInlinePreview: true
        },
        {
          label: "Rare",
          url: "https://i.imgur.com/n8KPA7L.jpeg",
          showInlinePreview: true
        },
        {
          label: "Winter",
          url: "https://i.imgur.com/CBKjqiN.jpeg",
          showInlinePreview: true
        },
        {
          label: "Legendary",
          url: "https://i.imgur.com/YD00B5U.jpeg",
          showInlinePreview: true
        },
        {
          label: "Mythical",
          url: "https://i.imgur.com/ybcdHxC.jpeg",
          showInlinePreview: true
        }
      ],
      creators: [
        {
          name: "Bella",
          avatar: "https://cdn.discordapp.com/avatars/1400054123969380354/241dfc8a181b9e4b9dab6f1ac4f7567a.webp"
        }
      ]
    },
    {
      id: "mgtools",
      title: "MGTools",
      description: "Mod/userscript adding pet management, ability tracking, calculators, timers, and a customizable UI",
      url: "",
      actions: [
        {
          label: "Discord",
          url: "https://discord.gg/qFpQ436HZc"
        },
        {
          label: "Github",
          url: "https://github.com/Myke247/MGTools/"
        },
        {
          label: "Install",
          url: "https://github.com/Umm12many/MGTools-M/raw/refs/heads/main/MGTools.user.js"
        }
      ],
      icon: "https://cdn.discordapp.com/icons/1428162440297840640/23c0c05e578d5eb307febb4b562626e9.webp",
      tags: ["mod"],
      creators: [
        {
          name: "Myke",
          avatar: "https://cdn.discordapp.com/avatars/184699074543484928/ca44cd2f0f3002b2455a9805986eeac9.webp"
        },
        {
          name: "Normie",
          avatar: "https://cdn.discordapp.com/avatars/375367702094544898/ebd1ef1279c16a4ab8e73ee9fbd70148.png"
        }
      ]
    },
    {
      id: "mg-android",
      title: "Magic Garden Android App",
      description: "Basic Android companion app for Magic Garden (early build, not actively maintained)",
      url: "https://appdistribution.firebase.dev/i/cde454c6e9eb5f30",
      icon: "",
      tags: ["android"],
      creators: [
        {
          name: "Umm12many",
          avatar: "https://cdn.discordapp.com/avatars/925833066310672465/ad6f0f9d27e1a4b1acebf6987b3d7c39.png"
        }
      ]
    }
  ];
  var TOOL_TAGS = Array.from(
    new Set(
      TOOL_LIST.flatMap((tool) => {
        return tool.tags ?? [];
      })
    )
  ).sort((a, b) => a.localeCompare(b));
  function cloneTool(tool) {
    return {
      ...tool,
      tags: tool.tags ? [...tool.tags] : void 0,
      actions: tool.actions ? tool.actions.map((action2) => ({ ...action2 })) : void 0,
      showInlinePreview: tool.showInlinePreview
    };
  }
  function resolve(tool) {
    if (typeof tool === "string") {
      const found = TOOL_LIST.find((entry) => entry.id === tool);
      return found ? cloneTool(found) : null;
    }
    return cloneTool(tool);
  }
  function openUrl(url) {
    if (typeof GM_openInTab === "function") {
      GM_openInTab(url, { active: true, insert: true });
      return true;
    }
    if (typeof window === "undefined") return false;
    try {
      const a = document.createElement("a");
      a.href = url;
      a.target = "_blank";
      a.rel = "noopener noreferrer";
      document.body.appendChild(a);
      a.click();
      a.remove();
      return true;
    } catch {
      return false;
    }
  }
  function openLink(url) {
    return openUrl(url);
  }
  var ToolsService = {
    list() {
      const list = TOOL_LIST.map(cloneTool);
      return list;
    },
    tags() {
      return TOOL_TAGS.map((tag) => tag);
    },
    get(id) {
      const found = TOOL_LIST.find((tool) => tool.id === id);
      const entry = found ? cloneTool(found) : null;
      return entry;
    },
    open(tool) {
      const entry = resolve(tool);
      if (!entry) {
        return false;
      }
      const ok = openUrl(entry.url);
      return ok;
    }
  };

  // src/ui/menus/tools.ts
  function createTagPill(label2) {
    const pill = document.createElement("span");
    pill.textContent = label2;
    pill.style.display = "inline-flex";
    pill.style.alignItems = "center";
    pill.style.justifyContent = "center";
    pill.style.padding = "2px 8px";
    pill.style.borderRadius = "999px";
    pill.style.background = "#ffffff11";
    pill.style.border = "1px solid #ffffff22";
    pill.style.fontSize = "11px";
    pill.style.letterSpacing = "0.02em";
    pill.style.textTransform = "uppercase";
    pill.style.opacity = "0.8";
    return pill;
  }
  function renderToolCard(ui, tool) {
    async function fetchImageBlob(url) {
      if (typeof GM_xmlhttpRequest === "function") {
        try {
          return await new Promise((resolve2, reject) => {
            GM_xmlhttpRequest({
              method: "GET",
              url,
              responseType: "blob",
              timeout: 15e3,
              onload: (response) => {
                const blob = response.response;
                if (response.status >= 200 && response.status < 300 && blob instanceof Blob) {
                  resolve2(blob);
                } else {
                  reject(new Error(`GM_xmlhttpRequest failed: ${response.status}`));
                }
              },
              onerror: () => reject(new Error("GM_xmlhttpRequest error")),
              ontimeout: () => reject(new Error("GM_xmlhttpRequest timeout")),
              onabort: () => reject(new Error("GM_xmlhttpRequest aborted"))
            });
          });
        } catch (error) {
          console.warn("[Tools] GM_xmlhttpRequest failed, fallback to fetch", error);
        }
      }
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) {
        throw new Error(`HTTP ${res.status} while loading ${url}`);
      }
      return await res.blob();
    }
    const isIconUrl = !!tool.icon && /^https?:\/\//i.test(tool.icon);
    const card2 = ui.card("", { tone: "muted", align: "stretch" });
    card2.root.style.width = "100%";
    const body = card2.body;
    body.style.display = "grid";
    body.style.gap = "10px";
    body.style.justifyItems = "stretch";
    const header = document.createElement("div");
    header.style.display = "flex";
    header.style.alignItems = "center";
    header.style.gap = "10px";
    if (isIconUrl) {
      const img = document.createElement("img");
      img.alt = `${tool.title} icon`;
      img.style.width = "22px";
      img.style.height = "22px";
      img.style.objectFit = "contain";
      img.style.borderRadius = "0";
      img.style.border = "none";
      img.style.background = "none";
      img.style.padding = "0";
      img.style.margin = "0";
      img.style.boxShadow = "none";
      img.style.display = "block";
      img.style.flexShrink = "0";
      img.style.mixBlendMode = "screen";
      img.style.isolation = "isolate";
      header.appendChild(img);
      void (async () => {
        try {
          const blob = await fetchImageBlob(tool.icon);
          const objectUrl = URL.createObjectURL(blob);
          img.onload = () => {
            URL.revokeObjectURL(objectUrl);
          };
          img.src = objectUrl;
        } catch (error) {
          console.warn("[Tools] Unable to load icon via GM, fallback to direct src", error);
          img.src = tool.icon;
        }
      })();
    } else if (tool.icon) {
      const iconSpan = document.createElement("span");
      iconSpan.textContent = tool.icon;
      iconSpan.style.fontSize = "18px";
      header.appendChild(iconSpan);
    }
    const titleText = document.createElement("span");
    titleText.textContent = tool.title;
    titleText.style.fontSize = "15px";
    titleText.style.fontWeight = "700";
    header.appendChild(titleText);
    body.appendChild(header);
    const description = document.createElement("p");
    description.textContent = tool.description;
    description.style.margin = "0";
    description.style.fontSize = "13px";
    description.style.lineHeight = "1.45";
    description.style.opacity = "0.9";
    description.style.textAlign = "left";
    body.appendChild(description);
    if (tool.tags?.length || tool.creators?.length) {
      const metaRow = document.createElement("div");
      metaRow.style.display = "flex";
      metaRow.style.flexWrap = "wrap";
      metaRow.style.alignItems = "center";
      metaRow.style.justifyContent = "space-between";
      metaRow.style.gap = "10px";
      const tags = document.createElement("div");
      tags.style.display = "flex";
      tags.style.flexWrap = "wrap";
      tags.style.gap = "6px";
      tags.style.opacity = "0.85";
      if (tool.tags?.length) {
        tool.tags.forEach((tag) => tags.appendChild(createTagPill(tag)));
      }
      metaRow.appendChild(tags);
      if (tool.creators?.length) {
        const creators = document.createElement("div");
        creators.style.display = "flex";
        creators.style.flexWrap = "wrap";
        creators.style.gap = "6px";
        tool.creators.forEach((creatorInfo) => {
          const chip = document.createElement("div");
          chip.style.display = "inline-flex";
          chip.style.alignItems = "center";
          chip.style.gap = "8px";
          chip.style.padding = "4px 8px";
          chip.style.background = "#ffffff0c";
          chip.style.border = "1px solid #ffffff18";
          chip.style.borderRadius = "999px";
          if (creatorInfo.avatar) {
            const avatar2 = document.createElement("img");
            avatar2.src = creatorInfo.avatar;
            avatar2.alt = creatorInfo.name;
            avatar2.style.width = "26px";
            avatar2.style.height = "26px";
            avatar2.style.borderRadius = "999px";
            avatar2.style.objectFit = "cover";
            avatar2.style.border = "1px solid #ffffff22";
            chip.appendChild(avatar2);
          }
          const name = document.createElement("span");
          name.textContent = creatorInfo.name;
          name.style.fontSize = "12px";
          name.style.fontWeight = "600";
          chip.appendChild(name);
          creators.appendChild(chip);
        });
        metaRow.appendChild(creators);
      }
      body.appendChild(metaRow);
    }
    const actionsRow = ui.flexRow({ gap: 8, justify: "end", fullWidth: true });
    actionsRow.style.marginTop = "4px";
    const shouldShowInlinePreview = tool.showInlinePreview ?? false;
    const openInlinePreview = (url, title) => {
      let objectUrl;
      let zoomed = false;
      let lastOrigin = "center center";
      let closed = false;
      const overlay = document.createElement("div");
      overlay.style.position = "fixed";
      overlay.style.inset = "0";
      overlay.style.background = "rgba(0,0,0,0.72)";
      overlay.style.backdropFilter = "blur(4px)";
      overlay.style.zIndex = "9999";
      overlay.style.display = "grid";
      overlay.style.placeItems = "center";
      overlay.style.padding = "20px";
      const box = document.createElement("div");
      box.style.position = "relative";
      box.style.maxWidth = "90vw";
      box.style.maxHeight = "90vh";
      box.style.background = "#0f1318";
      box.style.border = "1px solid #ffffff22";
      box.style.borderRadius = "12px";
      box.style.boxShadow = "0 20px 50px rgba(0,0,0,0.45)";
      box.style.overflow = "hidden";
      const close = document.createElement("button");
      close.textContent = "\u2715";
      close.style.position = "absolute";
      close.style.top = "8px";
      close.style.right = "8px";
      close.style.border = "1px solid #ffffff33";
      close.style.borderRadius = "8px";
      close.style.background = "#0009";
      close.style.color = "#fff";
      close.style.width = "32px";
      close.style.height = "32px";
      close.style.cursor = "pointer";
      close.style.fontSize = "16px";
      close.style.lineHeight = "1";
      close.style.display = "grid";
      close.style.placeItems = "center";
      close.style.zIndex = "2";
      close.onclick = () => {
        if (objectUrl) {
          URL.revokeObjectURL(objectUrl);
        }
        closed = true;
        overlay.remove();
      };
      const status = document.createElement("div");
      status.textContent = "Loading preview...";
      status.style.padding = "14px 18px";
      status.style.fontSize = "13px";
      status.style.opacity = "0.85";
      const img = document.createElement("img");
      img.alt = title ?? tool.title;
      img.style.display = "block";
      img.style.maxWidth = "100%";
      img.style.maxHeight = "90vh";
      img.style.objectFit = "contain";
      img.style.transition = "transform 200ms ease";
      img.style.cursor = "zoom-in";
      img.style.display = "none";
      const toggleZoom = (event) => {
        if (!zoomed && event) {
          const rect = img.getBoundingClientRect();
          const x = Math.min(Math.max((event.clientX - rect.left) / rect.width, 0), 1) * 100;
          const y = Math.min(Math.max((event.clientY - rect.top) / rect.height, 0), 1) * 100;
          lastOrigin = `${x}% ${y}%`;
          img.style.transformOrigin = lastOrigin;
        }
        zoomed = !zoomed;
        img.style.transform = zoomed ? "scale(1.8)" : "scale(1)";
        img.style.cursor = zoomed ? "zoom-out" : "zoom-in";
      };
      img.onclick = (event) => {
        event.stopPropagation();
        toggleZoom(event);
      };
      box.append(close, status, img);
      overlay.appendChild(box);
      overlay.onclick = (ev) => {
        if (ev.target === overlay) {
          if (objectUrl) {
            URL.revokeObjectURL(objectUrl);
          }
          closed = true;
          overlay.remove();
        }
      };
      document.body.appendChild(overlay);
      void fetchImageBlob(url).then((blob) => {
        if (closed) return;
        objectUrl = URL.createObjectURL(blob);
        img.src = objectUrl;
        status.remove();
        img.style.display = "block";
      }).catch((error) => {
        if (closed) return;
        console.warn("[Tools] Unable to load preview", error);
        status.textContent = "Unable to load preview. Please open the link manually.";
        status.style.color = "#ffb3b3";
        img.style.display = "none";
      });
    };
    const showActionToast = () => {
      void toastSimple("Unable to open link", "Please open the address manually.", "error");
    };
    if (tool.actions?.length) {
      actionsRow.style.display = "grid";
      actionsRow.style.width = "100%";
      actionsRow.style.gridTemplateColumns = "repeat(auto-fit, minmax(140px, 1fr))";
      actionsRow.style.alignItems = "stretch";
      actionsRow.style.justifyContent = "stretch";
      tool.actions.forEach((action2) => {
        const actionBtn = ui.btn(action2.label, {
          variant: "primary",
          title: `Open ${action2.label}`
        });
        actionBtn.style.flex = "1 1 0";
        actionBtn.style.minWidth = "0";
        actionBtn.onclick = () => {
          if (action2.showInlinePreview) {
            openInlinePreview(action2.url, action2.label);
            return;
          }
          const ok = openLink(action2.url);
          if (!ok) {
            showActionToast();
          }
        };
        actionsRow.append(actionBtn);
      });
    } else {
      const openBtn = ui.btn("Open tool", {
        variant: "primary",
        icon: "\u{1F517}",
        fullWidth: true,
        title: "Open the tool in a new tab"
      });
      openBtn.style.flex = "1 1 auto";
      openBtn.style.minWidth = "0";
      openBtn.onclick = () => {
        if (shouldShowInlinePreview) {
          openInlinePreview(tool.url, tool.title);
        } else {
          const ok = ToolsService.open(tool);
          if (!ok) {
            showActionToast();
          }
        }
      };
      actionsRow.append(openBtn);
    }
    body.appendChild(actionsRow);
    return card2.root;
  }
  async function renderToolsMenu(container) {
    const ui = new Menu({ id: "tools", compact: true });
    ui.mount(container);
    const view = ui.root.querySelector(".qmm-views");
    view.innerHTML = "";
    view.style.display = "flex";
    view.style.flexDirection = "column";
    view.style.gap = "12px";
    view.style.alignItems = "center";
    view.style.padding = "8px";
    view.style.width = "100%";
    view.style.maxHeight = "70vh";
    view.style.overflowY = "auto";
    view.style.overflowX = "auto";
    const WRAPPER_WIDTH = 720;
    const wrapper = document.createElement("div");
    wrapper.style.display = "flex";
    wrapper.style.flexDirection = "column";
    wrapper.style.gap = "12px";
    wrapper.style.width = `${WRAPPER_WIDTH}px`;
    wrapper.style.minWidth = `${WRAPPER_WIDTH}px`;
    wrapper.style.maxWidth = `${WRAPPER_WIDTH}px`;
    wrapper.style.boxSizing = "border-box";
    wrapper.style.alignSelf = "center";
    const intro = ui.card("\u{1F9F0} Community tools", {
      tone: "muted",
      align: "stretch"
    });
    const introText = document.createElement("p");
    introText.textContent = "Discover community-made helpers to plan, calculate, and simplify your Magic Garden adventures.";
    introText.style.margin = "0";
    introText.style.fontSize = "13px";
    introText.style.lineHeight = "1.5";
    introText.style.opacity = "0.9";
    introText.style.textAlign = "left";
    intro.body.appendChild(introText);
    wrapper.appendChild(intro.root);
    const allTools = ToolsService.list();
    const filterSection = document.createElement("div");
    filterSection.style.display = "flex";
    filterSection.style.flexDirection = "column";
    filterSection.style.gap = "8px";
    filterSection.style.background = "#ffffff08";
    filterSection.style.border = "1px solid #ffffff11";
    filterSection.style.borderRadius = "12px";
    filterSection.style.padding = "12px";
    const filterTitle = document.createElement("span");
    filterTitle.textContent = "Filter by tags";
    filterTitle.style.fontSize = "12px";
    filterTitle.style.letterSpacing = "0.05em";
    filterTitle.style.textTransform = "uppercase";
    filterTitle.style.opacity = "0.75";
    filterTitle.style.fontWeight = "600";
    const filterControls = document.createElement("div");
    filterControls.style.display = "flex";
    filterControls.style.flexWrap = "wrap";
    filterControls.style.gap = "8px";
    const selectedTags = /* @__PURE__ */ new Set();
    const tagButtons = /* @__PURE__ */ new Map();
    let allButton;
    let cardsContainer;
    const filterBtnBaseStyle = (btn) => {
      btn.type = "button";
      btn.style.display = "inline-flex";
      btn.style.alignItems = "center";
      btn.style.justifyContent = "center";
      btn.style.padding = "4px 10px";
      btn.style.borderRadius = "999px";
      btn.style.border = "1px solid";
      btn.style.background = "#ffffff11";
      btn.style.borderColor = "#ffffff22";
      btn.style.fontSize = "11px";
      btn.style.fontWeight = "600";
      btn.style.letterSpacing = "0.03em";
      btn.style.textTransform = "uppercase";
      btn.style.color = "inherit";
      btn.style.opacity = "0.85";
      btn.style.cursor = "pointer";
      btn.style.transition = "background 120ms ease, border-color 120ms ease, opacity 120ms ease";
    };
    const setActiveState = (btn, active) => {
      if (active) {
        btn.style.background = "#2d8cff33";
        btn.style.borderColor = "#2d8cff66";
        btn.style.opacity = "1";
      } else {
        btn.style.background = "#ffffff11";
        btn.style.borderColor = "#ffffff22";
        btn.style.opacity = "0.85";
      }
    };
    const renderList = () => {
      cardsContainer.innerHTML = "";
      const filtered = selectedTags.size ? allTools.filter((tool) => tool.tags?.some((tag) => selectedTags.has(tag))) : allTools;
      if (filtered.length === 0) {
        const empty = document.createElement("p");
        empty.textContent = "No tools match the selected tags yet.";
        empty.style.margin = "12px 0 0";
        empty.style.fontSize = "13px";
        empty.style.opacity = "0.75";
        empty.style.textAlign = "center";
        empty.style.gridColumn = "1 / -1";
        cardsContainer.appendChild(empty);
        return;
      }
      filtered.forEach((tool) => {
        cardsContainer.appendChild(renderToolCard(ui, tool));
      });
    };
    const refreshButtonStates = () => {
      tagButtons.forEach((btn, tag) => {
        setActiveState(btn, selectedTags.has(tag));
      });
      setActiveState(allButton, selectedTags.size === 0);
    };
    const handleToggle = (tag) => {
      if (selectedTags.has(tag)) {
        selectedTags.delete(tag);
      } else {
        selectedTags.add(tag);
      }
      refreshButtonStates();
      renderList();
    };
    allButton = document.createElement("button");
    allButton.textContent = "All";
    filterBtnBaseStyle(allButton);
    allButton.onclick = () => {
      if (selectedTags.size === 0) return;
      selectedTags.clear();
      refreshButtonStates();
      renderList();
    };
    filterControls.appendChild(allButton);
    ToolsService.tags().forEach((tag) => {
      const btn = document.createElement("button");
      btn.textContent = tag;
      filterBtnBaseStyle(btn);
      btn.onclick = () => handleToggle(tag);
      filterControls.appendChild(btn);
      tagButtons.set(tag, btn);
    });
    filterSection.appendChild(filterTitle);
    filterSection.appendChild(filterControls);
    wrapper.appendChild(filterSection);
    cardsContainer = document.createElement("div");
    cardsContainer.style.display = "grid";
    cardsContainer.style.gridTemplateColumns = "repeat(auto-fit, minmax(320px, 1fr))";
    cardsContainer.style.gap = "12px";
    renderList();
    refreshButtonStates();
    wrapper.appendChild(cardsContainer);
    view.appendChild(wrapper);
  }

  // src/ui/menus/editor.ts
  var STYLE_ID4 = "qws-editor-menu-css";
  var TEAL = "#5eead4";
  var TEAL_DIM = "rgba(94,234,212,0.12)";
  var TEAL_MID = "rgba(94,234,212,0.22)";
  var TEAL_BORDER = "rgba(94,234,212,0.3)";
  var TEAL_BRD_HI = "rgba(94,234,212,0.55)";
  var BORDER = "rgba(255,255,255,0.08)";
  var BORDER_HI = "rgba(255,255,255,0.16)";
  var CARD_BG = "rgba(255,255,255,0.03)";
  var CARD_BG_HI = "rgba(255,255,255,0.06)";
  var TEXT = "#e7eef7";
  var TEXT_DIM = "rgba(226,232,240,0.45)";
  var DANGER = "#ef4444";
  var DANGER_DIM = "rgba(239,68,68,0.12)";
  var DANGER_BRD = "rgba(239,68,68,0.3)";
  var DANGER_HI = "rgba(239,68,68,0.2)";
  var DANGER_BRD_HI = "rgba(239,68,68,0.55)";
  function ensureStyles3() {
    if (document.getElementById(STYLE_ID4)) return;
    const st = document.createElement("style");
    st.id = STYLE_ID4;
    st.textContent = `
.qws-ed-scroll::-webkit-scrollbar { width: 6px; }
.qws-ed-scroll::-webkit-scrollbar-track { background: transparent; }
.qws-ed-scroll::-webkit-scrollbar-thumb { background: rgba(94,234,212,0.2); border-radius: 3px; }
.qws-ed-scroll::-webkit-scrollbar-thumb:hover { background: rgba(94,234,212,0.35); }
.qws-ed-scroll { scrollbar-width: thin; scrollbar-color: rgba(94,234,212,0.2) transparent; }

/* Toggle switch */
.qws-ed-toggle { position:relative; display:inline-block; width:36px; height:20px; cursor:pointer; flex-shrink:0; }
.qws-ed-toggle input { opacity:0; width:0; height:0; position:absolute; }
.qws-ed-track {
  position:absolute; inset:0; border-radius:10px;
  background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.12);
  transition:background 150ms ease, border-color 150ms ease;
}
.qws-ed-toggle input:checked ~ .qws-ed-track {
  background:rgba(94,234,212,0.25); border-color:rgba(94,234,212,0.5);
}
.qws-ed-thumb {
  position:absolute; top:3px; left:3px;
  width:12px; height:12px; border-radius:50%;
  background:rgba(226,232,240,0.5);
  transition:transform 150ms ease, background 150ms ease;
}
.qws-ed-toggle input:checked ~ .qws-ed-track .qws-ed-thumb {
  transform:translateX(16px); background:${TEAL};
}
`;
    document.head.appendChild(st);
  }
  var css = (el2, s) => Object.assign(el2.style, s);
  function sectionLabel(text) {
    const el2 = document.createElement("div");
    css(el2, {
      fontSize: "10px",
      fontWeight: "700",
      letterSpacing: "0.08em",
      color: TEXT_DIM,
      textTransform: "uppercase",
      paddingBottom: "7px"
    });
    el2.textContent = text;
    return el2;
  }
  function card(children) {
    const el2 = document.createElement("div");
    css(el2, {
      padding: "14px",
      background: CARD_BG,
      borderRadius: "12px",
      border: `1px solid ${BORDER}`,
      display: "flex",
      flexDirection: "column",
      gap: "10px"
    });
    el2.append(...children);
    return el2;
  }
  function primaryBtn(label2, onClick) {
    const btn = document.createElement("button");
    css(btn, {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      gap: "6px",
      padding: "10px 14px",
      border: `1px solid ${TEAL_BORDER}`,
      borderRadius: "10px",
      background: TEAL_DIM,
      color: TEAL,
      fontSize: "12px",
      fontWeight: "600",
      cursor: "pointer",
      transition: "all 120ms ease",
      flex: "1"
    });
    btn.textContent = label2;
    btn.onmouseenter = () => css(btn, { background: TEAL_MID, borderColor: TEAL_BRD_HI });
    btn.onmouseleave = () => css(btn, { background: TEAL_DIM, borderColor: TEAL_BORDER });
    btn.onclick = async () => {
      css(btn, { opacity: "0.6", pointerEvents: "none" });
      try {
        await onClick();
      } finally {
        css(btn, { opacity: "1", pointerEvents: "auto" });
      }
    };
    return btn;
  }
  function secondaryBtn(label2, onClick) {
    const btn = document.createElement("button");
    css(btn, {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      padding: "10px 14px",
      border: `1px solid ${BORDER}`,
      borderRadius: "10px",
      background: CARD_BG,
      color: TEXT,
      fontSize: "12px",
      fontWeight: "500",
      cursor: "pointer",
      transition: "all 120ms ease",
      flex: "1"
    });
    btn.textContent = label2;
    btn.onmouseenter = () => css(btn, { background: CARD_BG_HI, borderColor: BORDER_HI });
    btn.onmouseleave = () => css(btn, { background: CARD_BG, borderColor: BORDER });
    btn.onclick = async () => {
      css(btn, { opacity: "0.6", pointerEvents: "none" });
      try {
        await onClick();
      } finally {
        css(btn, { opacity: "1", pointerEvents: "auto" });
      }
    };
    return btn;
  }
  function dangerBtn(label2, onClick) {
    const btn = document.createElement("button");
    css(btn, {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      padding: "7px 11px",
      border: `1px solid ${DANGER_BRD}`,
      borderRadius: "8px",
      background: DANGER_DIM,
      color: DANGER,
      fontSize: "11px",
      fontWeight: "600",
      cursor: "pointer",
      transition: "all 120ms ease",
      flexShrink: "0"
    });
    btn.textContent = label2;
    btn.onmouseenter = () => css(btn, { background: DANGER_HI, borderColor: DANGER_BRD_HI });
    btn.onmouseleave = () => css(btn, { background: DANGER_DIM, borderColor: DANGER_BRD });
    btn.onclick = async () => {
      css(btn, { opacity: "0.6", pointerEvents: "none" });
      try {
        await onClick();
      } finally {
        css(btn, { opacity: "1", pointerEvents: "auto" });
      }
    };
    return btn;
  }
  function smallBtn(label2, teal, onClick) {
    const btn = document.createElement("button");
    css(btn, {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      padding: "7px 11px",
      border: `1px solid ${teal ? TEAL_BORDER : BORDER}`,
      borderRadius: "8px",
      background: teal ? TEAL_DIM : CARD_BG,
      color: teal ? TEAL : TEXT,
      fontSize: "11px",
      fontWeight: "600",
      cursor: "pointer",
      transition: "all 120ms ease",
      flexShrink: "0"
    });
    btn.textContent = label2;
    btn.onmouseenter = () => css(btn, { background: teal ? TEAL_MID : CARD_BG_HI, borderColor: teal ? TEAL_BRD_HI : BORDER_HI });
    btn.onmouseleave = () => css(btn, { background: teal ? TEAL_DIM : CARD_BG, borderColor: teal ? TEAL_BORDER : BORDER });
    btn.onclick = async () => {
      css(btn, { opacity: "0.6", pointerEvents: "none" });
      try {
        await onClick();
      } finally {
        css(btn, { opacity: "1", pointerEvents: "auto" });
      }
    };
    return btn;
  }
  function styledInput(placeholder) {
    const input = document.createElement("input");
    input.type = "text";
    input.placeholder = placeholder;
    css(input, {
      width: "100%",
      padding: "9px 12px",
      border: `1px solid ${BORDER}`,
      borderRadius: "10px",
      background: "rgba(255,255,255,0.06)",
      color: TEXT,
      fontSize: "12px",
      outline: "none",
      transition: "border-color 150ms ease",
      boxSizing: "border-box"
    });
    input.addEventListener("focus", () => css(input, { borderColor: TEAL_BORDER }));
    input.addEventListener("blur", () => css(input, { borderColor: BORDER }));
    return input;
  }
  function styledTextarea(placeholder) {
    const ta = document.createElement("textarea");
    ta.placeholder = placeholder;
    css(ta, {
      width: "100%",
      minHeight: "80px",
      padding: "9px 12px",
      border: `1px solid ${BORDER}`,
      borderRadius: "10px",
      background: "rgba(255,255,255,0.06)",
      color: TEXT,
      fontSize: "11px",
      fontFamily: "monospace",
      outline: "none",
      resize: "vertical",
      transition: "border-color 150ms ease",
      boxSizing: "border-box"
    });
    ta.addEventListener("focus", () => css(ta, { borderColor: TEAL_BORDER }));
    ta.addEventListener("blur", () => css(ta, { borderColor: BORDER }));
    return ta;
  }
  function createToggle(checked, onChange) {
    const label2 = document.createElement("label");
    label2.className = "qws-ed-toggle";
    const input = document.createElement("input");
    input.type = "checkbox";
    input.checked = checked;
    input.addEventListener("change", () => onChange(input.checked));
    const track = document.createElement("div");
    track.className = "qws-ed-track";
    const thumb = document.createElement("div");
    thumb.className = "qws-ed-thumb";
    track.appendChild(thumb);
    label2.append(input, track);
    return label2;
  }
  function renderEditorMenu(container) {
    ensureStyles3();
    css(container, { padding: "0", overflow: "hidden" });
    const wrap = document.createElement("div");
    wrap.className = "qws-ed-scroll";
    css(wrap, {
      display: "flex",
      flexDirection: "column",
      gap: "12px",
      padding: "14px",
      overflowY: "auto",
      height: "100%",
      boxSizing: "border-box",
      background: "linear-gradient(160deg, rgba(15,20,30,0.95) 0%, rgba(10,14,20,0.95) 60%, rgba(8,12,18,0.96) 100%)"
    });
    container.appendChild(wrap);
    const statusEl = document.createElement("div");
    css(statusEl, {
      fontSize: "11px",
      color: TEXT_DIM,
      minHeight: "16px",
      paddingLeft: "2px",
      transition: "opacity 200ms ease"
    });
    function setStatus(msg, tone = "ok") {
      statusEl.textContent = msg;
      statusEl.style.color = tone === "err" ? DANGER : tone === "warn" ? "#fbbf24" : TEAL;
      clearTimeout(statusEl.__t);
      statusEl.__t = setTimeout(() => {
        statusEl.textContent = "";
        statusEl.style.color = TEXT_DIM;
      }, 4e3);
    }
    const toggleRow = document.createElement("div");
    css(toggleRow, { display: "flex", alignItems: "center", justifyContent: "space-between", gap: "12px" });
    const toggleLabel = document.createElement("div");
    css(toggleLabel, { fontSize: "13px", fontWeight: "600", color: TEXT });
    toggleLabel.textContent = "Editor mode";
    const toggle = createToggle(EditorService.isEnabled(), (on) => {
      EditorService.setEnabled(on);
    });
    toggleRow.append(toggleLabel, toggle);
    const desc = document.createElement("div");
    css(desc, { fontSize: "11px", color: TEXT_DIM, lineHeight: "1.5" });
    desc.textContent = "Sandbox garden editor with every plant and decor unlocked. Place/Remove uses your action key \xB7 Toggle overlays with U \xB7 Edit keybinds in Keybinds \u203A Editor.";
    wrap.appendChild(card([toggleRow, desc]));
    const nameInput = styledInput("Garden name\u2026");
    const actRow = document.createElement("div");
    css(actRow, { display: "flex", gap: "8px" });
    actRow.append(
      primaryBtn("Save current garden", async () => {
        const fn = window.qwsEditorSaveGarden;
        if (typeof fn !== "function") return;
        const saved = await fn(nameInput.value);
        if (!saved) {
          setStatus("Save failed (no garden state found).", "err");
          return;
        }
        setStatus(`Saved "${saved.name}".`);
      }),
      secondaryBtn("Clear garden", async () => {
        const fn = window.qwsEditorClearGarden;
        if (typeof fn !== "function") return;
        const ok = await fn();
        setStatus(ok ? "Garden cleared." : "Clear failed.", ok ? "ok" : "err");
      })
    );
    wrap.appendChild(
      card([sectionLabel("Current garden"), nameInput, actRow])
    );
    const importArea = styledTextarea("Paste garden JSON here\u2026");
    wrap.appendChild(
      card([
        sectionLabel("Import"),
        importArea,
        primaryBtn("Import to saved gardens", async () => {
          const fn = window.qwsEditorImportGarden;
          if (typeof fn !== "function") return;
          const saved = await fn(nameInput.value || "Imported garden", importArea.value);
          if (!saved) {
            setStatus("Import failed (invalid JSON).", "err");
            return;
          }
          importArea.value = "";
          setStatus(`Imported "${saved.name}".`);
        })
      ])
    );
    const listWrap = document.createElement("div");
    css(listWrap, { display: "flex", flexDirection: "column", gap: "6px" });
    const renderSavedList = () => {
      const listFn = window.qwsEditorListSavedGardens;
      const loadFn = window.qwsEditorLoadGarden;
      const delFn = window.qwsEditorDeleteGarden;
      const expFn = window.qwsEditorExportGarden;
      listWrap.innerHTML = "";
      const items = typeof listFn === "function" ? listFn() : [];
      if (!items.length) {
        const empty = document.createElement("div");
        css(empty, { fontSize: "12px", color: TEXT_DIM, padding: "4px 0" });
        empty.textContent = "No saved gardens yet.";
        listWrap.appendChild(empty);
        return;
      }
      const editorOn = EditorService.isEnabled();
      for (const g of items) {
        const row = document.createElement("div");
        css(row, {
          display: "flex",
          alignItems: "center",
          gap: "8px",
          padding: "10px 12px",
          background: CARD_BG,
          borderRadius: "10px",
          border: `1px solid ${BORDER}`,
          transition: "border-color 120ms ease"
        });
        row.onmouseenter = () => css(row, { borderColor: BORDER_HI });
        row.onmouseleave = () => css(row, { borderColor: BORDER });
        const nameEl = document.createElement("div");
        css(nameEl, {
          flex: "1",
          fontSize: "12px",
          fontWeight: "600",
          color: TEXT,
          overflow: "hidden",
          textOverflow: "ellipsis",
          whiteSpace: "nowrap",
          minWidth: "0"
        });
        nameEl.textContent = g.name || "Untitled";
        nameEl.title = g.name || "Untitled";
        const loadBtn = smallBtn("Load", true, async () => {
          if (!EditorService.isEnabled()) {
            setStatus("Enable editor mode first.", "warn");
            return;
          }
          if (typeof loadFn !== "function") return;
          const ok = await loadFn(g.id);
          setStatus(ok ? `Loaded "${g.name}".` : "Load failed.", ok ? "ok" : "err");
        });
        loadBtn.disabled = !editorOn;
        if (!editorOn) {
          css(loadBtn, { opacity: "0.4", cursor: "not-allowed" });
          loadBtn.title = "Enable editor mode to load";
        }
        const expBtn = smallBtn("Export", false, async () => {
          if (typeof expFn !== "function") return;
          const json = expFn(g.id);
          if (!json) {
            setStatus("Export failed.", "err");
            return;
          }
          try {
            await navigator.clipboard.writeText(json);
            setStatus(`Copied "${g.name}" to clipboard.`);
            await toastSimple("Editor", `Copied "${g.name}" to clipboard`, "success");
          } catch {
            setStatus(`Exported "${g.name}". Copy manually.`);
            window.prompt("Garden JSON", json);
          }
        });
        const delBtn = dangerBtn("Delete", () => {
          if (typeof delFn !== "function") return;
          const ok = delFn(g.id);
          if (ok) {
            setStatus(`Deleted "${g.name}".`);
            renderSavedList();
          }
        });
        row.append(nameEl, loadBtn, expBtn, delBtn);
        listWrap.appendChild(row);
      }
    };
    renderSavedList();
    wrap.appendChild(
      card([sectionLabel("Saved gardens"), statusEl, listWrap])
    );
    const unsubChange = EditorService.onChange((enabled) => {
      toggle.querySelector("input").checked = enabled;
      renderSavedList();
    });
    const unsubSaved = EditorService.onSavedGardensChange(renderSavedList);
    container.__cleanup__ = () => {
      try {
        unsubChange();
      } catch {
      }
      try {
        unsubSaved();
      } catch {
      }
    };
  }

  // src/ui/menus/keybinds.ts
  function createKeybindRow(ui, action2) {
    const controls = document.createElement("div");
    controls.style.display = "flex";
    controls.style.alignItems = "center";
    controls.style.flexWrap = "nowrap";
    controls.style.gap = "8px";
    const button = ui.hotkeyButton(
      getKeybind(action2.id),
      (hk) => setKeybind(action2.id, hk),
      {
        emptyLabel: "Unassigned",
        listeningLabel: "Press a key\xE2\u20AC\xA6",
        clearable: true,
        allowModifierOnly: action2.allowModifierOnly
      }
    );
    button.style.flexShrink = "0";
    controls.appendChild(button);
    let detachHoldListener = null;
    if (action2.holdDetection) {
      if (action2.id === "game.action") {
        const holdContainer = document.createElement("div");
        holdContainer.style.display = "flex";
        holdContainer.style.flexDirection = "column";
        holdContainer.style.alignItems = "center";
        holdContainer.style.gap = "4px";
        holdContainer.style.flex = "0 1 160px";
        holdContainer.style.alignSelf = "center";
        const holdButton = ui.btn("Hold", { size: "sm", variant: "secondary" });
        holdButton.style.display = "inline-flex";
        holdButton.style.alignItems = "center";
        holdButton.style.gap = "6px";
        holdButton.setAttribute("aria-label", action2.holdDetection.label);
        holdButton.title = action2.holdDetection.label;
        const holdIndicator = document.createElement("span");
        holdIndicator.textContent = "\u25CF";
        holdIndicator.style.fontSize = "10px";
        holdIndicator.style.lineHeight = "1";
        holdIndicator.setAttribute("aria-hidden", "true");
        const holdText = document.createElement("span");
        holdText.textContent = "Hold";
        holdButton.replaceChildren(holdIndicator, holdText);
        let holdEnabled = getKeybindHoldDetection(action2.id);
        const updateHoldButton = (enabled) => {
          holdEnabled = enabled;
          holdButton.setAttribute("aria-pressed", enabled ? "true" : "false");
          holdIndicator.style.color = enabled ? "#34c759" : "#ff3b30";
        };
        updateHoldButton(holdEnabled);
        holdButton.addEventListener("click", () => {
          setKeybindHoldDetection(action2.id, !holdEnabled);
        });
        detachHoldListener = onKeybindHoldDetectionChange(action2.id, (enabled) => {
          updateHoldButton(enabled);
        });
        holdContainer.appendChild(holdButton);
        if (action2.holdDetection.description) {
          const holdDesc = document.createElement("div");
          holdDesc.textContent = action2.holdDetection.description;
          holdDesc.style.fontSize = "11px";
          holdDesc.style.opacity = "0.65";
          holdDesc.style.maxWidth = "100%";
          holdDesc.style.textAlign = "center";
          holdContainer.appendChild(holdDesc);
        }
        controls.appendChild(holdContainer);
      } else {
        const holdContainer = document.createElement("div");
        holdContainer.style.display = "flex";
        holdContainer.style.flexDirection = "column";
        holdContainer.style.alignItems = "flex-start";
        holdContainer.style.gap = "2px";
        holdContainer.style.padding = "2px 4px";
        holdContainer.style.borderRadius = "8px";
        holdContainer.style.background = "rgba(255, 255, 255, 0.04)";
        holdContainer.style.flex = "0 1 180px";
        holdContainer.style.maxWidth = "180px";
        const holdLabel = document.createElement("label");
        holdLabel.style.display = "inline-flex";
        holdLabel.style.alignItems = "center";
        holdLabel.style.gap = "6px";
        holdLabel.style.fontSize = "12px";
        holdLabel.style.cursor = "pointer";
        const holdToggle = ui.switch(getKeybindHoldDetection(action2.id));
        holdToggle.style.margin = "0";
        holdToggle.setAttribute("aria-label", action2.holdDetection.label);
        const holdText = document.createElement("span");
        holdText.textContent = action2.holdDetection.label;
        holdText.style.opacity = "0.85";
        holdLabel.append(holdToggle, holdText);
        holdContainer.appendChild(holdLabel);
        if (action2.holdDetection.description) {
          const holdDesc = document.createElement("div");
          holdDesc.textContent = action2.holdDetection.description;
          holdDesc.style.fontSize = "11px";
          holdDesc.style.opacity = "0.65";
          holdDesc.style.maxWidth = "100%";
          holdContainer.appendChild(holdDesc);
        }
        holdToggle.addEventListener("change", () => {
          setKeybindHoldDetection(action2.id, holdToggle.checked);
        });
        detachHoldListener = onKeybindHoldDetectionChange(action2.id, (enabled) => {
          holdToggle.checked = enabled;
        });
        controls.appendChild(holdContainer);
      }
    }
    const actionsWrap = document.createElement("div");
    actionsWrap.style.display = "flex";
    actionsWrap.style.alignItems = "center";
    actionsWrap.style.gap = "4px";
    actionsWrap.style.marginLeft = "auto";
    const clearBtn = action2.sectionId === "game" && !action2.allowClear ? null : ui.btn("", {
      icon: "\u{1F5D1}\uFE0F",
      variant: "danger",
      size: "sm",
      tooltip: "Remove this shortcut",
      ariaLabel: "Remove keybind"
    });
    if (clearBtn) {
      actionsWrap.appendChild(clearBtn);
    }
    const defaultHotkey = getDefaultKeybind(action2.id);
    const defaultString = hotkeyToString(defaultHotkey);
    let resetBtn = null;
    if (defaultHotkey) {
      resetBtn = ui.btn("", {
        icon: "\u{1F504}",
        variant: "primary",
        size: "sm",
        tooltip: "Restore default shortcut",
        ariaLabel: "Reset keybind to default"
      });
      actionsWrap.appendChild(resetBtn);
    }
    const setButtonEnabled = (btn, enabled) => {
      if (!btn) return;
      const setter = btn.setEnabled;
      if (setter) {
        setter(enabled);
      } else {
        btn.disabled = !enabled;
        btn.classList.toggle("is-disabled", !enabled);
        btn.setAttribute("aria-disabled", (!enabled).toString());
      }
    };
    const updateButtons2 = (current) => {
      const hasHotkey = hotkeyToString(current).length > 0;
      if (clearBtn) {
        setButtonEnabled(clearBtn, hasHotkey);
      }
      if (resetBtn) {
        const isDefault = hotkeyToString(current) === defaultString;
        setButtonEnabled(resetBtn, !isDefault);
      }
    };
    if (clearBtn) {
      clearBtn.addEventListener("click", () => {
        setKeybind(action2.id, null);
        const refreshed = getKeybind(action2.id);
        button.refreshHotkey(refreshed);
        updateButtons2(refreshed);
      });
    }
    if (resetBtn) {
      resetBtn.addEventListener("click", () => {
        resetKeybind(action2.id);
        const refreshed = getKeybind(action2.id);
        button.refreshHotkey(refreshed);
        updateButtons2(refreshed);
      });
    }
    controls.appendChild(actionsWrap);
    updateButtons2(getKeybind(action2.id));
    const stop2 = onKeybindChange(action2.id, (hk) => {
      button.refreshHotkey(hk);
      updateButtons2(hk);
    });
    ui.on("unmounted", stop2);
    if (detachHoldListener) ui.on("unmounted", detachHoldListener);
    const row = ui.formRow(action2.label, controls, { labelWidth: "180px" });
    row.label.style.fontSize = "13px";
    row.label.style.opacity = "0.92";
    if (action2.hint) {
      const hintEl = document.createElement("div");
      hintEl.textContent = action2.hint;
      hintEl.style.fontSize = "11px";
      hintEl.style.opacity = "0.7";
      hintEl.style.marginTop = "2px";
      hintEl.style.gridColumn = "2 / 3";
      row.root.appendChild(hintEl);
    }
    return row.root;
  }
  async function renderKeybindsMenu(container) {
    const ui = new Menu({ id: "keybinds", compact: true });
    ui.mount(container);
    const view = ui.root.querySelector(".qmm-views");
    view.innerHTML = "";
    view.style.display = "flex";
    view.style.flexDirection = "column";
    view.style.gap = "12px";
    view.style.padding = "8px";
    view.style.maxHeight = "60vh";
    view.style.overflowY = "auto";
    const wrapper = document.createElement("div");
    wrapper.style.display = "grid";
    wrapper.style.gap = "12px";
    wrapper.style.width = "100%";
    wrapper.style.maxWidth = "720px";
    wrapper.style.margin = "0 auto";
    for (const section of getKeybindSections()) {
      const card2 = ui.card(`${section.icon} ${section.title}`, { tone: "muted", align: "stretch" });
      card2.root.dataset.section = section.id;
      card2.body.style.display = "flex";
      card2.body.style.flexDirection = "column";
      card2.body.style.gap = "10px";
      const desc = document.createElement("p");
      desc.textContent = section.description;
      desc.style.margin = "0";
      desc.style.fontSize = "12px";
      desc.style.opacity = "0.78";
      card2.body.appendChild(desc);
      for (const action2 of section.actions) {
        const row = createKeybindRow(ui, action2);
        card2.body.appendChild(row);
      }
      wrapper.appendChild(card2.root);
    }
    view.appendChild(wrapper);
  }

  // src/services/players.ts
  init_fakeModal();
  init_atoms();
  function findPlayersDeep2(state3) {
    if (!state3 || typeof state3 !== "object") return [];
    const out = [];
    const seen = /* @__PURE__ */ new Set();
    const stack = [state3];
    while (stack.length) {
      const cur = stack.pop();
      if (!cur || typeof cur !== "object" || seen.has(cur)) continue;
      seen.add(cur);
      for (const k of Object.keys(cur)) {
        const v = cur[k];
        if (Array.isArray(v) && v.length && v.every((x) => x && typeof x === "object")) {
          const looks = v.some((p) => "id" in p && "name" in p);
          if (looks && /player/i.test(k)) out.push(...v);
        }
        if (v && typeof v === "object") stack.push(v);
      }
    }
    const byId = /* @__PURE__ */ new Map();
    for (const p of out) if (p?.id) byId.set(String(p.id), p);
    return [...byId.values()];
  }
  function getPlayersArray2(st) {
    const direct = st?.fullState?.data?.players ?? st?.data?.players ?? st?.players;
    return Array.isArray(direct) ? direct : findPlayersDeep2(st);
  }
  function getSlotsArray2(st) {
    const raw = st?.child?.data?.userSlots ?? st?.fullState?.child?.data?.userSlots ?? st?.data?.userSlots;
    if (Array.isArray(raw)) return raw;
    if (raw && typeof raw === "object") {
      const entries = Object.entries(raw);
      entries.sort((a, b) => {
        const ai = Number(a[0]);
        const bi = Number(b[0]);
        if (Number.isFinite(ai) && Number.isFinite(bi)) return ai - bi;
        return a[0].localeCompare(b[0]);
      });
      return entries.map(([, v]) => v);
    }
    return [];
  }
  function extractPosFromSlot(slot) {
    const pos = slot?.data?.position ?? slot?.position ?? slot?.data?.coords ?? slot?.coords;
    const x = Number(pos?.x);
    const y = Number(pos?.y);
    return Number.isFinite(x) && Number.isFinite(y) ? { x, y } : null;
  }
  function extractInventoryFromSlot(slot) {
    const inv = slot?.data?.inventory;
    if (!inv || typeof inv !== "object") return null;
    const items = Array.isArray(inv.items) ? inv.items : [];
    const favoritedItemIds = Array.isArray(inv.favoritedItemIds) ? inv.favoritedItemIds : [];
    return { items, favoritedItemIds };
  }
  function extractJournalFromSlot(slot) {
    const j = slot?.data?.journal ?? slot?.journal;
    if (!j || typeof j !== "object") return null;
    const produce = j.produce && typeof j.produce === "object" ? j.produce : void 0;
    const pets = j.pets && typeof j.pets === "object" ? j.pets : void 0;
    const normProduce = produce ? Object.fromEntries(Object.entries(produce).map(([k, v]) => [
      String(k),
      { variantsLogged: Array.isArray(v?.variantsLogged) ? v.variantsLogged : [] }
    ])) : void 0;
    const normPets = pets ? Object.fromEntries(Object.entries(pets).map(([k, v]) => [
      String(k),
      {
        variantsLogged: Array.isArray(v?.variantsLogged) ? v.variantsLogged : [],
        abilitiesLogged: Array.isArray(v?.abilitiesLogged) ? v.abilitiesLogged : []
      }
    ])) : void 0;
    return { produce: normProduce, pets: normPets };
  }
  function extractStatsFromSlot(slot) {
    const stats = slot?.data?.stats ?? slot?.stats;
    if (!stats || typeof stats !== "object") return null;
    return stats;
  }
  function extractActivityLogsFromSlot(slot) {
    const logs = slot?.data?.activityLogs ?? slot?.activityLogs;
    if (!Array.isArray(logs)) return null;
    return logs;
  }
  function extractGardenFromSlot(slot) {
    const g = slot?.data?.garden ?? slot?.garden;
    if (!g || typeof g !== "object") return null;
    const to = g.tileObjects;
    const bto = g.boardwalkTileObjects;
    const tileObjects = to && typeof to === "object" ? to : {};
    const boardwalkTileObjects = bto && typeof bto === "object" ? bto : {};
    return { tileObjects, boardwalkTileObjects };
  }
  function getSlotByPlayerId(st, playerId2) {
    for (const s of getSlotsArray2(st)) if (String(s?.playerId ?? "") === String(playerId2)) return s;
    return null;
  }
  function enrichPlayersWithSlots(players, st) {
    const byPid = /* @__PURE__ */ new Map();
    for (const slot of getSlotsArray2(st)) {
      if (!slot || typeof slot !== "object") continue;
      const pid = slot.playerId != null ? String(slot.playerId) : "";
      if (!pid) continue;
      const pos = extractPosFromSlot(slot);
      const inv = extractInventoryFromSlot(slot);
      byPid.set(pid, { x: pos?.x, y: pos?.y, inventory: inv ?? null });
    }
    return players.map((p) => {
      const extra = byPid.get(String(p.id));
      return extra ? { ...p, ...extra } : { ...p, inventory: null };
    });
  }
  function orderPlayersBySlots(players, st) {
    const slots = getSlotsArray2(st);
    const mapById = /* @__PURE__ */ new Map();
    for (const p of players) mapById.set(String(p.id), p);
    const out = [];
    const seen = /* @__PURE__ */ new Set();
    for (const s of slots) {
      const pid = s?.playerId != null ? String(s.playerId) : "";
      if (!pid || seen.has(pid)) continue;
      const p = mapById.get(pid);
      if (p) {
        out.push(p);
        seen.add(pid);
      }
    }
    for (const p of players) {
      const pid = String(p.id);
      if (!seen.has(pid)) {
        out.push(p);
        seen.add(pid);
      }
    }
    return out;
  }
  function clampPlayers2(n) {
    const v = Math.floor(Number(n));
    if (!Number.isFinite(v)) return 1;
    return Math.max(1, Math.min(6, v));
  }
  async function getPlayersInRoom() {
    try {
      const raw = await Atoms.server.numPlayers.get();
      return clampPlayers2(raw);
    } catch {
      return 1;
    }
  }
  var __cachedSpawnTiles = null;
  var __spawnLoadPromise = null;
  async function getSpawnTilesSorted() {
    if (Array.isArray(__cachedSpawnTiles)) return __cachedSpawnTiles;
    if (__spawnLoadPromise) return __spawnLoadPromise;
    __spawnLoadPromise = (async () => {
      try {
        const map2 = await Atoms.root.map.get();
        const arr = map2?.spawnTiles;
        if (Array.isArray(arr) && arr.every((n) => Number.isFinite(n))) {
          __cachedSpawnTiles = [...arr].sort((a, b) => a - b);
          return __cachedSpawnTiles;
        }
      } catch {
      }
      try {
        const st = await Atoms.root.state.get();
        const seen = /* @__PURE__ */ new Set();
        const stack = [st];
        while (stack.length) {
          const cur = stack.pop();
          if (!cur || typeof cur !== "object" || seen.has(cur)) continue;
          seen.add(cur);
          const arr = cur?.spawnTiles;
          if (Array.isArray(arr) && arr.every((n) => Number.isFinite(n))) {
            __cachedSpawnTiles = [...arr].sort((a, b) => a - b);
            return __cachedSpawnTiles;
          }
          for (const k of Object.keys(cur)) {
            const v = cur[k];
            if (v && typeof v === "object") stack.push(v);
          }
        }
      } catch {
      }
      __cachedSpawnTiles = [];
      return __cachedSpawnTiles;
    })();
    const res = await __spawnLoadPromise;
    __spawnLoadPromise = null;
    return res;
  }
  async function getMapCols() {
    try {
      const map2 = await Atoms.root.map.get();
      const cols = Number(map2?.cols);
      if (Number.isFinite(cols) && cols > 0) return cols;
    } catch {
    }
    try {
      const st = await Atoms.root.state.get();
      const maybeCols = Number(
        st?.map?.cols ?? st?.child?.data?.map?.cols ?? st?.fullState?.map?.cols
      );
      if (Number.isFinite(maybeCols) && maybeCols > 0) return maybeCols;
    } catch {
    }
    return 81;
  }
  function assignGardenPositions(players, spawnTilesSorted) {
    if (!players.length || !spawnTilesSorted.length) {
      return players.map((p) => ({ ...p, gardenPosition: null }));
    }
    const out = [];
    for (let i = 0; i < players.length; i++) {
      out.push({ ...players[i], gardenPosition: spawnTilesSorted[i] ?? null });
    }
    return out;
  }
  function nowTs() {
    return Date.now();
  }
  function normJournal(j) {
    if (!j || typeof j !== "object") return {};
    const out = {};
    if (j.produce && typeof j.produce === "object") out.produce = j.produce;
    if (j.pets && typeof j.pets === "object") out.pets = j.pets;
    return out;
  }
  function hasJournalData(j) {
    if (!j) return false;
    const hasProduce = !!j.produce && Object.values(j.produce).some((s) => (s.variantsLogged?.length ?? 0) > 0);
    const hasPets = !!j.pets && Object.values(j.pets).some((s) => (s.variantsLogged?.length ?? 0) > 0 || (s.abilitiesLogged?.length ?? 0) > 0);
    return hasProduce || hasPets;
  }
  var followingState = {
    currentTargetId: null,
    unsub: null,
    lastPos: null,
    prevPos: null,
    steps: 0
  };
  var PET_FOLLOW_INTERVAL_MS = 20;
  var PET_HISTORY_FACTOR = 3;
  var PET_SPACING_STEPS = 1;
  var petFollowState = {
    targetId: null,
    unsub: null,
    timer: null,
    pets: [],
    history: [],
    historyCap: 0
  };
  function clearPetFollowTimer() {
    if (petFollowState.timer) {
      clearInterval(petFollowState.timer);
      petFollowState.timer = null;
    }
  }
  async function resetPetFollowState() {
    if (petFollowState.unsub) {
      const fn = petFollowState.unsub;
      petFollowState.unsub = null;
      try {
        await fn();
      } catch {
      }
    } else {
      petFollowState.unsub = null;
    }
    clearPetFollowTimer();
    petFollowState.targetId = null;
    petFollowState.pets = [];
    petFollowState.history = [];
    petFollowState.historyCap = 0;
  }
  function recordPetHistory(pos, force = false) {
    const top = petFollowState.history[0];
    if (!force && top && top.x === pos.x && top.y === pos.y) return;
    petFollowState.history.unshift({ x: pos.x, y: pos.y });
    const cap = petFollowState.historyCap || petFollowState.history.length;
    if (petFollowState.history.length > cap) {
      petFollowState.history.length = cap;
    }
  }
  var PlayersService = {
    async list() {
      const st = await Atoms.root.state.get();
      if (!st) return [];
      const base = enrichPlayersWithSlots(getPlayersArray2(st), st);
      const ordered = orderPlayersBySlots(base, st);
      const spawns = await getSpawnTilesSorted();
      const players = assignGardenPositions(ordered, spawns);
      return players;
    },
    async onChange(cb) {
      return Atoms.root.state.onChange(async () => {
        try {
          cb(await this.list());
        } catch {
        }
      });
    },
    async getPosition(playerId2) {
      const st = await Atoms.root.state.get();
      if (!st) return null;
      const slot = getSlotByPlayerId(st, playerId2);
      const pos = extractPosFromSlot(slot);
      return pos;
    },
    async getInventory(playerId2) {
      const st = await Atoms.root.state.get();
      if (!st) return null;
      const slot = getSlotByPlayerId(st, playerId2);
      const inv = extractInventoryFromSlot(slot);
      return inv;
    },
    async getJournal(playerId2) {
      const st = await Atoms.root.state.get();
      if (!st) return null;
      const slot = getSlotByPlayerId(st, playerId2);
      const j = extractJournalFromSlot(slot);
      const journal = j ? normJournal(j) : null;
      return journal;
    },
    async getGarden(playerId2) {
      const st = await Atoms.root.state.get();
      if (!st) return null;
      const slot = getSlotByPlayerId(st, playerId2);
      return extractGardenFromSlot(slot);
    },
    async getGardenPosition(playerId2) {
      const list = await this.list();
      const p = list.find((x) => String(x.id) === String(playerId2));
      return p?.gardenPosition ?? null;
    },
    async getPlayerNameById(playerId2) {
      try {
        const st = await Atoms.root.state.get();
        if (st) {
          const arr = getPlayersArray2(st);
          const p = arr.find((x) => String(x?.id) === String(playerId2));
          if (p && typeof p.name === "string" && p.name) return p.name;
        }
      } catch {
      }
      try {
        const list = await this.list();
        const p = list.find((x) => String(x.id) === String(playerId2));
        return p?.name ?? null;
      } catch {
        return null;
      }
    },
    async teleportToPlayer(playerId2) {
      const pos = await this.getPosition(playerId2);
      if (!pos) throw new Error("Unknown position for this player");
      PlayerService.teleport(pos.x, pos.y);
      toastSimple("Teleport", `Teleported to ${await this.getPlayerNameById(playerId2)}`, "success");
    },
    async teleportToGarden(playerId2) {
      const tileId = await this.getGardenPosition(playerId2);
      if (tileId == null) {
        await toastSimple("Teleport", "No garden position for this player.", "error");
        return;
      }
      const cols = await getMapCols();
      const x = tileId % cols, y = Math.floor(tileId / cols);
      await PlayerService.teleport(x, y);
      await toastSimple("Teleport", `Teleported to ${await this.getPlayerNameById(playerId2)}'s garden`, "success");
    },
    async getInventoryValue(playerId2, opts) {
      try {
        const playersInRoom = await getPlayersInRoom();
        const inv = await this.getInventory(playerId2);
        const items = Array.isArray(inv?.items) ? inv.items : [];
        if (!items.length) return 0;
        const value = sumInventoryValue(items, opts, playersInRoom);
        return value;
      } catch {
        return 0;
      }
    },
    async getGardenValue(playerId2, opts) {
      try {
        const playersInRoom = await getPlayersInRoom();
        const garden2 = await this.getGarden(playerId2);
        if (!garden2) return 0;
        const value = sumGardenValue(garden2.tileObjects ?? {}, opts, playersInRoom);
        return value;
      } catch {
        return 0;
      }
    },
    /** Ouvre laperu dinventaire (fake modal) avec garde + toasts. */
    async openInventoryPreview(playerId2, playerName) {
      try {
        const inv = await this.getInventory(playerId2);
        if (!inv) {
          await toastSimple("Inventory", "No inventory object found for this player.", "error");
          return;
        }
        const items = Array.isArray(inv.items) ? inv.items : [];
        if (items.length === 0) {
          await toastSimple("Inventory", "Inventory is empty for this player.", "info");
          return;
        }
        try {
          await fakeInventoryShow({ ...inv, items }, { open: true });
        } catch (err) {
          await toastSimple("Inventory", err?.message || "Failed to open inventory", "error");
          return;
        }
        if (playerName) await toastSimple("Inventory", `${playerName}'s inventory displayed.`, "info");
      } catch (e) {
        await toastSimple("Inventory", e?.message || "Failed to open inventory.", "error");
      }
    },
    /** Ouvre le Journal (produce + pets) avec garde + toasts. */
    async openJournalLog(playerId2, playerName) {
      try {
        const journal = await this.getJournal(playerId2);
        if (!hasJournalData(journal)) {
          await toastSimple("Journal", "No journal data for this player.", "error");
          return;
        }
        const safe = journal ?? {};
        try {
          await fakeJournalShow(safe, { open: true });
        } catch (err) {
          await toastSimple("Journal", err?.message || "Failed to open journal.", "error");
          return;
        }
        if (playerName) await toastSimple("Journal", `${playerName}'s journal displayed.`, "info");
      } catch (e) {
        await toastSimple("Journal", e?.message || "Failed to open journal.", "error");
      }
    },
    async getStats(playerId2) {
      const st = await Atoms.root.state.get();
      if (!st) return null;
      const slot = getSlotByPlayerId(st, playerId2);
      return extractStatsFromSlot(slot);
    },
    async getActivityLogs(playerId2) {
      const st = await Atoms.root.state.get();
      if (!st) return null;
      const slot = getSlotByPlayerId(st, playerId2);
      return extractActivityLogsFromSlot(slot);
    },
    async openStatsModal(playerId2, playerName) {
      try {
        const stats = await this.getStats(playerId2);
        if (!stats) {
          await toastSimple("Stats", "No stats found for this player.", "error");
          return;
        }
        await fakeStatsShow(stats, { open: true });
        if (playerName) await toastSimple("Stats", `${playerName}'s stats displayed.`, "info");
      } catch (e) {
        await toastSimple("Stats", e?.message || "Failed to open stats modal.", "error");
      }
    },
    async openActivityLogModal(playerId2, playerName) {
      try {
        const logs = await this.getActivityLogs(playerId2);
        if (!logs || logs.length === 0) {
          await toastSimple("Activity log", "No activity logs for this player.", "info");
          return;
        }
        skipNextActivityLogHistoryReopen();
        await fakeActivityLogShow(logs, { open: true });
        if (playerName) await toastSimple("Activity log", `${playerName}'s activity log displayed.`, "info");
      } catch (e) {
        await toastSimple("Activity log", e?.message || "Failed to open activity log.", "error");
      }
    },
    /* ---------------- Ajouts "fake" au journal (UI only, avec gardes) ---------------- */
    async addProduceVariant(playerId2, species, variant, createdAt = nowTs()) {
      if (!species || !variant) {
        await toastSimple("Journal", "Missing species or variant.", "error");
        return;
      }
      try {
        await fakeJournalShow({
          produce: {
            [String(species)]: {
              variantsLogged: [{ variant: String(variant), createdAt }]
            }
          }
        }, { open: true });
        const name = await this.getPlayerNameById(playerId2);
        await toastSimple("Journal", `Added produce variant "${variant}" for ${name ?? playerId2}.`, "success");
      } catch (e) {
        await toastSimple("Journal", e?.message || "Failed to add produce variant.", "error");
      }
    },
    async addPetVariant(playerId2, petSpecies, variant, createdAt = nowTs()) {
      if (!petSpecies || !variant) {
        await toastSimple("Journal", "Missing pet species or variant.", "error");
        return;
      }
      try {
        await fakeJournalShow({
          pets: {
            [String(petSpecies)]: {
              variantsLogged: [{ variant: String(variant), createdAt }]
            }
          }
        }, { open: true });
        const name = await this.getPlayerNameById(playerId2);
        await toastSimple("Journal", `Added pet variant "${variant}" for ${name ?? playerId2}.`, "success");
      } catch (e) {
        await toastSimple("Journal", e?.message || "Failed to add pet variant.", "error");
      }
    },
    async addPetAbility(playerId2, petSpecies, ability, createdAt = nowTs()) {
      if (!petSpecies || !ability) {
        await toastSimple("Journal", "Missing pet species or ability.", "error");
        return;
      }
      try {
        await fakeJournalShow({
          pets: {
            [String(petSpecies)]: {
              abilitiesLogged: [{ ability: String(ability), createdAt }]
            }
          }
        }, { open: true });
        const name = await this.getPlayerNameById(playerId2);
        await toastSimple("Journal", `Added pet ability "${ability}" for ${name ?? playerId2}.`, "success");
      } catch (e) {
        await toastSimple("Journal", e?.message || "Failed to add pet ability.", "error");
      }
    },
    /* ---------------- Follow ---------------- */
    async stopFollowing() {
      if (followingState.unsub) {
        try {
          await followingState.unsub();
        } catch {
        }
      }
      followingState.unsub = null;
      followingState.currentTargetId = null;
      followingState.lastPos = null;
      followingState.prevPos = null;
      followingState.steps = 0;
    },
    isFollowing(playerId2) {
      return followingState.currentTargetId === playerId2;
    },
    async startFollowing(playerId2) {
      if (followingState.unsub) {
        try {
          await followingState.unsub();
        } catch {
        }
        followingState.unsub = null;
      }
      followingState.currentTargetId = playerId2;
      followingState.lastPos = null;
      followingState.prevPos = null;
      followingState.steps = 0;
      const pos = await this.getPosition(playerId2);
      if (!pos) {
        await toastSimple("Follow", "Unable to retrieve player position.", "error");
        followingState.currentTargetId = null;
        return;
      }
      await PlayerService.teleport(pos.x, pos.y);
      followingState.lastPos = { x: pos.x, y: pos.y };
      followingState.prevPos = null;
      followingState.steps = 0;
      followingState.unsub = await this.onChange(async (players) => {
        if (followingState.currentTargetId !== playerId2) return;
        const target = players.find((p) => p.id === playerId2);
        if (!target || typeof target.x !== "number" || typeof target.y !== "number") {
          await this.stopFollowing();
          await toastSimple("Follow", "The target is no longer trackable (disconnected?).", "error");
          return;
        }
        const cur = { x: target.x, y: target.y };
        const last = followingState.lastPos;
        if (!last) {
          followingState.lastPos = cur;
          return;
        }
        if (cur.x !== last.x || cur.y !== last.y) {
          followingState.steps += 1;
          if (followingState.steps >= 2) {
            if (last) {
              PlayerService.move(last.x, last.y);
            }
          }
          followingState.prevPos = followingState.lastPos;
          followingState.lastPos = cur;
        }
      });
      await toastSimple("Follow", "Follow enabled", "success");
    },
    /* ---------------- Pet Follow ---------------- */
    async stopPetFollowing(opts) {
      await resetPetFollowState();
      if (!opts?.silent) {
        await toastSimple("Pet follow", opts?.message ?? "Disabled.", opts?.tone ?? "info");
      }
    },
    isPetFollowing(playerId2) {
      return petFollowState.targetId === playerId2;
    },
    async startPetFollowing(playerId2) {
      await this.stopPetFollowing({ silent: true });
      const petsRaw = await Atoms.pets.myPetInfos.get();
      const petIds = Array.isArray(petsRaw) ? petsRaw.map((entry) => entry?.slot?.id).filter((id) => typeof id === "string" && !!id) : [];
      if (!petIds.length) {
        await toastSimple("Pet follow", "You don't have any active pets.", "error");
        return;
      }
      const pos = await this.getPosition(playerId2);
      if (!pos) {
        await toastSimple("Pet follow", "Unable to retrieve player position.", "error");
        return;
      }
      petFollowState.targetId = playerId2;
      petFollowState.pets = petIds;
      petFollowState.historyCap = Math.max(petIds.length * PET_HISTORY_FACTOR, petIds.length + PET_SPACING_STEPS + 1);
      petFollowState.history = [];
      for (let i = 0; i < petFollowState.historyCap; i += 1) {
        recordPetHistory(pos, true);
      }
      const sendPositions = async () => {
        if (petFollowState.targetId !== playerId2) return;
        if (!petFollowState.pets.length || !petFollowState.history.length) return;
        const payload = {};
        for (let i = 0; i < petFollowState.pets.length; i += 1) {
          const petId = petFollowState.pets[i];
          const historyIndex = Math.min(
            petFollowState.history.length - 1,
            (i + 1) * PET_SPACING_STEPS
          );
          const targetPos = petFollowState.history[historyIndex] ?? petFollowState.history[petFollowState.history.length - 1];
          if (targetPos) {
            payload[petId] = { x: targetPos.x, y: targetPos.y };
          }
        }
        if (Object.keys(payload).length === 0) return;
        try {
          await PlayerService.petPositions(payload);
        } catch (err) {
        }
      };
      petFollowState.timer = setInterval(() => {
        sendPositions().catch(() => {
        });
      }, PET_FOLLOW_INTERVAL_MS);
      const initialSend = sendPositions();
      petFollowState.unsub = await this.onChange(async (players) => {
        if (petFollowState.targetId !== playerId2) return;
        const target = players.find((p) => p.id === playerId2);
        if (!target || typeof target.x !== "number" || typeof target.y !== "number") {
          await this.stopPetFollowing({ silent: false, message: "Target is no longer trackable.", tone: "error" });
          return;
        }
        recordPetHistory({ x: target.x, y: target.y });
      });
      await initialSend;
      await toastSimple("Pet follow", "Pets are now following the target.", "success");
    }
  };

  // src/ui/menus/room.ts
  init_fakeModal();
  init_page_context();
  var STYLE_ID5 = "qws-room-menu-css";
  var TEAL2 = "#5eead4";
  var TEAL_DIM2 = "rgba(94,234,212,0.12)";
  var TEAL_MID2 = "rgba(94,234,212,0.22)";
  var TEAL_BORDER2 = "rgba(94,234,212,0.3)";
  var TEAL_BORDER_HI = "rgba(94,234,212,0.55)";
  var BORDER2 = "rgba(255,255,255,0.08)";
  var BORDER_HI2 = "rgba(255,255,255,0.16)";
  var CARD_BG2 = "rgba(255,255,255,0.03)";
  var CARD_BG_HI2 = "rgba(255,255,255,0.06)";
  var TEXT2 = "#e7eef7";
  var TEXT_DIM2 = "rgba(226,232,240,0.45)";
  var GREEN = "#10b981";
  function ensureStyles4() {
    if (document.getElementById(STYLE_ID5)) return;
    const st = document.createElement("style");
    st.id = STYLE_ID5;
    st.textContent = `
.qws-rm-scroll::-webkit-scrollbar { width: 6px; }
.qws-rm-scroll::-webkit-scrollbar-track { background: transparent; }
.qws-rm-scroll::-webkit-scrollbar-thumb { background: ${TEAL_DIM2}; border-radius: 3px; }
.qws-rm-scroll::-webkit-scrollbar-thumb:hover { background: rgba(94,234,212,0.35); }
.qws-rm-scroll { scrollbar-width: thin; scrollbar-color: ${TEAL_DIM2} transparent; }
@keyframes qws-rm-spin { from { transform:rotate(0deg); } to { transform:rotate(360deg); } }
`;
    document.head.appendChild(st);
  }
  var css2 = (el2, s) => Object.assign(el2.style, s);
  function sectionLabel2(text) {
    const el2 = document.createElement("div");
    css2(el2, {
      fontSize: "10px",
      fontWeight: "700",
      letterSpacing: "0.08em",
      color: TEXT_DIM2,
      textTransform: "uppercase",
      paddingBottom: "6px"
    });
    el2.textContent = text;
    return el2;
  }
  function avatar(player2, size) {
    const el2 = document.createElement("div");
    css2(el2, {
      width: `${size}px`,
      height: `${size}px`,
      borderRadius: "50%",
      flexShrink: "0",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      fontSize: `${Math.floor(size * 0.38)}px`,
      fontWeight: "700",
      color: TEAL2,
      overflow: "hidden"
    });
    if (player2.discordAvatarUrl) {
      css2(el2, {
        backgroundImage: `url(${player2.discordAvatarUrl})`,
        backgroundSize: "cover",
        backgroundPosition: "center",
        border: `2px solid ${TEAL_BORDER2}`
      });
    } else {
      css2(el2, {
        background: "linear-gradient(135deg, rgba(94,234,212,0.22), rgba(59,130,246,0.22))",
        border: `2px solid rgba(94,234,212,0.2)`
      });
      el2.textContent = (player2.name || "?").charAt(0).toUpperCase();
    }
    return el2;
  }
  function statusPill(online) {
    const wrap = document.createElement("div");
    css2(wrap, {
      display: "flex",
      alignItems: "center",
      gap: "4px",
      fontSize: "11px",
      color: online ? GREEN : TEXT_DIM2
    });
    const dot = document.createElement("span");
    css2(dot, {
      width: "6px",
      height: "6px",
      borderRadius: "50%",
      background: online ? GREEN : "rgba(226,232,240,0.3)",
      flexShrink: "0"
    });
    wrap.append(dot, document.createTextNode(online ? "Online" : "Offline"));
    return wrap;
  }
  function primaryBtn2(label2, iconSvg, onClick) {
    const btn = document.createElement("button");
    css2(btn, {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      gap: "7px",
      padding: "10px 14px",
      border: `1px solid ${TEAL_BORDER2}`,
      borderRadius: "10px",
      background: TEAL_DIM2,
      color: TEAL2,
      fontSize: "12px",
      fontWeight: "600",
      cursor: "pointer",
      transition: "all 120ms ease",
      flex: "1",
      whiteSpace: "nowrap"
    });
    const icon = document.createElement("span");
    icon.innerHTML = iconSvg;
    css2(icon, { display: "flex", alignItems: "center", flexShrink: "0" });
    btn.append(icon, document.createTextNode(label2));
    btn.onmouseenter = () => css2(btn, { background: TEAL_MID2, borderColor: TEAL_BORDER_HI });
    btn.onmouseleave = () => css2(btn, { background: TEAL_DIM2, borderColor: TEAL_BORDER2 });
    btn.onclick = async () => {
      css2(btn, { opacity: "0.6", pointerEvents: "none" });
      try {
        await onClick();
      } finally {
        css2(btn, { opacity: "1", pointerEvents: "auto" });
      }
    };
    return btn;
  }
  function toggleBtn(label2, iconSvg, active, onToggle) {
    let isActive = active;
    const btn = document.createElement("button");
    const applyState2 = () => {
      css2(btn, {
        border: `1px solid ${isActive ? TEAL_BORDER_HI : BORDER2}`,
        background: isActive ? TEAL_MID2 : CARD_BG2,
        color: isActive ? TEAL2 : TEXT2
      });
    };
    css2(btn, {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      gap: "7px",
      padding: "10px 14px",
      borderRadius: "10px",
      fontSize: "12px",
      fontWeight: "600",
      cursor: "pointer",
      transition: "all 120ms ease",
      flex: "1",
      whiteSpace: "nowrap"
    });
    const icon = document.createElement("span");
    icon.innerHTML = iconSvg;
    css2(icon, { display: "flex", alignItems: "center", flexShrink: "0" });
    btn.append(icon, document.createTextNode(label2));
    applyState2();
    btn.onmouseenter = () => {
      if (!isActive) css2(btn, { background: CARD_BG_HI2, borderColor: TEAL_BORDER2 });
    };
    btn.onmouseleave = applyState2;
    btn.onclick = async () => {
      css2(btn, { opacity: "0.6", pointerEvents: "none" });
      try {
        const next = !isActive;
        await onToggle(next);
        isActive = next;
        applyState2();
      } finally {
        css2(btn, { opacity: "1", pointerEvents: "auto" });
      }
    };
    btn.__setActive = (v) => {
      isActive = v;
      applyState2();
    };
    return btn;
  }
  function secondaryBtn2(label2, iconSvg, onClick) {
    const btn = document.createElement("button");
    css2(btn, {
      display: "flex",
      alignItems: "center",
      gap: "7px",
      padding: "9px 12px",
      border: `1px solid ${BORDER2}`,
      borderRadius: "10px",
      background: CARD_BG2,
      color: TEXT2,
      fontSize: "12px",
      fontWeight: "500",
      cursor: "pointer",
      transition: "all 120ms ease",
      width: "100%",
      textAlign: "left"
    });
    const icon = document.createElement("span");
    icon.innerHTML = iconSvg;
    css2(icon, { display: "flex", alignItems: "center", flexShrink: "0", opacity: "0.7" });
    btn.append(icon, document.createTextNode(label2));
    btn.onmouseenter = () => css2(btn, { background: CARD_BG_HI2, borderColor: BORDER_HI2 });
    btn.onmouseleave = () => css2(btn, { background: CARD_BG2, borderColor: BORDER2 });
    btn.onclick = async () => {
      css2(btn, { opacity: "0.6", pointerEvents: "none" });
      try {
        await onClick();
      } finally {
        css2(btn, { opacity: "1", pointerEvents: "auto" });
      }
    };
    return btn;
  }
  var ICO = (d) => `<svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">${d}</svg>`;
  var ICONS = {
    teleport: ICO(`<circle cx="12" cy="8" r="4"/><path d="M4 21c0-4.4 3.6-8 8-8s8 3.6 8 8"/>`),
    garden: ICO(`<polygon points="12 3 20 15 4 15"/><polygon points="12 9 21 21 3 21"/><rect x="10" y="21" width="4" height="3" rx="1"/>`),
    inventory: ICO(`<rect x="2" y="7" width="20" height="14" rx="2"/><path d="M16 7V5a2 2 0 0 0-4 0v2"/>`),
    journal: ICO(`<path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/>`),
    stats: ICO(`<line x1="18" y1="20" x2="18" y2="10"/><line x1="12" y1="20" x2="12" y2="4"/><line x1="6" y1="20" x2="6" y2="14"/>`),
    actLog: ICO(`<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/>`),
    save: ICO(`<path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13"/><polyline points="7 3 7 8 15 8"/>`),
    user: ICO(`<path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/>`),
    follow: ICO(`<path d="M5 12h14"/><path d="M12 5l7 7-7 7"/>`)
  };
  async function renderRoomMenu(root) {
    ensureStyles4();
    css2(root, { padding: "0", overflow: "hidden" });
    const wrap = document.createElement("div");
    css2(wrap, {
      display: "flex",
      flexDirection: "row",
      minHeight: "400px",
      height: "100%",
      background: "linear-gradient(160deg, rgba(15,20,30,0.95) 0%, rgba(10,14,20,0.95) 60%, rgba(8,12,18,0.96) 100%)"
    });
    const leftPane = document.createElement("div");
    leftPane.className = "qws-rm-scroll";
    css2(leftPane, {
      width: "200px",
      flexShrink: "0",
      display: "flex",
      flexDirection: "column",
      gap: "5px",
      overflowY: "auto",
      padding: "14px 8px 14px 12px",
      borderRight: `1px solid ${BORDER2}`
    });
    const rightPane = document.createElement("div");
    rightPane.className = "qws-rm-scroll";
    css2(rightPane, {
      flex: "1",
      overflowY: "auto",
      padding: "14px 14px 14px 16px",
      minWidth: "0"
    });
    wrap.append(leftPane, rightPane);
    root.appendChild(wrap);
    const getWin = () => root.closest(".qws-win");
    const hideWin = () => {
      const w = getWin();
      if (w) w.style.display = "none";
    };
    const showWin = () => {
      const w = getWin();
      if (w) w.style.display = "";
    };
    let players = [];
    let selectedId = null;
    function renderRightPanel(playerId2) {
      rightPane.innerHTML = "";
      const player2 = playerId2 ? players.find((p) => p.id === playerId2) ?? null : null;
      if (!player2) {
        const hint = document.createElement("div");
        css2(hint, {
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          justifyContent: "center",
          height: "100%",
          gap: "10px",
          color: TEXT_DIM2,
          fontSize: "12px",
          paddingTop: "60px"
        });
        const iconWrap = document.createElement("div");
        iconWrap.innerHTML = ICONS.user.replace("13", "28").replace("13", "28");
        css2(iconWrap, { opacity: "0.35" });
        hint.append(iconWrap, document.createTextNode("Select a player"));
        rightPane.appendChild(hint);
        return;
      }
      const content = document.createElement("div");
      css2(content, { display: "flex", flexDirection: "column", gap: "18px" });
      const profileCard = document.createElement("div");
      css2(profileCard, {
        display: "flex",
        alignItems: "center",
        gap: "12px",
        padding: "14px",
        background: CARD_BG2,
        borderRadius: "12px",
        border: `1px solid ${BORDER2}`
      });
      const av = avatar(player2, 46);
      const infoBlock = document.createElement("div");
      css2(infoBlock, { display: "flex", flexDirection: "column", gap: "4px", minWidth: "0", flex: "1" });
      const nameEl = document.createElement("div");
      css2(nameEl, {
        fontSize: "15px",
        fontWeight: "700",
        color: TEXT2,
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
      });
      nameEl.textContent = player2.name || player2.id;
      infoBlock.append(nameEl, statusPill(player2.isConnected ?? false));
      profileCard.append(av, infoBlock);
      content.appendChild(profileCard);
      const teleSection = document.createElement("div");
      teleSection.appendChild(sectionLabel2("Teleport"));
      const teleRow = document.createElement("div");
      css2(teleRow, { display: "flex", gap: "8px" });
      teleRow.append(
        primaryBtn2("To player", ICONS.teleport, () => PlayersService.teleportToPlayer(player2.id)),
        primaryBtn2("To garden", ICONS.garden, () => PlayersService.teleportToGarden(player2.id))
      );
      teleSection.appendChild(teleRow);
      content.appendChild(teleSection);
      const followSection = document.createElement("div");
      followSection.appendChild(sectionLabel2("Follow"));
      const followRow = document.createElement("div");
      css2(followRow, { display: "flex", gap: "8px" });
      const followPlayerBtn = toggleBtn(
        "Follow player",
        ICONS.follow,
        PlayersService.isFollowing(player2.id),
        async (next) => {
          if (next) {
            await PlayersService.startFollowing(player2.id);
            await toastSimple("Follow", `Following ${player2.name || player2.id}.`, "success");
          } else {
            PlayersService.stopFollowing();
            await toastSimple("Follow", "Stopped following.", "info");
          }
        }
      );
      followRow.append(followPlayerBtn);
      followSection.appendChild(followRow);
      content.appendChild(followSection);
      const inspectSection = document.createElement("div");
      inspectSection.appendChild(sectionLabel2("Inspect"));
      const inspectGrid = document.createElement("div");
      css2(inspectGrid, { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "6px" });
      inspectGrid.append(
        secondaryBtn2("Inventory", ICONS.inventory, async () => {
          hideWin();
          try {
            await PlayersService.openInventoryPreview(player2.id, player2.name);
            if (await isInventoryPanelOpen()) await waitInventoryPanelClosed();
          } finally {
            showWin();
          }
        }),
        secondaryBtn2("Journal", ICONS.journal, async () => {
          hideWin();
          try {
            await PlayersService.openJournalLog(player2.id, player2.name);
            if (await isJournalModalOpen()) await waitJournalModalClosed();
          } finally {
            showWin();
          }
        }),
        secondaryBtn2("Stats", ICONS.stats, async () => {
          hideWin();
          try {
            await PlayersService.openStatsModal(player2.id, player2.name);
            if (await isStatsModalOpenAsync()) await waitStatsModalClosed();
          } finally {
            showWin();
          }
        }),
        secondaryBtn2("Activity log", ICONS.actLog, async () => {
          hideWin();
          try {
            await PlayersService.openActivityLogModal(player2.id, player2.name);
            if (await isActivityLogModalOpenAsync()) await waitActivityLogModalClosed();
          } finally {
            showWin();
          }
        })
      );
      inspectSection.appendChild(inspectGrid);
      content.appendChild(inspectSection);
      const editorSection = document.createElement("div");
      editorSection.appendChild(sectionLabel2("Editor"));
      editorSection.appendChild(
        secondaryBtn2("Save player garden", ICONS.save, async () => {
          const fn = window.qwsEditorSaveGardenForPlayer ?? pageWindow?.qwsEditorSaveGardenForPlayer;
          if (typeof fn !== "function") {
            await toastSimple("Save garden", "Editor save unavailable.", "error");
            return;
          }
          const saved = await fn(player2.id, `${player2.name || player2.id}'s garden`);
          if (!saved) await toastSimple("Save garden", "Save failed (no garden state).", "error");
          else await toastSimple(`Saved "${saved.name}".`, "success");
        })
      );
      content.appendChild(editorSection);
      const valSection = document.createElement("div");
      valSection.appendChild(sectionLabel2("Crop values"));
      const valRow = document.createElement("div");
      css2(valRow, { display: "flex", gap: "8px" });
      const makeValCard = (label2) => {
        const card2 = document.createElement("div");
        css2(card2, {
          flex: "1",
          padding: "11px 14px",
          background: CARD_BG2,
          borderRadius: "10px",
          border: `1px solid ${BORDER2}`,
          display: "flex",
          flexDirection: "column",
          gap: "4px"
        });
        const lbl = document.createElement("div");
        css2(lbl, { fontSize: "10px", color: TEXT_DIM2, fontWeight: "600", textTransform: "uppercase", letterSpacing: "0.05em" });
        lbl.textContent = label2;
        const val = document.createElement("div");
        css2(val, { fontSize: "15px", fontWeight: "700", color: "#FFD84D" });
        val.textContent = "\u2026";
        card2.append(lbl, val);
        return { card: card2, val };
      };
      const { card: invCard, val: invVal } = makeValCard("Inventory");
      const { card: gardenCard, val: gardenVal } = makeValCard("Garden");
      valRow.append(invCard, gardenCard);
      valSection.appendChild(valRow);
      content.appendChild(valSection);
      rightPane.appendChild(content);
      void (async () => {
        try {
          invVal.textContent = formatPrice(Math.round(await PlayersService.getInventoryValue(player2.id))) ?? "\u2014";
        } catch {
          invVal.textContent = "\u2014";
        }
        try {
          gardenVal.textContent = formatPrice(Math.round(await PlayersService.getGardenValue(player2.id))) ?? "\u2014";
        } catch {
          gardenVal.textContent = "\u2014";
        }
      })();
    }
    function createPlayerCard(player2) {
      const isSelected = selectedId === player2.id;
      const card2 = document.createElement("div");
      css2(card2, {
        display: "flex",
        alignItems: "center",
        gap: "10px",
        padding: "9px 10px",
        borderRadius: "10px",
        border: isSelected ? `1px solid ${TEAL_BORDER2}` : `1px solid ${BORDER2}`,
        background: isSelected ? TEAL_DIM2 : "rgba(255,255,255,0.02)",
        cursor: "pointer",
        transition: "all 120ms ease"
      });
      if (!isSelected) {
        card2.onmouseenter = () => css2(card2, { background: CARD_BG_HI2, borderColor: "rgba(94,234,212,0.18)" });
        card2.onmouseleave = () => css2(card2, { background: "rgba(255,255,255,0.02)", borderColor: BORDER2 });
      }
      card2.onclick = () => {
        selectedId = player2.id;
        renderPlayerList();
        renderRightPanel(player2.id);
      };
      const av = avatar(player2, 32);
      const info = document.createElement("div");
      css2(info, { flex: "1", minWidth: "0" });
      const nameEl = document.createElement("div");
      css2(nameEl, {
        fontSize: "12px",
        fontWeight: "600",
        color: TEXT2,
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
      });
      nameEl.textContent = player2.name || player2.id;
      const st = document.createElement("div");
      css2(st, {
        display: "flex",
        alignItems: "center",
        gap: "4px",
        marginTop: "2px",
        fontSize: "10px",
        color: player2.isConnected ? GREEN : TEXT_DIM2
      });
      const dot = document.createElement("span");
      css2(dot, { width: "5px", height: "5px", borderRadius: "50%", background: player2.isConnected ? GREEN : "rgba(226,232,240,0.3)", flexShrink: "0" });
      st.append(dot, document.createTextNode(player2.isConnected ? "Online" : "Offline"));
      info.append(nameEl, st);
      card2.append(av, info);
      return card2;
    }
    function renderPlayerList() {
      leftPane.innerHTML = "";
      const header = document.createElement("div");
      css2(header, {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        marginBottom: "6px"
      });
      const countEl = document.createElement("div");
      css2(countEl, { fontSize: "10px", fontWeight: "700", letterSpacing: "0.07em", color: TEXT_DIM2, textTransform: "uppercase" });
      countEl.textContent = `${players.length} player${players.length !== 1 ? "s" : ""}`;
      header.appendChild(countEl);
      leftPane.appendChild(header);
      if (players.length === 0) {
        const empty = document.createElement("div");
        css2(empty, { paddingTop: "16px", textAlign: "center", color: TEXT_DIM2, fontSize: "12px" });
        empty.textContent = "No players in room";
        leftPane.appendChild(empty);
        return;
      }
      for (const p of players) {
        leftPane.appendChild(createPlayerCard(p));
      }
    }
    let lastSig = "";
    function buildSig(ps) {
      return ps.map((p) => `${p.id}|${p.name ?? ""}|${p.isConnected ? 1 : 0}`).join(";");
    }
    async function refresh(keepSelection = true) {
      const prevSel = selectedId;
      const next = await PlayersService.list();
      const s = buildSig(next);
      if (s === lastSig) return;
      lastSig = s;
      players = next;
      const sel = keepSelection && prevSel && players.some((p) => p.id === prevSel) ? prevSel : players[0]?.id ?? null;
      selectedId = sel;
      renderPlayerList();
      renderRightPanel(sel);
    }
    await PlayersService.onChange(() => {
      void refresh(true);
    });
    await refresh(true);
  }

  // src/utils/antiafk.ts
  function createAntiAfkController(deps) {
    const STOP_EVENTS = ["visibilitychange", "blur", "focus", "focusout", "pagehide", "freeze", "resume"];
    const listeners5 = [];
    function swallowAll() {
      const add = (target, t) => {
        const h = (e) => {
          e.stopImmediatePropagation();
          e.preventDefault?.();
        };
        target.addEventListener(t, h, { capture: true });
        listeners5.push({ t, h, target });
      };
      STOP_EVENTS.forEach((t) => {
        add(document, t);
        add(window, t);
      });
    }
    function unswallowAll() {
      for (const { t, h, target } of listeners5) try {
        target.removeEventListener(t, h, { capture: true });
      } catch {
      }
      listeners5.length = 0;
    }
    const docProto = Object.getPrototypeOf(document);
    const saved = {
      hidden: Object.getOwnPropertyDescriptor(docProto, "hidden"),
      visibilityState: Object.getOwnPropertyDescriptor(docProto, "visibilityState"),
      hasFocus: document.hasFocus ? document.hasFocus.bind(document) : null
    };
    function patchProps() {
      try {
        Object.defineProperty(docProto, "hidden", { configurable: true, get() {
          return false;
        } });
      } catch {
      }
      try {
        Object.defineProperty(docProto, "visibilityState", { configurable: true, get() {
          return "visible";
        } });
      } catch {
      }
      try {
        document.hasFocus = () => true;
      } catch {
      }
    }
    function restoreProps() {
      try {
        if (saved.hidden) Object.defineProperty(docProto, "hidden", saved.hidden);
      } catch {
      }
      try {
        if (saved.visibilityState) Object.defineProperty(docProto, "visibilityState", saved.visibilityState);
      } catch {
      }
      try {
        if (saved.hasFocus) document.hasFocus = saved.hasFocus;
      } catch {
      }
    }
    let audioCtx = null;
    let osc = null;
    let gain = null;
    const resumeIfSuspended = () => {
      if (audioCtx && audioCtx.state !== "running") audioCtx.resume?.().catch(() => {
      });
    };
    function startAudioKeepAlive() {
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: "interactive" });
        gain = audioCtx.createGain();
        gain.gain.value = 1e-5;
        osc = audioCtx.createOscillator();
        osc.frequency.value = 1;
        osc.connect(gain).connect(audioCtx.destination);
        osc.start();
        document.addEventListener("visibilitychange", resumeIfSuspended, { capture: true });
        window.addEventListener("focus", resumeIfSuspended, { capture: true });
      } catch {
        stopAudioKeepAlive();
      }
    }
    function stopAudioKeepAlive() {
      try {
        osc?.stop();
      } catch {
      }
      try {
        osc?.disconnect();
        gain?.disconnect();
      } catch {
      }
      try {
        audioCtx?.close?.();
      } catch {
      }
      document.removeEventListener("visibilitychange", resumeIfSuspended, { capture: true });
      window.removeEventListener("focus", resumeIfSuspended, { capture: true });
      osc = null;
      gain = null;
      audioCtx = null;
    }
    let hb = null;
    function startHeartbeat() {
      const targetEl = document.querySelector("canvas") || document.body || document.documentElement;
      hb = window.setInterval(() => {
        try {
          targetEl.dispatchEvent(new MouseEvent("mousemove", { bubbles: true, clientX: 1, clientY: 1 }));
        } catch {
        }
      }, 25e3);
    }
    function stopHeartbeat() {
      if (hb !== null) {
        clearInterval(hb);
        hb = null;
      }
    }
    let pingTimer = null;
    async function pingPosition() {
      try {
        const cur = await deps.getPosition();
        if (!cur) return;
        await deps.move(Math.round(cur.x), Math.round(cur.y));
      } catch {
      }
    }
    function startPing() {
      pingTimer = window.setInterval(pingPosition, 6e4);
      void pingPosition();
    }
    function stopPing() {
      if (pingTimer !== null) {
        clearInterval(pingTimer);
        pingTimer = null;
      }
    }
    return {
      start() {
        patchProps();
        swallowAll();
        startAudioKeepAlive();
        startHeartbeat();
        startPing();
      },
      stop() {
        stopPing();
        stopHeartbeat();
        stopAudioKeepAlive();
        unswallowAll();
        restoreProps();
      }
    };
  }

  // src/main.ts
  (async function() {
    "use strict";
    if (initAuthBridgeIfNeeded()) return;
    if (isDiscordActivityContext()) {
      installEmojiDataFetchInterceptor();
    }
    installPageWebSocketHook();
    initGameVersion();
    MGVersion.prefetch();
    try {
      warmupSpriteCache();
    } catch {
    }
    tos.init();
    EditorService.init();
    mountHUD({
      onRegister(register) {
        register("pets", "\u{1F43E} Pets", renderPetsMenu);
        register("locker", "\u{1F512} Locker", renderLockerMenu);
        register("alerts", "\u{1F514} Alerts", renderNotifierMenu);
        register("calculator", "\u{1F913} Calculator", renderCalculatorMenu);
        register("room", "\u{1F3E0} Room", renderRoomMenu);
        register("editor", "\u{1F4DD} Editor", renderEditorMenu);
        register("stats", "\u{1F4CA} Stats", renderStatsMenu);
        register("misc", "\u{1F9E9} Misc", renderMiscMenu);
        register("keybinds", "\u2328\uFE0F Keybinds", renderKeybindsMenu);
        register("tools", "\u{1F6E0}\uFE0F Tools", renderToolsMenu);
        register("settings", "\u2699\uFE0F Settings", renderSettingsMenu);
        register("debug-data", "\u{1F41E} Debug", renderDebugDataMenu);
      }
    });
    initWatchers();
    const antiAfk = createAntiAfkController({
      getPosition: () => PlayerService.getPosition(),
      move: (x, y) => PlayerService.move(x, y)
    });
    antiAfk.start();
    startPlayerStateReportingWhenGameReady();
    initializeStreamsWhenReady();
  })();
})();
